<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Across 跨链桥合约解析 · QIWIHUI</title><meta name="description" content="Across 跨链桥合约解析 - qiwihui"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/nella.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.12/css/all.css" integrity="sha384-G0fIWCsCzJIMAVNQPfjH08cyYaUtMwjJwqiRKxxE/rx96Uroj1BtIQ6MLJuheaO9" crossorigin="anonymous"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
google_ad_client: "ca-pub-8935595858652656",
enable_page_level_ads: true
});
</script><link rel="search" type="application/opensearchdescription+xml" href="https://qiwihui.com/atom.xml" title="QIWIHUI"><meta property="og:site_name" content="QIWIHUI"><meta property="og:url" content="https://qiwihui.com/qiwihui-blog-158/index.html"><meta property="og:title" content="Across 跨链桥合约解析"><meta property="og:description" content="Across 跨链桥合约解析"><meta property="og:type" content="article"><script src="//code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/images/avatar.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/search/" target="_self" class="nav-list-link">SEARCH</a></li><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/projects/" target="_self" class="nav-list-link">PROJECTS</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">TAGS</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="/links/" target="_self" class="nav-list-link">LINKS</a></li><!--li.nav-list-item--><!--    a.nav-list-link(class="search" href=url_for("search") target="_self") SEARCH--></ul></header><main class="container"></main><div class="post"><article class="post-block"><h1 class="post-title">Across 跨链桥合约解析</h1><div class="post-info">May 15, 2024<span class="categories"><i class="fa fa-bookmark" aria-hidden="true"></i></span><span>42 min. read</span></div><div class="post-content"><h2><span id="shi-me-shi-across">什么是 Across</span></h2>
<p>以太坊跨链协议 <a href="https://across.to/" target="_blank" rel="noopener">Across</a> 是一种新颖的跨链方法，它结合了乐观预言机（Optimistic Oracle）、绑定中继者和单边流动性池，可以提供从 Rollup 链到以太坊主网的去中心化即时交易。目前，Across 协议通过集成以太坊二层扩容方案Optimism、Arbitrum和Boba Network支持双向桥接，即可将资产从L1发送至L2，亦可从L2发送至L1。</p>
<a id="more"></a>
<h3><span id="cun-kuan-kua-lian-liu-cheng">存款跨链流程</span></h3>
<p><img src="https://user-images.githubusercontent.com/3297411/158982132-cd917c98-e156-45d4-b50b-0256f222db32.png" alt="process"></p>
<p>来源于：<a href="https://docs.across.to/bridge/how-does-across-work-1/architecture-process-walkthrough" target="_blank" rel="noopener">https://docs.across.to/bridge/how-does-across-work-1/architecture-process-walkthrough</a></p>
<p>Across 协议中，存款跨链有几种可能的流程，最重要的是，存款人在任何这些情况下都不会损失资金。在每一种情况下，在 L2 上存入的任何代币都会通过 Optimism 或 Arbitrum 的原生桥转移到 L1 上的流动池，用以偿还给流动性提供者。</p>
<p>从上面的流程中，我们可以看到 Across 协议流程包括以下几种：</p>
<ul>
<li>即时中继，无争议；</li>
<li>即时中继，有争议；</li>
<li>慢速中继，无争议；</li>
<li>慢速中继，有争议；</li>
<li>慢速中继，加速为即时中继。</li>
</ul>
<p>Across 协议中主要包括几类角色：</p>
<ul>
<li>存款者（Depositor）：需要将资产从二层链转移到L1的用户；</li>
<li>中继者（Relayer）：负责将L1层资产转移给用户，以及L2层资产跨链的节点；</li>
<li>流动性提供者（LP）：为流动性池提供资产；</li>
<li>争议者（Disputor）：对中继过程有争议的人，可以向 Optimistic Oracle 提交争议；</li>
</ul>
<h2><span id="xiang-mu-zong-lan">项目总览</span></h2>
<p>Across 的合约源码地址为 <a href="https://github.com/across-protocol/contracts-v1%EF%BC%8C%E7%9B%AE%E5%89%8D" target="_blank" rel="noopener">https://github.com/across-protocol/contracts-v1，目前</a> Across Protocol 正在进行 v2 版本合约的开发，我们这一篇文章主要分析 v1 版本的合约源码。首先我们下载源码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/across-protocol/contracts-v1</span><br><span class="line"><span class="built_in">cd</span> contracts-v1</span><br></pre></td></tr></table></figure>
<p>合约源码的主要的目录结构为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">contract-v1</span><br><span class="line">├── contracts // Across protocol 的合约源码</span><br><span class="line">├── deploy // 部署脚本</span><br><span class="line">├── hardhat.config.js // hardhat 配置</span><br><span class="line">├── helpers // 辅助函数</span><br><span class="line">├── networks // 合约在不同链上的部署地址</span><br><span class="line">└── package.json // 依赖包</span><br></pre></td></tr></table></figure>
<p>在这篇解析中，我们主要关注 <code>contracts</code> 和 <code>deploy</code> 目录下的文件。</p>
<h3><span id="he-yue-zong-lan">合约总览</span></h3>
<p>合约目录 <code>contracts</code> 的目录结构为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">contracts/</span><br><span class="line">├── common</span><br><span class="line">│   ├── implementation</span><br><span class="line">│   └── interfaces</span><br><span class="line">├── external</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── avm</span><br><span class="line">│   ├── chainbridge</span><br><span class="line">│   ├── ovm</span><br><span class="line">│   └── polygon</span><br><span class="line">├── insured-bridge</span><br><span class="line">│   ├── BridgeAdmin.sol</span><br><span class="line">│   ├── BridgeDepositBox.sol</span><br><span class="line">│   ├── BridgePool.sol</span><br><span class="line">│   ├── RateModelStore.sol</span><br><span class="line">│   ├── avm</span><br><span class="line">│   ├── interfaces</span><br><span class="line">│   ├── ovm</span><br><span class="line">│   └── <span class="built_in">test</span></span><br><span class="line">└── oracle</span><br><span class="line">    ├── implementation</span><br><span class="line">    └── interfaces</span><br></pre></td></tr></table></figure>
<p>其中，各个目录包含的内容为：</p>
<ul>
<li><code>common</code>：一些通用功能的库方法等，包括：
<ul>
<li><a href="https://github.com/across-protocol/contracts-v1/blob/master/contracts/common/implementation/AncillaryData.sol" target="_blank" rel="noopener">AncillaryData.sol</a>：用来编码和解码 DVM价格请求的数据的库；</li>
<li><a href="https://github.com/across-protocol/contracts-v1/blob/master/contracts/common/implementation/FixedPoint.sol" target="_blank" rel="noopener">FixedPoint.sol</a>：定点数运算；</li>
<li><a href="https://github.com/across-protocol/contracts-v1/blob/master/contracts/common/implementation/Lockable.sol" target="_blank" rel="noopener">Lockable.sol</a>：防止重入攻击的一些函数修改器；</li>
<li><a href="https://github.com/across-protocol/contracts-v1/blob/master/contracts/common/implementation/MultiCaller.sol" target="_blank" rel="noopener">MultiCaller.sol</a> ：可以在当个调用中调用合约的多个方法；</li>
<li><a href="https://github.com/across-protocol/contracts-v1/blob/master/contracts/common/implementation/Testable.sol" target="_blank" rel="noopener">Testable.sol</a>：测试时修改时间；</li>
<li><a href="https://github.com/across-protocol/contracts-v1/blob/master/contracts/common/implementation/Timer.sol" target="_blank" rel="noopener">Timer.sol</a>：获取时间方法；</li>
</ul>
</li>
<li><code>external</code>：外部合约，主要用于实现在管理员合约中对不同 L2 的消息发送；</li>
<li><code>insured-bridge</code> 合约主要功能，我们会在接下来的章节章节中重点分析；</li>
<li><code>oracle</code>：主要是 Optimistic Oracle 提供功能的方法接口，在这篇文章中我们不对 Optimistic Oracle 的原理实现进行介绍，主要会介绍 Across 协议会在何处使用 Optimistic Oracle。</li>
</ul>
<p>接下来我们会重点分析 <code>insured-bridge</code> 中的合约的功能，这是 Across 主要功能的合约所在。</p>
<p>在 <code>insured-bridge</code> 目录中：</p>
<ul>
<li><code>BridgeAdmin.sol</code> ：管理合约，负责管理和生成生成 L2 上的 DepositBox 合约和 L1 上的 BridgePool 合约；</li>
<li><code>BridgeDepositBox.sol</code> ：L2 层上负责存款的抽象合约，Arbitrum，Optimism 和 Boba 网络的合约都是继承自这个合约；</li>
<li><code>BridgePool.sol</code> ：桥接池合约，管理 L1 层资金池。</li>
</ul>
<h2><span id="bridgeadmin">BridgeAdmin</span></h2>
<p>这个合约是管理员合约，部署在L1层，并有权限管理 L1 层上的流动性池和 L2 上的存款箱（DepositBoxes）。可以注意的是，这个合约的管理帐号是一个多钱钱包，避免了一些安全问题。</p>
<p>首先我们看到合约中的几个状态变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract BridgeAdmin is BridgeAdminInterface, Ownable, Lockable &#123;</span><br><span class="line"></span><br><span class="line">    address public override finder;</span><br><span class="line"></span><br><span class="line">    mapping(uint256 =&gt; DepositUtilityContracts) private _depositContracts;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; L1TokenRelationships) private _whitelistedTokens;</span><br><span class="line"></span><br><span class="line">    // Set upon construction and can be reset by Owner.</span><br><span class="line">    uint32 public override optimisticOracleLiveness;</span><br><span class="line">    uint64 public override proposerBondPct;</span><br><span class="line">    bytes32 public override identifier;</span><br><span class="line"></span><br><span class="line">    constructor(</span><br><span class="line">        address _finder,</span><br><span class="line">        uint32 _optimisticOracleLiveness,</span><br><span class="line">        uint64 _proposerBondPct,</span><br><span class="line">        bytes32 _identifier</span><br><span class="line">    ) &#123;</span><br><span class="line">        finder = _finder;</span><br><span class="line">        require(address(_getCollateralWhitelist()) != address(0), &quot;Invalid finder&quot;);</span><br><span class="line">        _setOptimisticOracleLiveness(_optimisticOracleLiveness);</span><br><span class="line">        _setProposerBondPct(_proposerBondPct);</span><br><span class="line">        _setIdentifier(_identifier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>finder</code> 用来记录查询最新 OptimisticOracle 和 UMA 生态中其他合约的合约地址；</li>
<li><code>_depositContracts</code> 该合约可以将消息中继到任意数量的 L2 存款箱，每个 L2 网络一个，每个都由唯一的网络 ID 标识。 要中继消息，需要存储存款箱合约地址和信使（messenger）合约地址。 每个 L2 的信使实现不同，因为 L1 --&gt; L2 消息传递是非标准的；</li>
<li><code>_whitelistedTokens</code> 记录了 L1 代币地址与对应 L2 代币地址以及桥接池的映射；</li>
<li><code>optimisticOracleLiveness</code> 中继存款的争议时长；</li>
<li><code>proposerBondPct</code> Optimistic Oracle 中 proposer 的绑定费率</li>
</ul>
<p>管理员可以设置以上这些变量的内容，以及可以设置每秒的 LP 费率，转移桥接池的管理员权限等。</p>
<p>同时，管理员还可以通过信使设置 L2 层合约的参数，包括；</p>
<ul>
<li><code>setCrossDomainAdmin</code> ：设置 L2 存款合约的管理员地址；</li>
<li><code>setMinimumBridgingDelay</code> ：设置 L2 存款合约的最小桥接延迟；</li>
<li><code>setEnableDepositsAndRelays</code>：开启或者暂停代币 L2 存款，这个方法会同时暂停 L1 层桥接池；</li>
<li><code>whitelistToken</code>：关联 L2 代币地址，这样这个代币就可以开始存款和中继；</li>
</ul>
<p>对于消息发送，管理员合约通过调用不同的信使的 <code>relayMessage</code> 方法来完成，将 msg.value == l1CallValue 发送给信使，然后它可以以任何方式使用它来执行跨域消息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function _relayMessage(</span><br><span class="line">    address messengerContract,</span><br><span class="line">    uint256 l1CallValue,</span><br><span class="line">    address target,</span><br><span class="line">    address user,</span><br><span class="line">    uint256 l2Gas,</span><br><span class="line">    uint256 l2GasPrice,</span><br><span class="line">    uint256 maxSubmissionCost,</span><br><span class="line">    bytes memory message</span><br><span class="line">) private &#123;</span><br><span class="line">    require(l1CallValue == msg.value, &quot;Wrong number of ETH sent&quot;);</span><br><span class="line">    MessengerInterface(messengerContract).relayMessage&#123; value: l1CallValue &#125;(</span><br><span class="line">        target,</span><br><span class="line">        user,</span><br><span class="line">        l1CallValue,</span><br><span class="line">        l2Gas,</span><br><span class="line">        l2GasPrice,</span><br><span class="line">        maxSubmissionCost,</span><br><span class="line">        message</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同L2的消息方法分别在对应链的 <code>CrossDomainEnabled.sol</code> 合约中，比如：</p>
<ul>
<li>Arbitrum: <code>contracts/insured-bridge/avm/Arbitrum_CrossDomainEnabled.sol</code>；</li>
<li>Optimism，Boba: <code>contracts/insured-bridge/ovm/OVM_CrossDomainEnabled.sol</code>；</li>
</ul>
<h2><span id="bridgedepositbox">BridgeDepositBox</span></h2>
<p>接下来我们看到 <code>BridgeDepositBox.sol</code>，抽象合约 <code>BridgeDepositBox</code> 合约中主要有两个功能。</p>
<h3><span id="bridgetokens"><code>bridgeTokens</code></span></h3>
<p>第一个是 <code>bridgeTokens</code> 方法，用于将 L2 层代币通过原生代币桥转移到 L1 上，这个方法需要在不同的 L2 层合约上实现，目前支持的 L2 层包括 Arbitrum，Optimism 和 Boba，分别对应的文件为：</p>
<ul>
<li>Arbitrum: <code>contracts/insured-bridge/avm/AVM_BridgeDepositBox.sol</code></li>
<li>Optimism: <code>contracts/insured-bridge/ovm/OVM_BridgeDepositBox.sol</code></li>
<li>Boba: <code>contracts/insured-bridge/ovm/OVM_OETH_BridgeDepositBox.sol</code></li>
</ul>
<p>以 Arbitrum 链上的 <code>bridgeToken</code> 为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  // BridgeDepositBox.sol 文件中</span><br><span class="line">  function canBridge(address l2Token) public view returns (bool) &#123;</span><br><span class="line">      return isWhitelistToken(l2Token) &amp;&amp; _hasEnoughTimeElapsedToBridge(l2Token);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// AVM_BridgeDepositBox.sol文件中</span><br><span class="line">  function bridgeTokens(address l2Token, uint32 l1Gas) public override nonReentrant() &#123;</span><br><span class="line">      uint256 bridgeDepositBoxBalance = TokenLike(l2Token).balanceOf(address(this));</span><br><span class="line">      require(bridgeDepositBoxBalance &gt; 0, &quot;can&apos;t bridge zero tokens&quot;);</span><br><span class="line">      require(canBridge(l2Token), &quot;non-whitelisted token or last bridge too recent&quot;);</span><br><span class="line"></span><br><span class="line">      whitelistedTokens[l2Token].lastBridgeTime = uint64(getCurrentTime());</span><br><span class="line"></span><br><span class="line">      StandardBridgeLike(l2GatewayRouter).outboundTransfer(</span><br><span class="line">          whitelistedTokens[l2Token].l1Token, // _l1Token. Address of the L1 token to bridge over.</span><br><span class="line">          whitelistedTokens[l2Token].l1BridgePool, // _to. Withdraw, over the bridge, to the l1 withdraw contract.</span><br><span class="line">          bridgeDepositBoxBalance, // _amount. Send the full balance of the deposit box to bridge.</span><br><span class="line">          &quot;&quot; // _data. We don&apos;t need to send any data for the bridging action.</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      emit TokensBridged(l2Token, bridgeDepositBoxBalance, l1Gas, msg.sender);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>bridgeTokens</code> 上有一个装饰器 <code>canBridge</code> 包含两个判断， <code>isWhitelistToken</code> 用于判断对应 L2 层代币是否已经在 L1 层上添加了桥接池， <code>_hasEnoughTimeElapsedToBridge</code> 用来减少频繁跨连导致的费用消耗问题，因此设置了最小的跨链接时间。</p>
<p><code>bridgeTokens</code> 主要就是调用了 L2 层原生的跨链方法，比如 <code>outboundTransfer</code>。</p>
<h3><span id="deposit"><code>deposit</code></span></h3>
<p>第二个是 <code>deposit</code> 方法用于将 L2 层资产转移到以太坊 L1 层上，对应与前端页面 Deposit 操作。对应代码为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> bridgeTokens(address l2Token, uint32 l2Gas) public virtual;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> deposit(</span><br><span class="line">    address l1Recipient,</span><br><span class="line">    address l2Token,</span><br><span class="line">    uint256 amount,</span><br><span class="line">    uint64 slowRelayFeePct,</span><br><span class="line">    uint64 instantRelayFeePct,</span><br><span class="line">    uint64 quoteTimestamp</span><br><span class="line">) public payable onlyIfDepositsEnabled(l2Token) <span class="function"><span class="title">nonReentrant</span></span>() &#123;</span><br><span class="line">    require(isWhitelistToken(l2Token), <span class="string">"deposit token not whitelisted"</span>);</span><br><span class="line"></span><br><span class="line">    require(slowRelayFeePct &lt;= 0.25e18, <span class="string">"slowRelayFeePct must be &lt;= 25%"</span>);</span><br><span class="line">    require(instantRelayFeePct &lt;= 0.25e18, <span class="string">"instantRelayFeePct must be &lt;= 25%"</span>);</span><br><span class="line"></span><br><span class="line">    require(</span><br><span class="line">        getCurrentTime() &gt;= quoteTimestamp - 10 minutes &amp;&amp; getCurrentTime() &lt;= quoteTimestamp + 10 minutes,</span><br><span class="line">        <span class="string">"deposit mined after deadline"</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (whitelistedTokens[l2Token].l1Token == l1Weth &amp;&amp; msg.value &gt; 0) &#123;</span><br><span class="line">        require(msg.value == amount, <span class="string">"msg.value must match amount"</span>);</span><br><span class="line">        WETH9Like(address(l2Token)).deposit&#123; value: msg.value &#125;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> IERC20(l2Token).safeTransferFrom(msg.sender, address(this), amount);</span><br><span class="line"></span><br><span class="line">    emit FundsDeposited(</span><br><span class="line">        chainId,</span><br><span class="line">        numberOfDeposits, // depositId: the current number of deposits acts as a deposit ID (nonce).</span><br><span class="line">        l1Recipient,</span><br><span class="line">        msg.sender,</span><br><span class="line">        whitelistedTokens[l2Token].l1Token,</span><br><span class="line">        l2Token,</span><br><span class="line">        amount,</span><br><span class="line">        slowRelayFeePct,</span><br><span class="line">        instantRelayFeePct,</span><br><span class="line">        quoteTimestamp</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    numberOfDeposits += 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，合约区分了 ETH 和 ERC20 代币的存入方式。</p>
<p>存入资产后，合约产生了一个事件 <code>FundsDeposited</code>，用于中继者程序捕获并进行资产跨链，事件信息包含合约部署的 L2 链ID，存款ID <code>numberOfDeposits</code>，L1层接收者，存款者，L1和L2层代币地址，数量和费率，以及时间戳。</p>
<h2><span id="bridgepool">BridgePool</span></h2>
<p><code>BridgePool</code> 合约部署在 Layer 1 上，提供了给中继者完成 Layer2 上存款订单的函数。主要包含以下功能：</p>
<ol>
<li>流动性提供者添加和删除流动性的方法 <code>addLiquidity</code>， <code>removeLiquidity</code>；</li>
<li>慢速中继： <code>relayDeposit</code></li>
<li>即时中继： <code>relayAndSpeedUp</code>， <code>speedUpRelay</code></li>
<li>争议： <code>disputeRelay</code></li>
<li>解决中继： <code>settleRelay</code></li>
</ol>
<h3><span id="gou-zao-qi">构造器</span></h3>
<p>在合约初始时，合约设置了对应的桥管理员地址，L1代币地址，每秒的 LP 费率，以及标识是否为 WETH 池。同时，通过 <code>syncUmaEcosystemParams</code> 和 <code>syncWithBridgeAdminParams</code> 两个方法同步了 Optimistic Oracle 地址信息，Store 的地址信息，以及对应的 <code>ProposerBondPct</code> ， <code>OptimisticOracleLiveness</code> 等参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  function syncUmaEcosystemParams() public nonReentrant() &#123;</span><br><span class="line">      FinderInterface finder = FinderInterface(bridgeAdmin.finder());</span><br><span class="line">      optimisticOracle = SkinnyOptimisticOracleInterface(</span><br><span class="line">          finder.getImplementationAddress(OracleInterfaces.SkinnyOptimisticOracle)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      store = StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));</span><br><span class="line">      l1TokenFinalFee = store.computeFinalFee(address(l1Token)).rawValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">function syncWithBridgeAdminParams() public nonReentrant() &#123;</span><br><span class="line">      proposerBondPct = bridgeAdmin.proposerBondPct();</span><br><span class="line">      optimisticOracleLiveness = bridgeAdmin.optimisticOracleLiveness();</span><br><span class="line">      identifier = bridgeAdmin.identifier();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">constructor(</span><br><span class="line">      string memory _lpTokenName,</span><br><span class="line">      string memory _lpTokenSymbol,</span><br><span class="line">      address _bridgeAdmin,</span><br><span class="line">      address _l1Token,</span><br><span class="line">      uint64 _lpFeeRatePerSecond,</span><br><span class="line">      bool _isWethPool,</span><br><span class="line">      address _timer</span><br><span class="line">  ) Testable(_timer) ERC20(_lpTokenName, _lpTokenSymbol) &#123;</span><br><span class="line">      require(bytes(_lpTokenName).length != 0 &amp;&amp; bytes(_lpTokenSymbol).length != 0, &quot;Bad LP token name or symbol&quot;);</span><br><span class="line">      bridgeAdmin = BridgeAdminInterface(_bridgeAdmin);</span><br><span class="line">      l1Token = IERC20(_l1Token);</span><br><span class="line">      lastLpFeeUpdate = uint32(getCurrentTime());</span><br><span class="line">      lpFeeRatePerSecond = _lpFeeRatePerSecond;</span><br><span class="line">      isWethPool = _isWethPool;</span><br><span class="line"></span><br><span class="line">      syncUmaEcosystemParams(); // Fetch OptimisticOracle and Store addresses and L1Token finalFee.</span><br><span class="line">      syncWithBridgeAdminParams(); // Fetch ProposerBondPct OptimisticOracleLiveness, Identifier from the BridgeAdmin.</span><br><span class="line"></span><br><span class="line">      emit LpFeeRateSet(lpFeeRatePerSecond);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3><span id="tian-jia-he-shan-chu-liu-dong-xing">添加和删除流动性</span></h3>
<p>我们首先看到添加和删除流动性，添加流动性即流动性提供者向连接池中提供 L1 代币，并获取相应数量的 LP 代币作为证明，LP 代币数量根据现行汇率计算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function addLiquidity(uint256 l1TokenAmount) public payable nonReentrant() &#123;</span><br><span class="line">// 如果是 weth 池，调用发送 msg.value，msg.value 与 l1TokenAmount 相同</span><br><span class="line">// 否则，msg.value 必需为 0</span><br><span class="line">    require((isWethPool &amp;&amp; msg.value == l1TokenAmount) || msg.value == 0, &quot;Bad add liquidity Eth value&quot;);</span><br><span class="line"></span><br><span class="line"> // 由于 `_exchangeRateCurrent()` 读取合约的余额并使用它更新合约状态，</span><br><span class="line">// 因此我们必需在转入任何代币之前调用</span><br><span class="line">    uint256 lpTokensToMint = (l1TokenAmount * 1e18) / _exchangeRateCurrent();</span><br><span class="line">    _mint(msg.sender, lpTokensToMint);</span><br><span class="line">    liquidReserves += l1TokenAmount;</span><br><span class="line"></span><br><span class="line">    if (msg.value &gt; 0 &amp;&amp; isWethPool) WETH9Like(address(l1Token)).deposit&#123; value: msg.value &#125;();</span><br><span class="line">    else l1Token.safeTransferFrom(msg.sender, address(this), l1TokenAmount);</span><br><span class="line"></span><br><span class="line">    emit LiquidityAdded(l1TokenAmount, lpTokensToMint, msg.sender);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于合约支持 WETH 作为流动性池，因此添加流动性区分了 WETH 和其他 ERC20 代币的添加方法。</p>
<p>此处的难点在于 LP 代币和 L1 代币之间的汇率换算 <code>_exchangeRateCurrent</code> 的实现，我们从合约中提取出了 <code>_exchangeRateCurrent</code> 所使用的函数，包括 <code>_updateAccumulatedLpFees</code> 和 <code>_sync</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">function _getAccumulatedFees() internal view returns (uint256) &#123;</span><br><span class="line">      uint256 possibleUnpaidFees =</span><br><span class="line">          (undistributedLpFees * lpFeeRatePerSecond * (getCurrentTime() - lastLpFeeUpdate)) / (1e18);</span><br><span class="line">      return possibleUnpaidFees &lt; undistributedLpFees ? possibleUnpaidFees : undistributedLpFees;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _updateAccumulatedLpFees() internal &#123;</span><br><span class="line">      uint256 unallocatedAccumulatedFees = _getAccumulatedFees();</span><br><span class="line"></span><br><span class="line">      undistributedLpFees = undistributedLpFees - unallocatedAccumulatedFees;</span><br><span class="line"></span><br><span class="line">      lastLpFeeUpdate = uint32(getCurrentTime());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">function _sync() internal &#123;</span><br><span class="line">      uint256 l1TokenBalance = l1Token.balanceOf(address(this)) - bonds;</span><br><span class="line">      if (l1TokenBalance &gt; liquidReserves) &#123;</span><br><span class="line">          </span><br><span class="line">          utilizedReserves -= int256(l1TokenBalance - liquidReserves);</span><br><span class="line">          liquidReserves = l1TokenBalance;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">function _exchangeRateCurrent() internal returns (uint256) &#123;</span><br><span class="line">      if (totalSupply() == 0) return 1e18; // initial rate is 1 pre any mint action.</span><br><span class="line"></span><br><span class="line">      _updateAccumulatedLpFees();</span><br><span class="line">      _sync();</span><br><span class="line"></span><br><span class="line">      int256 numerator = int256(liquidReserves) + utilizedReserves - int256(undistributedLpFees);</span><br><span class="line">      return (uint256(numerator) * 1e18) / totalSupply();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>换算汇率等于当前合约中代币的储备与总 LP 供应量的比值，计算步骤如下：</p>
<ol>
<li>更新自上次方法调用以来的累积LP费用 <code>_updateAccumulatedLpFees</code>
<ol>
<li>计算可能未付的费用 <code>possibleUnpaidFees</code> ，等于未分配的 Lp 费用 <code>undistributedLpFees</code> * 每秒 LP 费率 *（当前时间-上次更新时间），目前 WETH 桥接池中每秒LP费率为 0.0000015。</li>
<li>计算累积费用 <code>unallocatedAccumulatedFees</code> ，如果 <code>possibleUnpaidFees</code> 小于未分配的 Lp 费用，则所有未分配的 LP 费用都将用于累积费用；</li>
<li>当前未分配 LP 费用 = 原先未分配 LP 费用 - 累积费用；</li>
</ol>
</li>
<li>计算由于代币桥接产生的余额变化
<ol>
<li>当前合约中的代币储备=当前合约中的代币数量 - 被绑定在中继过程中的代币数量；</li>
<li>如果当前合约中的代币储备大于流动储备 <code>liquidReserves</code>，则被使用的储备  <code>utilizedReserves</code> = 原先被使用的储备 -（当前合约中的代币储备 - 流动储备）；</li>
<li>当前流动性储备 = 当前合约中的代币储备；</li>
</ol>
</li>
<li>计算汇率：
<ol>
<li>经过更新之后，汇率计算的分子：流动储备 + 被使用的储备 - 未被分配 LP 费用；</li>
<li>分子与LP 代币总供应量的比值即为换算汇率。</li>
</ol>
</li>
</ol>
<p>利用换算汇率，可以计算得到添加 <code>l1TokenAmount</code> 数量的代币时所能得到的 LP 代币的数量。</p>
<p>对于移除流动性，过程与添加流动性相反，这里不再赘述。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function removeLiquidity(uint256 lpTokenAmount, bool sendEth) public nonReentrant() &#123;</span><br><span class="line">    // 如果是 WETH 池，则只能通过发送 ETH 来取出流动性</span><br><span class="line">    require(!sendEth || isWethPool, &quot;Cant send eth&quot;);</span><br><span class="line">    uint256 l1TokensToReturn = (lpTokenAmount * _exchangeRateCurrent()) / 1e18;</span><br><span class="line"></span><br><span class="line">    // 检查是否有足够的流储备来支持取款金额</span><br><span class="line">    require(liquidReserves &gt;= (pendingReserves + l1TokensToReturn), &quot;Utilization too high to remove&quot;);</span><br><span class="line"></span><br><span class="line">    _burn(msg.sender, lpTokenAmount);</span><br><span class="line">    liquidReserves -= l1TokensToReturn;</span><br><span class="line"></span><br><span class="line">    if (sendEth) _unwrapWETHTo(payable(msg.sender), l1TokensToReturn);</span><br><span class="line">    else l1Token.safeTransfer(msg.sender, l1TokensToReturn);</span><br><span class="line"></span><br><span class="line">    emit LiquidityRemoved(l1TokensToReturn, lpTokenAmount, msg.sender);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="man-su-zhong-ji">慢速中继</span></h3>
<p>慢速中继，以及之后要讨论的即时中继，都会用到 <code>DepositData</code> 和 <code>RelayData</code> 这两个数据，前者表示存框交易的数据，后者表示中继交易的信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 来自 L2 存款交易的数据。</span><br><span class="line">  struct DepositData &#123;</span><br><span class="line">      uint256 chainId;</span><br><span class="line">      uint64 depositId;</span><br><span class="line">      address payable l1Recipient;</span><br><span class="line">      address l2Sender;</span><br><span class="line">      uint256 amount;</span><br><span class="line">      uint64 slowRelayFeePct;</span><br><span class="line">      uint64 instantRelayFeePct;</span><br><span class="line">      uint32 quoteTimestamp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 每个 L2 存款在任何时候都可以进行一次中继尝试。 中继尝试的特征在于其 RelayData。</span><br><span class="line">  struct RelayData &#123;</span><br><span class="line">      RelayState relayState;</span><br><span class="line">      address slowRelayer;</span><br><span class="line">      uint32 relayId;</span><br><span class="line">      uint64 realizedLpFeePct;</span><br><span class="line">      uint32 priceRequestTime;</span><br><span class="line">      uint256 proposerBond;</span><br><span class="line">      uint256 finalFee;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>下面我们看到 <code>relayDeposit</code> 方法，这个方法由中继者调用，执行从 L2 到 L1 的慢速中继。对于每一个存款而言，只能有一个待处理的中继，这个待处理的中继不包括有争议的中继。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function relayDeposit(DepositData memory depositData, uint64 realizedLpFeePct)</span><br><span class="line">    public</span><br><span class="line">    onlyIfRelaysEnabld()</span><br><span class="line">    nonReentrant()</span><br><span class="line">&#123;</span><br><span class="line">// realizedLPFeePct 不超过 50%，慢速和即时中继费用不超过25%，费用合计不超过100%</span><br><span class="line">    require(</span><br><span class="line">        depositData.slowRelayFeePct &lt;= 0.25e18 &amp;&amp;</span><br><span class="line">            depositData.instantRelayFeePct &lt;= 0.25e18 &amp;&amp;</span><br><span class="line">            realizedLpFeePct &lt;= 0.5e18,</span><br><span class="line">        &quot;Invalid fees&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 查看是否已经有待处理的中继</span><br><span class="line">    bytes32 depositHash = _getDepositHash(depositData);</span><br><span class="line"></span><br><span class="line">// 对于有争议的中继，relays 中对应的 hash 会被删除，这个条件可以通过</span><br><span class="line">    require(relays[depositHash] == bytes32(0), &quot;Pending relay exists&quot;);</span><br><span class="line"></span><br><span class="line">// 如果存款没有正在执行的中继，则关联调用者的中继尝试</span><br><span class="line">    uint32 priceRequestTime = uint32(getCurrentTime());</span><br><span class="line"></span><br><span class="line">    uint256 proposerBond = _getProposerBond(depositData.amount);</span><br><span class="line"></span><br><span class="line">    // 保存新中继尝试参数的哈希值。</span><br><span class="line">    // 注意：这个中继的活跃时间（liveness）可以在 BridgeAdmin 中更改，这意味着每个中继都有一个潜在的可变活跃时间。</span><br><span class="line">// 这不应该提供任何被利用机会，特别是因为 BridgeAdmin 状态（包括 liveness 值）被许可给跨域所有者。</span><br><span class="line">RelayData memory relayData =</span><br><span class="line">        RelayData(&#123;</span><br><span class="line">            relayState: RelayState.Pending,</span><br><span class="line">            slowRelayer: msg.sender,</span><br><span class="line">            relayId: numberOfRelays++, // 注意：在将 relayId 设置为其当前值的同时增加 numberOfRelays。</span><br><span class="line">            realizedLpFeePct: realizedLpFeePct,</span><br><span class="line">            priceRequestTime: priceRequestTime,</span><br><span class="line">            proposerBond: proposerBond,</span><br><span class="line">            finalFee: l1TokenFinalFee</span><br><span class="line">        &#125;);</span><br><span class="line">    relays[depositHash] = _getRelayDataHash(relayData);</span><br><span class="line"></span><br><span class="line">    bytes32 relayHash = _getRelayHash(depositData, relayData);</span><br><span class="line"></span><br><span class="line">// 健全性检查池是否有足够的余额来支付中继金额 + 提议者奖励。 OptimisticOracle 价格请求经过挑战期后，将在结算时支付奖励金额。</span><br><span class="line">    // 注意：liquidReserves 应该总是 &lt;= balance - bonds。</span><br><span class="line">    require(liquidReserves - pendingReserves &gt;= depositData.amount, &quot;Insufficient pool balance&quot;);</span><br><span class="line"></span><br><span class="line">// 计算总提议保证金并从调用者那里拉取，以便 OptimisticOracle 可以从这里拉取它。</span><br><span class="line">    uint256 totalBond = proposerBond + l1TokenFinalFee;</span><br><span class="line">    pendingReserves += depositData.amount; // 在正在处理的准备中预订此中继使用的最大流动性。</span><br><span class="line">    bonds += totalBond;</span><br><span class="line"></span><br><span class="line">    l1Token.safeTransferFrom(msg.sender, address(this), totalBond);</span><br><span class="line">    emit DepositRelayed(depositHash, depositData, relayData, relayHash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，存款哈希与 <code>depositData</code> 有关，中继哈希与 <code>depositData</code> 和 <code>relayData</code> 都有关。最后我们可以看到， <code>relayDeposit</code> 还未实际付款给用户的 L1 地址，需要等待中继者处理，或者通过加速处理中继。</p>
<h3><span id="jia-su-zhong-ji">加速中继</span></h3>
<p><code>speedUpRelay</code> 方法立即将存款金额减去费用后转发给 <code>l1Recipient</code>，即时中继者在待处理的中继挑战期后获得奖励。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  // 我们假设调用者已经执行了链外检查，以确保他们尝试中继的存款数据是有效的。</span><br><span class="line">// 如果存款数据无效，则即时中继者在无效存款数据发生争议后无权收回其资金。</span><br><span class="line">// 此外，没有人能够重新提交无效存款数据的中继，因为他们知道这将再次引起争议。</span><br><span class="line">// 另一方面，如果存款数据是有效的，那么即使它被错误地争议，即时中继者最终也会得到补偿，</span><br><span class="line">// 因为会激励其他人重新提交中继，以获得慢中继者的奖励。</span><br><span class="line">// 一旦有效中继最终确定，即时中继将得到补偿。因此，调用者在验证中继数据方面与争议者具有相同的责任。</span><br><span class="line">function speedUpRelay(DepositData memory depositData, RelayData memory relayData) public nonReentrant() &#123;</span><br><span class="line">      bytes32 depositHash = _getDepositHash(depositData);</span><br><span class="line">      _validateRelayDataHash(depositHash, relayData);</span><br><span class="line">      bytes32 instantRelayHash = _getInstantRelayHash(depositHash, relayData);</span><br><span class="line">      require(</span><br><span class="line">          // 只能在没有与之关联的现有即时中继的情况下加速待处理的中继。</span><br><span class="line">          getCurrentTime() &lt; relayData.priceRequestTime + optimisticOracleLiveness &amp;&amp;</span><br><span class="line">              relayData.relayState == RelayState.Pending &amp;&amp;</span><br><span class="line">              instantRelays[instantRelayHash] == address(0),</span><br><span class="line">          &quot;Relay cannot be sped up&quot;</span><br><span class="line">      );</span><br><span class="line">      instantRelays[instantRelayHash] = msg.sender;</span><br><span class="line"></span><br><span class="line">      // 从调用者那里提取中继金额减去费用并发送存款到 l1Recipient。</span><br><span class="line">		// 支付的总费用是 LP 费用、中继费用和即时中继费用的总和。</span><br><span class="line">      uint256 feesTotal =</span><br><span class="line">          _getAmountFromPct(</span><br><span class="line">              relayData.realizedLpFeePct + depositData.slowRelayFeePct + depositData.instantRelayFeePct,</span><br><span class="line">              depositData.amount</span><br><span class="line">          );</span><br><span class="line">      // 如果 L1 代币是 WETH，那么：a) 从即时中继者提取 WETH b) 解包 WETH 为 ETH c) 将 ETH 发送给接收者。</span><br><span class="line">      uint256 recipientAmount = depositData.amount - feesTotal;</span><br><span class="line">      if (isWethPool) &#123;</span><br><span class="line">          l1Token.safeTransferFrom(msg.sender, address(this), recipientAmount);</span><br><span class="line">          _unwrapWETHTo(depositData.l1Recipient, recipientAmount);</span><br><span class="line">          // 否则，这是一个普通的 ERC20 代币。 发送给收件人。</span><br><span class="line">      &#125; else l1Token.safeTransferFrom(msg.sender, depositData.l1Recipient, recipientAmount);</span><br><span class="line"></span><br><span class="line">      emit RelaySpedUp(depositHash, msg.sender, relayData);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3><span id="ji-shi-zhong-ji">即时中继</span></h3>
<p><code>relayAndSpeedUp</code> 执行即时中继。这个方法的函数内容与 <code>relayDeposit</code> 和 <code>speedUpRelay</code> 方法是一致的，这里就不具体注释了，可以参考前文中的注释。这个函数的代码几乎是直接将 <code>relayDeposit</code> 和 <code>speedUpRelay</code> 的代码进行了合并，代码冗余。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  // 由 Relayer 调用以执行从 L2 到 L1 的慢 + 快中继，完成相应的存款订单。</span><br><span class="line">  // 存款只能有一个待处理的中继。此方法实际上是串联的 relayDeposit 和 speedUpRelay 方法。</span><br><span class="line">// 这可以重构为只调用每个方法，但是结合传输和哈希计算可以节省一些 gas。</span><br><span class="line">function relayAndSpeedUp(DepositData memory depositData, uint64 realizedLpFeePct)</span><br><span class="line">      public</span><br><span class="line">      onlyIfRelaysEnabld()</span><br><span class="line">      nonReentrant()</span><br><span class="line">  &#123;</span><br><span class="line">      uint32 priceRequestTime = uint32(getCurrentTime());</span><br><span class="line"></span><br><span class="line">      require(</span><br><span class="line">          depositData.slowRelayFeePct &lt;= 0.25e18 &amp;&amp;</span><br><span class="line">              depositData.instantRelayFeePct &lt;= 0.25e18 &amp;&amp;</span><br><span class="line">              realizedLpFeePct &lt;= 0.5e18,</span><br><span class="line">          &quot;Invalid fees&quot;</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      bytes32 depositHash = _getDepositHash(depositData);</span><br><span class="line"></span><br><span class="line">      require(relays[depositHash] == bytes32(0), &quot;Pending relay exists&quot;);</span><br><span class="line"></span><br><span class="line">      uint256 proposerBond = _getProposerBond(depositData.amount);</span><br><span class="line"></span><br><span class="line">      RelayData memory relayData =</span><br><span class="line">          RelayData(&#123;</span><br><span class="line">              relayState: RelayState.Pending,</span><br><span class="line">              slowRelayer: msg.sender,</span><br><span class="line">              relayId: numberOfRelays++, // Note: Increment numberOfRelays at the same time as setting relayId to its current value.</span><br><span class="line">              realizedLpFeePct: realizedLpFeePct,</span><br><span class="line">              priceRequestTime: priceRequestTime,</span><br><span class="line">              proposerBond: proposerBond,</span><br><span class="line">              finalFee: l1TokenFinalFee</span><br><span class="line">          &#125;);</span><br><span class="line">      bytes32 relayHash = _getRelayHash(depositData, relayData);</span><br><span class="line">      relays[depositHash] = _getRelayDataHash(relayData);</span><br><span class="line"></span><br><span class="line">      bytes32 instantRelayHash = _getInstantRelayHash(depositHash, relayData);</span><br><span class="line">      require(</span><br><span class="line">          instantRelays[instantRelayHash] == address(0),</span><br><span class="line">          &quot;Relay cannot be sped up&quot;</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      require(liquidReserves - pendingReserves &gt;= depositData.amount, &quot;Insufficient pool balance&quot;);</span><br><span class="line"></span><br><span class="line">      uint256 totalBond = proposerBond + l1TokenFinalFee;</span><br><span class="line"></span><br><span class="line">      uint256 feesTotal =</span><br><span class="line">          _getAmountFromPct(</span><br><span class="line">              relayData.realizedLpFeePct + depositData.slowRelayFeePct + depositData.instantRelayFeePct,</span><br><span class="line">              depositData.amount</span><br><span class="line">          );</span><br><span class="line">      uint256 recipientAmount = depositData.amount - feesTotal;</span><br><span class="line"></span><br><span class="line">      bonds += totalBond;</span><br><span class="line">      pendingReserves += depositData.amount;</span><br><span class="line"></span><br><span class="line">      instantRelays[instantRelayHash] = msg.sender;</span><br><span class="line"></span><br><span class="line">      l1Token.safeTransferFrom(msg.sender, address(this), recipientAmount + totalBond);</span><br><span class="line"></span><br><span class="line">      if (isWethPool) &#123;</span><br><span class="line">          _unwrapWETHTo(depositData.l1Recipient, recipientAmount);</span><br><span class="line">      &#125; else l1Token.safeTransfer(depositData.l1Recipient, recipientAmount);</span><br><span class="line"></span><br><span class="line">      emit DepositRelayed(depositHash, depositData, relayData, relayHash);</span><br><span class="line">      emit RelaySpedUp(depositHash, msg.sender, relayData);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3><span id="zheng-yi">争议</span></h3>
<p>当对待处理的中继提出争议时，争议者需要想 Optimistic Oracle 提交提案，并等待争议解决。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  // 由 Disputer 调用以对待处理的中继提出争议。</span><br><span class="line">// 这个方法的结果是总是抛出中继，为另一个中继者提供处理相同存款的机会。</span><br><span class="line">// 在争议者和提议者之间，谁不正确，谁就失去了他们的质押。谁是正确的，谁就拿回来并获得一笔钱。</span><br><span class="line">function disputeRelay(DepositData memory depositData, RelayData memory relayData) public nonReentrant() &#123;</span><br><span class="line">      require(relayData.priceRequestTime + optimisticOracleLiveness &gt; getCurrentTime(), &quot;Past liveness&quot;);</span><br><span class="line">      require(relayData.relayState == RelayState.Pending, &quot;Not disputable&quot;);</span><br><span class="line">      // 检验输入数据</span><br><span class="line">      bytes32 depositHash = _getDepositHash(depositData);</span><br><span class="line">      _validateRelayDataHash(depositHash, relayData);</span><br><span class="line"></span><br><span class="line">      // 将提案和争议提交给 Optimistic Oracle。</span><br><span class="line">      bytes32 relayHash = _getRelayHash(depositData, relayData);</span><br><span class="line"></span><br><span class="line">      // 注意：在某些情况下，这会由于 Optimistic Oracle 的变化而失败，并且该方法将退还中继者。</span><br><span class="line">      bool success =</span><br><span class="line">          _requestProposeDispute(</span><br><span class="line">              relayData.slowRelayer,</span><br><span class="line">              msg.sender,</span><br><span class="line">              relayData.proposerBond,</span><br><span class="line">              relayData.finalFee,</span><br><span class="line">              _getRelayAncillaryData(relayHash)</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">		// 放弃中继并从跟踪的保证金中移除中继的保证金。</span><br><span class="line">      bonds -= relayData.finalFee + relayData.proposerBond;</span><br><span class="line">      pendingReserves -= depositData.amount;</span><br><span class="line">      delete relays[depositHash];</span><br><span class="line">      if (success) emit RelayDisputed(depositHash, _getRelayDataHash(relayData), msg.sender);</span><br><span class="line">      else emit RelayCanceled(depositHash, _getRelayDataHash(relayData), msg.sender);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其中， <code>_requestProposeDispute</code> 的函数内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  // 向 optimistic oracle 提议与 `customAncillaryData` 相关的中继事件的新价格为真。</span><br><span class="line">// 如果有人不同意中继参数，不管他们是否映射到 L2 存款，他们可以与预言机争议。</span><br><span class="line">  function _requestProposeDispute(</span><br><span class="line">      address proposer,</span><br><span class="line">      address disputer,</span><br><span class="line">      uint256 proposerBond,</span><br><span class="line">      uint256 finalFee,</span><br><span class="line">      bytes memory customAncillaryData</span><br><span class="line">  ) private returns (bool) &#123;</span><br><span class="line">      uint256 totalBond = finalFee + proposerBond;</span><br><span class="line">      l1Token.safeApprove(address(optimisticOracle), totalBond);</span><br><span class="line">      try</span><br><span class="line">          optimisticOracle.requestAndProposePriceFor(</span><br><span class="line">              identifier,</span><br><span class="line">              uint32(getCurrentTime()),</span><br><span class="line">              customAncillaryData,</span><br><span class="line">              IERC20(l1Token),</span><br><span class="line">              // 将奖励设置为 0，因为在中继提案经过挑战期后，我们将直接从该合约中结算提案人奖励支出。</span><br><span class="line">              0,</span><br><span class="line">              // 为价格请求设置 Optimistic oracle 提议者保证金。</span><br><span class="line">              proposerBond,</span><br><span class="line">              // 为价格请求设置 Optimistic oracle 活跃时间。</span><br><span class="line">              optimisticOracleLiveness,</span><br><span class="line">              proposer,</span><br><span class="line">              // 表示 &quot;True&quot;; 及提议的中继是合法的</span><br><span class="line">              int256(1e18)</span><br><span class="line">          )</span><br><span class="line">      returns (uint256 bondSpent) &#123;</span><br><span class="line">          if (bondSpent &lt; totalBond) &#123;</span><br><span class="line">              // 如果 Optimistic oracle 拉取得更少（由于最终费用的变化），则退还提议者。</span><br><span class="line">              uint256 refund = totalBond - bondSpent;</span><br><span class="line">              l1Token.safeTransfer(proposer, refund);</span><br><span class="line">              l1Token.safeApprove(address(optimisticOracle), 0);</span><br><span class="line">              totalBond = bondSpent;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; catch &#123;</span><br><span class="line">          // 如果 Optimistic oracle 中出现错误，这意味着已经更改了某些内容以使该请求无可争议。</span><br><span class="line">				// 为确保请求不会默认通过，退款提议者并提前返回，允许调用方法删除请求，但 Optimistic oracle 没有额外的追索权。</span><br><span class="line">          l1Token.safeTransfer(proposer, totalBond);</span><br><span class="line">          l1Token.safeApprove(address(optimisticOracle), 0);</span><br><span class="line"></span><br><span class="line">          // 提早返回，注意到提案+争议的尝试没有成功。</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      SkinnyOptimisticOracleInterface.Request memory request =</span><br><span class="line">          SkinnyOptimisticOracleInterface.Request(&#123;</span><br><span class="line">              proposer: proposer,</span><br><span class="line">              disputer: address(0),</span><br><span class="line">              currency: IERC20(l1Token),</span><br><span class="line">              settled: false,</span><br><span class="line">              proposedPrice: int256(1e18),</span><br><span class="line">              resolvedPrice: 0,</span><br><span class="line">              expirationTime: getCurrentTime() + optimisticOracleLiveness,</span><br><span class="line">              reward: 0,</span><br><span class="line">              finalFee: totalBond - proposerBond,</span><br><span class="line">              bond: proposerBond,</span><br><span class="line">              customLiveness: uint256(optimisticOracleLiveness)</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">      // 注意：在此之前不要提取资金，以避免任何不需要的转账。</span><br><span class="line">      l1Token.safeTransferFrom(msg.sender, address(this), totalBond);</span><br><span class="line">      l1Token.safeApprove(address(optimisticOracle), totalBond);</span><br><span class="line">      // 对我们刚刚发送的请求提出争议。</span><br><span class="line">      optimisticOracle.disputePriceFor(</span><br><span class="line">          identifier,</span><br><span class="line">          uint32(getCurrentTime()),</span><br><span class="line">          customAncillaryData,</span><br><span class="line">          request,</span><br><span class="line">          disputer,</span><br><span class="line">          address(this)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      // 返回 true 表示提案 + 争议调用成功。</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们来看看 <code>settleRelay</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  // 如果待处理中继价格请求在 OptimisticOracle 上有可用的价格，则奖励中继者，并将中继标记为完成。</span><br><span class="line"> // 我们使用 relayData 和 depositData 来计算中继价格请求在 OptimisticOracle 上唯一关联的辅助数据。</span><br><span class="line">// 如果传入的价格请求与待处理的中继价格请求不匹配，那么这将恢复(revert)。</span><br><span class="line">function settleRelay(DepositData memory depositData, RelayData memory relayData) public nonReentrant() &#123;</span><br><span class="line">      bytes32 depositHash = _getDepositHash(depositData);</span><br><span class="line">      _validateRelayDataHash(depositHash, relayData);</span><br><span class="line">      require(relayData.relayState == RelayState.Pending, &quot;Already settled&quot;);</span><br><span class="line">      uint32 expirationTime = relayData.priceRequestTime + optimisticOracleLiveness;</span><br><span class="line">      require(expirationTime &lt;= getCurrentTime(), &quot;Not settleable yet&quot;);</span><br><span class="line"></span><br><span class="line">      // 注意：此检查是为了给中继者一小段但合理的时间来完成中继，然后再被其他人“偷走”。</span><br><span class="line">		// 这是为了确保有动力快速解决中继。</span><br><span class="line">      require(</span><br><span class="line">          msg.sender == relayData.slowRelayer || getCurrentTime() &gt; expirationTime + 15 minutes,</span><br><span class="line">          &quot;Not slow relayer&quot;</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      // 将中继状态更新为已完成。 这可以防止中继的任何重新设处理。</span><br><span class="line">      relays[depositHash] = _getRelayDataHash(</span><br><span class="line">          RelayData(&#123;</span><br><span class="line">              relayState: RelayState.Finalized,</span><br><span class="line">              slowRelayer: relayData.slowRelayer,</span><br><span class="line">              relayId: relayData.relayId,</span><br><span class="line">              realizedLpFeePct: relayData.realizedLpFeePct,</span><br><span class="line">              priceRequestTime: relayData.priceRequestTime,</span><br><span class="line">              proposerBond: relayData.proposerBond,</span><br><span class="line">              finalFee: relayData.finalFee</span><br><span class="line">          &#125;)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      // 奖励中继者并支付 l1Recipient。</span><br><span class="line">       // 此时有两种可能的情况：</span><br><span class="line">       // - 这是一个慢速中继：在这种情况下，a) 向慢速中继者支付奖励 b) 向 l1Recipient 支付</span><br><span class="line">       //   金额减去已实现的 LP 费用和慢速中继费用。 转账没有加快，所以没有即时费用。</span><br><span class="line">       // - 这是一个即时中继：在这种情况下，a) 向慢速中继者支付奖励 b) 向即时中继者支付</span><br><span class="line">       //   全部桥接金额，减去已实现的 LP 费用并减去慢速中继费用。</span><br><span class="line">		//    当即时中继者调用 speedUpRelay 时，它们存入的金额相同，减去即时中继者费用。</span><br><span class="line">		//    结果，他们实际上得到了加速中继时所花费的费用 + InstantRelayFee。</span><br><span class="line"></span><br><span class="line">      uint256 instantRelayerOrRecipientAmount =</span><br><span class="line">          depositData.amount -</span><br><span class="line">              _getAmountFromPct(relayData.realizedLpFeePct + depositData.slowRelayFeePct, depositData.amount);</span><br><span class="line"></span><br><span class="line">      // 如果即时中继参数与批准的中继相匹配，则退款给即时中继者。</span><br><span class="line">      bytes32 instantRelayHash = _getInstantRelayHash(depositHash, relayData);</span><br><span class="line">      address instantRelayer = instantRelays[instantRelayHash];</span><br><span class="line"></span><br><span class="line">      // 如果这是 WETH 池并且即时中继者是地址 0x0（即中继没有加速），那么：</span><br><span class="line">      // a) 将 WETH 提取到 ETH 和 b) 将 ETH 发送给接收者。</span><br><span class="line">      if (isWethPool &amp;&amp; instantRelayer == address(0)) &#123;</span><br><span class="line">          _unwrapWETHTo(depositData.l1Recipient, instantRelayerOrRecipientAmount);</span><br><span class="line">          // 否则，这是一个正常的慢速中继正在完成，合约将 ERC20 发送给接收者，</span><br><span class="line">				// 或者这是一个即时中继的最终完成，我们需要用 WETH 偿还即时中继者。</span><br><span class="line">      &#125; else</span><br><span class="line">          l1Token.safeTransfer(</span><br><span class="line">              instantRelayer != address(0) ? instantRelayer : depositData.l1Recipient,</span><br><span class="line">              instantRelayerOrRecipientAmount</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">      // 需要支付费用和保证金。费用归解决者。保证金总是归到慢速中继者。</span><br><span class="line">      // 注意：为了 gas 效率，我们使用 `if`，所以如果它们是相同的地址，我们可以合并这些转账。</span><br><span class="line">      uint256 slowRelayerReward = _getAmountFromPct(depositData.slowRelayFeePct, depositData.amount);</span><br><span class="line">      uint256 totalBond = relayData.finalFee + relayData.proposerBond;</span><br><span class="line">      if (relayData.slowRelayer == msg.sender)</span><br><span class="line">          l1Token.safeTransfer(relayData.slowRelayer, slowRelayerReward + totalBond);</span><br><span class="line">      else &#123;</span><br><span class="line">          l1Token.safeTransfer(relayData.slowRelayer, totalBond);</span><br><span class="line">          l1Token.safeTransfer(msg.sender, slowRelayerReward);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      uint256 totalReservesSent = instantRelayerOrRecipientAmount + slowRelayerReward;</span><br><span class="line"></span><br><span class="line">      // 按更改的金额和分配的 LP 费用更新储备。</span><br><span class="line">      pendingReserves -= depositData.amount;</span><br><span class="line">      liquidReserves -= totalReservesSent;</span><br><span class="line">      utilizedReserves += int256(totalReservesSent);</span><br><span class="line">      bonds -= totalBond;</span><br><span class="line">      _updateAccumulatedLpFees();</span><br><span class="line">      _allocateLpFees(_getAmountFromPct(relayData.realizedLpFeePct, depositData.amount));</span><br><span class="line"></span><br><span class="line">      emit RelaySettled(depositHash, msg.sender, relayData);</span><br><span class="line"></span><br><span class="line">      // 清理状态存储并获得gas退款。</span><br><span class="line">		// 这也可以防止 `priceDisputed()` 重置这个新的 Finalized 中继状态。</span><br><span class="line">      delete instantRelays[instantRelayHash];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _allocateLpFees(uint256 allocatedLpFees) internal &#123;</span><br><span class="line">      undistributedLpFees += allocatedLpFees;</span><br><span class="line">      utilizedReserves += int256(allocatedLpFees);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们分析完了 Across 合约的主要功能的代码。</p>
<h2><span id="he-yue-bu-shu">合约部署</span></h2>
<p>部署合约目录 <code>deploy</code> 下包含 8 脚本，依次部署了管理合约，WETH 桥接池，Optimism，Arbitrum和Boba的信使，以及 Arbitrum，Optimism 和 Boba 的存款合约。由于过程比较简单，这里就不仔细分析了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy/</span><br><span class="line">├── 001_deploy_across_bridge_admin.js</span><br><span class="line">├── 002_deploy_across_weth_bridge_pool.js</span><br><span class="line">├── 003_deploy_across_optimism_wrapper.js</span><br><span class="line">├── 004_deploy_across_optimism_messenger.js</span><br><span class="line">├── 005_deploy_across_arbitrum_messenger.js</span><br><span class="line">├── 006_deploy_across_boba_messenger.js</span><br><span class="line">├── 007_deploy_across_ovm_bridge_deposit_box.js</span><br><span class="line">└── 008_deploy_across_avm_deposit_box.js</span><br></pre></td></tr></table></figure>
<h2><span id="zong-jie">总结</span></h2>
<p>Across 协议整体结构简单，流程清晰，支持了 Across 协议安全，快速的从 L2 向 L1 的资金转移。</p>
<p>代码中调用了 Optimistic Oracle 的接口来出和解决争议，对应的逻辑有空之后详说。</p>
<h3><span id="comments">Comments</span></h3>
</div><p class="post-tags"><i class="fa fa-tags" aria-hidden="true"></i><a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">#区块链</a></p></article></div><div class="post-copyright"><blockquote><p>版权声明：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">署名-相同方式共享 | CC BY-SA 4.0 </a>许可协议。</p></blockquote></div><footer><div class="paginator"><a href="/qiwihui-blog-162/" class="prev">PREV</a><a href="/qiwihui-blog-165/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'blog-qiwihui-com';
var disqus_identifier = 'qiwihui-blog-158/';
var disqus_title = 'Across 跨链桥合约解析';
var disqus_url = 'https://qiwihui.com/qiwihui-blog-158/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//blog-qiwihui-com.disqus.com/count.js" async></script><!-- block copyright--></footer></div><script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true,
        processEnvironments: true,
        skipTags: ["script","noscript","style","textarea","code","pre"]
    }
});
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-46660488-3",'auto');ga('send','pageview');</script><link rel="stylesheet" href="//cdn.datatables.net/1.10.7/css/jquery.dataTables.min.css" media="screen" type="text/css"><script src="//cdn.datatables.net/1.10.7/js/jquery.dataTables.min.js"></script><script>$(function(){$('.datatable').dataTable( {"order": [[ 0, "desc" ]],"iDisplayLength": -1,"lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]} );});</script></body></html>