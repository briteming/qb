<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 17. 多进程 — Python 进阶 · QIWIHUI</title><meta name="description" content="17. 多进程 — Python 进阶 - qiwihui"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/nella.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.12/css/all.css" integrity="sha384-G0fIWCsCzJIMAVNQPfjH08cyYaUtMwjJwqiRKxxE/rx96Uroj1BtIQ6MLJuheaO9" crossorigin="anonymous"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
google_ad_client: "ca-pub-8935595858652656",
enable_page_level_ads: true
});
</script><link rel="search" type="application/opensearchdescription+xml" href="https://qiwihui.com/atom.xml" title="QIWIHUI"><meta property="og:site_name" content="QIWIHUI"><meta property="og:url" content="https://qiwihui.com/qiwihui-blog-135/index.html"><meta property="og:title" content="17. 多进程 — Python 进阶"><meta property="og:description" content="17. 多进程 — Python 进阶"><meta property="og:type" content="article"><script src="//code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/images/avatar.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/search/" target="_self" class="nav-list-link">SEARCH</a></li><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/projects/" target="_self" class="nav-list-link">PROJECTS</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">TAGS</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="/links/" target="_self" class="nav-list-link">LINKS</a></li><!--li.nav-list-item--><!--    a.nav-list-link(class="search" href=url_for("search") target="_self") SEARCH--></ul></header><main class="container"></main><div class="post"><article class="post-block"><h1 class="post-title">17. 多进程 — Python 进阶</h1><div class="post-info">Aug 13, 2022<span class="categories"><i class="fa fa-bookmark" aria-hidden="true"></i></span><a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">#技术</a><span>15 min. read</span></div><div class="post-content"><p>在本文中，我们讨论了如何在Python中使用 <code>multiprocessing</code> 模块。</p>
<ul>
<li>如何创建和启动多个进程</li>
<li>如何等待进程完成</li>
<li>如何在进程之间共享数据</li>
<li>如何使用 <code>lock</code> 来防止竞态情</li>
<li>如何使用 <code>Queue</code> 进行进程安全的数据/任务处理</li>
<li>如何使用 <code>Pool</code> 来管理多个工作进程。</li>
</ul>
<a id="more"></a>
<h3><span id="chuang-jian-he-yun-xing-jin-cheng">创建和运行进程</span></h3>
<p>你可以使用 <code>multiprocessing.Process()</code> 创建一个进程。 它包含两个重要的参数：</p>
<ul>
<li><code>target</code>：进程启动时要调用的可调用对象（函数）</li>
<li><code>args</code>：目标函数的（函数）参数。 这必须是一个元组。</li>
</ul>
<p>使用 <code>process.start()</code> 启动一个进程</p>
<p>调用 <code>process.join()</code> 告诉程序在继续执行其余代码之前，应等待该进程完成。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_numbers</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">        result = i * i</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:        </span><br><span class="line">    processes = []</span><br><span class="line">    num_processes = os.cpu_count()</span><br><span class="line">    <span class="comment"># 机器CPU的数量，通常是确定进程数量的一个好选择</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建进程并分配每个进程一个函数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_processes):</span><br><span class="line">        process = Process(target=square_numbers)</span><br><span class="line">        processes.append(process)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动所有进程</span></span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">        process.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待所有进程结束</span></span><br><span class="line">    <span class="comment"># 阻塞主程序直到所有进程结束</span></span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">        process.join()</span><br></pre></td></tr></table></figure>
<h3><span id="zai-jin-cheng-zhi-jian-gong-xiang-shu-ju">在进程之间共享数据</span></h3>
<p>由于进程不在同一个内存空间中，因此它们无法访问相同（公共）数据。 因此，它们需要特殊的共享内存对象来共享数据。</p>
<p>可以使用 <code>Value</code> 或者 <code>Array</code> 将数据存储在共享内存变量中。</p>
<ul>
<li><code>Value(type, value)</code>：创建类型为 <code>type</code> 的 <code>ctypes</code> 对象。 使用 <code>.target</code> 访问该值。</li>
<li><code>Array(type, value)</code>：使用类型为 <code>type</code> 的元素创建一个 <code>ctypes</code> 数组。 用 <code>[]</code> 访问值。</li>
</ul>
<p>任务：创建两个进程，每个进程都应该有权访问一个共享变量并对其进行修改（在这种情况下，只是将其重复增加1达100次）。 创建另外两个共享一个数组的进程，然后修改（增加）该数组中的所有元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Value, Array</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_100</span><span class="params">(number)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">        number.value += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_100_array</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            numbers[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    shared_number = Value(<span class="string">'i'</span>, <span class="number">0</span>) </span><br><span class="line">    print(<span class="string">'Value at beginning:'</span>, shared_number.value)</span><br><span class="line"></span><br><span class="line">    shared_array = Array(<span class="string">'d'</span>, [<span class="number">0.0</span>, <span class="number">100.0</span>, <span class="number">200.0</span>])</span><br><span class="line">    print(<span class="string">'Array at beginning:'</span>, shared_array[:])</span><br><span class="line"></span><br><span class="line">    process1 = Process(target=add_100, args=(shared_number,))</span><br><span class="line">    process2 = Process(target=add_100, args=(shared_number,))</span><br><span class="line"></span><br><span class="line">    process3 = Process(target=add_100_array, args=(shared_array,))</span><br><span class="line">    process4 = Process(target=add_100_array, args=(shared_array,))</span><br><span class="line"></span><br><span class="line">    process1.start()</span><br><span class="line">    process2.start()</span><br><span class="line">    process3.start()</span><br><span class="line">    process4.start()</span><br><span class="line"></span><br><span class="line">    process1.join()</span><br><span class="line">    process2.join()</span><br><span class="line">    process3.join()</span><br><span class="line">    process4.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Value at end:'</span>, shared_number.value)</span><br><span class="line">    print(<span class="string">'Array at end:'</span>, shared_array[:])</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'end main'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Value at beginning: <span class="number">0</span></span><br><span class="line">Array at beginning: [<span class="number">0.0</span>, <span class="number">100.0</span>, <span class="number">200.0</span>]</span><br><span class="line">Value at end: <span class="number">144</span></span><br><span class="line">Array at end: [<span class="number">134.0</span>, <span class="number">237.0</span>, <span class="number">339.0</span>]</span><br><span class="line">end main</span><br></pre></td></tr></table></figure>
<h3><span id="ru-he-shi-yong-suo">如何使用锁</span></h3>
<p>请注意，在上面的示例中，两个进程应将共享值增加1达100次。 这样一来，总共进行了200次操作。 但是为什么终值不是200？</p>
<h3><span id="jing-tai-tiao-jian">竞态条件</span></h3>
<p>这里发生了竞态情况。当两个或多个进程或线程可以访问共享数据并且它们试图同时更改它们时，就会发生竞态情况。在我们的示例中，两个进程必须读取共享值，将其增加1，然后将其写回到共享变量中。如果这同时发生，则两个进程将读取相同的值，将其增加并写回。因此，两个进程都将相同的增加的值写回到共享对象中，并且该值未增加2。有关竞态条件的详细说明，请参见 <a href="https://www.notion.so/16-Python-1d15878dedcd42f18eed31799af94980" target="_blank" rel="noopener">16. 多线程 — Python 进阶</a> 。</p>
<h3><span id="bi-mian-dai-suo-de-jing-tai-tiao-jian">避免带锁的竞态条件</span></h3>
<p>锁（也称为互斥锁）是一种同步机制，用于在存在许多执行进程/线程的环境中强制限制对资源的访问。锁具有两种状态：锁定和解锁。如果状态为锁定，则在状态再次被解锁之前，不允许其他并发进程/线程进入此代码段。</p>
<p>两个函数很重要：</p>
<ul>
<li><code>lock.acquire()</code>：这将锁定状态并阻塞</li>
<li><code>lock.release()</code>：这将再次解锁状态。</li>
</ul>
<p>重要提示：块获得后，你应始终再次释放它！</p>
<p>在我们的示例中，读取并增加了共享变量的关键代码部分现已锁定。这样可以防止第二个进程同时修改共享库。我们的代码没有太大变化。所有新更改都在下面的代码中进行了注释。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import Lock</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Lock</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Value, Array</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_100</span><span class="params">(number, lock)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">        <span class="comment"># lock the state</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        </span><br><span class="line">        number.value += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 解锁状态</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_100_array</span><span class="params">(numbers, lock)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            lock.acquire()</span><br><span class="line">            numbers[i] += <span class="number">1</span></span><br><span class="line">            lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建锁</span></span><br><span class="line">    lock = Lock()</span><br><span class="line">    </span><br><span class="line">    shared_number = Value(<span class="string">'i'</span>, <span class="number">0</span>) </span><br><span class="line">    print(<span class="string">'Value at beginning:'</span>, shared_number.value)</span><br><span class="line"></span><br><span class="line">    shared_array = Array(<span class="string">'d'</span>, [<span class="number">0.0</span>, <span class="number">100.0</span>, <span class="number">200.0</span>])</span><br><span class="line">    print(<span class="string">'Array at beginning:'</span>, shared_array[:])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将锁传入目标函数</span></span><br><span class="line">    process1 = Process(target=add_100, args=(shared_number, lock))</span><br><span class="line">    process2 = Process(target=add_100, args=(shared_number, lock))</span><br><span class="line"></span><br><span class="line">    process3 = Process(target=add_100_array, args=(shared_array, lock))</span><br><span class="line">    process4 = Process(target=add_100_array, args=(shared_array, lock))</span><br><span class="line"></span><br><span class="line">    process1.start()</span><br><span class="line">    process2.start()</span><br><span class="line">    process3.start()</span><br><span class="line">    process4.start()</span><br><span class="line"></span><br><span class="line">    process1.join()</span><br><span class="line">    process2.join()</span><br><span class="line">    process3.join()</span><br><span class="line">    process4.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Value at end:'</span>, shared_number.value)</span><br><span class="line">    print(<span class="string">'Array at end:'</span>, shared_array[:])</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'end main'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Value at beginning: <span class="number">0</span></span><br><span class="line">Array at beginning: [<span class="number">0.0</span>, <span class="number">100.0</span>, <span class="number">200.0</span>]</span><br><span class="line">Value at end: <span class="number">200</span></span><br><span class="line">Array at end: [<span class="number">200.0</span>, <span class="number">300.0</span>, <span class="number">400.0</span>]</span><br><span class="line">end main</span><br></pre></td></tr></table></figure>
<h3><span id="shi-yong-suo-zuo-wei-shang-xia-wen-guan-li-qi">使用锁作为上下文管理器</span></h3>
<p>在 <code>lock.acquire()</code> 之后，你应该永远不要忘记调用 <code>lock.release()</code> 来解锁代码。 你还可以将锁用作上下文管理器，这将安全地锁定和解锁你的代码。 建议以这种方式使用锁：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_100</span><span class="params">(number, lock)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">        <span class="keyword">with</span> lock:</span><br><span class="line">            number.value += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3><span id="zai-python-zhong-shi-yong-dui-lie">在Python中使用队列</span></h3>
<p>数据也可以通过队列在进程之间共享。 队列可用于多线程和多进程环境中的线程安全/进程安全数据交换和数据处理，这意味着你可以避免使用任何同步原语（例如锁）。</p>
<p>队列
队列是遵循先进先出（FIFO）原理的线性数据结构。 一个很好的例子是排队等候的客户队列，其中首先服务的是第一位的客户。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建队列</span></span><br><span class="line">q = Queue()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">q.put(<span class="number">1</span>) <span class="comment"># 1</span></span><br><span class="line">q.put(<span class="number">2</span>) <span class="comment"># 2 1</span></span><br><span class="line">q.put(<span class="number">3</span>) <span class="comment"># 3 2 1 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在 q 看起来是这样的:</span></span><br><span class="line"><span class="comment"># back --&gt; 3 2 1 --&gt; front</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取和移除第一个元素</span></span><br><span class="line">first = q.get() <span class="comment"># --&gt; 1</span></span><br><span class="line">print(first) </span><br><span class="line"></span><br><span class="line"><span class="comment"># q 现在看起来是这样的:</span></span><br><span class="line"><span class="comment"># back --&gt; 3 2 --&gt; front</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3><span id="zai-duo-jin-cheng-zhong-shi-yong-dui-lie">在多进程中使用队列</span></h3>
<p>带有队列的操作是进程安全的。 除了 <code>task_done()</code> 和 <code>join()</code> 之外，多进程队列实现了 <code>queue.Queue</code> 的所有方法。 重要方法是：</p>
<ul>
<li><code>q.get()</code>：删除并返回第一项。 默认情况下，它会阻塞，直到该项可用为止。</li>
<li><code>q.put(item)</code>：将元素放在队列的末尾。 默认情况下，它会阻塞，直到有空闲插槽可用为止。</li>
<li><code>q.empty()</code>：如果队列为空，则返回True。</li>
<li><code>q.close()</code>：指示当前进程不会再将更多数据放入此队列。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用多进程队列在进程之间进行通信</span></span><br><span class="line"><span class="comment"># 队列是线程和进程安全的</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(numbers, queue)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">        queue.put(i*i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_negative</span><span class="params">(numbers, queue)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">        queue.put(i*<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    </span><br><span class="line">    numbers = range(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">    q = Queue()</span><br><span class="line"></span><br><span class="line">    p1 = Process(target=square, args=(numbers,q))</span><br><span class="line">    p2 = Process(target=make_negative, args=(numbers,q))</span><br><span class="line"></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 顺序可能不是按序列的</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">        print(q.get())</span><br><span class="line">        </span><br><span class="line">    print(<span class="string">'end main'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">-2</span></span><br><span class="line"><span class="number">-3</span></span><br><span class="line"><span class="number">-4</span></span><br><span class="line"><span class="number">-5</span></span><br><span class="line">end main</span><br></pre></td></tr></table></figure>
<h3><span id="jin-cheng-chi">进程池</span></h3>
<p>进程池对象控制可以向其提交作业的工作进程池。它支持带有超时和回调的异步结果，并具有并行映射实现。它可以自动管理可用的处理器，并将数据拆分为较小的块，然后由不同的进程并行处理。有关所有可能的方法，请参见 <a href="https://docs.python.org/3.7/library/multiprocessing.html#multiprocessing.pool" target="_blank" rel="noopener">https://docs.python.org/3.7/library/multiprocessing.html#multiprocessing.pool</a>。重要方法有</p>
<ul>
<li><code>map(func, iterable[, chunksize])</code>：此方法将 Iterable 分成许多块，作为单独的任务提交给进程池。这些块的（大约）大小可以通过将 chunksize 设置为正整数来指定。它会阻塞，直到结果准备好为止。</li>
<li><code>close()</code>：阻止将更多任务提交到池中。一旦完成所有任务，工作进程将退出。</li>
<li><code>join()</code>：等待工作进程退出。使用 <code>join()</code> 之前，必须先调用 <code>close()</code> 或 <code>terminate()</code>。</li>
<li><code>apply(func, args)</code>：使用参数args调用func。它会阻塞，直到结果准备好为止。 func仅在池的一个工作程序中执行。</li>
</ul>
<p>注意：也有不会阻塞的异步变体 <code>map_async()</code> 和 <code>apply_async()</code>。结果准备好后，他们可以执行回调。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cube</span><span class="params">(number)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> number * number * number</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    numbers = range(<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    p = Pool()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 默认情况下，这将分配此任务的最大可用处理器数 --&gt; os.cpu_count()</span></span><br><span class="line">    result = p.map(cube,  numbers)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># or </span></span><br><span class="line">    <span class="comment"># result = [p.apply(cube, args=(i,)) for i in numbers]</span></span><br><span class="line">    </span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    </span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">125</span>, <span class="number">216</span>, <span class="number">343</span>, <span class="number">512</span>, <span class="number">729</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>GitHub repo: <a href="https://github.com/qiwihui/blog" target="_blank" rel="noopener">qiwihui/blog</a></p>
<p>Follow me: <a href="https://github.com/qiwihui" target="_blank" rel="noopener">@qiwihui</a></p>
<p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p>
</blockquote>
<h3><span id="comments">Comments</span></h3>
</div><p class="post-tags"><i class="fa fa-tags" aria-hidden="true"></i><a href="/tags/%E6%8A%80%E6%9C%AF/">#技术</a><a href="/tags/Python/">#Python</a></p></article></div><div class="post-copyright"><blockquote><p>版权声明：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">署名-相同方式共享 | CC BY-SA 4.0 </a>许可协议。</p></blockquote></div><footer><div class="paginator"><a href="/qiwihui-blog-91/" class="prev">PREV</a><a href="/qiwihui-blog-72/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'blog-qiwihui-com';
var disqus_identifier = 'qiwihui-blog-135/';
var disqus_title = '17. 多进程 — Python 进阶';
var disqus_url = 'https://qiwihui.com/qiwihui-blog-135/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//blog-qiwihui-com.disqus.com/count.js" async></script><!-- block copyright--></footer></div><script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true,
        processEnvironments: true,
        skipTags: ["script","noscript","style","textarea","code","pre"]
    }
});
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-46660488-3",'auto');ga('send','pageview');</script><link rel="stylesheet" href="//cdn.datatables.net/1.10.7/css/jquery.dataTables.min.css" media="screen" type="text/css"><script src="//cdn.datatables.net/1.10.7/js/jquery.dataTables.min.js"></script><script>$(function(){$('.datatable').dataTable( {"order": [[ 0, "desc" ]],"iDisplayLength": -1,"lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]} );});</script></body></html>