<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Sui 类狼羊游戏项目开发实践 · QIWIHUI</title><meta name="description" content="Sui 类狼羊游戏项目开发实践 - qiwihui"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/nella.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.12/css/all.css" integrity="sha384-G0fIWCsCzJIMAVNQPfjH08cyYaUtMwjJwqiRKxxE/rx96Uroj1BtIQ6MLJuheaO9" crossorigin="anonymous"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
google_ad_client: "ca-pub-8935595858652656",
enable_page_level_ads: true
});
</script><link rel="search" type="application/opensearchdescription+xml" href="https://qiwihui.com/atom.xml" title="QIWIHUI"><meta property="og:site_name" content="QIWIHUI"><meta property="og:url" content="https://qiwihui.com/qiwihui-blog-171/index.html"><meta property="og:title" content="Sui 类狼羊游戏项目开发实践"><meta property="og:description" content="Sui 类狼羊游戏项目开发实践"><meta property="og:type" content="article"><script src="//code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/images/avatar.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/search/" target="_self" class="nav-list-link">SEARCH</a></li><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/projects/" target="_self" class="nav-list-link">PROJECTS</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">TAGS</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="/links/" target="_self" class="nav-list-link">LINKS</a></li><!--li.nav-list-item--><!--    a.nav-list-link(class="search" href=url_for("search") target="_self") SEARCH--></ul></header><main class="container"></main><div class="post"><article class="post-block"><h1 class="post-title">Sui 类狼羊游戏项目开发实践</h1><div class="post-info">May 15, 2024<span class="categories"><i class="fa fa-bookmark" aria-hidden="true"></i></span><a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">#技术</a><span>50 min. read</span></div><div class="post-content"><p>这篇文章将向你介绍 Sui Move 版本的类狼羊游戏的合约和前端编写过程。阅读前，建议先熟悉以下内容：</p>
<ol>
<li>Sui 命令行的基本操作；</li>
<li>Move 语法（<a href="https://mp.weixin.qq.com/s/epwJmR6oXCgtKtSbBqJyAw" target="_blank" rel="noopener">基础</a>和<a href="https://mp.weixin.qq.com/s/OXLyiUKzpFzAzc-PVxLvTA" target="_blank" rel="noopener">高级</a>）和 Sui Move 的对象语法；</li>
<li>React 基本语法。</li>
</ol>
<p>项目代码：</p>
<ul>
<li>合约：<a href="https://github.com/AptosWolfGame/fox_game_contract" target="_blank" rel="noopener">https://github.com/AptosWolfGame/fox_game_contract</a></li>
<li>前端： <a href="https://github.com/AptosWolfGame/fox_game_interface" target="_blank" rel="noopener">https://github.com/AptosWolfGame/fox_game_interface</a></li>
</ul>
<p>在线 Demo： <a href="https://fox-game-interface.vercel.app/" target="_blank" rel="noopener">https://fox-game-interface.vercel.app/</a></p>
<p><img src="https://user-images.githubusercontent.com/3297411/215304366-1aeb3308-5859-4613-a61a-f353d0b48877.png" alt="Untitled"></p>
<h2><span id="0x1-lang-yang-you-xi-de-gui-ze">0x1 狼羊游戏的规则</span></h2>
<p>狼羊游戏是以太坊上的 NFT 游戏，玩家通过购买NFT，然后将 NFT 质押来获取游戏代币 $WOOL，游戏代币 $WOOL 可用于之后的 NFT 铸造。有趣的是，狼羊游戏在这个过程中引入了随机性，让单纯的质押过程增加了不确定性，因而吸引了大量玩家参与到游戏中，狼羊游戏的可玩性也是建立在这个基础之上。具体的游戏规则为：</p>
<h3><span id="1-1-yang">1.1 <strong>羊</strong></span></h3>
<p>你有90%的概率铸造一只羊，每只羊都有独特的特征。以下是他们可以采取的行动：</p>
<ol>
<li>
<p>进入谷仓（Stake）</p>
</li>
<li>
<p>每天累积 10,000 羊毛 $WOOL</p>
</li>
<li>
<p>剪羊毛 $WOOL (Claim)</p>
<p>收到的羊毛80%累积在羊的身上，狼对剪下的羊毛收取20%的税，作为不攻击谷仓的回报。征税的 $WOOL 分配给目前在谷仓中质押的所有狼，数量与他们的 Alpha 分数成正比。</p>
</li>
<li>
<p>离开谷仓（Unstake）</p>
<p>羊被从谷仓中移除，所有 $WOOL 都被剪掉了。只有当羊积累了2天价值的 $WOOL 时才能离开谷仓，离开谷仓时你所有累积的 $WOOL 有50%的几率被狼全部偷走。被盗 $WOOL 分配给当前在谷仓中质押的所有狼，数量与他们的 Alpha 分数成正比。</p>
</li>
<li>
<p>使用 $WOOL 铸造一个新羊</p>
<p>铸造的 NFT 有10%的可能性实际上是狼！新的羊或狼有10%的几率被质押的狼偷走。每只狼的成功机会与他们的 Alpha 分数成正比。</p>
</li>
</ol>
<h3><span id="1-2-lang">1.2 <strong>狼</strong></span></h3>
<p>你有 10% 的机会铸造一只狼，每只狼都有独特的特征，包括 5~8 的 Alpha 值。Alpha值越高，狼从税收中赚取的 $WOOL 部分越高，偷一只新铸造的羊或狼的概率也越高。只有被质押的狼才能偷羊或赚取 $WOOL 税。</p>
<p>例子：狼A的 Alpha 为8，狼B的 Alpha 为6，并且他们都被质押。</p>
<ul>
<li>如果累计 70,000 羊毛作为税款，狼A将能够获得 40,000 羊毛，狼B将能够获得 30,000 羊毛；</li>
<li>如果新铸造的羊或狼被盗，狼A有57%概率获得，狼B有43%的概率获得。</li>
</ul>
<p>本次项目实践，我们将在 Sui 区块链上通过 Move 智能合约语言来实现游戏铸造，质押和获取 NFT 过程，并使用新的游戏元素：狐狸，鸡和鸡蛋，其中狐狸对应狼，鸡对应羊，鸡蛋对应羊毛，其他过程不变，我们将这个游戏命名为<strong>狐狸游戏</strong>。</p>
<h2><span id="0x2-he-yue-kai-fa">0x2 合约开发</span></h2>
<p>我们首先进行智能合约的编写，大致分为以下几个部分：</p>
<ul>
<li>创建 NFT</li>
<li>铸造 NFT（Mint）</li>
<li>质押 NFT （Stake）</li>
<li>鸡蛋（EGG）代币和收集鸡蛋（Collect/Claim）</li>
<li>提取 NFT（Unstake）</li>
</ul>
<h3><span id="2-1-nft-jie-gou">2.1 NFT 结构</span></h3>
<p>首先我们定义狐狸和鸡的 NFT 的结构，我们使用一个结构体 <code>FoxOrChicken</code> 来表示这个 NFT， 通过 <code>is_chicken</code> 来进行区分：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件：token_helper.move</span></span><br><span class="line">   <span class="comment">/// Defines a Fox or Chicken attribute. Eg: `pattern: 'panda'`</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Attribute</span></span> has store, copy, <span class="built_in">drop</span> &#123;</span><br><span class="line">       name: vector&lt;<span class="built_in">u8</span>&gt;,</span><br><span class="line">       value: vector&lt;<span class="built_in">u8</span>&gt;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">FoxOrChicken</span></span> has key, store &#123;</span><br><span class="line">       id: UID,</span><br><span class="line">       index: <span class="built_in">u64</span>, <span class="comment">// 索引</span></span><br><span class="line">       is_chicken: <span class="built_in">bool</span>, <span class="comment">// 是否是鸡</span></span><br><span class="line">       alpha: <span class="built_in">u8</span>, <span class="comment">// 狐狸的 alpha</span></span><br><span class="line">       url: Url, <span class="comment">// 图片</span></span><br><span class="line">       link: Url, <span class="comment">// NFT 链接</span></span><br><span class="line">       item_count: <span class="built_in">u8</span>, <span class="comment">// 当前 NFT 的数量</span></span><br><span class="line">       attributes: vector&lt;Attribute&gt;, <span class="comment">// 属性</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其中， <code>url</code> 既可以是指向 NFT 图片的链接，也可以是 base64 编码的字符串，比如 <code>data:image/svg+xml;base64,PHN2Zy......</code>。<code>link</code> 是一个指向 NFT 的页面。</p>
<h3><span id="2-2-chuang-jian-nft-dui-xiang">2.2 创建 NFT 对象</span></h3>
<p>整个创建 NFT 的逻辑大致就是根据随机种子生成对应属性索引，根据属性索引构建对应的属性列表和图片，从而创建 NFT。</p>
<p>创建 NFT 使用到 <code>FoCRegistry</code> 结构体，这个数据结构用于记录关于 NFT 的一些数据，比如 <code>foc_born</code> 记录生产的 NFT 总数，<code>foc_hash</code> 用于在生产 NFT 时产生随机数，该随机数用于生成 NFT 的属性，<code>foc_hash</code> 可以看作是 NFT 的基因。具体的属性值记录如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件：token_helper.move</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">FoCRegistry</span></span> has key, store &#123;</span><br><span class="line">        id: UID,</span><br><span class="line">        foc_born: <span class="built_in">u64</span>, <span class="comment">// NFT supply</span></span><br><span class="line">        foc_hash: vector&lt;<span class="built_in">u8</span>&gt;, <span class="comment">// NFT gene</span></span><br><span class="line">        rarities: vector&lt;vector&lt;<span class="built_in">u8</span>&gt;&gt;, <span class="comment">// 属性值概率</span></span><br><span class="line">        aliases: vector&lt;vector&lt;<span class="built_in">u8</span>&gt;&gt;, <span class="comment">// 属性值索引</span></span><br><span class="line">        types: Table&lt;ID, <span class="built_in">bool</span>&gt;, <span class="comment">// NFT 对象 ID 与类型（是否为鸡）的对应</span></span><br><span class="line">        alphas: Table&lt;ID, <span class="built_in">u8</span>&gt;, <span class="comment">// 狐狸的 Alpha 值</span></span><br><span class="line">        trait_data: Table&lt;<span class="built_in">u8</span>, Table&lt;<span class="built_in">u8</span>, Trait&gt;&gt;, <span class="comment">// 属性值，第一个u8是类型编号，第二个u8是属性索引</span></span><br><span class="line">        trait_types: vector&lt;vector&lt;<span class="built_in">u8</span>&gt;&gt;, <span class="comment">// 属性类型名称</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>创建 NFT 方法 <code>create_foc</code> 如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件：token_helper.move</span></span><br><span class="line">        public(friend) fun create_foc(</span><br><span class="line">        reg: &amp;<span class="keyword">mut</span> FoCRegistry, ctx: &amp;<span class="keyword">mut</span> TxContext</span><br><span class="line">    ): FoxOrChicken &#123;</span><br><span class="line">        <span class="keyword">let</span> id = object::new(ctx);</span><br><span class="line">        reg.foc_born = reg.foc_born + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 根据 UID 与旧 foc_hash 生产新的 foc_hash</span></span><br><span class="line">        vec::append(&amp;<span class="keyword">mut</span> reg.foc_hash, object::uid_to_bytes(&amp;id));</span><br><span class="line">        reg.foc_hash = hash(reg.foc_hash);</span><br><span class="line">        <span class="comment">// 随机产生 trait，并生成属性对 attributes</span></span><br><span class="line">        <span class="keyword">let</span> fc = generate_traits(reg);</span><br><span class="line">        <span class="keyword">let</span> attributes = get_attributes(reg, &amp;fc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> alpha = *vec::borrow(&amp;ALPHAS, (fc.alpha_index <span class="keyword">as</span> <span class="built_in">u64</span>));</span><br><span class="line">        <span class="comment">// 记录ID对应类型</span></span><br><span class="line">        table::add(&amp;<span class="keyword">mut</span> reg.types, object::uid_to_inner(&amp;id), fc.is_chicken);</span><br><span class="line">        <span class="keyword">if</span> (!fc.is_chicken) &#123;</span><br><span class="line">            table::add(&amp;<span class="keyword">mut</span> reg.alphas, object::uid_to_inner(&amp;id), alpha);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 生成事件</span></span><br><span class="line">        emit(FoCBorn &#123;</span><br><span class="line">            id: object::uid_to_inner(&amp;id),</span><br><span class="line">            index: reg.foc_born,</span><br><span class="line">            attributes: *&amp;attributes,</span><br><span class="line">            created_by: tx_context::sender(ctx),</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 返回生成的 FoxOrChicken</span></span><br><span class="line">        FoxOrChicken &#123;</span><br><span class="line">            id,</span><br><span class="line">            index: reg.foc_born,</span><br><span class="line">            is_chicken: fc.is_chicken,</span><br><span class="line">            alpha: alpha,</span><br><span class="line">            url: img_url(reg, &amp;fc),</span><br><span class="line">            link: link_url(reg.foc_born, fc.is_chicken),</span><br><span class="line">            attributes,</span><br><span class="line">            item_count: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>genetate_traits</code> 用于根据 <code>foc_hash</code> 生成 NFT 的属性值，此处属性为对应属性值的索引，<code>select_trait</code> 根据 A.J. Walker’s Alias 算法根据预先设置好的每一个属性的随机概率（<code>rarities</code>）来快速生成对应的属性索引。详情可以参考文章 <a href="https://zhuanlan.zhihu.com/p/436785581" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/436785581</a> 中 A.J. Walker’s Alias 算法一节****。****</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件： token_helper.move</span></span><br><span class="line">        <span class="comment">// generates traits for a specific token, checking to make sure it's unique</span></span><br><span class="line">    public fun generate_traits(</span><br><span class="line">        reg: &amp;FoCRegistry,</span><br><span class="line">        <span class="comment">// seed: &amp;vector&lt;u8&gt;</span></span><br><span class="line">    ): Traits &#123;</span><br><span class="line">        <span class="keyword">let</span> seed = reg.foc_hash;</span><br><span class="line">        <span class="keyword">let</span> is_chicken = *vec::borrow(&amp;seed, <span class="number">0</span>) &gt;= <span class="number">26</span>; <span class="comment">// 90% 0f 255</span></span><br><span class="line">        <span class="keyword">let</span> shift = <span class="keyword">if</span> (is_chicken) <span class="number">0</span> <span class="keyword">else</span> <span class="number">9</span>;</span><br><span class="line">        <span class="comment">// 根据随机种子生成属性</span></span><br><span class="line">                Traits &#123;</span><br><span class="line">            is_chicken,</span><br><span class="line">            fur: select_trait(reg, *vec::borrow(&amp;seed, <span class="number">1</span>), *vec::borrow(&amp;seed, <span class="number">10</span>), <span class="number">0</span> + shift),</span><br><span class="line">            head: select_trait(reg, *vec::borrow(&amp;seed, <span class="number">2</span>), *vec::borrow(&amp;seed, <span class="number">11</span>), <span class="number">1</span> + shift),</span><br><span class="line">            ears: select_trait(reg, *vec::borrow(&amp;seed, <span class="number">3</span>), *vec::borrow(&amp;seed, <span class="number">12</span>), <span class="number">2</span> + shift),</span><br><span class="line">            eyes: select_trait(reg, *vec::borrow(&amp;seed, <span class="number">4</span>), *vec::borrow(&amp;seed, <span class="number">13</span>), <span class="number">3</span> + shift),</span><br><span class="line">            nose: select_trait(reg, *vec::borrow(&amp;seed, <span class="number">5</span>), *vec::borrow(&amp;seed, <span class="number">14</span>), <span class="number">4</span> + shift),</span><br><span class="line">            mouth: select_trait(reg, *vec::borrow(&amp;seed, <span class="number">6</span>), *vec::borrow(&amp;seed, <span class="number">15</span>), <span class="number">5</span> + shift),</span><br><span class="line">            neck: select_trait(reg, *vec::borrow(&amp;seed, <span class="number">7</span>), *vec::borrow(&amp;seed, <span class="number">16</span>), <span class="number">6</span> + shift),</span><br><span class="line">            feet: select_trait(reg, *vec::borrow(&amp;seed, <span class="number">8</span>), *vec::borrow(&amp;seed, <span class="number">17</span>), <span class="number">7</span> + shift),</span><br><span class="line">            alpha_index: select_trait(reg, *vec::borrow(&amp;seed, <span class="number">9</span>), *vec::borrow(&amp;seed, <span class="number">18</span>), <span class="number">8</span> + shift),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据 A.J. Walker's Alias 算法计算属性值</span></span><br><span class="line">        fun select_trait(reg: &amp;FoCRegistry, seed1: <span class="built_in">u8</span>, seed2: <span class="built_in">u8</span>, trait_type: <span class="built_in">u64</span>): <span class="built_in">u8</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="class"><span class="keyword">trait</span> = (<span class="title">seed1</span></span> <span class="keyword">as</span> <span class="built_in">u64</span>) % vec::length(vec::borrow(&amp;reg.rarities, trait_type));</span><br><span class="line">        <span class="keyword">if</span> (seed2 &lt; *vec::borrow(vec::borrow(&amp;reg.rarities, trait_type), <span class="class"><span class="keyword">trait</span>)) &#123;</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="class"><span class="keyword">trait</span> <span class="title">as</span></span> <span class="built_in">u8</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        *vec::borrow(vec::borrow(&amp;reg.aliases, trait_type), <span class="class"><span class="keyword">trait</span>)</span></span><br><span class="line"><span class="class">    &#125;</span></span><br></pre></td></tr></table></figure>
<p>而 <code>get_attributes</code> 则是根据属性索引值对应从 <code>trait_types</code> 和 <code>trait_data</code> 中将属性的真实值取出并构建成属性数组。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">fun get_attributes(reg: &amp;<span class="keyword">mut</span> FoCRegistry, fc: &amp;Traits): vector&lt;Attribute&gt;</span><br></pre></td></tr></table></figure>
<p>而 <code>img_url</code> 则通过上述生成的特征构建出对应的 base64 编码的 svg 图片。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/// Construct an image URL for the NFT.</span></span><br><span class="line">fun img_url(reg:&amp;<span class="keyword">mut</span> FoCRegistry, fc: &amp;Traits): Url &#123;</span><br><span class="line">    url::new_unsafe_from_bytes(token_uri(reg, fc))</span><br><span class="line">&#125;</span><br><span class="line">    fun token_uri(reg: &amp;<span class="keyword">mut</span> FoCRegistry, foc: &amp;Traits): vector&lt;<span class="built_in">u8</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> uri = <span class="string">b"data:image/svg+xml;base64,"</span>;</span><br><span class="line">    vec::append(&amp;<span class="keyword">mut</span> uri, base64::encode(&amp;draw_svg(reg, foc)));</span><br><span class="line">    uri</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们可以通过 <code>create_foc</code> 方法创建一个 FoxOrChicken NFT。</p>
<h3><span id="2-3-zhu-zao-nft">2.3 铸造 NFT</span></h3>
<p>接下来我们看到铸造 NFT 过程，大致过程为：</p>
<ol>
<li>判断总供给量是否满足条件；</li>
<li>如果在 SUI 代币购买阶段，则转移 SUI 代币，否则，需要支付 EGG 代币进行铸造，EGG 的铸造和销毁在之后的章节中介绍；</li>
<li>铸造 NFT 并根据50%概率判断是否被质押的狐狸盗走；</li>
<li>如果选择质押则将 NFT 转入质押，否则转入铸造者的账户中。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件： fox.move</span></span><br><span class="line">    <span class="comment">/// mint a fox or chicken</span></span><br><span class="line">    public entry fun mint(</span><br><span class="line">        global: &amp;<span class="keyword">mut</span> Global,</span><br><span class="line">        treasury_cap: &amp;<span class="keyword">mut</span> TreasuryCap&lt;EGG&gt;,</span><br><span class="line">        amount: <span class="built_in">u64</span>,</span><br><span class="line">        stake: <span class="built_in">bool</span>,</span><br><span class="line">        pay_sui: vector&lt;Coin&lt;SUI&gt;&gt;,</span><br><span class="line">        pay_egg: vector&lt;Coin&lt;EGG&gt;&gt;,</span><br><span class="line">        ctx: &amp;<span class="keyword">mut</span> TxContext,</span><br><span class="line">    ) &#123;</span><br><span class="line">        assert_enabled(global);</span><br><span class="line">        <span class="comment">// 检查供应量是否超出总供应量</span></span><br><span class="line">        <span class="built_in">assert!</span>(amount &gt; <span class="number">0</span> &amp;&amp; amount &lt;= config::max_single_mint(), EINVALID_MINTING);</span><br><span class="line">        <span class="keyword">let</span> token_supply = token_helper::total_supply(&amp;global.foc_registry);</span><br><span class="line">        <span class="built_in">assert!</span>(token_supply + amount &lt;= config::target_max_tokens(), EALL_MINTED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> receiver_addr = sender(ctx);</span><br><span class="line">        <span class="comment">// 处理 SUI 代币付款</span></span><br><span class="line">        <span class="keyword">if</span> (token_supply &lt; config::paid_tokens()) &#123;</span><br><span class="line">            <span class="built_in">assert!</span>(vec::length(&amp;pay_sui) &gt; <span class="number">0</span>, EINSUFFICIENT_SUI_BALANCE);</span><br><span class="line">            <span class="built_in">assert!</span>(token_supply + amount &lt;= config::paid_tokens(), EALL_MINTED);</span><br><span class="line">            <span class="keyword">let</span> price = config::mint_price() * amount;</span><br><span class="line">            <span class="keyword">let</span> (paid, remainder) = merge_and_split(pay_sui, price, ctx);</span><br><span class="line">            coin::put(&amp;<span class="keyword">mut</span> global.balance, paid);</span><br><span class="line">            transfer(remainder, sender(ctx));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// EGG 代币付款阶段返还 SUI 代币</span></span><br><span class="line">            <span class="keyword">if</span> (vec::length(&amp;pay_sui) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                transfer(merge(pay_sui, ctx), sender(ctx));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                vec::destroy_empty(pay_sui);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> id = object::new(ctx);</span><br><span class="line">        <span class="keyword">let</span> seed = hash(object::uid_to_bytes(&amp;id));</span><br><span class="line">        <span class="keyword">let</span> total_egg_cost: <span class="built_in">u64</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> tokens: vector&lt;FoxOrChicken&gt; = vec::empty&lt;FoxOrChicken&gt;();</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; amount) &#123;</span><br><span class="line">            <span class="keyword">let</span> token_index = token_supply + i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 判断是否被狐狸盗走</span></span><br><span class="line">            <span class="keyword">let</span> recipient: address = select_recipient(&amp;<span class="keyword">mut</span> global.pack, receiver_addr, seed, token_index);</span><br><span class="line">            <span class="keyword">let</span> token = token_helper::create_foc(&amp;<span class="keyword">mut</span> global.foc_registry, ctx);</span><br><span class="line">            <span class="keyword">if</span> (!stake || recipient != receiver_addr) &#123;</span><br><span class="line">                transfer(token, receiver_addr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                vec::push_back(&amp;<span class="keyword">mut</span> tokens, token);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 计算 EGG 代币花费</span></span><br><span class="line">            total_egg_cost = total_egg_cost + mint_cost(token_index);</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 如果需要 EGG 代币花费，则转移并销毁 EGG 代币</span></span><br><span class="line">        <span class="keyword">if</span> (total_egg_cost &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">assert!</span>(vec::length(&amp;pay_egg) &gt; <span class="number">0</span>, EINSUFFICIENT_EGG_BALANCE);</span><br><span class="line">            <span class="comment">// burn EGG</span></span><br><span class="line">            <span class="keyword">let</span> total_egg = merge(pay_egg, ctx);</span><br><span class="line">            <span class="built_in">assert!</span>(coin::value(&amp;total_egg) &gt;= total_egg_cost, EINSUFFICIENT_EGG_BALANCE);</span><br><span class="line">            <span class="keyword">let</span> paid = coin::split(&amp;<span class="keyword">mut</span> total_egg, total_egg_cost, ctx);</span><br><span class="line">            egg::burn(treasury_cap, paid);</span><br><span class="line">            transfer(total_egg, sender(ctx));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec::length(&amp;pay_egg) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                transfer(merge(pay_egg, ctx), sender(ctx));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                vec::destroy_empty(pay_egg);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 铸造的同时质押，则将 NFT 转入重要中</span></span><br><span class="line">        <span class="keyword">if</span> (stake) &#123;</span><br><span class="line">            barn::stake_many_to_barn_and_pack(</span><br><span class="line">                &amp;<span class="keyword">mut</span> global.barn_registry,</span><br><span class="line">                &amp;<span class="keyword">mut</span> global.barn,</span><br><span class="line">                &amp;<span class="keyword">mut</span> global.pack,</span><br><span class="line">                tokens,</span><br><span class="line">                ctx</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vec::destroy_empty(tokens);</span><br><span class="line">        &#125;;</span><br><span class="line">        object::delete(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2-4-zhi-ya-nft">2.4 质押 NFT</span></h3>
<p>质押 NFT 时，我们通过 NFT 的属性值 <code>is_chicken</code> 来将不同的NFT放置到不同的容器中。其中，狐狸放置在 Pack 中，鸡放置在 Barn 中。每一个 NFT 在放置的同时记录对应的 owner 地址和用于计算质押收益的时间戳。</p>
<p>对于 <code>Barn</code>，除了记录 NFT 对象 <code>ID</code> 与 <code>Stake</code> 之间对应关系的 <code>items</code>，还增加了一个 <code>dynamic_field</code>，用于记录 owner 地址所有质押的 NFT 的数组： <code>dynamic_field: &lt;address, vector&lt;ID&gt;&gt;</code> 。</p>
<p>同理，<code>Pack</code> 也用 <code>items</code> 记录了质押的所有 NFT，用 Alpha 进行了分类存储，在 <code>ObjectTable&lt;u8, ObjectTable&lt;u64, Stake&gt;&gt;</code> 的结构中，第一个 <code>u8</code> 对应于 Alpha 值，第二个 <code>ObjectTable&lt;u64, Stake&gt;</code> 则是用 <code>ObjectTable</code> 实现了 <code>vector</code> 的功能，<code>u64</code> 对应 <code>Stake</code> 的索引，因此，item_size 这个属性记录了每个 Alpha 值对应 <code>ObjectTable</code> 的大小。</p>
<p><code>pack_indices</code> 用于记录每个 NFT 所在数组中的索引，最后还有一个 <code>dynamic_field</code> 记录了 owner 地址的所有质押的 NFT 的数组。</p>
<p>以上关于 Barn 和 Pack 的设计目的在于：</p>
<ol>
<li>当 <code>FoxOrChicken</code> 成为 <code>Stake</code> 的一个属性时，在区块链上无法追踪，因此，只能通过 <code>Stake</code> 的 Object ID 进行追踪，items 都是为了保证能直接通过 NFT 的 Object ID 来对应到 Stake；</li>
<li>记录 owner 地址的所有质押的 NFT ID 的数组是为了方便在业务中查询某个地址的质押的 NFT，<code>dynamic_field</code> 可以方便查询。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// struct to store a stake's token, owner, and earning values</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stake</span></span> has key, store &#123;</span><br><span class="line">    id: UID,</span><br><span class="line">    item: FoxOrChicken,</span><br><span class="line">    value: <span class="built_in">u64</span>, <span class="comment">// 用于质押收益计算的时间戳</span></span><br><span class="line">    owner: address,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Barn</span></span> has key, store &#123;</span><br><span class="line">    id: UID,</span><br><span class="line">    items: ObjectTable&lt;ID, Stake&gt;,</span><br><span class="line">    <span class="comment">// staked: Table&lt;address, vector&lt;ID&gt;&gt;, // address -&gt; stake_id</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pack</span></span> has key, store &#123;</span><br><span class="line">    id: UID,</span><br><span class="line">    items: ObjectTable&lt;<span class="built_in">u8</span>, ObjectTable&lt;<span class="built_in">u64</span>, Stake&gt;&gt;,</span><br><span class="line">    <span class="comment">// alpha -&gt; index -&gt; Stake</span></span><br><span class="line">    item_size: vector&lt;<span class="built_in">u64</span>&gt;,</span><br><span class="line">    <span class="comment">// size for each alpha</span></span><br><span class="line">    pack_indices: Table&lt;ID, <span class="built_in">u64</span>&gt;,</span><br><span class="line">    <span class="comment">// staked: Table&lt;address, vector&lt;ID&gt;&gt;, // address -&gt; stake_id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们接下来看到如何质押一个 Chicken 的 NFT，方法调用层级为 <code>stake_many_to_barn_and_pack -&gt; stake_chicken_to_barn -&gt; add_chicken_to_barn, record_staked</code> ：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件： Token_helper.move</span></span><br><span class="line">        <span class="comment">// 质押多个 NFT</span></span><br><span class="line">        public fun stake_many_to_barn_and_pack(</span><br><span class="line">        reg: &amp;<span class="keyword">mut</span> BarnRegistry,</span><br><span class="line">        barn: &amp;<span class="keyword">mut</span> Barn,</span><br><span class="line">        pack: &amp;<span class="keyword">mut</span> Pack,</span><br><span class="line">        tokens: vector&lt;FoxOrChicken&gt;,</span><br><span class="line">        ctx: &amp;<span class="keyword">mut</span> TxContext,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">let</span> i = vec::length&lt;FoxOrChicken&gt;(&amp;tokens);</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> token = vec::pop_back(&amp;<span class="keyword">mut</span> tokens);</span><br><span class="line">            <span class="comment">// 通过属性 is_chicken 判断质押方向</span></span><br><span class="line">            <span class="keyword">if</span> (token_helper::is_chicken(&amp;token)) &#123;</span><br><span class="line">                <span class="comment">// 更新收益</span></span><br><span class="line">                update_earnings(reg, ctx);</span><br><span class="line">                stake_chicken_to_barn(reg, barn, token, ctx);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stake_fox_to_pack(reg, pack, token, ctx);</span><br><span class="line">            &#125;;</span><br><span class="line">            i = i - <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        vec::destroy_empty(tokens)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        fun stake_chicken_to_barn(reg: &amp;<span class="keyword">mut</span> BarnRegistry, barn: &amp;<span class="keyword">mut</span> Barn, item: FoxOrChicken, ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        reg.total_chicken_staked = reg.total_chicken_staked + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> stake_id = add_chicken_to_barn(reg, barn, item, ctx);</span><br><span class="line">                <span class="comment">// 记录 owner 地址的所有质押的 NFT</span></span><br><span class="line">        record_staked(&amp;<span class="keyword">mut</span> barn.id, sender(ctx), stake_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        fun add_chicken_to_barn(reg: &amp;<span class="keyword">mut</span> BarnRegistry, barn: &amp;<span class="keyword">mut</span> Barn, item: FoxOrChicken, ctx: &amp;<span class="keyword">mut</span> TxContext): ID &#123;</span><br><span class="line">        <span class="keyword">let</span> foc_id = object::id(&amp;item);</span><br><span class="line">        <span class="comment">// 获取当前时间戳</span></span><br><span class="line">        <span class="keyword">let</span> value = timestamp_now(reg, ctx);</span><br><span class="line">        <span class="keyword">let</span> stake = Stake &#123;</span><br><span class="line">            id: object::new(ctx),</span><br><span class="line">            item,</span><br><span class="line">            value,</span><br><span class="line">            owner: sender(ctx),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 生成并添加质押</span></span><br><span class="line">        <span class="keyword">let</span> stake_id = object::id(&amp;stake);</span><br><span class="line">        emit(FoCStaked &#123; id: foc_id, owner: sender(ctx), value &#125;);</span><br><span class="line">        object_table::add(&amp;<span class="keyword">mut</span> barn.items, foc_id, stake);</span><br><span class="line">        stake_id</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        fun record_staked(staked: &amp;<span class="keyword">mut</span> UID, account: address, stake_id: ID) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dof::exists_(staked, account)) &#123;</span><br><span class="line">            vec::push_back(dof::borrow_mut(staked, account), stake_id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dof::add(staked, account, vec::singleton(stake_id));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>同理，质押 Fox 进入 Pack 中的过程也是类似的，这里就不再赘述，方法调用层级为 <code>stake_many_to_barn_and_pack -&gt;</code> <code>stake_fox_to_pack -&gt;``add_fox_to_pack, record_staked</code> 。</p>
<h3><span id="2-5-ti-qu-nft">2.5 提取 NFT</span></h3>
<p>提取 Chicken NFT 时，方法调用层级为 <code>claim_many_from_barn_and_pack -&gt; claim_chicken_from_barn -&gt; remove_chicken_from_barn, remove_staked</code></p>
<p>主要的过程为：</p>
<ol>
<li>判断 NFT 类型，根据类型从不同的容器中提取 NFT；</li>
<li>判断 NFT 是否存在，是否超过最小质押时间；</li>
<li>计算质押收益；</li>
<li>如果选择提取 NFT，则收益50%概率被狐狸全部拿走；</li>
<li>如果只收集鸡蛋，则需要交 20% 作为保护费。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件： token_helper.move</span></span><br><span class="line">    <span class="comment">// 提取多个 NFT</span></span><br><span class="line">        public fun claim_many_from_barn_and_pack(</span><br><span class="line">        foc_reg: &amp;<span class="keyword">mut</span> FoCRegistry,</span><br><span class="line">        reg: &amp;<span class="keyword">mut</span> BarnRegistry,</span><br><span class="line">        barn: &amp;<span class="keyword">mut</span> Barn,</span><br><span class="line">        pack: &amp;<span class="keyword">mut</span> Pack,</span><br><span class="line">        treasury_cap: &amp;<span class="keyword">mut</span> TreasuryCap&lt;EGG&gt;,</span><br><span class="line">        tokens: vector&lt;ID&gt;,</span><br><span class="line">        unstake: <span class="built_in">bool</span>,</span><br><span class="line">        ctx: &amp;<span class="keyword">mut</span> TxContext,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// 更新收益</span></span><br><span class="line">        update_earnings(reg, ctx);</span><br><span class="line">        <span class="keyword">let</span> i = vec::length&lt;ID&gt;(&amp;tokens);</span><br><span class="line">        <span class="keyword">let</span> owed: <span class="built_in">u64</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> token_id = vec::pop_back(&amp;<span class="keyword">mut</span> tokens);</span><br><span class="line">            <span class="comment">// 通过 ID 判断是否为 chickena</span></span><br><span class="line">            <span class="comment">// 计算提取收益 owed</span></span><br><span class="line">            <span class="keyword">if</span> (token_helper::is_chicken_from_id(foc_reg, token_id)) &#123;</span><br><span class="line">                owed = owed + claim_chicken_from_barn(reg, barn, token_id, unstake, ctx);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                owed = owed + claim_fox_from_pack(foc_reg, reg, pack, token_id, unstake, ctx);</span><br><span class="line">            &#125;;</span><br><span class="line">            i = i - <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 根据 owed 的数量为地址铸造 EGG 代币</span></span><br><span class="line">        <span class="keyword">if</span> (owed == <span class="number">0</span>) &#123; <span class="keyword">return</span> &#125;;</span><br><span class="line">        egg::mint(treasury_cap, owed, sender(ctx), ctx);</span><br><span class="line">        vec::destroy_empty(tokens)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        fun claim_chicken_from_barn(</span><br><span class="line">        reg: &amp;<span class="keyword">mut</span> BarnRegistry,</span><br><span class="line">        barn: &amp;<span class="keyword">mut</span> Barn,</span><br><span class="line">        foc_id: ID,</span><br><span class="line">        unstake: <span class="built_in">bool</span>,</span><br><span class="line">        ctx: &amp;<span class="keyword">mut</span> TxContext</span><br><span class="line">    ): <span class="built_in">u64</span> &#123;</span><br><span class="line">        <span class="comment">// 判断需要提取的 NFT 是否存在</span></span><br><span class="line">        <span class="built_in">assert!</span>(object_table::contains(&amp;barn.items, foc_id), ENOT_IN_PACK_OR_BARN);</span><br><span class="line">        <span class="keyword">let</span> stake_time = get_chicken_stake_value(barn, foc_id);</span><br><span class="line">        <span class="keyword">let</span> timenow = timestamp_now(reg, ctx);</span><br><span class="line">        <span class="comment">// 判断是否超过了 48 小时的最小质押时间</span></span><br><span class="line">        <span class="built_in">assert!</span>(!(unstake &amp;&amp; timenow - stake_time &lt; MINIMUM_TO_EXIT), ESTILL_COLD);</span><br><span class="line">        <span class="keyword">let</span> owed: <span class="built_in">u64</span>;</span><br><span class="line">        <span class="comment">// 判断是否超过了最大 EGG 铸造量，并计算质押所得</span></span><br><span class="line">        <span class="keyword">if</span> (reg.total_egg_earned &lt; MAXIMUM_GLOBAL_EGG) &#123;</span><br><span class="line">            owed = (timenow - stake_time) * DAILY_EGG_RATE / ONE_DAY_IN_SECOND;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stake_time &gt; reg.last_claim_timestamp) &#123;</span><br><span class="line">            owed = <span class="number">0</span>; <span class="comment">// $WOOL production stopped already</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// stop earning additional $EGG if it's all been earned</span></span><br><span class="line">            owed = (reg.last_claim_timestamp - stake_time) * DAILY_EGG_RATE / ONE_DAY_IN_SECOND;</span><br><span class="line">        &#125;;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> (unstake) &#123;</span><br><span class="line">            <span class="comment">// 如果进行提取，则有50%的概率 EGG 全部被盗走</span></span><br><span class="line">            <span class="keyword">let</span> id = object::new(ctx);</span><br><span class="line">            <span class="comment">// FIXME</span></span><br><span class="line">            <span class="keyword">if</span> (random::rand_u64_range_with_seed(hash(object::uid_to_bytes(&amp;id)), <span class="number">0</span>, <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 50% chance of all $EGG stolen</span></span><br><span class="line">                pay_fox_tax(reg, owed);</span><br><span class="line">                owed = <span class="number">0</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            object::delete(id);</span><br><span class="line">            <span class="comment">// 更新质押数据，并移除质押，转移 NFT 给 owner 地址</span></span><br><span class="line">            reg.total_chicken_staked = reg.total_chicken_staked - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> (item, stake_id) = remove_chicken_from_barn(barn, foc_id, ctx);</span><br><span class="line">            remove_staked(&amp;<span class="keyword">mut</span> barn.id, sender(ctx), stake_id);</span><br><span class="line">            transfer::transfer(item, sender(ctx));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 如果只是收集 EGG，则 20% 作为保护费交给狐狸</span></span><br><span class="line">            <span class="comment">// percentage tax to staked foxes</span></span><br><span class="line">            pay_fox_tax(reg, owed * EGG_CLAIM_TAX_PERCENTAGE / <span class="number">100</span>);</span><br><span class="line">            <span class="comment">// remainder goes to Chicken owner</span></span><br><span class="line">            owed = owed * (<span class="number">100</span> - EGG_CLAIM_TAX_PERCENTAGE) / <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 重设质押状态</span></span><br><span class="line">            set_chicken_stake_value(barn, foc_id, timenow);</span><br><span class="line">        &#125;;</span><br><span class="line">        emit(FoCClaimed &#123; id: foc_id, earned: owed, unstake &#125;);</span><br><span class="line">        owed</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>同理，从 Pack 中提取 Fox  中的过程也是类似的，这里就不再赘述。</p>
<h3><span id="2-6-chuang-jian-egg-dai-bi-he-shou-ji-egg-dai-bi">2.6 创建 EGG 代币和收集 EGG 代币</span></h3>
<p>EGG 代币创建过程使用了 one-time-witness 模式，具体可以参考：<a href="https://mp.weixin.qq.com/s/OXLyiUKzpFzAzc-PVxLvTA" target="_blank" rel="noopener">Move 高阶语法 | 共学课优秀笔记</a> 中的 Witness 模式一节。</p>
<p>代币的铸造能力 <code>treasury_cap: TreasuryCap&lt;EGG&gt;</code> 保存为共享对象，但是 <code>mint</code> 和 <code>burn</code> 方法t通过 <code>friend</code> 关键字限制了只能在 <code>fox</code> 和 <code>barn</code> 模块中调用，因此控制了代币的产生和销毁的权限。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件： egg.move</span></span><br><span class="line">module fox_game::egg &#123;</span><br><span class="line">    <span class="keyword">use</span> std::option;</span><br><span class="line">    <span class="keyword">use</span> sui::coin::&#123;<span class="keyword">Self</span>, Coin, TreasuryCap&#125;;</span><br><span class="line">    <span class="keyword">use</span> sui::transfer;</span><br><span class="line">    <span class="keyword">use</span> sui::tx_context::TxContext;</span><br><span class="line"></span><br><span class="line">    friend fox_game::fox;</span><br><span class="line">    friend fox_game::barn;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EGG</span></span> has <span class="built_in">drop</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    fun init(witness: EGG, ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        <span class="keyword">let</span> (treasury_cap, metadata) = coin::create_currency&lt;EGG&gt;(</span><br><span class="line">            witness,</span><br><span class="line">            <span class="number">9</span>,</span><br><span class="line">            <span class="string">b"EGG"</span>,</span><br><span class="line">            <span class="string">b"Fox Game Egg"</span>,</span><br><span class="line">            <span class="string">b"Fox game egg coin"</span>,</span><br><span class="line">            option::none(),</span><br><span class="line">            ctx</span><br><span class="line">        );</span><br><span class="line">        transfer::freeze_object(metadata);</span><br><span class="line">        transfer::share_object(treasury_cap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Manager can mint new coins</span></span><br><span class="line">    public(friend) fun mint(</span><br><span class="line">        treasury_cap: &amp;<span class="keyword">mut</span> TreasuryCap&lt;EGG&gt;, amount: <span class="built_in">u64</span>, recipient: address, ctx: &amp;<span class="keyword">mut</span> TxContext</span><br><span class="line">    ) &#123;</span><br><span class="line">        coin::mint_and_transfer(treasury_cap, amount, recipient, ctx)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Manager can burn coins</span></span><br><span class="line">    public(friend) fun burn(treasury_cap: &amp;<span class="keyword">mut</span> TreasuryCap&lt;EGG&gt;, coin: Coin&lt;EGG&gt;) &#123;</span><br><span class="line">        coin::burn(treasury_cap, coin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2-7-chu-shi-hua-fang-fa-he-entry-fang-fa">2.7 初始化方法和 entry 方法</span></h3>
<p><code>fox</code> 模块作为整个包的入口模块，将对所有模块进行初始化，并提供 entry 方法。</p>
<p>我们在 fox 模块中设置了 <code>Global</code> 作为全局参数的结构体，用来保存不同模块需要用到的不同对象，一来方便我们看到系统需要处理的对象信息，二来减少了方法调用时需要传入的参数个数，通过Global对象将不同模块的对象进行分发，可以有效减少代码复杂度。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件: fox.move</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Global</span></span> has key &#123;</span><br><span class="line">        id: UID,</span><br><span class="line">        minting_enabled: <span class="built_in">bool</span>,</span><br><span class="line">        balance: Balance&lt;SUI&gt;,</span><br><span class="line">        pack: Pack,</span><br><span class="line">        barn: Barn,</span><br><span class="line">        barn_registry: BarnRegistry,</span><br><span class="line">        foc_registry: FoCRegistry,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun init(ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        <span class="comment">// 初始化 FoC 管理权限</span></span><br><span class="line">        transfer(token_helper::init_foc_manage_cap(ctx), sender(ctx));</span><br><span class="line">        <span class="comment">// 初始化全局设置</span></span><br><span class="line">        share_object(Global &#123;</span><br><span class="line">            id: object::new(ctx),</span><br><span class="line">            minting_enabled: <span class="literal">true</span>,</span><br><span class="line">            balance: balance::zero(),</span><br><span class="line">            barn_registry: barn::init_barn_registry(ctx),</span><br><span class="line">            pack: barn::init_pack(ctx),</span><br><span class="line">            barn: barn::init_barn(ctx),</span><br><span class="line">            foc_registry: token_helper::init_foc_registry(ctx),</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 初始化时间设置权限</span></span><br><span class="line">        transfer(config::init_time_manager_cap(ctx), @<span class="number">0xa3e46ec682bb5082849c240d2f2d20b0f6e054aa</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>除了之前介绍过的 mint 方法，我们还提供用于质押和提取 NFT 的 entry 方法：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件： fox.move</span></span><br><span class="line">        public entry fun add_many_to_barn_and_pack(</span><br><span class="line">        global: &amp;<span class="keyword">mut</span> Global,</span><br><span class="line">        tokens: vector&lt;FoxOrChicken&gt;,</span><br><span class="line">        ctx: &amp;<span class="keyword">mut</span> TxContext,</span><br><span class="line">    ) &#123;</span><br><span class="line">        barn::stake_many_to_barn_and_pack(&amp;<span class="keyword">mut</span> global.barn_registry, &amp;<span class="keyword">mut</span> global.barn, &amp;<span class="keyword">mut</span> global.pack, tokens, ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public entry fun claim_many_from_barn_and_pack(</span><br><span class="line">        global: &amp;<span class="keyword">mut</span> Global,</span><br><span class="line">        treasury_cap: &amp;<span class="keyword">mut</span> TreasuryCap&lt;EGG&gt;,</span><br><span class="line">        tokens: vector&lt;ID&gt;,</span><br><span class="line">        unstake: <span class="built_in">bool</span>,</span><br><span class="line">        ctx: &amp;<span class="keyword">mut</span> TxContext,</span><br><span class="line">    ) &#123;</span><br><span class="line">        barn::claim_many_from_barn_and_pack(</span><br><span class="line">            &amp;<span class="keyword">mut</span> global.foc_registry,</span><br><span class="line">            &amp;<span class="keyword">mut</span> global.barn_registry,</span><br><span class="line">            &amp;<span class="keyword">mut</span> global.barn,</span><br><span class="line">            &amp;<span class="keyword">mut</span> global.pack,</span><br><span class="line">            treasury_cap,</span><br><span class="line">            tokens,</span><br><span class="line">            unstake,</span><br><span class="line">            ctx</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2-8-shi-jian-chuo-wen-ti">2.8 时间戳问题</span></h3>
<p>目前 Sui 区块链还没有完全实现区块时间，而目前提供的 <code>tx_context::epoch()</code> 的精度为24小时，无法满足游戏需求。因此在游戏中，我们通过手动设置时间戳来模拟时间增加，以确保游戏顺利进行。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件: barn.move</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">BarnRegistry</span></span> has key, store &#123;</span><br><span class="line">        id: UID,</span><br><span class="line">        <span class="comment">// 其他属性省略</span></span><br><span class="line">        <span class="comment">// fake_timestamp</span></span><br><span class="line">        timestamp: <span class="built_in">u64</span>,</span><br><span class="line">    &#125;</span><br><span class="line">        public(friend) fun set_timestamp(reg: &amp;<span class="keyword">mut</span> BarnRegistry, current: <span class="built_in">u64</span>, _ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        reg.timestamp = current;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 当前时间戳</span></span><br><span class="line">    fun timestamp_now(reg: &amp;<span class="keyword">mut</span> BarnRegistry, _ctx: &amp;<span class="keyword">mut</span> TxContext): <span class="built_in">u64</span> &#123;</span><br><span class="line">        reg.timestamp</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在初始化时，将设置时间的能力给到了一个预先生成的专门用于设置时间戳的地址 <code>0xa3e46ec682bb5082849c240d2f2d20b0f6e054aa</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件: config.move</span></span><br><span class="line">        <span class="comment">// Manager cap to set time</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TimeManagerCap</span></span> has key, store &#123; id: UID &#125;</span><br><span class="line"></span><br><span class="line">    public(friend) fun init_time_manager_cap(ctx: &amp;<span class="keyword">mut</span> TxContext): TimeManagerCap &#123;</span><br><span class="line">        TimeManagerCap &#123; id: object::new(ctx) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件: fox.move</span></span><br><span class="line">        fun init(ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        transfer(config::init_time_manager_cap(ctx), @<span class="number">0xa3e46ec682bb5082849c240d2f2d20b0f6e054aa</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        public entry fun set_timestamp(_: &amp;TimeManagerCap, global: &amp;<span class="keyword">mut</span> Global, current: <span class="built_in">u64</span>, ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        barn::set_timestamp(&amp;<span class="keyword">mut</span> global.barn_registry, current, ctx)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>之后，我们可以设置定时任务进行时间戳更新，通过调用设置时间的命令进行，详细结果可以查看 3.2 节合约命令行调用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sui client call --<span class="keyword">function</span> set_timestamp --module fox --package <span class="variable">$&#123;fox_game&#125;</span> --args <span class="variable">$&#123;time_cap&#125;</span> <span class="variable">$&#123;global&#125;</span> \"$(date +%s)\" --gas-budget 30000</span><br></pre></td></tr></table></figure>
<p>至此，我们介绍了合约部分的主要功能，详细的代码可以阅读项目仓库。</p>
<h2><span id="0x3-he-yue-bu-shu-he-diao-yong">0x3 合约部署和调用</span></h2>
<p>下面，我们首先将部署合约，并通过命令行进行方法的调用。</p>
<h3><span id="3-1-he-yue-bu-shu">3.1 合约部署</span></h3>
<p>通过以下命令可以编译和部署合约：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sui move build</span><br><span class="line">sui client publish . --gas-budget 300000</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sui client publish . --gas-budget 300000</span><br><span class="line">UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git</span><br><span class="line">INCLUDING DEPENDENCY MoveStdlib</span><br><span class="line">INCLUDING DEPENDENCY Sui</span><br><span class="line">BUILDING fox_game</span><br><span class="line">----- Certificate ----</span><br><span class="line">Transaction Hash: 5FZi4YxiiBJsCj67JSSzkVZvHdJjKKPtMMMrfGbmPXvH</span><br><span class="line">Transaction Signature: AA==@G9yAoybgfIEi7Wj8HFYeEFwG5WPtJ4FlJ+/jaMXFPyjWg4pUun3WQpB4VH5gim/FzqspMY7QAJcd0iTyJ910Dw==@htyihgkhXVia7MCmWeGtDeU96b7w1ivXPKBAV37DZoo=</span><br><span class="line">Signed Authorities Bitmap: RoaringBitmap&lt;[0, 1, 2]&gt;</span><br><span class="line">Transaction Kind : Publish</span><br><span class="line">Sender: 0xefbb0d3f2dc566f1f4fa844621bee76b43c9579a</span><br><span class="line">Gas Payment: Object ID: 0x0942e72397f46a831ce61003601cbb05697e7a83, version: 0x20f, digest: 0xc318f23ac2772738efe1b958be0b51e3c49d9c772d5aede9f41e1dc69edeb2ea</span><br><span class="line">Gas Price: 1</span><br><span class="line">Gas Budget: 300000</span><br><span class="line">----- Transaction Effects ----</span><br><span class="line">Status : Success</span><br><span class="line">Created Objects:</span><br><span class="line">    - 省略了其他的创建的对象</span><br><span class="line">  - ID: 0x17db4feb4652b8b5ce9ebf6dc7d29463b08e234e , Owner: Shared</span><br><span class="line">  - ID: 0x1d525318e381f93dd2b2f043d2ed96400b4f16d9 , Owner: Immutable</span><br><span class="line">  - ID: 0x59a85fbef4bc17cd73f8ff89d227fdcd6226c885 , Owner: Immutable</span><br><span class="line">  - ID: 0xe364474bd00b7544b9393f0a2b0af2dbea143fd3 , Owner: Account Address ( 0xa3e46ec682bb5082849c240d2f2d20b0f6e054aa )</span><br><span class="line">  - ID: 0xe4ffefc480e20129ff7893d7fd550b17fda0ab0f , Owner: Shared</span><br><span class="line">  - ID: 0xe572b53c8fa93602ae97baca3a94e231c2917af6 , Owner: Account Address ( 0xefbb0d3f2dc566f1f4fa844621bee76b43c9579a )</span><br><span class="line">Mutated Objects:</span><br><span class="line">  - ID: 0x0942e72397f46a831ce61003601cbb05697e7a83 , Owner: Account Address ( 0xefbb0d3f2dc566f1f4fa844621bee76b43c9579a )</span><br></pre></td></tr></table></figure>
<p>可以通过交易哈希 <code>5FZi4YxiiBJsCj67JSSzkVZvHdJjKKPtMMMrfGbmPXvH</code> 在 sui explorer 中查看部署的合约信息：</p>
<p><img src="https://user-images.githubusercontent.com/3297411/215304390-507211a2-638c-4c97-ae58-56ea419e8fcd.png" alt="Untitled 1"></p>
<p>通过 <code>sui client object &lt;object_id&gt;</code> 可以查看创建的 object 的属性，可以知道：</p>
<ul>
<li><code>0x17db4feb4652b8b5ce9ebf6dc7d29463b08e234e</code> 为代币 EGG 的 TreasuryCap 的 ObjectId</li>
<li><code>0x1d525318e381f93dd2b2f043d2ed96400b4f16d9</code> 为 EGG 的 CoinMetadata</li>
<li><code>0x59a85fbef4bc17cd73f8ff89d227fdcd6226c885</code> 为部署的地址</li>
<li><code>0xe364474bd00b7544b9393f0a2b0af2dbea143fd3</code> 为 TimeManagerCap</li>
<li><code>0xe4ffefc480e20129ff7893d7fd550b17fda0ab0f</code> 为 Global 对象</li>
<li><code>0xe572b53c8fa93602ae97baca3a94e231c2917af6</code> 为 FoCManagerCap 对象</li>
</ul>
<p>这些对象将在之后的命令行调用和前端项目中使用到。其他省略的创建的对象为 Trait 对象，在之后不会使用到。</p>
<h3><span id="3-2-he-yue-ming-ling-xing-diao-yong">3.2 合约命令行调用</span></h3>
<ol>
<li>
<p>设置环境变量</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> fox_game=0x59a85fbef4bc17cd73f8ff89d227fdcd6226c885</span><br><span class="line"><span class="built_in">export</span> global=0xe4ffefc480e20129ff7893d7fd550b17fda0ab0f</span><br><span class="line"><span class="built_in">export</span> egg_treasury=0x17db4feb4652b8b5ce9ebf6dc7d29463b08e234e</span><br><span class="line"><span class="built_in">export</span> time_cap=0xe364474bd00b7544b9393f0a2b0af2dbea143fd3</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li>
<p>设置时间戳</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要切换到时间戳的管理地址 0xa3e46ec682bb5082849c240d2f2d20b0f6e054aa</span></span><br><span class="line">sui client switch --address 0xa3e46ec682bb5082849c240d2f2d20b0f6e054aa</span><br><span class="line"><span class="comment"># 设置时间戳</span></span><br><span class="line">sui client call --<span class="keyword">function</span> set_timestamp --module fox --package <span class="variable">$&#123;fox_game&#125;</span> --args <span class="variable">$&#123;time_cap&#125;</span> <span class="variable">$&#123;global&#125;</span> \"$(date +%s)\" --gas-budget 30000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前时间戳</span></span><br><span class="line">curl https://fullnode.devnet.sui.io:443 -H <span class="string">"Content-Type: application/json"</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">  "jsonrpc": "2.0",</span></span><br><span class="line"><span class="string">  "id": 1,</span></span><br><span class="line"><span class="string">  "method": "sui_getObject",</span></span><br><span class="line"><span class="string">  "params":[</span></span><br><span class="line"><span class="string">      "0xe4ffefc480e20129ff7893d7fd550b17fda0ab0f"</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;'</span> | jq .result.details.data.fields.barn_registry</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果，可以看到时间戳已经被设置为 1674831518</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"0x59a85fbef4bc17cd73f8ff89d227fdcd6226c885::barn::BarnRegistry"</span>,</span><br><span class="line">  <span class="string">"fields"</span>: &#123;</span><br><span class="line">    <span class="string">"egg_per_alpha"</span>: <span class="string">"0"</span>,</span><br><span class="line">    <span class="string">"id"</span>: &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="string">"0x48136d916ea8a148ab864fdb1fc668f6e6dcf3ff"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"last_claim_timestamp"</span>: <span class="string">"0"</span>,</span><br><span class="line">    <span class="string">"timestamp"</span>: <span class="string">"1674831518"</span>,</span><br><span class="line">    <span class="string">"total_alpha_staked"</span>: <span class="string">"0"</span>,</span><br><span class="line">    <span class="string">"total_chicken_staked"</span>: <span class="string">"0"</span>,</span><br><span class="line">    <span class="string">"total_egg_earned"</span>: <span class="string">"0"</span>,</span><br><span class="line">    <span class="string">"unaccounted_rewards"</span>: <span class="string">"8518518"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>之后的每一步操作前都需要同步一次时间戳，保证数据正确。
</code></pre>
<ol start="3">
<li>
<p>铸造 NFT</p>
<p>使用以下命令进行铸造：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前gas</span></span><br><span class="line">sui client switch --address 0x659f89084673bf4a993cdea89a94dabf93a2ddb4</span><br><span class="line">sui client gas</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">Object ID                  |  Gas Value </span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"> 0x0bd32adfbfc73e8daa42eef21b4e4e6cc7081240 |    25219   </span><br><span class="line"> 0x2ad1e472502aefd87c3767157391ebc1f169c6b5 |   9928743  </span><br><span class="line"> 0x3cd2bb1e03326e5141203cc008e6d2eb44a0df05 |  10000000  </span><br><span class="line"> 0x5f2c80c89bedddf92f0dc32cfa16b0ecf76a4680 |  10000000  </span><br><span class="line"> 0x635ce8d2e9a9c0056ff1cd8591baee16fe010911 |  10000000</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mint 1 个 NFT</span></span><br><span class="line">sui client call --<span class="keyword">function</span> mint --module fox --package <span class="variable">$&#123;fox_game&#125;</span> --args <span class="variable">$&#123;global&#125;</span> <span class="variable">$&#123;egg_treasury&#125;</span> \"1\" <span class="literal">false</span> \[0x3cd2bb1e03326e5141203cc008e6d2eb44a0df05\] \[\] --gas-budget 100000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">----- Certificate ----</span><br><span class="line">Transaction Hash: 7p1nmTPYE9884gBCJL6sah2t6Vzh9P59MUeFVURXaEFx</span><br><span class="line">Transaction Signature: AA==@TNx7guUd7EjEg4s8jyOf+kTkuhVqmzrZWGKzcJNM3iHqcCRk0+pzITmFth8dYM6qKnYAvT3eeSkKNDUaQF2LAA==@oC1nequkpzyJfYuKx7DqIZFNUfF66e+6DEF1Urqo/EM=</span><br><span class="line">Signed Authorities Bitmap: RoaringBitmap&lt;[1, 2, 3]&gt;</span><br><span class="line">Transaction Kind : Call</span><br><span class="line">Package ID : 0x59a85fbef4bc17cd73f8ff89d227fdcd6226c885</span><br><span class="line">Module : fox</span><br><span class="line">Function : mint</span><br><span class="line">Arguments : [<span class="string">"0xe4ffefc480e20129ff7893d7fd550b17fda0ab0f"</span>, <span class="string">"0x17db4feb4652b8b5ce9ebf6dc7d29463b08e234e"</span>, [1,0,0,0,0,0,0,0], <span class="string">""</span>, [<span class="string">"0x3cd2bb1e03326e5141203cc008e6d2eb44a0df05"</span>], []]</span><br><span class="line">Type Arguments : []</span><br><span class="line">Sender: 0x659f89084673bf4a993cdea89a94dabf93a2ddb4</span><br><span class="line">Gas Payment: Object ID: 0x2ad1e472502aefd87c3767157391ebc1f169c6b5, version: 0x215, digest: 0x197c624ca59151af7cd968b985062fa3e0dbf21711777d7b4602215664233c5b</span><br><span class="line">Gas Price: 1</span><br><span class="line">Gas Budget: 100000</span><br><span class="line">----- Transaction Effects ----</span><br><span class="line">Status : Success</span><br><span class="line">Created Objects:</span><br><span class="line">  - ID: 0x185aa8a244c74ddfe83c38618b46c744425cd7f5 , Owner: Object ID: ( 0x2ba674fcac290baa2927ff26110463f337237f0d )</span><br><span class="line">  - ID: 0x6917cbcf0e6e58184a98e05ad6bbc70a75755d28 , Owner: Object ID: ( 0x2ed343ceebf792a36b2ff0e918b801e34399f4ed )</span><br><span class="line">  - ID: 0x84fe8e597bcb9387b2911b5ef39b90bb111e71a2 , Owner: Account Address ( 0x659f89084673bf4a993cdea89a94dabf93a2ddb4 )</span><br><span class="line">Mutated Objects:</span><br><span class="line">  - ID: 0x17db4feb4652b8b5ce9ebf6dc7d29463b08e234e , Owner: Shared</span><br><span class="line">  - ID: 0x2ad1e472502aefd87c3767157391ebc1f169c6b5 , Owner: Account Address ( 0x659f89084673bf4a993cdea89a94dabf93a2ddb4 )</span><br><span class="line">  - ID: 0x3cd2bb1e03326e5141203cc008e6d2eb44a0df05 , Owner: Account Address ( 0x659f89084673bf4a993cdea89a94dabf93a2ddb4 )</span><br><span class="line">  - ID: 0xe4ffefc480e20129ff7893d7fd550b17fda0ab0f , Owner: Shared</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>其中：

- `\&quot;1\&quot;` 表示铸造的数量为 1；
- `false` 表示不质押，如果要铸造的同时进行质押，可以修改为 `true`；
- `\[0x3cd2bb1e03326e5141203cc008e6d2eb44a0df05\]` 是用于支付 0.0099 SUI 铸造费用的 SUI 对象；
- `\[\]` 表示用于支付 `EGG` 的对象。

可以看到生成的对象中， `0x84fe8e597bcb9387b2911b5ef39b90bb111e71a2` 在地址 `0x659f89084673bf4a993cdea89a94dabf93a2ddb4` 之下，查看属性可以看到对应的 type 为 `0x59a85fbef4bc17cd73f8ff89d227fdcd6226c885::token_helper::FoxOrChicken` ，这个就是我们铸造得到的 NFT，相应的其他属性也可以查看到，命令输出结果可以查看此 [gist](https://gist.github.com/qiwihui/86e7385c635f88b539ed2f032018ca28)。

或者，我们可以通过 `sui_getObjectsOwnedByAddress` RPC 接口可以查看地址所拥有的对象，比如对于地址 `0x659f89084673bf4a993cdea89a94dabf93a2ddb4` ，可以查看所有对象，过滤即可找到创建的对象。

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl https://fullnode.devnet.sui.io:443 -H <span class="string">"Content-Type: application/json"</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">  "jsonrpc": "2.0",</span></span><br><span class="line"><span class="string">  "id": 1,</span></span><br><span class="line"><span class="string">  "method": "sui_getObjectsOwnedByAddress",</span></span><br><span class="line"><span class="string">  "params":[</span></span><br><span class="line"><span class="string">      "0x659f89084673bf4a993cdea89a94dabf93a2ddb4"</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="4">
<li>
<p>质押 NFT</p>
<p>通过以下命令对前一步铸造的 NFT 进行质押：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sui client call --<span class="keyword">function</span> add_many_to_barn_and_pack --module fox --package <span class="variable">$&#123;fox_game&#125;</span> --args <span class="variable">$&#123;global&#125;</span> \[0x84fe8e597bcb9387b2911b5ef39b90bb111e71a2\] --gas-budget 100000</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li>
<p>获取收益和 提取 NFT</p>
<p>通过以下命令获取质押收益 EGG：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sui client call --<span class="keyword">function</span> claim_many_from_barn_and_pack --module fox --package <span class="variable">$&#123;fox_game&#125;</span> --args <span class="variable">$&#123;global&#125;</span> <span class="variable">$&#123;egg_treasury&#125;</span> <span class="string">'["0x84fe8e597bcb9387b2911b5ef39b90bb111e71a2"]'</span> <span class="literal">false</span> --gas-budget 100000</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>等 48 小时之后，将 `false` 变为 `true`，可以进行 Unstake，将质押的 NFT 提取出来。
</code></pre>
<p>至此，命令行操作完成。</p>
<h2><span id="0x4-qian-duan-kai-fa">0x4 前端开发</span></h2>
<h3><span id="4-1-scaffold-move-kai-fa-jiao-shou-jia">4.1 scaffold-move 开发脚手架</span></h3>
<p>这个项目基于 NonceGeek DAO 的 scaffold-move 开发脚手架，这个脚手架目前包含 Aptos 和 Sui 两个公链的前端开发实例，可以可以在这个基础上快速进行 Sui 的前端部分开发。</p>
<p>通过运行以下步骤可以设置开发环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/NonceGeek/scaffold-move.git</span><br><span class="line"><span class="built_in">cd</span> scaffold-move/scaffold-sui/</span><br><span class="line">yarn</span><br><span class="line">yarn dev</span><br></pre></td></tr></table></figure>
<h3><span id="4-2-xiang-mu-ye-mian-jie-gou">4.2 项目页面结构</span></h3>
<p>项目页面主要包括三部分，位于 <code>src/pages</code> 目录：index，game 和 whitepapers：</p>
<ul>
<li>index：入口页面，做为游戏的引导页面；</li>
<li>game：主要的逻辑页面，涉及铸造，质押和提取；</li>
<li>whitepaper：白皮书页面，介绍游戏机制和玩法。</li>
</ul>
<p>我们之后的部分主要聚焦在 game 页面。game 页面功能主要包括三部分：</p>
<ul>
<li>菜单栏：包含logo，页面导航以及链接钱包；</li>
<li>左侧 Mint 栏：主要当前 mint 状态和 mint 操作；</li>
<li>右侧 Stake 栏：主要是 Stake，Unstale 和 Collect EGG 的操作。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/3297411/215304399-47738ec4-8dc2-4063-9d1a-fa5ab05f963b.png" alt="Untitled 2"></p>
<p>其中，质押和提取时进行的多选操作，可以通过设置选择变量进行过滤来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [unstakedSelected, setUnstakedSelected] = useState&lt;Array&lt;string&gt;&gt;([])</span><br><span class="line">const [stakedSelected, setStakedSelected] = useState&lt;Array&lt;string&gt;&gt;([]);</span><br><span class="line">  </span><br><span class="line">  // 设置添加和删除操作</span><br><span class="line">  function addStaked(item: string) &#123;</span><br><span class="line">  setUnstakedSelected([])</span><br><span class="line">  setStakedSelected([...stakedSelected, item])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function removeStaked(item: string) &#123;</span><br><span class="line">  setUnstakedSelected([])</span><br><span class="line">  setStakedSelected(stakedSelected.filter(i =&gt; i !== item))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function addUnstaked(item: string) &#123;</span><br><span class="line">  setStakedSelected([])</span><br><span class="line">  setUnstakedSelected([...unstakedSelected, item])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function removeUnstaked(item: string) &#123;</span><br><span class="line">  setStakedSelected([])</span><br><span class="line">  setUnstakedSelected(unstakedSelected.filter(i =&gt; i !== item))</span><br><span class="line">&#125;</span><br><span class="line">  // 之后添加元素的点击事件</span><br><span class="line">  // 处理未质押的</span><br><span class="line">function renderUnstaked(item: any, type: string) &#123;</span><br><span class="line">  const itemIn = unstakedSelected.includes(item.objectId);</span><br><span class="line">  return &lt;div key=&#123;item.objectId&#125; style=&#123;&#123; marginRight: &quot;5px&quot;, marginLeft: &quot;5px&quot;, border: itemIn ? &quot;2px solid red&quot; : &quot;2px solid rgb(0,0,0,0)&quot;, overflow: &apos;hidden&apos;, display: &quot;inline-block&quot; &#125;&#125;&gt;</span><br><span class="line">    &lt;div className=&quot;flex flex-col items-center&quot;&gt;</span><br><span class="line">      &lt;div style=&#123;&#123; fontSize: &quot;0.75rem&quot;, height: &quot;1rem&quot; &#125;&#125;&gt;#&#123;item.index&#125;&lt;/div&gt;</span><br><span class="line">      &lt;Image src=&#123;`$&#123;item.url&#125;`&#125; width=&#123;48&#125; height=&#123;48&#125; alt=&#123;`$&#123;item.objectId&#125;`&#125; onClick=&#123;() =&gt; itemIn ? removeUnstaked(item.objectId) : addUnstaked(item.objectId)&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line">// 处理质押的</span><br><span class="line">function renderStaked(item: any, type: string) &#123;</span><br><span class="line">  const itemIn = stakedSelected.includes(item.objectId);</span><br><span class="line">  return &lt;div key=&#123;item.objectId&#125; style=&#123;&#123; marginRight: &quot;5px&quot;, marginLeft: &quot;5px&quot;, border: itemIn ? &quot;2px solid red&quot; : &quot;2px solid rgb(0,0,0,0)&quot;, overflow: &apos;hidden&apos;, display: &quot;inline-block&quot; &#125;&#125;&gt;</span><br><span class="line">    &lt;div className=&quot;flex flex-col items-center&quot;&gt;</span><br><span class="line">      &lt;div style=&#123;&#123; fontSize: &quot;0.75rem&quot;, height: &quot;1rem&quot; &#125;&#125;&gt;#&#123;item.index&#125;&lt;/div&gt;</span><br><span class="line">      &lt;Image src=&#123;`$&#123;item.url&#125;`&#125; width=&#123;48&#125; height=&#123;48&#125; alt=&#123;`$&#123;item.objectId&#125;`&#125; onClick=&#123;() =&gt; itemIn ? removeStaked(item.objectId) : addStaked(item.objectId)&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="4-3-lian-jie-qian-bao">4.3 连接钱包</span></h3>
<p>我们使用 Suiet 钱包开发的 <code>@suiet/wallet-kit</code> 包连接 Sui 钱包，从包对应的 WalletContextState 可以看出， <code>useWallet</code> 包含了我们在构建 App 时会使用到的基本信息和功能，比如钱包信息，链信息，连接状态信息，以及发送交易，签名信息等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface WalletContextState &#123;</span><br><span class="line">    configuredWallets: IWallet[];</span><br><span class="line">    detectedWallets: IWallet[];</span><br><span class="line">    allAvailableWallets: IWallet[];</span><br><span class="line">    chains: Chain[];</span><br><span class="line">    chain: Chain | undefined;</span><br><span class="line">    name: string | undefined;</span><br><span class="line">    adapter: IWalletAdapter | undefined;</span><br><span class="line">    account: WalletAccount | undefined;</span><br><span class="line">    address: string | undefined;</span><br><span class="line">    connecting: boolean;</span><br><span class="line">    connected: boolean;</span><br><span class="line">    status: &quot;disconnected&quot; | &quot;connected&quot; | &quot;connecting&quot;;</span><br><span class="line">    select: (walletName: string) =&gt; void;</span><br><span class="line">    disconnect: () =&gt; Promise&lt;void&gt;;</span><br><span class="line">    getAccounts: () =&gt; readonly WalletAccount[];</span><br><span class="line">    signAndExecuteTransaction(transaction: SuiSignAndExecuteTransactionInput): Promise&lt;SuiSignAndExecuteTransactionOutput&gt;;</span><br><span class="line">    signMessage: (input: &#123;</span><br><span class="line">        message: Uint8Array;</span><br><span class="line">    &#125;) =&gt; Promise&lt;ExpSignMessageOutput&gt;;</span><br><span class="line">    on: &lt;E extends WalletEvent&gt;(event: E, listener: WalletEventListeners[E]) =&gt; () =&gt; void;</span><br><span class="line">&#125;</span><br><span class="line">export declare const WalletContext: import(&quot;react&quot;).Context&lt;WalletContextState&gt;;</span><br><span class="line">export declare function useWallet(): WalletContextState;</span><br></pre></td></tr></table></figure>
<p>在 <code>src/components/SuiConnect.tsx</code> 中，我们可以很方便的设置钱包连接功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  ConnectButton,</span><br><span class="line">&#125; from &apos;@suiet/wallet-kit&apos;;</span><br><span class="line"></span><br><span class="line">export function SuiConnect() &#123;</span><br><span class="line">  return (</span><br><span class="line">      &lt;ConnectButton&gt;Connect Wallet&lt;/ConnectButton&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后，我们将需要使用的信息在 <code>src/pages/game.tsx</code> 中引入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  useWallet,</span><br><span class="line">&#125; from &apos;@suiet/wallet-kit&apos;;</span><br><span class="line"></span><br><span class="line">export default function Home() &#123;</span><br><span class="line"></span><br><span class="line">  const &#123; signAndExecuteTransaction, connected, account, status &#125; = useWallet();</span><br><span class="line"></span><br><span class="line">    // 省略</span><br></pre></td></tr></table></figure>
<p>其中， <code>signAndExecuteTransaction</code> 方法用来签名并执行交易，支持 <code>moveCall</code> ， <code>transferSui</code>， <code>transferObject</code> 等交易。</p>
<h3><span id="4-4-rpc-jie-kou-diao-yong">4.4 RPC 接口调用</span></h3>
<p>我们使用官方提供的 <code>@mysten/sui.js</code> 库调用 Sui 的 RPC 接口，这个库支持了大部分 <a href="https://docs.sui.io/sui-jsonrpc" target="_blank" rel="noopener">Sui JSON-RPC</a>，同时，还提供了一些额外的方法方便开发，例如：</p>
<ul>
<li><code>selectCoinsWithBalanceGreaterThanOrEqual</code> ：获取大于等于指定数量的coin对象ID数组</li>
<li><code>selectCoinSetWithCombinedBalanceGreaterThanOrEqual</code>：获取总和大于等于指定数量的coin对象ID数组</li>
</ul>
<p>这两个方法在需要在 NFT 铸造时支付 SUI 或者其他代币时十分有用。我们在 <code>game.tsx</code> 中引入 JsonProvider 进行初始化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 文件: src/pages/game.tsx</span><br><span class="line">import &#123; JsonRpcProvider &#125; from &apos;@mysten/sui.js&apos;;</span><br><span class="line"></span><br><span class="line">export default function Home() &#123;</span><br><span class="line">    // 操作 client</span><br><span class="line">  const provider = new JsonRpcProvider();</span><br><span class="line">    // 调用</span><br><span class="line">    const suiObjects = await provider.selectCoinSetWithCombinedBalanceGreaterThanOrEqual(account!.address, suiCost)</span><br><span class="line">// 其他省略</span><br></pre></td></tr></table></figure>
<p>其他方法的介绍可以参考库的文档，这里不多赘述。</p>
<h3><span id="4-5-zhu-zao-nft-deng-entry-fang-fa">4.5 铸造 NFT 等 entry 方法</span></h3>
<p>我们首先看到如何铸造 NFT：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 文件: src/pages/game.tsx </span><br><span class="line">  async function mint_nft() &#123;</span><br><span class="line">    let suiObjectIds = [] as Array&lt;string&gt;</span><br><span class="line">    let eggObiectIds = [] as Array&lt;string&gt;</span><br><span class="line">        // 获取足够的 SUI 或者 EGG 代币的对象ID</span><br><span class="line">    if (collectionSupply &lt; PAID_TOKENS) &#123;</span><br><span class="line">      const suiObjects = await provider.selectCoinSetWithCombinedBalanceGreaterThanOrEqual(account!.address, suiCost)</span><br><span class="line">      suiObjectIds = suiObjects.filter(item =&gt; item.status === &quot;Exists&quot;).map((item: any) =&gt; item.details.data.fields.id.id)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      const eggObjects = await provider.selectCoinSetWithCombinedBalanceGreaterThanOrEqual(account!.address, eggCost, `$&#123;PACKAGE_ID&#125;::egg::EGG`)</span><br><span class="line">      eggObiectIds = eggObjects.filter(item =&gt; item.status === &quot;Exists&quot;).map((item: any) =&gt; item.details.data.fields.id.id)</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">            // 调用 moveCall 方法，构造交易并签名</span><br><span class="line">      const resData = await signAndExecuteTransaction(&#123;</span><br><span class="line">        transaction: &#123;</span><br><span class="line">          kind: &apos;moveCall&apos;,</span><br><span class="line">          data: mint(false, suiObjectIds, eggObiectIds),</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">            // 检查结果</span><br><span class="line">      if (resData.effects.status.status !== &quot;success&quot;) &#123;</span><br><span class="line">        console.log(&apos;failed&apos;, resData);</span><br><span class="line">      &#125;</span><br><span class="line">      // 设置 Mint 交易</span><br><span class="line">      setMintTx(&apos;https://explorer.sui.io/transaction/&apos; + resData.certificate.transactionDigest)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      console.error(&apos;failed&apos;, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    // 构造 mint 方法所需要的参数</span><br><span class="line">  function mint(stake: boolean, sui_objects: Array&lt;string&gt;, egg_objects: Array&lt;string&gt;) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      packageObjectId: PACKAGE_ID,</span><br><span class="line">      module: &apos;fox&apos;,</span><br><span class="line">      function: &apos;mint&apos;,</span><br><span class="line">      typeArguments: [],</span><br><span class="line">      arguments: [</span><br><span class="line">        GLOBAL, EGG_TREASUTY, mintAmount.toString(), stake, sui_objects, egg_objects</span><br><span class="line">      ],</span><br><span class="line">      gasBudget: 1000000,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">        // 其他部分省略</span><br><span class="line">        &lt;div className=&quot;text-center font-console pt-1&quot; onClick=&#123;() =&gt; mint_nft()&#125;&gt;Mint&lt;/div&gt;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>其中 <code>arguments</code> 参数对应 mint 方法所需要的参数。</p>
<p>同理，其他的 entry 方法的调用和签名也与 Mint 方法类似，分别为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 铸造并质押</span><br><span class="line">async function mint_nft_stake()</span><br><span class="line">// 质押</span><br><span class="line">async function stake_nft()</span><br><span class="line">// 提取</span><br><span class="line">async function unstake_nft()</span><br><span class="line">// 收集 EGG</span><br><span class="line">async function claim_egg()</span><br></pre></td></tr></table></figure>
<h3><span id="4-6-he-yue-shu-ju-du-qu">4.6 合约数据读取</span></h3>
<p>对于 Sui 公链，除了调用合约，另一块难点是合约数据的读取。相对于 EVM 合约，Move的合约数据结构更复杂，更难读取。由于在 Sui 中，Object 对象被包装后可能无法进行追踪（详情可以参考官方 <a href="https://docs.sui.io/build/programming-with-objects" target="_blank" rel="noopener">Object 教程系列</a>），因此在之前的数据结构设计中，Pack 和 Barn 中存储的 NFT 需要使用能进行追踪的数据结构。因此，ObjectTable 被做为基本的键值存储结构区别于不可追踪的 Table 数据类型。相应地，可以使用  <code>sui_getDynamicFieldObject</code> 来读取其中的数据，例如，通过读取保存在 PackStaked 中的 NFT 对象质押列表，从而通过 <code>getObjectBatch</code> 可以获取当前地址所有的质押的 NFT。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 读取 Pack 中质押的 Fox NFT</span><br><span class="line">const objects: any = await sui_client.getDynamicFieldObject(packStakedObject, account!.address);</span><br><span class="line">  if (objects != null) &#123;</span><br><span class="line">    const fox_staked = objects.details.data.fields.value</span><br><span class="line">    const fox_stakes = await provider.getObjectBatch(fox_staked)</span><br><span class="line">    const staked = fox_stakes.filter(item =&gt; item.status === &quot;Exists&quot;).map((item: any) =&gt; &#123;</span><br><span class="line">      let foc = item.details.data.fields.item</span><br><span class="line">      return &#123;</span><br><span class="line">        objectId: foc.fields.id.id,</span><br><span class="line">        index: parseInt(foc.fields.index),</span><br><span class="line">        url: foc.fields.url,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    setStakedFox(staked)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中， <code>packStakedObject</code> 对象ID通过 <code>GLOBAL</code> 对象 ID 获取得到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      const globalObject: any = await provider.getObject(GLOBAL)</span><br><span class="line"></span><br><span class="line">const pack_staked = globalObject.details.data.fields.pack.fields.id.id</span><br><span class="line">setPackStakedObject(pack_staked)</span><br></pre></td></tr></table></figure>
<p>对于当前地址所拥有的未质押的NFT，需要通过读取全部对象ID后进行类型过滤才能得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        // 获取所有对象</span><br><span class="line">        const objects = await provider.getObjectsOwnedByAddress(account!.address)</span><br><span class="line">// 过滤 FoxOrChicken 对象</span><br><span class="line">        const foc = objects</span><br><span class="line">  .filter(item =&gt; item.type === `$&#123;PACKAGE_ID&#125;::token_helper::FoxOrChicken`)</span><br><span class="line">  .map(item =&gt; item.objectId)</span><br><span class="line">const foces = await provider.getObjectBatch(foc)</span><br><span class="line">        // 过滤并读取信息，然后排序</span><br><span class="line">const unstaked = foces.filter(item =&gt; item.status === &quot;Exists&quot;).map((item: any) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    objectId: item.details.data.fields.id.id,</span><br><span class="line">    index: parseInt(item.details.data.fields.index),</span><br><span class="line">    url: item.details.data.fields.url,</span><br><span class="line">    is_chicken: item.details.data.fields.is_chicken,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).sort((n1, n2) =&gt; n1.index - n2.index)</span><br><span class="line">        // 存储</span><br><span class="line">setUnstakedFox(unstaked.filter(item =&gt; !item.is_chicken))</span><br><span class="line">setUnstakedChicken(unstaked.filter(item =&gt; item.is_chicken))</span><br></pre></td></tr></table></figure>
<p>最后，对于当前地址中包含的 EGG 代币的余额，可以通过 <code>getCoinBalancesOwnedByAddress</code> 获得所有余额对象并进行求和得到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const balanceObjects = await provider.getCoinBalancesOwnedByAddress(account!.address, `$&#123;PACKAGE_ID&#125;::egg::EGG`)</span><br><span class="line">const balances = balanceObjects.filter(item =&gt; item.status === &apos;Exists&apos;).map((item: any) =&gt; parseInt(item.details.data.fields.balance))</span><br><span class="line">const initialValue = 0;</span><br><span class="line">const sumWithInitial = balances.reduce(</span><br><span class="line">  (accumulator, currentValue) =&gt; accumulator + currentValue,</span><br><span class="line">  initialValue</span><br><span class="line">)</span><br><span class="line">setEggBalance(sumWithInitial);</span><br></pre></td></tr></table></figure>
<h2><span id="zong-jie">总结</span></h2>
<p>至此，我们完成了狐狸游戏合约和前端代码的介绍。我们实现的狐狸游戏虽然功能上只有铸造，质押和提取这几个主要的功能，但是涉及 NFT 创建以及 Sui Move 的诸多语法，整体项目具有一定的难度。</p>
<p>这篇文章希望对有兴趣于 Sui 上的 NFT 的操作的同学有所帮助，也希望大家提出宝贵的建议和意见。项目目前只完成了初步的逻辑功能，还需要继续补充测试和形式验证，欢迎有兴趣的同学提交 Pull Request。</p>
<h2><span id="can-kao-wen-dang">参考文档</span></h2>
<ul>
<li><a href="https://docs.sui.io/" target="_blank" rel="noopener">https://docs.sui.io/</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/439236444" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/439236444</a></li>
</ul>
<h3><span id="comments">Comments</span></h3>
</div><p class="post-tags"><i class="fa fa-tags" aria-hidden="true"></i><a href="/tags/%E6%8A%80%E6%9C%AF/">#技术</a><a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">#区块链</a></p></article></div><div class="post-copyright"><blockquote><p>版权声明：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">署名-相同方式共享 | CC BY-SA 4.0 </a>许可协议。</p></blockquote></div><footer><div class="paginator"><a href="/qiwihui-blog-172/" class="prev">PREV</a><a href="/qiwihui-blog-123/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'blog-qiwihui-com';
var disqus_identifier = 'qiwihui-blog-171/';
var disqus_title = 'Sui 类狼羊游戏项目开发实践';
var disqus_url = 'https://qiwihui.com/qiwihui-blog-171/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//blog-qiwihui-com.disqus.com/count.js" async></script><!-- block copyright--></footer></div><script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true,
        processEnvironments: true,
        skipTags: ["script","noscript","style","textarea","code","pre"]
    }
});
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-46660488-3",'auto');ga('send','pageview');</script><link rel="stylesheet" href="//cdn.datatables.net/1.10.7/css/jquery.dataTables.min.css" media="screen" type="text/css"><script src="//cdn.datatables.net/1.10.7/js/jquery.dataTables.min.js"></script><script>$(function(){$('.datatable').dataTable( {"order": [[ 0, "desc" ]],"iDisplayLength": -1,"lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]} );});</script></body></html>